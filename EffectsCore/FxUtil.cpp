const Flash::`vftable'; int __cdecl CL_GetLocalClientNum(void) { UNIMPLEMENTED();
}

void __cdecl LocalConvertQuatToMat(struct DObjAnimMat_s const *,
                                   float (*const)[3])
{
  UNIMPLEMENTED();
}

public:
void __cdecl Effect::ClearFlags(int)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Effect::SetMin(float const *const)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Effect::SetMax(float const *const)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Effect::SetOrigin1(float const *const)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Effect::SetFlags(int)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Effect::SetGroupFlags(int)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Effect::SetImpactFx(struct EffectTemplate const *)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Effect::SetDeathFx(struct EffectTemplate const *)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Effect::SetFx(struct EffectTemplate const *)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Effect::SetPrimIndex(int)
{
  UNIMPLEMENTED();
}

public:
int __cdecl Effect::GetTimeStart(void)
{
  UNIMPLEMENTED();
}

public:
struct EffectTemplate const *__cdecl Effect::GetFx(void)
{
  UNIMPLEMENTED();
}

public:
int __cdecl Effect::GetPrimIndex(void)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Light::SetRandomColorsWeight(float)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Light::SetRandomSizeWeight(float)
{
  UNIMPLEMENTED();
}

public:
static void *__cdecl Light::operator new(unsigned int)
{
  UNIMPLEMENTED();
}

public:
__cdecl Flash::Flash(void)
{
  UNIMPLEMENTED();
}

public:
virtual __cdecl Flash::~Flash(void)
{
  UNIMPLEMENTED();
}

public:
virtual bool __cdecl Flash::Cull(void)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Flash::SetMaterial(struct Material *)
{
  UNIMPLEMENTED();
}

public:
virtual void *__cdecl Flash::`vector
    deleting destructor'(unsigned int) { UNIMPLEMENTED();
}

public:
virtual void *__cdecl Flash::`scalar
    deleting destructor'(unsigned int) { UNIMPLEMENTED();
}

public:
void __cdecl Particle::SetMaterial(struct Material *)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Particle::SetGravity(float)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Particle::SetRotation(float)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Particle::SetElasticity(float)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Particle::SetNonUniformScale(bool)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Particle::SetStartFrame(int)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Particle::SetPlayRate(float)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Particle::SetLoopMode(int)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Particle::SetLoopTimes(int)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Particle::SetRandomColorsWeight(float)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Particle::SetRandomAlphaWeight(float)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Particle::SetRandomSizeWeight(float)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Particle::SetRandomSize2Weight(float)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Particle::SetRandomRotationDeltaWeight(float)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Particle::SetWindWeight(float)
{
  UNIMPLEMENTED();
}

public:
static void *__cdecl Particle::operator new(unsigned int)
{
  UNIMPLEMENTED();
}

public:
static void *__cdecl Cloud::operator new(unsigned int)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Line::SetOrigin2(float *const)
{
  UNIMPLEMENTED();
}

public:
static void *__cdecl Line::operator new(unsigned int)
{
  UNIMPLEMENTED();
}

public:
void __cdecl OrientedParticle::SetNormal(float *const)
{
  UNIMPLEMENTED();
}

public:
static void *__cdecl OrientedParticle::operator new(unsigned int)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Tail::SetOldOrigin(float const *const)
{
  UNIMPLEMENTED();
}

public:
static void *__cdecl Tail::operator new(unsigned int)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Cylinder::SetNormal(float *const)
{
  UNIMPLEMENTED();
}

public:
static void *__cdecl Cylinder::operator new(unsigned int)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Emitter::SetModel(struct XModel *)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Emitter::SetAngles(float *const)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Emitter::SetAngleDelta(float *const)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Emitter::SetEmitterFx(struct EffectTemplate *)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Emitter::SetDensity(float)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Emitter::SetVariance(float)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Emitter::SetOldTime(int)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Emitter::SetLastOrg(float const *const)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Emitter::SetLastVel(float const *const)
{
  UNIMPLEMENTED();
}

public:
void __cdecl Emitter::SetLastBindOrg(float const *const)
{
  UNIMPLEMENTED();
}

public:
static void *__cdecl Emitter::operator new(unsigned int)
{
  UNIMPLEMENTED();
}

public:
int __cdecl FxArchive::UsedBytes(void)
{
  UNIMPLEMENTED();
}

public:
static void *__cdecl FxScheduler::operator new(unsigned int)
{
  UNIMPLEMENTED();
}

public:
static void __cdecl FxScheduler::operator delete(void *)
{
  UNIMPLEMENTED();
}

void __cdecl `vector constructor
    iterator'(void *,unsigned int,int,void * (__cdecl*)(void *)) { UNIMPLEMENTED();
}

public:
void *__cdecl FxMemMgr<class Light>::Alloc(unsigned int)
{
  UNIMPLEMENTED();
}

public:
void *__cdecl FxMemMgr<class Particle>::Alloc(unsigned int)
{
  UNIMPLEMENTED();
}

public:
void *__cdecl FxMemMgr<class Cloud>::Alloc(unsigned int)
{
  UNIMPLEMENTED();
}

public:
void *__cdecl FxMemMgr<class Line>::Alloc(unsigned int)
{
  UNIMPLEMENTED();
}

public:
void *__cdecl FxMemMgr<class OrientedParticle>::Alloc(unsigned int)
{
  UNIMPLEMENTED();
}

public:
void *__cdecl FxMemMgr<class Tail>::Alloc(unsigned int)
{
  UNIMPLEMENTED();
}

public:
void *__cdecl FxMemMgr<class Cylinder>::Alloc(unsigned int)
{
  UNIMPLEMENTED();
}

public:
void *__cdecl FxMemMgr<class Emitter>::Alloc(unsigned int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_InitServer()
{
  g_effectVisArrayCount = 0;
}

void __cdecl FX_FreeEffectList(void)
{
  UNIMPLEMENTED();
}

void __cdecl FX_EffectList_SwitchToLocalClient(int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_SetSortGroup(class Effect *fx)
{
  int result; // eax

  a1->mSortGroup = 0;
  result = *(_DWORD *)a1->mRefEnt;
    if (result) {
      result = FxHelper::IsMaterialRefractive(theFxHelper,
                                              *(Material **)a1->mRefEnt);
      if ((_BYTE)result)
        a1->mSortGroup = -1;
    }
  return result;
}

float __cdecl FX_GetClientVisibility(float const *const, float const *const)
{
  UNIMPLEMENTED();
}

int __cdecl FX_GetCluster(float const *const origin)
{
  size_t v1;         // eax
  float *v2;         // edx
  signed __int32 v4; // esi
  int v6;            // ebx
  float v7;          // [esp+1Ch] [ebp-1Ch]

  v1 = effectClusterCount;
    if ((int)effectClusterCount > 0) {
      v4 = 0;
      v6 = 0;
        while (1) {
          v7 = Vec3DistanceSq(a1, (float *)((char *)effectClusters + v6));
          if (v7 < 131072.0)
            break;
          ++v4;
          v1 = effectClusterCount;
          v6 += 16;
          if (v4 >= (int)effectClusterCount)
            goto LABEL_2;
        }
      ++*(_DWORD *)((char *)effectClusters + v6 + 12);
    }
    else {
    LABEL_2:
      v2 = (float *)((char *)effectClusters + 16 * v1);
      *v2 = *a1;
      v2[1] = a1[1];
      v2[2] = a1[2];
      *((_DWORD *)effectClusters + 4 * effectClusterCount + 3) = 1;
      return effectClusterCount++;
    }
  return v4;
}

void __cdecl FX_UpdateAllNonBolt()
{
  int result;  // eax
  int v1;      // edi
  int v2;      // esi
  int v3;      // esi
  _DWORD *v4;  // edx
  _BYTE *v5;   // ebx
  _DWORD *v6;  // ecx
  int v7;      // esi
  int v8;      // edx
  int i;       // edx
  _DWORD *v10; // edi
  int v11;     // ebx
  _DWORD *v12; // ecx
  size_t v13;  // eax
  int v14;     // ecx
  int v15;     // edx
  int v16;     // ecx
  int v17;     // edx
  int v18;     // [esp+18h] [ebp-20h]
  int v19;     // [esp+1Ch] [ebp-1Ch]

  result = effectActiveCountNonBolt;
  privateEffectActiveCountNonBolt = effectActiveCountNonBolt;
  initialEffectActiveCountNonBolt = effectActiveCountNonBolt;
  v1 = 0;
  v2 = effectActiveCountNonBolt;
LABEL_2:
    while (v1 < v2) {
        while (1) {
          v3 = 4 * v1;
          v4 = (_DWORD *)*((_DWORD *)effectListNonBolt + v1);
            if ((signed int)theFxHelper->mTime <= v4[47]) {
              result = (*(int(__cdecl **)(_DWORD))(*v4 + 12))(
                  *((_DWORD *)effectListNonBolt + v1));
                if ((_BYTE)result) {
                  ++v1;
                  v2 = privateEffectActiveCountNonBolt;
                  goto LABEL_2;
                }
            }
            else {
              v4[42] &= ~0x400u;
            }
          v5 = *(_BYTE **)((char *)effectListNonBolt + v3);
          --privateEffectActiveCountNonBolt;
          v6 = (_DWORD *)((char *)effectListNonBolt + v3);
          v7 = *(_DWORD *)((char *)effectListNonBolt + v3);
          v8 = 4 * privateEffectActiveCountNonBolt;
          *v6 =
              *((_DWORD *)effectListNonBolt + privateEffectActiveCountNonBolt);
          *(_DWORD *)((char *)effectListNonBolt + v8) = v7;
          result = (*(int(__cdecl **)(_BYTE *))(*(_DWORD *)v5 + 8))(v5);
          if ((v5[169] & 0x10) == 0)
            break;
          --effectBlockSightCount;
          v2 = privateEffectActiveCountNonBolt;
          if (v1 >= privateEffectActiveCountNonBolt)
            goto LABEL_7;
        }
      v2 = privateEffectActiveCountNonBolt;
    }
LABEL_7:
    if (initialEffectActiveCountNonBolt > v2) {
      v19 = 4 * v2;
        for (i = 4 * v2;; i = v19) {
          v10 = *(_DWORD **)((char *)effectListNonBolt + i);
          v18 = v10[43];
          v11 = 4 * v18;
          --*((_DWORD *)effectClusters + 4 * v18 + 3);
          v12 = effectClusters;
            if (*((int *)effectClusters + 4 * v18 + 3) <= 0) {
              v13 = effectClusterCount - 1;
              effectClusterCount = v13;
                if (v18 != v13) {
                  *(_DWORD *)((char *)effectClusters + v11 * 4) =
                      *((_DWORD *)effectClusters + 4 * v13);
                  v12[v11 + 1] = v12[4 * v13 + 1];
                  v12[v11 + 2] = v12[4 * v13 + 2];
                  v12[v11 + 3] = v12[4 * v13 + 3];
                    if (effectActiveCountBolt > 0) {
                      v14 = 0;
                        do {
                            while (1) {
                              v15 = *((_DWORD *)effectListBolt + v14);
                              if (*(_DWORD *)(v15 + 172) == effectClusterCount)
                                break;
                              if (effectActiveCountBolt <= ++v14)
                                goto LABEL_18;
                            }
                          *(_DWORD *)(v15 + 172) = v18;
                          ++v14;
                        }
                      while (effectActiveCountBolt > v14);
                    }
                LABEL_18:
                    if (effectActiveCountNonBolt > 0) {
                      v16 = 0;
                        do {
                          v17 = *((_DWORD *)effectListNonBolt + v16);
                          if (*(_DWORD *)(v17 + 172) == effectClusterCount)
                            *(_DWORD *)(v17 + 172) = v18;
                          ++v16;
                        }
                      while (v16 < effectActiveCountNonBolt);
                    }
                }
            }
          (*(void(__cdecl **)(_DWORD *))(*v10 + 4))(v10);
          --effectActiveCountNonBolt;
          result = *((_DWORD *)effectListNonBolt + effectActiveCountNonBolt);
          *(_DWORD *)((char *)effectListNonBolt + v19) = result;
          ++v2;
          --effectActiveCount;
          v19 += 4;
          if (initialEffectActiveCountNonBolt <= v2)
            break;
        }
    }
  return result;
}

void __cdecl FX_UpdateAllBolt()
{
  int result;  // eax
  int v1;      // edi
  int v2;      // esi
  int v3;      // esi
  _DWORD *v4;  // edx
  _BYTE *v5;   // ebx
  _DWORD *v6;  // ecx
  int v7;      // esi
  int v8;      // edx
  int i;       // edx
  _DWORD *v10; // edi
  int v11;     // ebx
  _DWORD *v12; // ecx
  size_t v13;  // eax
  int v14;     // ecx
  int v15;     // edx
  int v16;     // ecx
  int v17;     // edx
  int v18;     // [esp+18h] [ebp-20h]
  int v19;     // [esp+1Ch] [ebp-1Ch]

  result = effectActiveCountBolt;
  privateEffectActiveCountBolt = effectActiveCountBolt;
  initialEffectActiveCountBolt = effectActiveCountBolt;
  v1 = 0;
  v2 = effectActiveCountBolt;
LABEL_2:
    while (v1 < v2) {
        while (1) {
          v3 = 4 * v1;
          v4 = (_DWORD *)*((_DWORD *)effectListBolt + v1);
            if ((signed int)theFxHelper->mTime <= v4[47]) {
              result = (*(int(__cdecl **)(_DWORD))(*v4 + 12))(
                  *((_DWORD *)effectListBolt + v1));
                if ((_BYTE)result) {
                  ++v1;
                  v2 = privateEffectActiveCountBolt;
                  goto LABEL_2;
                }
            }
            else {
              v4[42] &= ~0x400u;
            }
          v5 = *(_BYTE **)((char *)effectListBolt + v3);
          --privateEffectActiveCountBolt;
          v6 = (_DWORD *)((char *)effectListBolt + v3);
          v7 = *(_DWORD *)((char *)effectListBolt + v3);
          v8 = 4 * privateEffectActiveCountBolt;
          *v6 = *((_DWORD *)effectListBolt + privateEffectActiveCountBolt);
          *(_DWORD *)((char *)effectListBolt + v8) = v7;
          result = (*(int(__cdecl **)(_BYTE *))(*(_DWORD *)v5 + 8))(v5);
          if ((v5[169] & 0x10) == 0)
            break;
          --effectBlockSightCount;
          v2 = privateEffectActiveCountBolt;
          if (v1 >= privateEffectActiveCountBolt)
            goto LABEL_7;
        }
      v2 = privateEffectActiveCountBolt;
    }
LABEL_7:
    if (initialEffectActiveCountBolt > v2) {
      v19 = 4 * v2;
        for (i = 4 * v2;; i = v19) {
          v10 = *(_DWORD **)((char *)effectListBolt + i);
          v18 = v10[43];
          v11 = 4 * v18;
          --*((_DWORD *)effectClusters + 4 * v18 + 3);
          v12 = effectClusters;
            if (*((int *)effectClusters + 4 * v18 + 3) <= 0) {
              v13 = effectClusterCount - 1;
              effectClusterCount = v13;
                if (v18 != v13) {
                  *(_DWORD *)((char *)effectClusters + v11 * 4) =
                      *((_DWORD *)effectClusters + 4 * v13);
                  v12[v11 + 1] = v12[4 * v13 + 1];
                  v12[v11 + 2] = v12[4 * v13 + 2];
                  v12[v11 + 3] = v12[4 * v13 + 3];
                    if (effectActiveCountBolt > 0) {
                      v14 = 0;
                        do {
                            while (1) {
                              v15 = *((_DWORD *)effectListBolt + v14);
                              if (*(_DWORD *)(v15 + 172) == effectClusterCount)
                                break;
                              if (effectActiveCountBolt <= ++v14)
                                goto LABEL_18;
                            }
                          *(_DWORD *)(v15 + 172) = v18;
                          ++v14;
                        }
                      while (effectActiveCountBolt > v14);
                    }
                LABEL_18:
                    if (effectActiveCountNonBolt > 0) {
                      v16 = 0;
                        do {
                          v17 = *((_DWORD *)effectListNonBolt + v16);
                          if (*(_DWORD *)(v17 + 172) == effectClusterCount)
                            *(_DWORD *)(v17 + 172) = v18;
                          ++v16;
                        }
                      while (v16 < effectActiveCountNonBolt);
                    }
                }
            }
          (*(void(__cdecl **)(_DWORD *))(*v10 + 4))(v10);
          --effectActiveCountBolt;
          result = *((_DWORD *)effectListBolt + effectActiveCountBolt);
          *(_DWORD *)((char *)effectListBolt + v19) = result;
          ++v2;
          --effectActiveCount;
          v19 += 4;
          if (initialEffectActiveCountBolt <= v2)
            break;
        }
    }
  return result;
}

void __cdecl FX_UpdateScheduledEffectsBolt()
{
  int result; // eax
  int v1;     // ecx
  int v2;     // edi
  int v3;     // ebx
  _DWORD *v4; // edx
  int *v5;    // edx
  _BYTE *v6;  // ebx
  int v7;     // esi
  int v8;     // ecx
  int v9;     // edi
  int i;      // edx
  float *v11; // esi
  int v12;    // ebx
  int v13;    // [esp+1Ch] [ebp-1Ch]

  result = fx_enable;
  if (!*(_BYTE *)(fx_enable + 8))
    return result;
  cullEffectCountBolt = 0;
  visibleEffectCountBolt = 0;
  v1 = privateEffectActiveCountBolt;
  initialEffectActiveCountBolt = privateEffectActiveCountBolt;
  v2 = 0;
LABEL_3:
  result = v1;
    if (v2 < v1) {
        do {
          v3 = 4 * v2;
          v4 = (_DWORD *)*((_DWORD *)effectListBolt + v2);
            if ((signed int)theFxHelper->mTime <= v4[47]) {
                if ((*(unsigned __int8(__cdecl **)(_DWORD))(*v4 + 12))(
                        *((_DWORD *)effectListBolt + v2))) {
                  ++v2;
                  v1 = privateEffectActiveCountBolt;
                  goto LABEL_3;
                }
            }
            else {
              v4[42] &= ~0x400u;
            }
          v5 = (int *)((char *)effectListBolt + v3);
          v6 = *(_BYTE **)((char *)effectListBolt + v3);
          --privateEffectActiveCountBolt;
          v7 = *v5;
          v8 = 4 * privateEffectActiveCountBolt;
          *v5 = *((_DWORD *)effectListBolt + privateEffectActiveCountBolt);
          *(_DWORD *)((char *)effectListBolt + v8) = v7;
          (*(void(__cdecl **)(_BYTE *))(*(_DWORD *)v6 + 8))(v6);
          if ((v6[169] & 0x10) != 0)
            --effectBlockSightCount;
          v1 = privateEffectActiveCountBolt;
          result = privateEffectActiveCountBolt;
        }
      while (v2 < privateEffectActiveCountBolt);
    }
  v9 = cullEffectCountBolt;
    if (cullEffectCountBolt < v1) {
      v13 = 4 * cullEffectCountBolt;
        for (i = 4 * cullEffectCountBolt;; i = v13) {
          v11 = *(float **)((char *)effectListBolt + i);
            if (!*(_BYTE *)(fx_cull + 8) ||
                !(*(unsigned __int8(__cdecl **)(float *))(*(_DWORD *)v11 + 16))(
                    v11)) {
              v12 = visibleEffectCountBolt;
              visibleEffectsBolt[2 * visibleEffectCountBolt] = (int)v11;
              flt_4AE684[2 * v12] =
                  Vec3DistanceSq(v11 + 31, theFxHelper->mCamera.vieworg);
              ++visibleEffectCountBolt;
            }
          ++v9;
          result = privateEffectActiveCountBolt;
          v13 += 4;
          if (v9 >= privateEffectActiveCountBolt)
            break;
        }
    }
  cullEffectCountBolt = result;
  return result;
}

void __cdecl FX_UpdateScheduledEffectsNonBolt()
{
  int v0;     // ecx
  int v1;     // edi
  int v2;     // edx
  int v3;     // ebx
  _DWORD *v4; // edx
  int *v5;    // edx
  _BYTE *v6;  // ebx
  int v7;     // esi
  int v8;     // ecx
  int v9;     // edi
  int i;      // edx
  float *v11; // esi
  int v12;    // ebx
  int v13;    // [esp+1Ch] [ebp-1Ch]

  if (!*(_BYTE *)(fx_enable + 8))
    return;
  cullEffectCountNonBolt = 0;
  visibleEffectCountNonBolt = 0;
  v0 = privateEffectActiveCountNonBolt;
  initialEffectActiveCountNonBolt = privateEffectActiveCountNonBolt;
  v1 = 0;
LABEL_3:
  v2 = v0;
    if (v1 < v0) {
        do {
          v3 = 4 * v1;
          v4 = (_DWORD *)*((_DWORD *)effectListNonBolt + v1);
            if ((signed int)theFxHelper->mTime <= v4[47]) {
                if ((*(unsigned __int8(__cdecl **)(_DWORD))(*v4 + 12))(
                        *((_DWORD *)effectListNonBolt + v1))) {
                  ++v1;
                  v0 = privateEffectActiveCountNonBolt;
                  goto LABEL_3;
                }
            }
            else {
              v4[42] &= ~0x400u;
            }
          v5 = (int *)((char *)effectListNonBolt + v3);
          v6 = *(_BYTE **)((char *)effectListNonBolt + v3);
          --privateEffectActiveCountNonBolt;
          v7 = *v5;
          v8 = 4 * privateEffectActiveCountNonBolt;
          *v5 =
              *((_DWORD *)effectListNonBolt + privateEffectActiveCountNonBolt);
          *(_DWORD *)((char *)effectListNonBolt + v8) = v7;
          (*(void(__cdecl **)(_BYTE *))(*(_DWORD *)v6 + 8))(v6);
          if ((v6[169] & 0x10) != 0)
            --effectBlockSightCount;
          v0 = privateEffectActiveCountNonBolt;
          v2 = privateEffectActiveCountNonBolt;
        }
      while (v1 < privateEffectActiveCountNonBolt);
    }
    if (fx_camera_valid) {
      v9 = cullEffectCountNonBolt;
        if (cullEffectCountNonBolt < v0) {
          v13 = 4 * cullEffectCountNonBolt;
            for (i = 4 * cullEffectCountNonBolt;; i = v13) {
              v11 = *(float **)((char *)effectListNonBolt + i);
                if (!*(_BYTE *)(fx_cull + 8) ||
                    !(*(unsigned __int8(__cdecl **)(float *))(*(_DWORD *)v11 +
                                                              16))(v11)) {
                  v12 = visibleEffectCountNonBolt;
                  visibleEffectsNonBolt[2 * visibleEffectCountNonBolt] =
                      (int)v11;
                  dword_4B1EC4[2 * v12] =
                      Vec3DistanceSq(v11 + 31, theFxHelper->mCamera.vieworg);
                  ++visibleEffectCountNonBolt;
                }
              ++v9;
              v2 = privateEffectActiveCountNonBolt;
              v13 += 4;
              if (v9 >= privateEffectActiveCountNonBolt)
                break;
            }
        }
      cullEffectCountNonBolt = v2;
    }
}

float __cdecl FX_GetServerVisibility(float const *const start,
                                     float const *const end)
{
  long double result; // fst7
  int v3;             // esi
  int v4;             // ebx
  float v5;           // xmm1_4
  float v6;           // [esp+20h] [ebp-68h]
  float v7;           // [esp+3Ch] [ebp-4Ch]
  float v8;           // [esp+44h] [ebp-44h]
  float *v9;          // [esp+48h] [ebp-40h]
  float *v10;         // [esp+4Ch] [ebp-3Ch]
  float v11[3];       // [esp+58h] [ebp-30h] BYREF
  float v12;          // [esp+64h] [ebp-24h] BYREF
  float v13;          // [esp+68h] [ebp-20h]
  float v14;          // [esp+6Ch] [ebp-1Ch]

  if (!g_effectVisArrayCount)
    return 1.0;
  v12 = *a2 - *a1;
  v9 = (float *)(a1 + 1);
  v13 = a2[1] - a1[1];
  v10 = (float *)(a1 + 2);
  v14 = a2[2] - a1[2];
  v7 = Vec3Normalize(&v12);
  if (*(float *)(fx_visMinTraceDist + 8) > v7 || g_effectVisArrayCount <= 0)
    return 1.0;
  result = 1.0;
  v3 = 0;
  v4 = 0;
    do {
      v5 = (float)((float)((float)(*(float *)&g_effectVisArray[v4] - *a1) *
                           v12) +
                   (float)((float)(*(float *)&dword_FFEF04[v4] - *v9) * v13)) +
           (float)((float)(*(float *)&dword_FFEF08[v4] - *v10) * v14);
        if (fabs(v5 - (float)(v7 * 0.5)) <= (float)(v7 * 0.5)) {
          v11[0] = *a1 + (float)(v12 * v5);
          v11[1] = (float)(v13 * v5) + *v9;
          v11[2] = (float)(v14 * v5) + *v10;
          v6 = result;
          v8 = Vec3DistanceSq((float *)&g_effectVisArray[v4], v11);
          result = v6;
          if (v8 < *(float *)&dword_FFEF0C[v4])
            result = (float)(v6 * *(float *)&dword_FFEF10[v4]);
        }
      ++v3;
      v4 += 5;
    }
  while (v3 < g_effectVisArrayCount);
  return result;
}

void __cdecl FX_Rewind(int time)
{
  int v1;      // ecx
  int v2;      // edi
  int v3;      // esi
  int *v4;     // edx
  int v5;      // ebx
  int v6;      // ecx
  int v7;      // edi
  _DWORD *v8;  // esi
  int v9;      // ebx
  _DWORD *v10; // ecx
  size_t v11;  // eax
  int v12;     // ecx
  int v13;     // edx
  int v14;     // ecx
  int v15;     // edx
  int v16;     // ecx
  int v17;     // edi
  int v18;     // esi
  int *v19;    // edx
  int v20;     // ebx
  int v21;     // ecx
  int v22;     // edi
  _DWORD *v23; // esi
  int v24;     // ebx
  _DWORD *v25; // ecx
  size_t v26;  // eax
  int v27;     // ecx
  int v28;     // edx
  int v29;     // ecx
  int v30;     // edx
  int v32;     // [esp+10h] [ebp-28h]
  int v33;     // [esp+14h] [ebp-24h]
  int v34;     // [esp+18h] [ebp-20h]
  int v35;     // [esp+1Ch] [ebp-1Ch]

  v1 = effectActiveCountBolt;
  privateEffectActiveCountBolt = effectActiveCountBolt;
  initialEffectActiveCountBolt = effectActiveCountBolt;
  v2 = 0;
LABEL_2:
    while (1) {
      v32 = v1;
      if (v2 >= v1)
        break;
        while (1) {
          v3 = *((_DWORD *)effectListBolt + v2);
            if (a1 >= *(_DWORD *)(v3 + 184)) {
              ++v2;
              goto LABEL_2;
            }
          privateEffectActiveCountBolt = v1 - 1;
          v4 = (int *)((char *)effectListBolt + 4 * v2);
          v5 = *v4;
          v6 = 4 * (v1 - 1);
          *v4 = *(_DWORD *)((char *)effectListBolt + v6);
          *(_DWORD *)((char *)effectListBolt + v6) = v5;
          if ((*(_BYTE *)(v3 + 169) & 0x10) == 0)
            break;
          --effectBlockSightCount;
          v1 = privateEffectActiveCountBolt;
          v32 = privateEffectActiveCountBolt;
          if (v2 >= privateEffectActiveCountBolt)
            goto LABEL_6;
        }
      v1 = privateEffectActiveCountBolt;
    }
LABEL_6:
    if (initialEffectActiveCountBolt > v1) {
      v7 = 4 * v1;
        do {
          v8 = *(_DWORD **)((char *)effectListBolt + v7);
          v33 = v8[43];
          v9 = 4 * v33;
          --*((_DWORD *)effectClusters + 4 * v33 + 3);
          v10 = effectClusters;
            if (*((int *)effectClusters + 4 * v33 + 3) <= 0) {
              v11 = effectClusterCount - 1;
              effectClusterCount = v11;
                if (v33 != v11) {
                  *(_DWORD *)((char *)effectClusters + v9 * 4) =
                      *((_DWORD *)effectClusters + 4 * v11);
                  v10[v9 + 1] = v10[4 * v11 + 1];
                  v10[v9 + 2] = v10[4 * v11 + 2];
                  v10[v9 + 3] = v10[4 * v11 + 3];
                    if (effectActiveCountBolt > 0) {
                      v12 = 0;
                        do {
                            while (1) {
                              v13 = *((_DWORD *)effectListBolt + v12);
                              if (*(_DWORD *)(v13 + 172) == effectClusterCount)
                                break;
                              if (effectActiveCountBolt <= ++v12)
                                goto LABEL_16;
                            }
                          *(_DWORD *)(v13 + 172) = v33;
                          ++v12;
                        }
                      while (effectActiveCountBolt > v12);
                    }
                LABEL_16:
                    if (effectActiveCountNonBolt > 0) {
                      v14 = 0;
                        do {
                          v15 = *((_DWORD *)effectListNonBolt + v14);
                          if (*(_DWORD *)(v15 + 172) == effectClusterCount)
                            *(_DWORD *)(v15 + 172) = v33;
                          ++v14;
                        }
                      while (effectActiveCountNonBolt > v14);
                    }
                }
            }
          (*(void(__cdecl **)(_DWORD *))(*v8 + 4))(v8);
          --effectActiveCountBolt;
          *(_DWORD *)((char *)effectListBolt + v7) =
              *((_DWORD *)effectListBolt + effectActiveCountBolt);
          ++v32;
          --effectActiveCount;
          v7 += 4;
        }
      while (v32 < initialEffectActiveCountBolt);
    }
  v16 = effectActiveCountNonBolt;
  privateEffectActiveCountNonBolt = effectActiveCountNonBolt;
  initialEffectActiveCountNonBolt = effectActiveCountNonBolt;
  v17 = 0;
LABEL_24:
    while (1) {
      v34 = v16;
      if (v17 >= v16)
        break;
        while (1) {
          v18 = *((_DWORD *)effectListNonBolt + v17);
            if (*(_DWORD *)(v18 + 184) <= a1) {
              ++v17;
              goto LABEL_24;
            }
          privateEffectActiveCountNonBolt = v16 - 1;
          v19 = (int *)((char *)effectListNonBolt + 4 * v17);
          v20 = *v19;
          v21 = 4 * (v16 - 1);
          *v19 = *(_DWORD *)((char *)effectListNonBolt + v21);
          *(_DWORD *)((char *)effectListNonBolt + v21) = v20;
          if ((*(_BYTE *)(v18 + 169) & 0x10) == 0)
            break;
          --effectBlockSightCount;
          v16 = privateEffectActiveCountNonBolt;
          v34 = privateEffectActiveCountNonBolt;
          if (v17 >= privateEffectActiveCountNonBolt)
            goto LABEL_28;
        }
      v16 = privateEffectActiveCountNonBolt;
    }
LABEL_28:
    if (initialEffectActiveCountNonBolt > v16) {
      v22 = 4 * v16;
        do {
          v23 = *(_DWORD **)((char *)effectListNonBolt + v22);
          v35 = v23[43];
          v24 = 4 * v35;
          --*((_DWORD *)effectClusters + 4 * v35 + 3);
          v25 = effectClusters;
            if (*((int *)effectClusters + 4 * v35 + 3) <= 0) {
              v26 = effectClusterCount - 1;
              effectClusterCount = v26;
                if (v35 != v26) {
                  *(_DWORD *)((char *)effectClusters + v24 * 4) =
                      *((_DWORD *)effectClusters + 4 * v26);
                  v25[v24 + 1] = v25[4 * v26 + 1];
                  v25[v24 + 2] = v25[4 * v26 + 2];
                  v25[v24 + 3] = v25[4 * v26 + 3];
                    if (effectActiveCountBolt > 0) {
                      v27 = 0;
                        do {
                            while (1) {
                              v28 = *((_DWORD *)effectListBolt + v27);
                              if (*(_DWORD *)(v28 + 172) == effectClusterCount)
                                break;
                              if (effectActiveCountBolt <= ++v27)
                                goto LABEL_38;
                            }
                          *(_DWORD *)(v28 + 172) = v35;
                          ++v27;
                        }
                      while (effectActiveCountBolt > v27);
                    }
                LABEL_38:
                    if (effectActiveCountNonBolt > 0) {
                      v29 = 0;
                        do {
                          v30 = *((_DWORD *)effectListNonBolt + v29);
                          if (*(_DWORD *)(v30 + 172) == effectClusterCount)
                            *(_DWORD *)(v30 + 172) = v35;
                          ++v29;
                        }
                      while (effectActiveCountNonBolt > v29);
                    }
                }
            }
          (*(void(__cdecl **)(_DWORD *))(*v23 + 4))(v23);
          --effectActiveCountNonBolt;
          *(_DWORD *)((char *)effectListNonBolt + v22) =
              *((_DWORD *)effectListNonBolt + effectActiveCountNonBolt);
          ++v34;
          --effectActiveCount;
          v22 += 4;
        }
      while (initialEffectActiveCountNonBolt > v34);
    }
  return FxScheduler::Clean(theFxScheduler, 0, 0);
}

void __cdecl FX_Stop(void)
{
  UNIMPLEMENTED();
}

void __cdecl FX_Free(bool bRemoveTemplates)
{
  int v1;     // ebx
  int v2;     // edx
  int result; // eax
  int v4;     // ebx
  int v5;     // edx

    if (effectActiveCountBolt > 0) {
      v1 = 0;
        do {
          v2 = *((_DWORD *)effectListBolt + v1);
          if (v2)
            (*(void(__cdecl **)(_DWORD))(*(_DWORD *)v2 + 4))(
                *((_DWORD *)effectListBolt + v1));
          ++v1;
        }
      while (v1 < effectActiveCountBolt);
    }
  result = effectActiveCountNonBolt;
    if (effectActiveCountNonBolt > 0) {
      v4 = 0;
        do {
          result = (int)effectListNonBolt;
          v5 = *((_DWORD *)effectListNonBolt + v4);
          if (v5)
            result = (*(int(__cdecl **)(_DWORD))(*(_DWORD *)v5 + 4))(
                *((_DWORD *)effectListNonBolt + v4));
          ++v4;
        }
      while (v4 < effectActiveCountNonBolt);
    }
  effectActiveCountBolt = 0;
  effectActiveCountNonBolt = 0;
  effectActiveCount = 0;
  effectBlockSightCount = 0;
  effectClusterCount = 0;
    if (theFxScheduler) {
      FxScheduler::Clean(theFxScheduler, a1, 0);
      result = a1;
        if (a1) {
          Z_FreeInternal(theFxScheduler);
          theFxScheduler = 0;
          result = (int)fxSchedulers;
          fxSchedulers[0] = 0;
        }
    }
  return result;
}

int __cdecl FX_Init(bool rendererExists)
{
  int v1;          // ebx
  int v2;          // edx
  int v3;          // ebx
  int v4;          // edx
  FxScheduler *v5; // esi

    if (!fxInitialized) {
      fxInitialized = 1;
      effectActiveCountBolt = 0;
      effectActiveCountNonBolt = 0;
      effectActiveCount = 0;
      effectBlockSightCount = 0;
      effectClusterCount = 0;
    }
    if (effectActiveCountBolt > 0) {
      v1 = 0;
        do {
          v2 = *((_DWORD *)effectListBolt + v1);
          if (v2)
            (*(void(__cdecl **)(_DWORD))(*(_DWORD *)v2 + 4))(
                *((_DWORD *)effectListBolt + v1));
          ++v1;
        }
      while (v1 < effectActiveCountBolt);
    }
    if (effectActiveCountNonBolt > 0) {
      v3 = 0;
        do {
          v4 = *((_DWORD *)effectListNonBolt + v3);
          if (v4)
            (*(void(__cdecl **)(_DWORD))(*(_DWORD *)v4 + 4))(
                *((_DWORD *)effectListNonBolt + v3));
          ++v3;
        }
      while (v3 < effectActiveCountNonBolt);
    }
  effectActiveCountBolt = 0;
  effectActiveCountNonBolt = 0;
  effectActiveCount = 0;
  effectBlockSightCount = 0;
  effectClusterCount = 0;
    if (theFxScheduler) {
      FxScheduler::Clean(theFxScheduler, 1u, 0);
      Z_FreeInternal(theFxScheduler);
      theFxScheduler = 0;
      fxSchedulers[0] = 0;
    }
  g_rendererExists = a1;
  v5 = (FxScheduler *)Z_MallocInternal(0xCu);
  FxScheduler::FxScheduler(v5);
  theFxScheduler = v5;
  FX_InitTemplates();
  fxSchedulers[0] = theFxScheduler;
  FxHelper::Init(theFxHelper);
  return 1;
}

void __cdecl FX_CalcOrigin2(class PrimitiveTemplate const * primTemp, float * const org, float * const org2, float const * const origin, float const  ax)[3])
{
  UNIMPLEMENTED();
}

void __cdecl FX_AddFlash(struct EffectPrimitive *, float (*const)[3],
                         float const *const, int, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_DrawAll()
{
  int v0;              // edi
  int v1;              // eax
  int v2;              // edi
  int v3;              // eax
  int j;               // edx
  float *v5;           // esi
  int v6;              // ebx
  int *v7;             // esi
  int v8;              // ebx
  int v9;              // ecx
  int v10;             // edi
  float v11;           // edx
  size_t v12;          // eax
  signed __int32 v13;  // edx
  signed __int32 v14;  // ecx
  int v15;             // ebx
  _BYTE *v16;          // edx
  int v17;             // ebx
  _BYTE *v18;          // edx
  int i;               // edx
  float *v20;          // esi
  int v21;             // ebx
  int v22;             // esi
  int *v23;            // ebx
  signed __int32 v24;  // esi
  int __nel;           // [esp+14h] [ebp-5484h]
  int v26;             // [esp+18h] [ebp-5480h]
  int v27;             // [esp+1Ch] [ebp-547Ch]
  _DWORD __base[3600]; // [esp+20h] [ebp-5478h] BYREF
  _DWORD v29[1806];    // [esp+3860h] [ebp-1C38h] BYREF

    if (fx_camera_valid) {
      v0 = cullEffectCountNonBolt;
      v1 = privateEffectActiveCountNonBolt;
        if (privateEffectActiveCountNonBolt > cullEffectCountNonBolt) {
          v27 = 4 * cullEffectCountNonBolt;
            for (i = 4 * cullEffectCountNonBolt;; i = v27) {
              v20 = *(float **)((char *)effectListNonBolt + i);
                if (!*(_BYTE *)(fx_cull + 8) ||
                    !(*(unsigned __int8(__cdecl **)(float *))(*(_DWORD *)v20 +
                                                              16))(v20)) {
                  v21 = visibleEffectCountNonBolt;
                  visibleEffectsNonBolt[2 * visibleEffectCountNonBolt] =
                      (int)v20;
                  dword_4B1EC4[2 * v21] =
                      Vec3DistanceSq(v20 + 31, theFxHelper->mCamera.vieworg);
                  ++visibleEffectCountNonBolt;
                }
              ++v0;
              v1 = privateEffectActiveCountNonBolt;
              v27 += 4;
              if (privateEffectActiveCountNonBolt <= v0)
                break;
            }
        }
      cullEffectCountNonBolt = v1;
    }
  v2 = cullEffectCountBolt;
  v3 = privateEffectActiveCountBolt;
    if (cullEffectCountBolt < privateEffectActiveCountBolt) {
      v26 = 4 * cullEffectCountBolt;
        for (j = 4 * cullEffectCountBolt;; j = v26) {
          v5 = *(float **)((char *)effectListBolt + j);
            if (!*(_BYTE *)(fx_cull + 8) ||
                !(*(unsigned __int8(__cdecl **)(float *))(*(_DWORD *)v5 + 16))(
                    v5)) {
              v6 = visibleEffectCountBolt;
              visibleEffectsBolt[2 * visibleEffectCountBolt] = (int)v5;
              flt_4AE684[2 * v6] =
                  Vec3DistanceSq(v5 + 31, theFxHelper->mCamera.vieworg);
              ++visibleEffectCountBolt;
            }
          ++v2;
          v3 = privateEffectActiveCountBolt;
          v26 += 4;
          if (privateEffectActiveCountBolt <= v2)
            break;
        }
    }
  cullEffectCountBolt = v3;
    if (visibleEffectCountBolt > 0) {
      v7 = visibleEffectsBolt;
      v8 = 0;
      v9 = visibleEffectCountNonBolt;
      v10 = visibleEffectCountBolt;
        do {
          v11 = *((float *)v7 + 1);
          visibleEffectsNonBolt[2 * v9] = *v7;
          dword_4B1EC4[2 * v9++] = v11;
          ++v8;
          v7 += 2;
        }
      while (v8 < v10);
      visibleEffectCountNonBolt = v9;
    }
  g_effectVisArrayCount = 0;
    if (effectBlockSightCount) {
        if (effectActiveCountNonBolt > 0) {
          v15 = 0;
            do {
                while (1) {
                  v16 = (_BYTE *)*((_DWORD *)effectListNonBolt + v15);
                  if ((v16[169] & 0x10) != 0)
                    break;
                  if (++v15 >= effectActiveCountNonBolt)
                    goto LABEL_32;
                }
              (*(void(__cdecl **)(_DWORD))(*(_DWORD *)v16 + 28))(
                  *((_DWORD *)effectListNonBolt + v15++));
            }
          while (v15 < effectActiveCountNonBolt);
        }
    LABEL_32:
        if (effectActiveCountBolt > 0) {
          v17 = 0;
            do {
              v18 = (_BYTE *)*((_DWORD *)effectListBolt + v17);
              if ((v18[169] & 0x10) != 0)
                (*(void(__cdecl **)(_DWORD))(*(_DWORD *)v18 + 28))(
                    *((_DWORD *)effectListBolt + v17));
              ++v17;
            }
          while (v17 < effectActiveCountBolt);
        }
    }
    if (*(_BYTE *)(fx_sort + 8)) {
      __nel = visibleEffectCountNonBolt;
      v12 = effectClusterCount;
        if ((int)effectClusterCount > 0) {
          v24 = 0;
            do {
              __base[2 * v24] = v24;
              *(float *)&__base[2 * v24 + 1] =
                  Vec3DistanceSq((float *)effectClusters + 4 * v24,
                                 theFxHelper->mCamera.vieworg);
              ++v24;
              v12 = effectClusterCount;
            }
          while (v24 < (int)effectClusterCount);
        }
      qsort(__base, v12, 8u,
            (int(__cdecl *)(const void *, const void *))CompareSortedClusters);
        if ((int)effectClusterCount > 0) {
          v13 = 0;
          v14 = effectClusterCount;
            do {
              v29[__base[2 * v13]] = v13;
              ++v13;
            }
          while (v13 < v14);
        }
      clusterSort = (int)v29;
      qsort(visibleEffectsNonBolt, __nel, 8u,
            (int(__cdecl *)(const void *, const void *))CompareSortedEffects);
      clusterSort = 0;
    }
    if (*(_BYTE *)(fx_draw + 8) && visibleEffectCountNonBolt > 0) {
      v22 = 0;
      v23 = visibleEffectsNonBolt;
        do {
          (*(void(__cdecl **)(int))(*(_DWORD *)*v23 + 20))(*v23);
          ++v22;
          v23 += 2;
        }
      while (v22 < visibleEffectCountNonBolt);
    }
    if (*(_BYTE *)(fx_debug + 8)) {
      FX_Print("Active    FX: %i\n", effectActiveCount);
      FX_Print("Drawn     FX: %i\n", visibleEffectCountNonBolt);
      FX_Print("Scheduled FX: %i\n", *(_DWORD *)(theFxScheduler + 8));
    }
}

bool __cdecl FX_GetBoneOrientation(struct FxBoltInfo const *bolt,
                                   struct orientation_t *orient)
{
  DObj_s *ClientDObj;    // eax
  const DObj_s *v3;      // esi
  signed int boneIndex;  // ebx
  int32_t RotTransArray; // eax
  uint32_t v7;           // ebx
  float v8;              // xmm4_4
  float v9;              // xmm6_4
  float v10;             // xmm1_4
  float v11;             // xmm3_4
  float v12;             // xmm5_4
  float v13;             // xmm2_4
  float v14;             // xmm0_4
  float v15;             // xmm4_4
  float v16;             // xmm7_4
  float v17;             // xmm6_4
  float v18;             // xmm1_4
  float v19;             // xmm1_4
  float v20;             // xmm1_4
  float v21;             // [esp+34h] [ebp-84h]
  float v22;             // [esp+38h] [ebp-80h]
  float v23;             // [esp+3Ch] [ebp-7Ch]
  float v24[12];         // [esp+40h] [ebp-78h] BYREF
  float v25[9];          // [esp+70h] [ebp-48h] BYREF
  float v26;             // [esp+94h] [ebp-24h] BYREF
  float v27;             // [esp+98h] [ebp-20h]
  float v28;             // [esp+9Ch] [ebp-1Ch]

  CG_GetDObjOrientation(a1->dobjHandle, (float(*)[3])v24);
    if ((a1->boneIndex & 0x80000000) != 0) {
      a2->origin[0] = v24[9];
      a2->origin[1] = v24[10];
      a2->origin[2] = v24[11];
      AxisCopy(v24, a2->axis[0]);
      return 1;
    }
    else {
      ClientDObj = Com_GetClientDObj(a1->dobjHandle, 0);
      v3 = ClientDObj;
        if (ClientDObj &&
            (boneIndex = a1->boneIndex, boneIndex < DObjNumBones(ClientDObj)) &&
            (CG_DObjCalcBoneGeneric(a1->dobjHandle, 0, a1->boneIndex),
             (RotTransArray = DObjGetRotTransArray(v3)) != 0)) {
          v7 = RotTransArray + 32 * a1->boneIndex;
          v8 = *(float *)(v7 + 28) * *(float *)v7;
          v9 = *(float *)(v7 + 28) * *(float *)(v7 + 4);
          v10 = *(float *)(v7 + 28) * *(float *)(v7 + 8);
          v21 = v8 * *(float *)v7;
          v11 = *(float *)(v7 + 4);
          v12 = v8 * v11;
          v13 = *(float *)(v7 + 8);
          v22 = v8 * v13;
          v14 = *(float *)(v7 + 12);
          v15 = v8 * v14;
          v23 = v11 * v9;
          v16 = v9 * v13;
          v17 = v9 * v14;
          v25[0] = 1.0 - (float)(v23 + (float)(v10 * v13));
          v25[1] = (float)(v10 * v14) + v12;
          v25[2] = v22 - v17;
          v25[3] = v12 - (float)(v10 * v14);
          v25[4] = 1.0 - (float)((float)(v10 * v13) + v21);
          v25[5] = v15 + v16;
          v25[6] = v17 + v22;
          v25[7] = v16 - v15;
          v25[8] = 1.0 - (float)(v21 + v23);
          MatrixMultiply(v25, v24, a2->axis[0]);
          MatrixTransformVector43((const float *)(v7 + 16),
                                  (const float(*)[3])v24, a2->origin);
          v18 = *(float *)(fx_debugBolt + 8);
            if (v18 != 0.0) {
              v26 = (float)(v18 * a2->axis[0][0]) + a2->origin[0];
              v27 = (float)(v18 * a2->axis[0][1]) + a2->origin[1];
              v28 = (float)(v18 * a2->axis[0][2]) + a2->origin[2];
              CL_AddDebugLine(a2->origin, &v26, &colorRed, 1, 0, 0);
              v19 = *(float *)(fx_debugBolt + 8);
              v26 = (float)(v19 * a2->axis[1][0]) + a2->origin[0];
              v27 = (float)(v19 * a2->axis[1][1]) + a2->origin[1];
              v28 = (float)(v19 * a2->axis[1][2]) + a2->origin[2];
              CL_AddDebugLine(a2->origin, &v26, colorGreen, 1, 0, 0);
              v20 = *(float *)(fx_debugBolt + 8);
              v26 = (float)(v20 * a2->axis[2][0]) + a2->origin[0];
              v27 = (float)(v20 * a2->axis[2][1]) + a2->origin[1];
              v28 = (float)(v20 * a2->axis[2][2]) + a2->origin[2];
              CL_AddDebugLine(a2->origin, &v26, colorBlue, 1, 0, 0);
            }
          return 1;
        }
        else {
          return 0;
        }
    }
}

int __cdecl FX_Restore(struct MemoryFile *memFile)
{
  UNIMPLEMENTED();
}

int __cdecl FX_Save(struct MemoryFile *)
{
  UNIMPLEMENTED();
}

void __cdecl FX_AddLight(struct EffectPrimitive *, float (*const)[3],
                         float const *const, int, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_AddCameraShake(struct EffectPrimitive *, float (*const)[3],
                               float const *const, int, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_AddFxRunner(struct EffectPrimitive *, float (*const)[3],
                            float const *const, int, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_AddDecal(struct EffectPrimitive *, float (*const)[3],
                         float const *const, int, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_AddLine(struct EffectPrimitive *, float (*const)[3],
                        float const *const, int, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_AddCloud(struct EffectPrimitive *, float (*const)[3],
                         float const *const, int, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_AddOrientedParticle(struct EffectPrimitive *, float (*const)[3],
                                    float const *const, int, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_AddEmitter(struct EffectPrimitive *, float (*const)[3],
                           float const *const, int, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_AddCylinder(struct EffectPrimitive *, float (*const)[3],
                            float const *const, int, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_AddTail(struct EffectPrimitive *, float (*const)[3],
                        float const *const, int, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_AddParticle(struct EffectPrimitive *, float (*const)[3],
                            float const *const, int, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_AddScheduledEffects()
{
  void **v0;                // esi
  char *v1;                 // ebx
  const EffectTemplate *v2; // edi
  PrimitiveTemplate *v3;    // [esp+28h] [ebp-50h]
  orientation_t v4;         // [esp+30h] [ebp-48h] BYREF

    if (*(_BYTE *)(fx_enable + 8)) {
      v0 = (void **)(theFxScheduler + 4);
      v1 = *(char **)(theFxScheduler + 4);
        if (v1) {
            do {
                while (*((_DWORD *)v1 + 2) > (signed int)theFxHelper->mTime) {
                  v0 = (void **)(v1 + 76);
                LABEL_5:
                  v1 = (char *)*v0;
                  if (!*v0)
                    return;
                }
              v2 = *(const EffectTemplate **)v1;
              v3 = *(PrimitiveTemplate **)(*(_DWORD *)v1 +
                                           4 * *((_DWORD *)v1 + 1) + 8);
              Rand_Init(*((_DWORD *)v1 + 17));
              *v0 = (void *)*((_DWORD *)v1 + 19);
              --*(_DWORD *)(theFxScheduler + 8);
                if (*((int *)v1 + 3) < 0) {
                  FxScheduler::CreateEffect(
                      theFxScheduler, v2, v3, (const FxBoltInfo *)(v1 + 12),
                      (EffectPrimitive *)(v1 + 20), (float(*)[3])(v1 + 32),
                      theFxHelper->mTime - *((_DWORD *)v1 + 2),
                      *((PrimitiveTemplate **)v1 + 18));
                }
                else if ((unsigned __int8)FX_GetBoneOrientation(
                             (const FxBoltInfo *)(v1 + 12), &v4)) {
                  FxScheduler::CreateEffect(
                      theFxScheduler, v2, v3, (const FxBoltInfo *)(v1 + 12),
                      (EffectPrimitive *)&v4, v4.axis,
                      theFxHelper->mTime - *((_DWORD *)v1 + 2),
                      *((PrimitiveTemplate **)v1 + 18));
                }
              if (!v1)
                goto LABEL_5;
              operator delete[](v1);
              v1 = (char *)*v0;
            }
          while (*v0);
        }
    }
}

void __cdecl FX_DrawScheduledEffects()
{
  int v0;      // edi
  _DWORD *v1;  // esi
  int v2;      // ebx
  _DWORD *v3;  // ecx
  size_t v4;   // eax
  int v5;      // ecx
  int v6;      // edx
  int v7;      // ecx
  int v8;      // edx
  int v9;      // edi
  int v10;     // ecx
  int v11;     // esi
  _DWORD *v12; // edx
  _BYTE *v13;  // ebx
  _DWORD *v14; // edx
  int v15;     // esi
  int v16;     // ecx
  int v17;     // edi
  int v18;     // ecx
  int v19;     // esi
  _DWORD *v20; // edx
  _BYTE *v21;  // ebx
  _DWORD *v22; // edx
  int v23;     // esi
  int v24;     // ecx
  int v25;     // edi
  _DWORD *v26; // esi
  int v27;     // ebx
  _DWORD *v28; // ecx
  size_t v29;  // eax
  int v30;     // ecx
  int v31;     // edx
  int v32;     // ecx
  int v33;     // edx
  int v34;     // edi
  _DWORD *v35; // esi
  int v36;     // ebx
  _DWORD *v37; // ecx
  size_t v38;  // eax
  int v39;     // ecx
  int v40;     // edx
  int v41;     // ecx
  int v42;     // edx
  int v43;     // edi
  _DWORD *v44; // esi
  int v45;     // ebx
  _DWORD *v46; // ecx
  size_t v47;  // eax
  int v48;     // ecx
  int v49;     // edx
  int v50;     // ecx
  int v51;     // edx
  int v52;     // [esp+10h] [ebp-38h]
  int v53;     // [esp+14h] [ebp-34h]
  int v54;     // [esp+18h] [ebp-30h]
  int v55;     // [esp+1Ch] [ebp-2Ch]
  int v56;     // [esp+20h] [ebp-28h]
  int v57;     // [esp+24h] [ebp-24h]
  int v58;     // [esp+28h] [ebp-20h]
  int v59;     // [esp+2Ch] [ebp-1Ch]

    if (*(_BYTE *)(fx_enable + 8)) {
      v52 = privateEffectActiveCountNonBolt;
        if (privateEffectActiveCountNonBolt < initialEffectActiveCountNonBolt) {
          v0 = 4 * privateEffectActiveCountNonBolt;
            do {
              v1 = *(_DWORD **)((char *)effectListNonBolt + v0);
              v53 = v1[43];
              v2 = 4 * v53;
              --*((_DWORD *)effectClusters + 4 * v53 + 3);
              v3 = effectClusters;
                if (*((int *)effectClusters + 4 * v53 + 3) <= 0) {
                  v4 = effectClusterCount - 1;
                  effectClusterCount = v4;
                    if (v53 != v4) {
                      *(_DWORD *)((char *)effectClusters + v2 * 4) =
                          *((_DWORD *)effectClusters + 4 * v4);
                      v3[v2 + 1] = v3[4 * v4 + 1];
                      v3[v2 + 2] = v3[4 * v4 + 2];
                      v3[v2 + 3] = v3[4 * v4 + 3];
                        if (effectActiveCountBolt > 0) {
                          v5 = 0;
                            do {
                                while (1) {
                                  v6 = *((_DWORD *)effectListBolt + v5);
                                  if (*(_DWORD *)(v6 + 172) ==
                                      effectClusterCount)
                                    break;
                                  if (effectActiveCountBolt <= ++v5)
                                    goto LABEL_12;
                                }
                              *(_DWORD *)(v6 + 172) = v53;
                              ++v5;
                            }
                          while (effectActiveCountBolt > v5);
                        }
                    LABEL_12:
                        if (effectActiveCountNonBolt > 0) {
                          v7 = 0;
                            do {
                              v8 = *((_DWORD *)effectListNonBolt + v7);
                              if (*(_DWORD *)(v8 + 172) == effectClusterCount)
                                *(_DWORD *)(v8 + 172) = v53;
                              ++v7;
                            }
                          while (effectActiveCountNonBolt > v7);
                        }
                    }
                }
              (*(void(__cdecl **)(_DWORD *))(*v1 + 4))(v1);
              --effectActiveCountNonBolt;
              *(_DWORD *)((char *)effectListNonBolt + v0) =
                  *((_DWORD *)effectListNonBolt + effectActiveCountNonBolt);
              ++v52;
              --effectActiveCount;
              v0 += 4;
            }
          while (v52 < initialEffectActiveCountNonBolt);
        }
      v54 = privateEffectActiveCountBolt;
        if (initialEffectActiveCountBolt > privateEffectActiveCountBolt) {
          v43 = 4 * privateEffectActiveCountBolt;
            do {
              v44 = *(_DWORD **)((char *)effectListBolt + v43);
              v55 = v44[43];
              v45 = 4 * v55;
              --*((_DWORD *)effectClusters + 4 * v55 + 3);
              v46 = effectClusters;
                if (*((int *)effectClusters + 4 * v55 + 3) <= 0) {
                  v47 = effectClusterCount - 1;
                  effectClusterCount = v47;
                    if (v55 != v47) {
                      *(_DWORD *)((char *)effectClusters + v45 * 4) =
                          *((_DWORD *)effectClusters + 4 * v47);
                      v46[v45 + 1] = v46[4 * v47 + 1];
                      v46[v45 + 2] = v46[4 * v47 + 2];
                      v46[v45 + 3] = v46[4 * v47 + 3];
                        if (effectActiveCountBolt > 0) {
                          v48 = 0;
                            do {
                                while (1) {
                                  v49 = *((_DWORD *)effectListBolt + v48);
                                  if (*(_DWORD *)(v49 + 172) ==
                                      effectClusterCount)
                                    break;
                                  if (effectActiveCountBolt <= ++v48)
                                    goto LABEL_76;
                                }
                              *(_DWORD *)(v49 + 172) = v55;
                              ++v48;
                            }
                          while (effectActiveCountBolt > v48);
                        }
                    LABEL_76:
                        if (effectActiveCountNonBolt > 0) {
                          v50 = 0;
                            do {
                              v51 = *((_DWORD *)effectListNonBolt + v50);
                              if (*(_DWORD *)(v51 + 172) == effectClusterCount)
                                *(_DWORD *)(v51 + 172) = v55;
                              ++v50;
                            }
                          while (effectActiveCountNonBolt > v50);
                        }
                    }
                }
              (*(void(__cdecl **)(_DWORD *))(*v44 + 4))(v44);
              --effectActiveCountBolt;
              *(_DWORD *)((char *)effectListBolt + v43) =
                  *((_DWORD *)effectListBolt + effectActiveCountBolt);
              ++v54;
              --effectActiveCount;
              v43 += 4;
            }
          while (initialEffectActiveCountBolt > v54);
        }
      FX_AddScheduledEffects();
      v9 = privateEffectActiveCountNonBolt;
      v10 = effectActiveCountNonBolt;
      privateEffectActiveCountNonBolt = effectActiveCountNonBolt;
      initialEffectActiveCountNonBolt = effectActiveCountNonBolt;
    LABEL_19:
        while (1) {
          v56 = v10;
          if (v9 >= v10)
            break;
            while (1) {
              v11 = 4 * v9;
              v12 = (_DWORD *)*((_DWORD *)effectListNonBolt + v9);
                if ((signed int)theFxHelper->mTime <= v12[47]) {
                    if ((*(unsigned __int8(__cdecl **)(_DWORD))(*v12 + 12))(
                            *((_DWORD *)effectListNonBolt + v9))) {
                      ++v9;
                      v10 = privateEffectActiveCountNonBolt;
                      goto LABEL_19;
                    }
                }
                else {
                  v12[42] &= ~0x400u;
                }
              v13 = *(_BYTE **)((char *)effectListNonBolt + v11);
              --privateEffectActiveCountNonBolt;
              v14 = (_DWORD *)((char *)effectListNonBolt + v11);
              v15 = *(_DWORD *)((char *)effectListNonBolt + v11);
              v16 = 4 * privateEffectActiveCountNonBolt;
              *v14 = *((_DWORD *)effectListNonBolt +
                       privateEffectActiveCountNonBolt);
              *(_DWORD *)((char *)effectListNonBolt + v16) = v15;
              (*(void(__cdecl **)(_BYTE *))(*(_DWORD *)v13 + 8))(v13);
              if ((v13[169] & 0x10) == 0)
                break;
              --effectBlockSightCount;
              v10 = privateEffectActiveCountNonBolt;
              v56 = privateEffectActiveCountNonBolt;
              if (v9 >= privateEffectActiveCountNonBolt)
                goto LABEL_24;
            }
          v10 = privateEffectActiveCountNonBolt;
        }
    LABEL_24:
        if (initialEffectActiveCountNonBolt > v10) {
          v34 = 4 * v10;
            do {
              v35 = *(_DWORD **)((char *)effectListNonBolt + v34);
              v57 = v35[43];
              v36 = 4 * v57;
              --*((_DWORD *)effectClusters + 4 * v57 + 3);
              v37 = effectClusters;
                if (*((int *)effectClusters + 4 * v57 + 3) <= 0) {
                  v38 = effectClusterCount - 1;
                  effectClusterCount = v38;
                    if (v57 != v38) {
                      *(_DWORD *)((char *)effectClusters + v36 * 4) =
                          *((_DWORD *)effectClusters + 4 * v38);
                      v37[v36 + 1] = v37[4 * v38 + 1];
                      v37[v36 + 2] = v37[4 * v38 + 2];
                      v37[v36 + 3] = v37[4 * v38 + 3];
                        if (effectActiveCountBolt > 0) {
                          v39 = 0;
                            do {
                                while (1) {
                                  v40 = *((_DWORD *)effectListBolt + v39);
                                  if (*(_DWORD *)(v40 + 172) ==
                                      effectClusterCount)
                                    break;
                                  if (effectActiveCountBolt <= ++v39)
                                    goto LABEL_62;
                                }
                              *(_DWORD *)(v40 + 172) = v57;
                              ++v39;
                            }
                          while (effectActiveCountBolt > v39);
                        }
                    LABEL_62:
                        if (effectActiveCountNonBolt > 0) {
                          v41 = 0;
                            do {
                              v42 = *((_DWORD *)effectListNonBolt + v41);
                              if (*(_DWORD *)(v42 + 172) == effectClusterCount)
                                *(_DWORD *)(v42 + 172) = v57;
                              ++v41;
                            }
                          while (effectActiveCountNonBolt > v41);
                        }
                    }
                }
              (*(void(__cdecl **)(_DWORD *))(*v35 + 4))(v35);
              --effectActiveCountNonBolt;
              *(_DWORD *)((char *)effectListNonBolt + v34) =
                  *((_DWORD *)effectListNonBolt + effectActiveCountNonBolt);
              ++v56;
              --effectActiveCount;
              v34 += 4;
            }
          while (initialEffectActiveCountNonBolt > v56);
        }
      v17 = privateEffectActiveCountBolt;
      v18 = effectActiveCountBolt;
      privateEffectActiveCountBolt = effectActiveCountBolt;
      initialEffectActiveCountBolt = effectActiveCountBolt;
    LABEL_26:
        while (1) {
          v58 = v18;
          if (v17 >= v18)
            break;
            while (1) {
              v19 = 4 * v17;
              v20 = (_DWORD *)*((_DWORD *)effectListBolt + v17);
                if ((signed int)theFxHelper->mTime <= v20[47]) {
                    if ((*(unsigned __int8(__cdecl **)(_DWORD))(*v20 + 12))(
                            *((_DWORD *)effectListBolt + v17))) {
                      ++v17;
                      v18 = privateEffectActiveCountBolt;
                      goto LABEL_26;
                    }
                }
                else {
                  v20[42] &= ~0x400u;
                }
              v21 = *(_BYTE **)((char *)effectListBolt + v19);
              --privateEffectActiveCountBolt;
              v22 = (_DWORD *)((char *)effectListBolt + v19);
              v23 = *(_DWORD *)((char *)effectListBolt + v19);
              v24 = 4 * privateEffectActiveCountBolt;
              *v22 = *((_DWORD *)effectListBolt + privateEffectActiveCountBolt);
              *(_DWORD *)((char *)effectListBolt + v24) = v23;
              (*(void(__cdecl **)(_BYTE *))(*(_DWORD *)v21 + 8))(v21);
              if ((v21[169] & 0x10) == 0)
                break;
              --effectBlockSightCount;
              v18 = privateEffectActiveCountBolt;
              v58 = privateEffectActiveCountBolt;
              if (v17 >= privateEffectActiveCountBolt)
                goto LABEL_31;
            }
          v18 = privateEffectActiveCountBolt;
        }
    LABEL_31:
        if (initialEffectActiveCountBolt > v18) {
          v25 = 4 * v18;
            do {
              v26 = *(_DWORD **)((char *)effectListBolt + v25);
              v59 = v26[43];
              v27 = 4 * v59;
              --*((_DWORD *)effectClusters + 4 * v59 + 3);
              v28 = effectClusters;
                if (*((int *)effectClusters + 4 * v59 + 3) <= 0) {
                  v29 = effectClusterCount - 1;
                  effectClusterCount = v29;
                    if (v59 != v29) {
                      *(_DWORD *)((char *)effectClusters + v27 * 4) =
                          *((_DWORD *)effectClusters + 4 * v29);
                      v28[v27 + 1] = v28[4 * v29 + 1];
                      v28[v27 + 2] = v28[4 * v29 + 2];
                      v28[v27 + 3] = v28[4 * v29 + 3];
                        if (effectActiveCountBolt > 0) {
                          v30 = 0;
                            do {
                                while (1) {
                                  v31 = *((_DWORD *)effectListBolt + v30);
                                  if (*(_DWORD *)(v31 + 172) ==
                                      effectClusterCount)
                                    break;
                                  if (++v30 >= effectActiveCountBolt)
                                    goto LABEL_41;
                                }
                              *(_DWORD *)(v31 + 172) = v59;
                              ++v30;
                            }
                          while (v30 < effectActiveCountBolt);
                        }
                    LABEL_41:
                        if (effectActiveCountNonBolt > 0) {
                          v32 = 0;
                            do {
                              v33 = *((_DWORD *)effectListNonBolt + v32);
                              if (*(_DWORD *)(v33 + 172) == effectClusterCount)
                                *(_DWORD *)(v33 + 172) = v59;
                              ++v32;
                            }
                          while (v32 < effectActiveCountNonBolt);
                        }
                    }
                }
              (*(void(__cdecl **)(_DWORD *))(*v26 + 4))(v26);
              --effectActiveCountBolt;
              *(_DWORD *)((char *)effectListBolt + v25) =
                  *((_DWORD *)effectListBolt + effectActiveCountBolt);
              ++v58;
              --effectActiveCount;
              v25 += 4;
            }
          while (v58 < initialEffectActiveCountBolt);
        }
      FX_DrawAll();
    }
}

struct EffectCluster *effectClusters;
class Effect **effectListBolt;
class Effect **effectListNonBolt;
struct FxHelper *theFxHelper;
int effectActiveCount;
int privateEffectActiveCountBolt;
int visibleEffectCountNonBolt;
int visibleEffectCountBolt;
int privateEffectActiveCountNonBolt;
int effectClusterCount;
int cullEffectCountBolt;
int *clusterSort;
int initialEffectActiveCountBolt;
int marker_FxUtil;
int effectActiveCountBolt;
int g_effectVisArrayCount;
int initialEffectActiveCountNonBolt;
int cullEffectCountNonBolt;
int effectActiveCountNonBolt;
int effectBlockSightCount;
struct EffectVisInfo *g_effectVisArray;
int *fxInitialized;
struct FxHelper *theFxHelpers;

int __cdecl CompareSortedClusters(void const *, void const *)
{
  return 2 * (a2[1] > a1[1]) - 1;
}

int __cdecl CompareSortedEffects(void const *, void const *)
{
  int v2;     // esi
  int v3;     // ebx
  int result; // eax

  v2 = *(_DWORD *)a1;
  v3 = *(_DWORD *)a2;
  result = *(_DWORD *)(*(_DWORD *)a1 + 176) - *(_DWORD *)(*(_DWORD *)a2 + 176);
    if (!result) {
      result = *(_DWORD *)(clusterSort + 4 * *(_DWORD *)(v2 + 172)) -
               *(_DWORD *)(clusterSort + 4 * *(_DWORD *)(v3 + 172));
        if (!result) {
          result = *(_DWORD *)(v2 + 64) - *(_DWORD *)(v3 + 64);
          if (!result)
            return 2 * (a2[1] > a1[1]) - 1;
        }
    }
  return result;
}

class PrimitiveTemplate const *__cdecl FX_FindValidPrimitiveTemplate(
    struct EffectTemplate const *, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_UpdateServerVisibility(void)
{
  UNIMPLEMENTED();
}

class Effect **__cdecl FX_GetValidEffectSlotNonBolt(void)
{
  UNIMPLEMENTED();
}

class Effect **__cdecl FX_GetValidEffectSlotBolt(void)
{
  UNIMPLEMENTED();
}

void __cdecl FX_FreeEffectNonBolt(class Effect *, bool)
{
  UNIMPLEMENTED();
}

void __cdecl FX_SwapNonBolt(int, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_SwapBolt(int, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_FreeEffectInCluster(int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_CullAllNonBolt(void)
{
  UNIMPLEMENTED();
}

void __cdecl FX_CullAllBolt(void)
{
  UNIMPLEMENTED();
}

void __cdecl FX_Sort(struct SortedEffect *const, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_CheckFreeMembersNonBolt(void)
{
  UNIMPLEMENTED();
}

void __cdecl FX_CheckFreeMembersBolt(void)
{
  UNIMPLEMENTED();
}

void __cdecl FX_FreeMemberNonBolt(int, bool)
{
  UNIMPLEMENTED();
}

void __cdecl FX_FreeMemberBolt(int, bool)
{
  UNIMPLEMENTED();
}

void __cdecl FX_SetMaterialAndSequenceParams(class PrimitiveTemplate const *,
                                             class Particle *, int, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_UpdateAllBeforeDrawNonBolt(int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_UpdateAllBeforeDrawBolt(int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_PredictOrigin(class PrimitiveTemplate const *, class Particle *,
                              float *const, int)
{
  UNIMPLEMENTED();
}

void __cdecl FX_AllocError(void)
{
  UNIMPLEMENTED();
}

bool __cdecl FX_AddPrimitive(struct EffectPrimitive *, class Effect *,
                             float const *const)
{
  UNIMPLEMENTED();
}

void __cdecl FX_SaveEffect(class Effect *, class FxArchive *)
{
  UNIMPLEMENTED();
}

void __cdecl FX_CalcOriginAndAxis(struct EffectPrimitive *, float *const,
                                  float const *const, float (*const)[3])
{
  UNIMPLEMENTED();
}

void __cdecl FX_InitParticle(struct EffectPrimitive *, class Particle *,
                             float *const, float const *const,
                             float (*const)[3], int)
{
  UNIMPLEMENTED();
}
