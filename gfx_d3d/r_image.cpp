public:
long __cdecl D3DTexture::GetLevelDesc(unsigned int, struct _D3DSURFACE_DESC *) {
  UNIMPLEMENTED();
}

public:
long __cdecl D3DTexture::GetSurfaceLevel(unsigned int, struct D3DSurface **) {
  UNIMPLEMENTED();
}

public:
long __cdecl D3DVolumeTexture::GetLevelDesc(unsigned int,
                                            struct _D3DVOLUME_DESC *) {
  UNIMPLEMENTED();
}

public:
long __cdecl D3DCubeTexture::GetLevelDesc(unsigned int,
                                          struct _D3DSURFACE_DESC *) {
  UNIMPLEMENTED();
}

int __cdecl Image_MipmapRes(int, int) { UNIMPLEMENTED(); }

void __cdecl std::sort<struct GfxImage **,
                       int(__cdecl *)(struct GfxImage *, struct GfxImage *)>(
    struct GfxImage **, struct GfxImage **,
    int(__cdecl *)(struct GfxImage *, struct GfxImage *)) {
  UNIMPLEMENTED();
}

void __cdecl std::_Sort<struct GfxImage **, int,
                        int(__cdecl *)(struct GfxImage *, struct GfxImage *)>(
    struct GfxImage **, struct GfxImage **, int,
    int(__cdecl *)(struct GfxImage *, struct GfxImage *)) {
  UNIMPLEMENTED();
}

struct std::pair<struct GfxImage **, struct GfxImage **> __cdecl std::
    _Unguarded_partition<struct GfxImage **,
                         int(__cdecl *)(struct GfxImage *, struct GfxImage *)>(
        struct GfxImage **, struct GfxImage **,
        int(__cdecl *)(struct GfxImage *, struct GfxImage *)) {
  UNIMPLEMENTED();
}

void __cdecl std::make_heap<
    struct GfxImage **, int(__cdecl *)(struct GfxImage *, struct GfxImage *)>(
    struct GfxImage **, struct GfxImage **,
    int(__cdecl *)(struct GfxImage *, struct GfxImage *)) {
  UNIMPLEMENTED();
}

void __cdecl std::sort_heap<
    struct GfxImage **, int(__cdecl *)(struct GfxImage *, struct GfxImage *)>(
    struct GfxImage **, struct GfxImage **,
    int(__cdecl *)(struct GfxImage *, struct GfxImage *)) {
  UNIMPLEMENTED();
}

void __cdecl std::_Insertion_sort<
    struct GfxImage **, int(__cdecl *)(struct GfxImage *, struct GfxImage *)>(
    struct GfxImage **, struct GfxImage **,
    int(__cdecl *)(struct GfxImage *, struct GfxImage *)) {
  UNIMPLEMENTED();
}

public:
__cdecl std::pair<struct GfxImage **, struct GfxImage **>::pair<
    struct GfxImage **, struct GfxImage **>(struct GfxImage **const &,
                                            struct GfxImage **const &) {
  UNIMPLEMENTED();
}

void __cdecl std::_Median<struct GfxImage **,
                          int(__cdecl *)(struct GfxImage *, struct GfxImage *)>(
    struct GfxImage **, struct GfxImage **, struct GfxImage **,
    int(__cdecl *)(struct GfxImage *, struct GfxImage *)) {
  UNIMPLEMENTED();
}

void __cdecl std::iter_swap<struct GfxImage **, struct GfxImage **>(
    struct GfxImage **, struct GfxImage **) {
  UNIMPLEMENTED();
}

int *__cdecl std::_Dist_type<struct GfxImage **>(struct GfxImage **) {
  UNIMPLEMENTED();
}

struct GfxImage **__cdecl std::_Val_type<struct GfxImage **>(
    struct GfxImage **) {
  UNIMPLEMENTED();
}

void __cdecl std::_Make_heap<struct GfxImage **, int, struct GfxImage *,
                             int(__cdecl *)(struct GfxImage *,
                                            struct GfxImage *)>(
    struct GfxImage **, struct GfxImage **,
    int(__cdecl *)(struct GfxImage *, struct GfxImage *), int *,
    struct GfxImage **) {
  UNIMPLEMENTED();
}

void __cdecl std::pop_heap<
    struct GfxImage **, int(__cdecl *)(struct GfxImage *, struct GfxImage *)>(
    struct GfxImage **, struct GfxImage **,
    int(__cdecl *)(struct GfxImage *, struct GfxImage *)) {
  UNIMPLEMENTED();
}

void __cdecl std::rotate<struct GfxImage **>(struct GfxImage **,
                                             struct GfxImage **,
                                             struct GfxImage **) {
  UNIMPLEMENTED();
}

void __cdecl std::_Med3<struct GfxImage **,
                        int(__cdecl *)(struct GfxImage *, struct GfxImage *)>(
    struct GfxImage **, struct GfxImage **, struct GfxImage **,
    int(__cdecl *)(struct GfxImage *, struct GfxImage *)) {
  UNIMPLEMENTED();
}

void __cdecl std::swap<struct GfxImage *>(struct GfxImage *&,
                                          struct GfxImage *&) {
  UNIMPLEMENTED();
}

void __cdecl std::_Adjust_heap<struct GfxImage **, int, struct GfxImage *,
                               int(__cdecl *)(struct GfxImage *,
                                              struct GfxImage *)>(
    struct GfxImage **, int, int, struct GfxImage *,
    int(__cdecl *)(struct GfxImage *, struct GfxImage *)) {
  UNIMPLEMENTED();
}

void __cdecl std::_Pop_heap_0<struct GfxImage **, struct GfxImage *,
                              int(__cdecl *)(struct GfxImage *,
                                             struct GfxImage *)>(
    struct GfxImage **, struct GfxImage **,
    int(__cdecl *)(struct GfxImage *, struct GfxImage *), struct GfxImage **) {
  UNIMPLEMENTED();
}

struct std::random_access_iterator_tag __cdecl std::_Iter_cat<
    struct GfxImage **>(struct GfxImage **const &) {
  UNIMPLEMENTED();
}

void __cdecl std::_Rotate<struct GfxImage **>(
    struct GfxImage **, struct GfxImage **, struct GfxImage **,
    struct std::random_access_iterator_tag) {
  UNIMPLEMENTED();
}

void __cdecl std::_Push_heap<struct GfxImage **, int, struct GfxImage *,
                             int(__cdecl *)(struct GfxImage *,
                                            struct GfxImage *)>(
    struct GfxImage **, int, int, struct GfxImage *,
    int(__cdecl *)(struct GfxImage *, struct GfxImage *)) {
  UNIMPLEMENTED();
}

void __cdecl std::_Pop_heap<struct GfxImage **, int, struct GfxImage *,
                            int(__cdecl *)(struct GfxImage *,
                                           struct GfxImage *)>(
    struct GfxImage **, struct GfxImage **, struct GfxImage **,
    struct GfxImage *, int(__cdecl *)(struct GfxImage *, struct GfxImage *),
    int *) {
  UNIMPLEMENTED();
}

void __cdecl std::_Rotate<struct GfxImage **, int, struct GfxImage *>(
    struct GfxImage **, struct GfxImage **, struct GfxImage **, int *,
    struct GfxImage **) {
  UNIMPLEMENTED();
}

void __cdecl R_DownsampleMipMapBilinear(unsigned char const *src,
                                        int srcBufferSize, int srcWidth,
                                        int srcHeight, int texelPitch,
                                        unsigned char *dst, int dstBufferSize) {
  int result;                 // eax
  int v7;                     // edi
  const unsigned __int8 *v8;  // edi
  const unsigned __int8 *v9;  // esi
  int j;                      // ebx
  unsigned __int8 *v11;       // esi
  int v12;                    // ebx
  const unsigned __int8 *v13; // ecx
  const unsigned __int8 *v14; // [esp+4h] [ebp-3Ch]
  int v15;                    // [esp+Ch] [ebp-34h]
  int v16;                    // [esp+10h] [ebp-30h]
  int v17;                    // [esp+14h] [ebp-2Ch]
  int v18;                    // [esp+18h] [ebp-28h]
  int v19;                    // [esp+1Ch] [ebp-24h]
  int i;                      // [esp+2Ch] [ebp-14h]
  int v21;                    // [esp+30h] [ebp-10h]

  result = a3;
  if (a3 != 1 || a4 != 1) {
    v15 = a3 >> 1;
    v7 = a4 >> 1;
    v16 = a4 >> 1;
    v19 = a5 * a3;
    result = a3 >> 1;
    if (a3 >> 1 && v7) {
      if (v7 > 0) {
        v17 = 0;
        do {
          v8 = &a1[2 * v19 * v17];
          result = (int)&a6[a5 * (a3 >> 1) * v17];
          v21 = result;
          if (v15 > 0) {
            for (i = 0; i != v15; ++i) {
              if (a5 > 0) {
                v9 = &v8[v19 + a5];
                for (j = 0; j != a5; ++j)
                  *(_BYTE *)(v21 + j) =
                      (*v9++ + v8[j + v19] + v8[j] + v8[j + a5]) >> 2;
              }
              result = a5;
              v21 += a5;
              v8 += 2 * a5;
            }
          }
          ++v17;
        } while (v16 != v17);
      }
    } else {
      result = v16 + v15;
      if (v16 + v15 > 0) {
        v14 = a1;
        v11 = a6;
        v18 = 0;
        do {
          if (a5 > 0) {
            v12 = 0;
            v13 = v14;
            do {
              v11[v12++] = (v13[a5] + *v13) >> 1;
              ++v13;
            } while (a5 != v12);
          }
          v11 += a5;
          result = 2 * a5;
          v14 += 2 * a5;
          ++v18;
        } while (v16 + v15 != v18);
      }
    }
  }
  return result;
}

void __cdecl Load_Texture(struct GfxImageLoadDef **, unsigned long,
                          struct GfxImage *) {
  UNIMPLEMENTED();
}

void __cdecl R_FreeImageAllocations() { ; }

void __cdecl R_ResetImageAllocations() { ; }

struct GfxImage *__cdecl Image_AllocProg(int imageProgType,
                                         unsigned char category) {
  char *v2; // ebx
  char *v3; // edx
  int i;    // eax

  v2 = (char *)&g_imageProgs + 36 * a1;
  v3 = (&g_imageProgNames)[a1];
  *((_DWORD *)v2 + 8) = v3;
  v2[30] = a2;
  v2[10] = 0;
  v2[12] = 0;
  for (i = R_HashAssetName(v3) & 0x7FF; imageGlobals[i];
       i = ((_WORD)i + 1) & 0x7FF)
    ;
  imageGlobals[i] = (int)v2;
  return (char *)&g_imageProgs + 36 * a1;
}

void __cdecl Image_Release(struct GfxImage *image) {
  int result;    // eax
  GfxTexture v2; // edx
  GfxImage *v3;  // edx
  int *v4;       // ecx

  if (a1->track > 4u || (result = 1 << a1->track, (result & 0x13) == 0)) {
    v3 = a1;
    v4 = &imageGlobals;
    do {
      result = v4[2051] - LODWORD(v3->cardMemory.platform);
      v4[2051] = result;
      ++v4;
      v3 = (GfxImage *)((char *)v3 + 4);
    } while (v4 != (int *)&unk_C94BC8);
  }
  v2.basemap = (int32_t)a1->texture;
  if (v2.basemap) {
    result = (*(int(__cdecl **)(GfxTexture))(*(_DWORD *)v2.basemap + 8))(
        a1->texture);
    a1->texture.basemap = 0;
    a1->cardMemory.platform = 0;
  }
  a1->mapType = 0;
  return result;
}

struct GfxImage *__cdecl Image_AllocTemp(void) {
  UNIMPLEMENTED();
}

void *__cdecl Image_PhysicalAlloc(int) { UNIMPLEMENTED(); }

void __cdecl Image_TrackTexture(struct GfxImage *image, int imageFlags,
                                enum _D3DFORMAT format, int width, int height,
                                int depth) {
  int v6;     // esi
  int v7;     // edi
  char v8;    // cl
  int v9;     // edx
  int v10;    // ebx
  int v11;    // eax
  int result; // eax
  int v13;    // ebx
  int *v14;   // esi
  int *v15;   // [esp+2Ch] [ebp-1Ch]

  if ((a2 & 1) != 0) {
    v13 = a1;
    v14 = imageGlobals;
    do {
      result = Image_GetCardMemoryAmount(a2, a3, a4, a5, a6);
      *(_DWORD *)(v13 + 16) = result;
      if (*(_BYTE *)(a1 + 12) > 4u || ((1 << *(_BYTE *)(a1 + 12)) & 0x13) == 0)
        v14[2051] += result;
      ++v14;
      v13 += 4;
    } while (&unk_C94BC8 != (_UNKNOWN *)v14);
  } else {
    v6 = a1;
    v7 = a1;
    v15 = imageGlobals;
    do {
      v8 = *(_BYTE *)(v6 + 8);
      v9 = a4 >> v8;
      if (1 - (a4 >> v8) >= 0)
        v9 = 1;
      v10 = a5 >> v8;
      if (1 - (a5 >> v8) >= 0)
        v10 = 1;
      v11 = a6 >> v8;
      if (1 - (a6 >> v8) >= 0)
        v11 = 1;
      result = Image_GetCardMemoryAmount(a2, a3, v9, v10, v11);
      *(_DWORD *)(v7 + 16) = result;
      if (*(_BYTE *)(a1 + 12) > 4u || ((1 << *(_BYTE *)(a1 + 12)) & 0x13) == 0)
        v15[2051] += result;
      ++v15;
      v7 += 4;
      ++v6;
    } while (&unk_C94BC8 != (_UNKNOWN *)v15);
  }
  return result;
}

void __cdecl R_GetImageList(struct ImageList *) {
  a1->count = 0;
  return DB_EnumXAssets(3, (void (*)(XAssetHeader, void *))R_AddImageToList,
                        a1);
}

void __cdecl R_SumOfUsedImages(struct Image_MemUsage *) { UNIMPLEMENTED(); }

void __cdecl Image_SetupSystem(struct GfxImage *image, unsigned short width,
                               unsigned short height,
                               enum _D3DFORMAT imageFormat) {
  int v4;         // ebx
  const char *v6; // eax

  *(_WORD *)(a1 + 24) = a2;
  *(_WORD *)(a1 + 26) = a3;
  *(_WORD *)(a1 + 28) = 1;
  *(_DWORD *)a1 = 3;
  v4 = (*(int(__cdecl **)(int, _DWORD, _DWORD, int, int, int, int, int,
                          _DWORD))(*(_DWORD *)dword_117D8A8 + 92))(
      dword_117D8A8, a2, a3, 1, 512, a4, 2, a1 + 4, 0);
  if (v4 < 0) {
    v6 = (const char *)R_ErrorDescription();
    R_Error(ERR_DROP, "Create2DTexture( %s, %i, %i, %i, %i ) failed: %08x = %s",
            *(const char **)(a1 + 32), *(unsigned __int16 *)(a1 + 24),
            *(unsigned __int16 *)(a1 + 26), 0, a4, v4, v6);
  }
  return Image_TrackTexture(a1, 3, a4, a2, a3, 1);
}

void __cdecl Image_SetupRenderTarget(struct GfxImage *image,
                                     unsigned short width,
                                     unsigned short height,
                                     enum _D3DFORMAT imageFormat) {
  int v4;         // ebx
  const char *v6; // eax

  *(_WORD *)(a1 + 24) = a2;
  *(_WORD *)(a1 + 26) = a3;
  *(_WORD *)(a1 + 28) = 1;
  *(_DWORD *)a1 = 3;
  v4 = (*(int(__cdecl **)(int, _DWORD, _DWORD, int, int, int, _DWORD, int,
                          _DWORD))(*(_DWORD *)dword_117D8A8 + 92))(
      dword_117D8A8, a2, a3, 1, 1, a4, 0, a1 + 4, 0);
  if (v4 < 0) {
    v6 = (const char *)R_ErrorDescription();
    R_Error(ERR_DROP, "Create2DTexture( %s, %i, %i, %i, %i ) failed: %08x = %s",
            *(const char **)(a1 + 32), *(unsigned __int16 *)(a1 + 24),
            *(unsigned __int16 *)(a1 + 26), 0, a4, v4, v6);
  }
  return Image_TrackTexture(a1, 3, a4, a2, a3, 1);
}

void __cdecl Image_TrackFullscreenTexture(struct GfxImage *image, int picmip,
                                          enum _D3DFORMAT format) {
  int v3;     // ebx
  _DWORD *v4; // edi
  _DWORD *v5; // esi
  int v6;     // eax
  int v7;     // edx
  int result; // eax
  bool v9;    // zf
  int v10;    // [esp+3Ch] [ebp-2Ch]
  int v11;    // [esp+4Ch] [ebp-1Ch]

  v11 = 0;
LABEL_2:
  v3 = vidConfig;
  v4 = (_DWORD *)((char *)&unk_C96BCC + 4 * v11);
  v5 = (_DWORD *)(4 * v11 + a1 + 16);
  if (v11 == 1)
    v10 = 480;
  else
    v10 = HIDWORD(vidConfig);
  while (1) {
    v6 = v3 >> a2;
    LOWORD(v7) = 1;
    if (1 - (v3 >> a2) >= 0)
      LOWORD(v6) = 1;
    if (1 - (v10 >> a2) < 0)
      v7 = v10 >> a2;
    result = Image_GetCardMemoryAmount(3, a3, (unsigned __int16)v6,
                                       (unsigned __int16)v7, 1);
    *v5 += result;
    if (*(_BYTE *)(a1 + 12) > 4u || ((1 << *(_BYTE *)(a1 + 12)) & 0x13) == 0)
      break;
    v9 = ++v11 == 1;
    if (v11 > 1)
      return result;
  LABEL_13:
    if (!v9)
      goto LABEL_2;
    ++v4;
    ++v5;
    v10 = 480;
    v3 = 640;
  }
  *v4 += result;
  v9 = ++v11 == 1;
  if (v11 <= 1)
    goto LABEL_13;
  return result;
}

void __cdecl R_ImageList_f() {
  int v0;           // ecx
  _DWORD *v1;       // ebx
  unsigned int v2;  // edx
  int *v3;          // edx
  int v4;           // ebx
  int v5;           // eax
  int v6;           // edx
  int *v7;          // eax
  int *i;           // edi
  GfxImage **v9;    // ebx
  GfxImage *j;      // edx
  GfxImage *v11;    // esi
  const char **v12; // esi
  int v13;          // ecx
  int v14;          // ecx
  int v15;          // eax
  int v16;          // eax
  int v17;          // ebx
  int k;            // esi
  int *v19;         // edi
  float v20;        // xmm0_4
  double v21;       // xmm1_8
  int v22;          // edx
  int v23;          // eax
  int m;            // esi
  const char **v25; // ebx
  int v26;          // edi
  int *v27;         // ebx
  int v28;          // esi
  int v29;          // eax
  char *v30;        // eax
  int v31;          // esi
  _DWORD *v32;      // edi
  float v33;        // xmm1_4
  const char *v34;  // edx
  int v35;          // edx
  int v36;          // eax
  int v37;          // [esp+Ch] [ebp-20FCh]
  int v38;          // [esp+30h] [ebp-20D8h]
  int v39;          // [esp+34h] [ebp-20D4h]
  int v40;          // [esp+38h] [ebp-20D0h]
  bool v41;         // [esp+3Fh] [ebp-20C9h]
  char *v42;        // [esp+40h] [ebp-20C8h]
  GfxImage *v43;    // [esp+44h] [ebp-20C4h]
  int *v44;         // [esp+48h] [ebp-20C0h]
  const char **v45; // [esp+4Ch] [ebp-20BCh]
  int v46;          // [esp+58h] [ebp-20B0h] BYREF
  int __src[16];    // [esp+5Ch] [ebp-20ACh] BYREF
  int v48[2032];    // [esp+9Ch] [ebp-206Ch] BYREF
  _DWORD __b[20];   // [esp+205Ch] [ebp-ACh] BYREF
  int v50[8];       // [esp+20ACh] [ebp-5Ch] BYREF
  int v51[7];       // [esp+20CCh] [ebp-3Ch] BYREF
  _DWORD v52[8];    // [esp+20E8h] [ebp-20h] BYREF

  v41 = 0;
  if (unk_11807C0() == 2) {
    v30 = (char *)unk_11807C4(1);
    if (!I_stricmp(v30, "all"))
      v41 = 1;
  }
  v52[0] = 0;
  v52[1] = 0;
  memset(__b, 0, sizeof(__b));
  v46 = 0;
  v37 = 1;
  DB_EnumXAssets(3, (void (*)(XAssetHeader, void *))R_AddImageToList, &v46);
  if (v41) {
    v0 = 0;
    v1 = &g_imageProgs;
    v2 = v46;
    do {
      if (v2 > 0x7FF)
        break;
      if (*v1) {
        __src[v2] = (int)&g_imageProgs + 36 * v0;
        v46 = ++v2;
      }
      ++v0;
      v1 += 9;
    } while (v0 != 12);
  } else {
    v2 = v46;
  }
  v3 = &__src[v2];
  v42 = (char *)v3;
  if (__src != v3) {
    v4 = (char *)v3 - (char *)__src;
    v5 = v3 - __src;
    if (v5 == 1) {
      LOBYTE(v5) = 0;
    } else {
      v6 = 0;
      do {
        ++v6;
        v5 >>= 1;
      } while (v5 != 1);
      v5 = 2 * v6;
    }
    std::__introsort_loop<GfxImage **, int, int (*)(GfxImage *, GfxImage *)>(
        (char *)__src, v42, v5, (int(__cdecl *)(int, int))imagecompare);
    if (v4 <= 67) {
      std::__insertion_sort<GfxImage **, int (*)(GfxImage *, GfxImage *)>(
          __src, (int *)v42, (int(__cdecl *)(int, int))imagecompare);
    } else {
      std::__insertion_sort<GfxImage **, int (*)(GfxImage *, GfxImage *)>(
          __src, v48, (int(__cdecl *)(int, int))imagecompare);
      if (v42 != (char *)v48) {
        v44 = v48;
        v7 = v48;
        for (i = v48;; i = v44) {
          v43 = (GfxImage *)*v7;
          v9 = (GfxImage **)(v44 - 1);
          for (j = (GfxImage *)*v7;; j = v43) {
            v11 = *v9;
            if (!imagecompare(j, *v9))
              break;
            *i = (int)v11;
            i = (int *)v9--;
          }
          *i = (int)v43;
          if (v42 == (char *)++v44)
            break;
          v7 = v44;
        }
      }
    }
  }
  ri(0, "\n-if-- ");
  v12 = (const char **)g_platform_name;
  do
    ri(0, "%s", *v12++);
  while (&unk_3111A8 != (_UNKNOWN *)v12);
  ri(0, "  --name-------\n");
  if (v46 > 0) {
    v38 = 0;
    v13 = 0;
    do {
      v14 = __src[v13];
      v39 = v14;
      v15 = *(_DWORD *)v14;
      if (*(_DWORD *)v14 == 4) {
        (*(void(__cdecl **)(_DWORD, _DWORD, int *, int))(
            **(_DWORD **)(v14 + 4) + 68))(*(_DWORD *)(v14 + 4), 0, v51, v37);
        v16 = v51[0];
      } else {
        if (v15 == 5) {
          v29 = *(_DWORD *)(v14 + 4);
        } else {
          if (v15 != 3)
            return;
          v29 = *(_DWORD *)(v14 + 4);
        }
        (*(void(__cdecl **)(int, _DWORD, int *))(*(_DWORD *)v29 + 68))(v29, 0,
                                                                       v50);
        v16 = v50[0];
      }
      if (v16 == 50) {
        ri(0, "L8    ");
      } else if (v16 > 50) {
        if (v16 == 827611204) {
          ri(0, "DXT1  ");
        } else if (v16 <= 827611204) {
          if (v16 == 51) {
            ri(0, "AL16  ");
          } else if (v16 == 114) {
            ri(0, "R32F  ");
          }
        } else if (v16 == 861165636) {
          ri(0, "DXT3  ");
        } else if (v16 == 894720068) {
          ri(0, "DXT5  ");
        }
      } else if (v16 == 22) {
        ri(0, "RGB32 ");
      } else if (v16 <= 22) {
        if (v16 == 21)
          ri(0, "RGBA32");
      } else if (v16 == 23) {
        ri(0, "RGB16 ");
      } else if (v16 == 28) {
        ri(0, "A8    ");
      }
      ri(0, "  %s", imageTypeName[*(unsigned __int8 *)(v39 + 12)]);
      if (v41) {
        v31 = v39;
        v40 = 0;
        v32 = v52;
        do {
          v33 = (float)*(int *)(v31 + 16) * 0.0009765625;
          v34 = "%7.1f";
          if (v33 >= 10.0)
            v34 = "%7.0f";
          ri(0, v34, COERCE_UNSIGNED_INT64(v33),
             HIDWORD(COERCE_UNSIGNED_INT64(v33)));
          v35 = *(_DWORD *)(v31 + 16);
          v36 = v40 + 2 * *(unsigned __int8 *)(v39 + 12);
          __b[v36] += v35;
          *v32 += v35;
          ++v40;
          ++v32;
          v31 += 4;
        } while (v40 != 2);
      } else {
        v17 = v39;
        for (k = 0; k != 2; ++k) {
          v19 = (int *)(v17 + 16);
          v20 = (float)*(int *)(v17 + 16) * 0.0009765625;
          v21 = v20;
          if (v20 < 10.0)
            ri(0, "%7.1f", v21);
          else
            ri(0, "%7.0f", v21);
          v22 = *v19;
          v23 = k + 2 * *(unsigned __int8 *)(v39 + 12);
          __b[v23] += *v19;
          if (*(_BYTE *)(v39 + 12) > 4u ||
              ((1 << *(_BYTE *)(v39 + 12)) & 0x13) == 0)
            v52[k] += v22;
          v17 += 4;
        }
      }
      ri(0, stru_2182FC.name, *(_DWORD *)(v39 + 32));
      v13 = ++v38;
    } while (v38 < v46);
  }
  ri(0, " ---------\n");
  ri(0, " %i total images\n", v46);
  for (m = 0; m != 2; ++m)
    ri(0, " %5.1f MB %s total image size\n",
       (float)((float)(int)v52[m] * 0.00000095367432), g_platform_name[m]);
  ri(0, "\n");
  ri(0, "       ");
  v25 = (const char **)g_platform_name;
  do
    ri(0, "%s", *v25++);
  while (v25 != (const char **)&unk_3111A8);
  ri(0, "\n");
  v26 = 0;
  v45 = (const char **)imageTypeName;
  do {
    ri(0, "%s:", *v45);
    v27 = &__b[2 * v26];
    v28 = 2;
    do {
      ri(0, "  %5.1f", (float)((float)*v27++ * 0.00000095367432));
      --v28;
    } while (v28);
    ri(0, "  MB\n");
    ++v26;
    ++v45;
  } while (v26 != 10);
  ri(0, "Related commands: meminfo, imagelist, gfx_world, gfx_model, "
        "cg_drawfps, com_statmon, tempmeminfo\n");
}

struct GfxImage *__cdecl Image_FindExisting(char const *) {
  UNIMPLEMENTED();
}

void __cdecl Image_RebuildCosinePowerMap(float shift) {
  int *result;                 // eax
  int v2;                      // ebx
  int v3;                      // edi
  const char *v4;              // eax
  unsigned __int8 __src[8216]; // [esp+30h] [ebp-2018h] BYREF

  result = (int *)r_rendererInUse;
  if (*(_DWORD *)(r_rendererInUse + 8) != 2) {
    RB_UnbindImage((const GfxImage *)rgp[1029]);
    do {
      (*(void(__cdecl **)(_DWORD))(**(_DWORD **)(rgp[1029] + 4) + 8))(
          *(_DWORD *)(rgp[1029] + 4));
      *(_DWORD *)(rgp[1029] + 4) = 0;
    } while (alwaysfails);
    v2 = rgp[1029];
    *(_WORD *)(v2 + 24) = 32;
    *(_WORD *)(v2 + 26) = 256;
    *(_WORD *)(v2 + 28) = 1;
    *(_DWORD *)v2 = 3;
    v3 = (*(int(__cdecl **)(int, int, int, int, _DWORD, int, int, int, _DWORD))(
        *(_DWORD *)dword_117D8A8 + 92))(dword_117D8A8, 32, 256, 1, 0, 50, 1,
                                        v2 + 4, 0);
    if (v3 < 0) {
      v4 = (const char *)R_ErrorDescription();
      R_Error(ERR_DROP,
              "Create2DTexture( %s, %i, %i, %i, %i ) failed: %08x = %s",
              *(const char **)(v2 + 32), *(unsigned __int16 *)(v2 + 24),
              *(unsigned __int16 *)(v2 + 26), 0, 50, v3, v4);
    }
    Image_BuildSpecularityMap(a1, __src);
    return Image_UploadData((int *)rgp[1029], 50, 0, 0, (char *)__src);
  }
  return result;
}

struct GfxImage *__cdecl Image_Register(char const *imageName,
                                        unsigned char semantic,
                                        int imageTrack) {
  int v3;       // ebx
  GfxImage *v4; // esi
  int v5;       // eax

  v3 = R_HashAssetName(__s1) & 0x7FF;
  v4 = (GfxImage *)imageGlobals[v3];
  if (v4) {
    while (strcmp(__s1, *(const char **)v4->name)) {
      v3 = ((_WORD)v3 + 1) & 0x7FF;
      v4 = (GfxImage *)imageGlobals[v3];
      if (!v4)
        goto LABEL_4;
    }
  }
  if (v4 < (GfxImage *)&g_imageProgs || v4 >= (GfxImage *)&unk_C94BB0)
  LABEL_4:
    v5 = 0;
  else
    v5 = 1;
  if (v5 || !v4) {
    v4 = Image_Load(__s1, a2, a3);
    if (!v4)
      R_Error(ERR_DROP, "failed to load image '%s'", __s1);
  }
  return v4;
}

void __cdecl R_InitImages() { UNIMPLEMENTED(); }

struct D3DSurface *__cdecl Image_GetSurface(struct GfxImage *image) {
  _DWORD v2[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  do
    (*(void(__cdecl **)(GfxTexture, _DWORD, _DWORD *))(
        *(_DWORD *)a1->texture.basemap + 72))(a1->texture, 0, v2);
  while (alwaysfails);
  return v2[0];
}

char const **g_platform_name;
int marker_r_image;
int __cdecl imagecompare(struct GfxImage *, struct GfxImage *) {
  unsigned __int8 track; // al

  track = a2->track;
  if ((unsigned int)a1->track > track)
    return 0;
  if ((unsigned int)a1->track < track)
    return 1;
  return SLODWORD(a1->cardMemory.platform) < SLODWORD(a2->cardMemory.platform);
}

void __cdecl Image_Construct(char const *, int, unsigned char, unsigned char,
                             int, struct GfxImage *) {
  UNIMPLEMENTED();
}

int __cdecl Image_GetPlatformScreenHeight(int) { UNIMPLEMENTED(); }

int __cdecl Image_GetPlatformScreenWidth(int) { UNIMPLEMENTED(); }

void __cdecl R_AddImageToList(union XAssetHeader, void *) {
  XAssetHeader *result; // eax
  XAssetHeader v3;      // edx

  result = a2;
  v3.parts = a2->parts;
  a2[v3.parts + 1] = a1;
  a2->parts = v3.parts + 1;
  return result;
}

void __cdecl Image_GetMipmapResolution(int, int, int, unsigned short *,
                                       unsigned short *) {
  UNIMPLEMENTED();
}

void __cdecl R_InitCodeImages(void) { UNIMPLEMENTED(); }

R_GetMinSpecImageMemory() { UNIMPLEMENTED(); }

Image_Create2DTexture(GfxImage *image, unsigned short width,
                      unsigned short height, int mipmapCount,
                      unsigned long usage, _D3DFORMAT imageFormat,
                      _D3DPOOL memPool) {
  UNIMPLEMENTED();
}

Image_Create3DTexture(GfxImage *image, unsigned short width,
                      unsigned short height, unsigned short depth,
                      int mipmapCount, unsigned long usage,
                      _D3DFORMAT imageFormat, _D3DPOOL memPool) {
  UNIMPLEMENTED();
}

Image_CreateCubeTexture(GfxImage *image, unsigned short edgeLen,
                        int mipmapCount, unsigned long usage,
                        _D3DFORMAT imageFormat, _D3DPOOL memPool) {
  UNIMPLEMENTED();
}

Image_PicmipForSemantic(unsigned char semantic, Picmip *picmip) {
  UNIMPLEMENTED();
}

R_SetPicmip() { UNIMPLEMENTED(); }

R_LoadWaterSetup(water_t const *water) { UNIMPLEMENTED(); }

void std::__adjust_heap<GfxImage **, int, GfxImage *,
                        int (*)(GfxImage *, GfxImage *)>(
    GfxImage **, int, int, GfxImage *, int (*)(GfxImage *, GfxImage *)) {
  UNIMPLEMENTED();
}

R_ReloadLostImages() { UNIMPLEMENTED(); }

void std::__insertion_sort<GfxImage **, int (*)(GfxImage *, GfxImage *)>(
    GfxImage **, GfxImage **, int (*)(GfxImage *, GfxImage *)) {
  UNIMPLEMENTED();
}

Image_Alloc(char const *name, unsigned char category, unsigned char semantic,
            int imageTrack) {
  UNIMPLEMENTED();
}

void std::__introsort_loop<GfxImage **, int, int (*)(GfxImage *, GfxImage *)>(
    GfxImage **, GfxImage **, int, int (*)(GfxImage *, GfxImage *)) {
  UNIMPLEMENTED();
}

R_ShutdownImages() { UNIMPLEMENTED(); }

R_ReleaseLostImages() { UNIMPLEMENTED(); }

Image_UpdatePicmip(GfxImage *image) { UNIMPLEMENTED(); }

Image_Reload(GfxImage *image) { UNIMPLEMENTED(); }
