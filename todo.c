
/* Unmatched IDA functions */

void __cdecl __noreturn start(const char *argv) {
  int argc; // [esp+14h] [ebp+0h]

  _start(argc, &argv, (char **)&(&argv)[argc + 1]);
}

void __cdecl __noreturn _start(int argc, const char **argv, char **envp) {
  const char *v3;    // edi
  const char *v4;    // eax
  const char *v5;    // edx
  char v6;           // cl
  const char *v7;    // esi
  char **v8;         // eax
  int v9;            // eax
  void (*v10)(void); // [esp+1Ch] [ebp-1Ch]

  NXArgc = argc;
  NXArgv = (int)argv;
  environ = (int)envp;
  if (mach_init_routine)
    mach_init_routine();
  if (_cthread_init_routine)
    _cthread_init_routine();
  __keymgr_dwarf2_register_sections();
  _call_mod_init_funcs();
  if (v10)
    atexit(v10);
  errno = 0;
  v3 = *argv;
  if (*argv) {
    v6 = *v3;
    if (!*v3)
      goto LABEL_14;
    v7 = v3 + 1;
    v5 = *argv;
    v4 = 0;
    do {
      if (v6 == 47)
        v4 = v5;
      v5 = v7;
      v6 = *v7++;
    } while (v6);
    if (v4)
      __progname = (gentity_s *)(v4 + 1);
    else
    LABEL_14:
      __progname = (gentity_s *)*argv;
  }
  if (*envp) {
    v8 = envp;
    do
      ++v8;
    while (*v8);
  }
  v9 = main(argc, argv, (const char **)envp);
  exit(v9);
}

int _call_mod_init_funcs() {
  _DWORD v1[3]; // [esp+1Ch] [ebp-Ch] BYREF

  return ((int(__cdecl *)(float *, _DWORD *))v1[0])(&inData.s.pos.trBase[1],
                                                    v1);
}

_BOOL4 __cdecl UserPaneHitTestProc(ControlRef control, Point a2) {
  Rect bounds; // [esp+18h] [ebp-10h] BYREF

  GetControlBounds(control, &bounds);
  return (unsigned __int8)((int(__cdecl *)(_DWORD, _DWORD))PtInRect)(
             a2, &bounds) != 0;
}

void __cdecl ValidationProc(ControlRef theControl) {
  unsigned __int16 ControlMaximum; // bx
  __int16 v2;                      // ax
  _WORD inData[2];                 // [esp+28h] [ebp-10h] BYREF
  Size outMaxSize[3];              // [esp+2Ch] [ebp-Ch] BYREF

  ControlMaximum = GetControlMaximum(theControl);
  if (ControlMaximum) {
    if (GetControlDataSize(theControl, 0, 0x74657874u, outMaxSize))
      v2 = 0;
    else
      v2 = outMaxSize[0];
    if (v2 > (int)ControlMaximum) {
      inData[0] = ControlMaximum;
      inData[1] = 0x7FFF;
      SetControlData(theControl, 0, 0x73656C65u, 4, inData);
      HandleControlKey(theControl, 0, 8, 0);
    }
  }
}

UInt32 __cdecl HandleStandardEvents(EventHandlerCallRef a1, EventRef inEvent,
                                    OpaqueWindowPtr *window) {
  UInt32 EventKind;              // ebx
  OSType EventClass;             // eax
  OpaqueWindowPtr *ControlOwner; // eax
  OpaqueControlRef *Root;        // eax
  ThemeCursor v8;                // eax
  ControlKind outControlKind;    // [esp+2Eh] [ebp-1Ah] BYREF
  HIViewRef outData[3];          // [esp+3Ch] [ebp-Ch] BYREF

  EventKind = GetEventKind(inEvent);
  EventClass = GetEventClass(inEvent);
  if (EventClass == 1668113523) {
    if (EventKind == 1 && !GetEventParameter(inEvent, 0x2D2D2D2Du, 0x68636D64u,
                                             0, 0xEu, 0, &outControlKind)) {
      if (outControlKind.kind == 1869291552) {
        SetWRefCon(window, 1869291552);
        QuitAppModalLoopForWindow(window);
        LOBYTE(EventKind) = 0;
        return EventKind;
      }
      if (outControlKind.kind == 1852797985) {
        SetWRefCon(window, 1852797985);
        QuitAppModalLoopForWindow(window);
        return 0;
      }
      if (sBuilderProcPtr &&
          (unsigned __int8)sBuilderProcPtr(window, outControlKind.kind))
        return 0;
    }
    return -9874;
  }
  if (EventClass <= 0x636D6473) {
    if (EventClass == 1349675382 && EventKind == 1097102915 &&
        !GetEventParameter(inEvent, 0x504F6E65u, 0x6D61676Eu, 0, 4u, 0,
                           outData)) {
      ControlOwner = GetControlOwner(outData[0]);
      AdvanceKeyboardFocus(ControlOwner);
      return -9874;
    }
  } else {
    if (EventClass != 1836021107) {
      if (EventClass == 2003398244 && EventKind == 72) {
        if (sBuilderProcPtr) {
          sBuilderProcPtr(window, 1668050803);
          LOBYTE(EventKind) = 0;
          return EventKind;
        }
        return 0;
      }
      return -9874;
    }
    if (EventKind == 5) {
      Root = HIViewGetRoot(window);
      EventKind = HIViewGetViewForMouseEvent(Root, inEvent, outData);
      if (!EventKind) {
        if (!outData[0]) {
        LABEL_25:
          EventKind = 0;
          goto LABEL_26;
        }
        EventKind = GetControlKind(outData[0], &outControlKind);
        if (!EventKind) {
          if (outControlKind.kind == 1702131828 ||
              outControlKind.kind == 1702196344) {
            v8 = 4;
            goto LABEL_27;
          }
          goto LABEL_25;
        }
      }
    LABEL_26:
      v8 = 0;
    LABEL_27:
      SetThemeCursor(v8);
      return EventKind;
    }
  }
  return -9874;
}

int __cdecl KeyFilterProc(ControlRef theControl, SInt16 *a2, SInt16 *a3,
                          EventModifiers *a4) {
  unsigned __int8(__cdecl * ControlReference)(ControlRef, _DWORD); // edx
  unsigned __int16 ControlMaximum;                                 // di
  __int16 v6;                                                      // ax
  __int16 v7;                                                      // si
  __int16 v8;                                                      // ax
  int v9;                                                          // eax
  OpaqueWindowPtr *ControlOwner;                                   // eax
  Size outMaxSize;    // [esp+28h] [ebp-20h] BYREF
  _WORD inBuffer[14]; // [esp+2Ch] [ebp-1Ch] BYREF

  ControlReference = (unsigned __int8(__cdecl *)(
      ControlRef, _DWORD))GetControlReference(theControl);
  if (ControlReference && ControlReference(theControl, *a3))
    return 0;
  ControlMaximum = GetControlMaximum(theControl);
  if (!ControlMaximum || (*((_BYTE *)a4 + 1) & 1) != 0)
    return 1;
  v6 = *a3;
  if (*a3 <= 31) {
    if (v6 < 28 && (unsigned __int16)(v6 - 8) > 1u)
      goto LABEL_7;
    return 1;
  }
  if (v6 == 127)
    return 1;
LABEL_7:
  if (GetControlData(theControl, 0, 0x73656C65u, 4, inBuffer, 0))
    v7 = 0;
  else
    v7 = inBuffer[0] - inBuffer[1];
  if (GetControlDataSize(theControl, 0, 0x74657874u, &outMaxSize))
    v8 = 0;
  else
    v8 = outMaxSize;
  v9 = (__int16)(v8 + v7 + 1);
  if (v9 != ControlMaximum) {
    if (v9 > ControlMaximum) {
      AlertSoundPlay();
      return 0;
    }
    return 1;
  }
  ControlOwner = GetControlOwner(theControl);
  MacTools::PostPrivateEventToWindow(ControlOwner, 0x41647643u,
                                     (char)theControl, 0);
  return 1;
}

void dprintf() { ; }

void CenterWindowOnDisplay(void) {
  GDPtr *DeviceHandle;   // ebx
  int v1;                // edx
  Rect bounds;           // [esp+10h] [ebp-18h] BYREF
  Rect outAvailableRect; // [esp+18h] [ebp-10h] BYREF

  DeviceHandle = (GDPtr *)MacDisplay::GetDeviceHandle();
  if (!sInWindowMode ||
      GetAvailableWindowPositioningBounds(DeviceHandle, &outAvailableRect)) {
    v1 = *(_DWORD *)&(*DeviceHandle)->gdRect.bottom;
    *(_DWORD *)&outAvailableRect.top = *(_DWORD *)&(*DeviceHandle)->gdRect.top;
    *(_DWORD *)&outAvailableRect.bottom = v1;
  }
  GetWindowPortBounds(sMainWindow, &bounds);
  MoveWindow(sMainWindow,
             (outAvailableRect.right - outAvailableRect.left -
              (bounds.right - bounds.left)) /
                     2 +
                 outAvailableRect.left,
             (outAvailableRect.bottom - outAvailableRect.top -
              (bounds.bottom - bounds.top)) /
                     2 +
                 outAvailableRect.top,
             0);
}

int __cdecl BuilderCallback(OpaqueWindowPtr *a1, unsigned int a2) {
  CMacGameEngine *v3; // [esp+0h] [ebp-8h]

  if (a2 != 1668050803)
    return 0;
  CMacGameEngine::Quit(v3);
  return 1;
}

OSErr __cdecl UserPaneDrawProc(ControlRef control) {
  int *v1;                       // edx
  int *v2;                       // esi
  int *j;                        // eax
  int v4;                        // edx
  int v5;                        // ebx
  OpaqueWindowPtr *ControlOwner; // eax
  int v7;                        // eax
  int v8;                        // edx
  OpaqueIconRef *v9;             // ebx
  int v10;                       // ecx
  int v11;                       // eax
  OSErr result;                  // ax
  _DWORD *v13;                   // eax
  int32_t v14;                   // ebx
  uint32_t v15;                  // esi
  int32_t v16;                   // edi
  int v17;                       // eax
  float v18;                     // xmm0_4
  float v19;                     // xmm1_4
  float *v20;                    // eax
  float *i;                      // ebx
  int v22;                       // ecx
  int v23;                       // ecx
  int v24;                       // edx
  CGRect v25;                    // [esp+0h] [ebp-188h]
  CGRect v26;                    // [esp+0h] [ebp-188h]
  CGRect v27;                    // [esp+0h] [ebp-188h]
  CGRect v28;                    // [esp+4h] [ebp-184h]
  CGRect v29;                    // [esp+14h] [ebp-174h]
  CGFloat v30;                   // [esp+3Ch] [ebp-14Ch]
  float v31;                     // [esp+4Ch] [ebp-13Ch]
  float v32;                     // [esp+50h] [ebp-138h]
  CGFloat v33;                   // [esp+54h] [ebp-134h]
  int32_t height;                // [esp+58h] [ebp-130h]
  uint32_t width;                // [esp+5Ch] [ebp-12Ch]
  int32_t y;                     // [esp+60h] [ebp-128h]
  int32_t x;                     // [esp+64h] [ebp-124h]
  int32_t v38;                   // [esp+68h] [ebp-120h]
  _DWORD *v39;                   // [esp+6Ch] [ebp-11Ch]
  CGRect v40;                    // [esp+70h] [ebp-118h] BYREF
  FSRef inRef;                   // [esp+80h] [ebp-108h] BYREF
  CGRect v42;                    // [esp+D0h] [ebp-B8h]
  CGRect v43;                    // [esp+E0h] [ebp-A8h]
  CGRect r1;                     // [esp+F0h] [ebp-98h]
  CGRect rect;                   // [esp+100h] [ebp-88h]
  CGRect v46;                    // [esp+110h] [ebp-78h]
  CGRect r2;                     // [esp+120h] [ebp-68h]
  Rect inRect;                   // [esp+132h] [ebp-56h] BYREF
  Rect inBounds;                 // [esp+13Ah] [ebp-4Eh] BYREF
  int v50;                       // [esp+142h] [ebp-46h] BYREF
  int v51;                       // [esp+146h] [ebp-42h]
  _WORD v52[4];                  // [esp+14Ah] [ebp-3Eh] BYREF
  Rect bounds;                   // [esp+152h] [ebp-36h] BYREF
  Rect theRect;                  // [esp+15Ah] [ebp-2Eh] BYREF
  _WORD v55[3];                  // [esp+162h] [ebp-26h] BYREF
  IconRef outIconRef;            // [esp+168h] [ebp-20h] BYREF
  SInt16 outLabel[13];           // [esp+16Eh] [ebp-1Ah] BYREF

  if (!((dword_334784 - (int)sRectList) >> 3)) {
    GetControlBounds(control, &bounds);
    v31 = (float)(bounds.right - bounds.left);
    v32 = (float)(bounds.bottom - bounds.top);
    height = CGRectZero.size.height;
    width = CGRectZero.size.width;
    y = CGRectZero.origin.y;
    x = CGRectZero.origin.x;
    v13 = sDisplayList;
    if (sDisplayList != (void *)dword_334790) {
      v39 = sDisplayList;
      do {
        while (1) {
          v14 = v13[4];
          v15 = v13[3];
          v16 = v13[2];
          v38 = v13[1];
          rect.size.height = v14;
          rect.size.width = v15;
          rect.origin.y = v16;
          rect.origin.x = v38;
          v25.origin = (CGPoint)__PAIR64__(v16, v38);
          v25.size = (CGSize)__PAIR64__(v14, v15);
          LOBYTE(v17) = CGRectIsEmpty(v25);
          if (!v17)
            break;
          height = v14;
          width = v15;
          y = v16;
          x = v38;
          v39 += 25;
          v13 = v39;
          if ((_DWORD *)dword_334790 == v39)
            goto LABEL_22;
        }
        r2.size.height = height;
        r2.size.width = width;
        r2.origin.y = y;
        r2.origin.x = x;
        r1.size.height = v14;
        r1.size.width = v15;
        r1.origin.y = v16;
        r1.origin.x = v38;
        v29.origin = (CGPoint)__PAIR64__(y, x);
        v29.size = (CGSize)__PAIR64__(height, width);
        v28.origin = (CGPoint)__PAIR64__(v16, v38);
        v28.size = (CGSize)__PAIR64__(v14, v15);
        CGRectUnion(&v40, v28, v29);
        v42 = v40;
        height = v40.size.height;
        width = v40.size.width;
        y = v40.origin.y;
        x = v40.origin.x;
        v39 += 25;
        v13 = v39;
      } while ((_DWORD *)dword_334790 != v39);
    }
  LABEL_22:
    v43.size.height = height;
    v43.size.width = width;
    v43.origin.y = y;
    v43.origin.x = x;
    v26.origin = (CGPoint)__PAIR64__(y, x);
    v26.size = (CGSize)__PAIR64__(height, width);
    v33 = CGRectGetWidth(v26);
    v46.size.height = height;
    v46.size.width = width;
    v46.origin.y = y;
    v46.origin.x = x;
    v27.origin = (CGPoint)__PAIR64__(y, x);
    v27.size = (CGSize)__PAIR64__(height, width);
    v30 = CGRectGetHeight(v27);
    v18 = (float)(v30 / v33) * v31;
    v19 = v31;
    if (v18 > v32) {
      v19 = (float)(v31 / v18) * v32;
      v18 = v32;
    }
    v52[1] = 0;
    v52[0] = 0;
    v52[3] = (int)v19;
    v52[2] = (int)v18;
    OffsetRect(v52, (__int16)(bounds.left + (int)(float)(v31 - v19) / 2),
               (__int16)(bounds.top + (int)(float)(v32 - v18) / 2));
    inBounds.left = (int)*(float *)&x;
    inBounds.top = (int)*(float *)&y;
    inBounds.right = inBounds.left + (int)*(float *)&width;
    inBounds.bottom = inBounds.top + (int)*(float *)&height;
    v20 = (float *)sDisplayList;
    if (sDisplayList != (void *)dword_334790) {
      for (i = (float *)sDisplayList;; v20 = i) {
        HIWORD(v50) = (int)v20[1];
        v22 = (int)i[2];
        LOWORD(v50) = v22;
        HIWORD(v51) = HIWORD(v50) + (int)i[3];
        LOWORD(v51) = v22 + (int)i[4];
        MapRect(&v50, &inBounds, v52);
        v23 = dword_334784;
        if (dword_334784 == dword_334788) {
          std::vector<MacRect>::_M_insert_aux((int *)&sRectList,
                                              (_DWORD *)dword_334784, &v50);
        } else {
          if (dword_334784) {
            v24 = v51;
            *(_DWORD *)dword_334784 = v50;
            *(_DWORD *)(v23 + 4) = v24;
            v23 = dword_334784;
          }
          dword_334784 = v23 + 8;
        }
        if (*(_DWORD *)i == sMainDisplayID) {
          sMainRect = v50;
          dword_33490C = v51;
        }
        i += 25;
        if (i == (float *)dword_334790)
          break;
      }
    }
  }
  NormalizeThemeDrawingState();
  v55[0] = 21074;
  v55[1] = -30070;
  v55[2] = -13108;
  v1 = (int *)sRectList;
  v2 = (int *)sRectList;
  if ((void *)dword_334784 != sRectList) {
    for (j = (int *)sRectList;; j = v2) {
      v4 = j[1];
      v50 = *j;
      v51 = v4;
      RGBForeColor(v55);
      PaintRoundRect(&v50, 8, 8);
      if ((unsigned __int8)EqualRect(&sMainRect, &v50)) {
        v5 = NewRgn();
        OpenRgn();
        FrameRoundRect(&v50, 8, 8);
        CloseRgn(v5);
        SetClip(v5);
        DisposeRgn(v5);
        inBounds.left = HIWORD(v50);
        inBounds.right = HIWORD(v51);
        inBounds.bottom = v50 + 8;
        inBounds.top = v50 + 1;
        ClipRect(&inBounds);
        DrawThemeMenuBarBackground(&inBounds, 0, 1u);
        ControlOwner = GetControlOwner(control);
        GetWindowPortBounds(ControlOwner, &bounds);
        ClipRect(&bounds);
      }
      ForeColor(33);
      FrameRoundRect(&v50, 8, 8);
      v2 += 2;
      if ((int *)dword_334784 == v2)
        break;
    }
    v1 = (int *)sRectList;
  }
  if (-1030792151 * ((dword_334790 - (int)sDisplayList) >> 2) <=
      (unsigned int)sDisplayIndex) {
    v7 = *v1;
    v8 = v1[1];
  } else {
    v7 = v1[2 * (_DWORD)sDisplayIndex];
    v8 = v1[2 * (_DWORD)sDisplayIndex + 1];
  }
  *(_DWORD *)&inRect.top = v7;
  *(_DWORD *)&inRect.bottom = v8;
  InsetRect(&inRect, 4, 4);
  DrawThemeFocusRect(&inRect, 1u);
  MacFolders::GetApplicationRef((MacFolders *)&inRef);
  v9 = 0;
  if (!(unsigned __int16)GetIconRefFromFileInfo(&inRef, 0, 0, 0, 0, 0,
                                                &outIconRef, outLabel))
    v9 = outIconRef;
  outIconRef = v9;
  v10 = (inRect.left + inRect.right) / 2;
  theRect.left = v10 - 24;
  v11 = (inRect.top + inRect.bottom) / 2;
  theRect.top = v11 - 24;
  theRect.right = v10 + 24;
  result = v11 + 24;
  theRect.bottom = result;
  if (v9) {
    PlotIconRef(&theRect, 0, 0, 0, v9);
    return ReleaseIconRef(outIconRef);
  }
  return result;
}

int __cdecl UserPaneTrackingProc(ControlRef control, Point a2) {
  char *i;      // ebx
  int v3;       // edx
  _DWORD v5[8]; // [esp+18h] [ebp-20h] BYREF

  for (i = 0;; ++i) {
    if ((dword_334784 - (int)sRectList) >> 3 <= (unsigned int)i)
      return 0;
    v3 = *((_DWORD *)sRectList + 2 * (_DWORD)i + 1);
    v5[0] = *((_DWORD *)sRectList + 2 * (_DWORD)i);
    v5[1] = v3;
    if ((unsigned __int8)((int(__cdecl *)(_DWORD, _DWORD))PtInRect)(a2, v5))
      break;
  }
  if (i == sDisplayIndex)
    return 0;
  sDisplayIndex = i;
  UserPaneDrawProc(control);
  return 0;
}

void __usercall __static_initialization_and_destruction_0(int a1 @<eax>,
                                                          int a2 @<edx>) {
  char *v2; // eax

  if (a2 == 0xFFFF) {
    if (a1 == 1) {
      CStreamSound::sQTStreams = 0;
      dword_1218F84 = 0;
      dword_1218F88 = 0;
    } else if (!a1) {
      v2 = (char *)CStreamSound::sQTStreams;
      if (dword_1218F84 != CStreamSound::sQTStreams) {
        do
          v2 += 4;
        while (dword_1218F84 != v2);
      }
      if (CStreamSound::sQTStreams)
        operator delete(CStreamSound::sQTStreams);
    }
  }
}

int timeBeginPeriod() { return 0; }

int timeEndPeriod() { return 0; }

int __cdecl QueryPerformanceFrequency(_DWORD *a1) {
  *a1 = 1000000;
  a1[1] = 0;
  return 1;
}

int __cdecl MessageBoxA(int a1, MacStrings *a2, MacStrings *a3, char a4) {
  int v4;           // esi
  char *v5;         // ebx
  int v6;           // ebx
  int v8;           // ebx
  char v9[512];     // [esp+2Fh] [ebp-419h] BYREF
  char v10[512];    // [esp+22Fh] [ebp-219h] BYREF
  StShowCursor v11; // [esp+42Fh] [ebp-19h] BYREF

  v4 = a4 & 0xF;
  dprintf();
  if (a3 && *(_BYTE *)a3) {
    MacStrings::CopyAndClean(a3, v10, (char *)0x200);
    v5 = v9;
    MacStrings::CopyAndClean(a2, v9, (char *)0x200);
  } else {
    MacStrings::CopyAndClean(a2, v10, (char *)0x200);
    v5 = 0;
  }
  StShowCursor::StShowCursor(&v11);
  if ((a4 & 0xF) == 0) {
    MacTools::MessageAlert((MacTools *)v10, v5,
                           (const char *)((a4 & 0xF0) == 16));
    goto LABEL_7;
  }
  if (v4 == 1) {
    if (!MacTools::QuestionAlert((MacTools *)v10, v5)) {
      v6 = 2;
      goto LABEL_8;
    }
  LABEL_7:
    v6 = 1;
  LABEL_8:
    StShowCursor::~StShowCursor(&v11);
    return v6;
  }
  if (v4 != 4)
    goto LABEL_7;
  v8 = 7 - MacTools::QuestionAlert((MacTools *)v10, v5);
  StShowCursor::~StShowCursor(&v11);
  return v8;
}

int SetFileAttributesA() { return 0; }

int __cdecl GetFileAttributesA(MacFiles *a1) {
  return 2 * (MacFiles::access(a1, (const char *)4) != -1) - 1;
}

_BOOL4 __cdecl SetThreadPriority(pthread_t a1, int a2) {
  int v2;           // eax
  int priority_min; // eax
  sched_param v5;   // [esp+14h] [ebp-14h] BYREF
  int v6[3];        // [esp+1Ch] [ebp-Ch] BYREF

  v2 = pthread_getschedparam(a1, v6, &v5);
  if (!v2) {
    switch (a2) {
    case -15:
    case -2:
      v5.sched_priority = sched_get_priority_min(v6[0]);
      break;
    case -1:
      priority_min = sched_get_priority_min(v6[0]);
      goto LABEL_8;
    case 0:
      v5.sched_priority = 31;
      break;
    case 1:
    case 15:
      priority_min = sched_get_priority_max(v6[0]);
    LABEL_8:
      v5.sched_priority = (priority_min + 31) / 2;
      break;
    case 2:
      v5.sched_priority = sched_get_priority_max(v6[0]);
      break;
    default:
      break;
    }
    v2 = pthread_setschedparam(a1, v6[0], &v5);
  }
  return v2 == 0;
}

int GetCurrentThreadId() { return pthread_main_np(); }

OSStatus __cdecl WinSleep(Duration duration) {
  AbsoluteTime v1;             // rax
  AbsoluteTime expirationTime; // [esp+18h] [ebp-10h] BYREF

  v1 = UpTime();
  expirationTime = AddDurationToAbsolute(duration, v1);
  return MPDelayUntil(&expirationTime);
}

int __cdecl InterlockedExchangeAdd(int a1, int a2) {
  return OTAtomicAdd32(a2, a1) - a2;
}

int __cdecl InterlockedCompareExchange(int a1, int a2, int a3) {
  int v3; // ebx

  v3 = a3;
  if (!(unsigned __int8)OTCompareAndSwap32(a3, a2, a1))
    return a2;
  return v3;
}

int __cdecl MapVirtualKeyA(int a1) {
  int result; // eax

  switch (a1) {
  case 146:
  case 187:
    result = 61;
    break;
  case 186:
    result = 59;
    break;
  case 188:
    result = 44;
    break;
  case 189:
    result = 45;
    break;
  case 190:
    result = 46;
    break;
  case 191:
    result = 47;
    break;
  case 192:
    result = 96;
    break;
  case 219:
    result = 91;
    break;
  case 220:
    result = 92;
    break;
  case 221:
    result = 93;
    break;
  case 222:
    result = 39;
    break;
  default:
    result = 0;
    break;
  }
  return result;
}

void *__cdecl VirtualAlloc(void *a1, size_t a2) {
  void *result; // eax

  result = a1;
  if (!a1)
    return calloc(1u, a2);
  return result;
}

int __cdecl VirtualFree(void *a1, int a2, int a3) {
  if (!a1 || a3 != 0x8000)
    return 1;
  free(a1);
  return 1;
}

int __cdecl GetSystemMetrics(int a1) {
  int v2;    // [esp+18h] [ebp-10h] BYREF
  int v3[3]; // [esp+1Ch] [ebp-Ch] BYREF

  if (a1) {
    if (a1 == 1) {
      MacDisplay::GetCurrentDimensions((MacDisplay *)v3, &v2);
      return v2;
    } else {
      return 0;
    }
  } else {
    MacDisplay::GetCurrentDimensions((MacDisplay *)&v2, v3);
    return v2;
  }
}

int __cdecl FindNextFileA(int a1, int a2) {
  _DWORD *v2;      // edx
  char *v4;        // eax
  const char *v5;  // esi
  unsigned int v6; // kr04_4
  int v7;          // [esp+10h] [ebp-28h]
  int v8;          // [esp+14h] [ebp-24h]
  char *__dst;     // [esp+18h] [ebp-20h]

  if ((unsigned int)(a1 - 1) > 0xFFFFFFFD || !a2 || !*(_DWORD *)a1)
    return 0;
  v7 = a1 + 40;
  __dst = (char *)(a2 + 44);
  while (1) {
    if (*(_BYTE *)(a1 + 44)) {
      *(_DWORD *)(a1 + 40) += 350;
      v2 = *(_DWORD **)(a1 + 36);
    } else {
      v2 = *(_DWORD **)(a1 + 36);
      *(_DWORD *)(a1 + 40) = *v2;
      *(_BYTE *)(a1 + 44) = 1;
    }
    if (*(_DWORD *)(a1 + 40) == v2[1])
      return 0;
    if (*(_DWORD *)a1 == 1)
      break;
    if (*(_DWORD *)a1 != 2)
      return 0;
    v8 = *(_DWORD *)(a1 + 40);
    if ((*(_BYTE *)(v8 + 348) & 0x10) != 0) {
      *(_DWORD *)a2 = 16;
      strcpy((char *)(a2 + 44), (const char *)(*(_DWORD *)(a1 + 40) + 80));
      goto LABEL_16;
    }
    v4 = strrchr((const char *)(a1 + 4), 46);
    v5 = v4;
    if (!v4)
      return 0;
    v6 = strlen(v4) + 1;
    strcpy(__dst, (const char *)(v8 + 80));
    if (!strnicmp(&__dst[strlen(__dst) + 1 - v6], v5, v6 - 1)) {
      *(_DWORD *)a2 = 0;
    LABEL_16:
      *(_DWORD *)(a2 + 20) = *(_DWORD *)(*(_DWORD *)(a1 + 40) + 342);
      *(_DWORD *)(a2 + 24) = *(unsigned __int16 *)(*(_DWORD *)(a1 + 40) + 340);
      return 1;
    }
  }
  *(_DWORD *)a2 =
      (*(_WORD *)(*(_DWORD *)(a1 + 40) + 348) & 0x10) != 0 ? 0x10 : 0;
  strcpy(__dst, (const char *)(*(_DWORD *)v7 + 80));
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(*(_DWORD *)v7 + 342);
  *(_DWORD *)(a2 + 24) = *(unsigned __int16 *)(*(_DWORD *)v7 + 340);
  return 1;
}

unsigned __int64 timeGetTime() {
  UnsignedWide microTickCount; // [esp+18h] [ebp-10h] BYREF

  Microseconds(&microTickCount);
  return (*(_QWORD *)&microTickCount + 500LL) / 0x3E8uLL;
}

int __cdecl QueryPerformanceCounter(int32_t *a1) {
  int32_t hi;                  // ebx
  UnsignedWide microTickCount; // [esp+18h] [ebp-10h] BYREF

  Microseconds(&microTickCount);
  hi = microTickCount.hi;
  *a1 = microTickCount.lo;
  a1[1] = hi;
  return 1;
}

int __cdecl InterlockedExchange(_DWORD *a1, int a2) {
  int v2; // ebx

  v2 = *a1;
  if (!(unsigned __int8)OTCompareAndSwap32(*a1, a2, a1))
    return a2;
  return v2;
}

int __cdecl FindFirstFileA(MacFiles *a1, char *__b) {
  char *v2;                    // edi
  char *v3;                    // eax
  int v4;                      // ebx
  _DWORD *v5;                  // eax
  OSErr v6;                    // ax
  void **v7;                   // ebx
  char *v8;                    // edx
  char *v9;                    // eax
  void *v10;                   // ecx
  int result;                  // eax
  OSStatus Ref;                // eax
  const UniChar *p_length;     // edi
  FSCatalogInfo *v14;          // esi
  FSRef *i;                    // ecx
  int contentModDate_high;     // edx
  int *v17;                    // ebx
  char *v18;                   // eax
  OSErr v19;                   // [esp+32h] [ebp-C86h]
  int v20;                     // [esp+34h] [ebp-C84h]
  void *v21;                   // [esp+38h] [ebp-C80h]
  ItemCount v22;               // [esp+3Ch] [ebp-C7Ch]
  FSCatalogInfo *catalogInfos; // [esp+40h] [ebp-C78h]
  FSRef *refs;                 // [esp+44h] [ebp-C74h]
  HFSUniStr255 *names;         // [esp+48h] [ebp-C70h]
  FSRef *v26;                  // [esp+4Ch] [ebp-C6Ch]
  char __big[1024];            // [esp+56h] [ebp-C62h] BYREF
  UInt8 __dst[1024];           // [esp+456h] [ebp-862h] BYREF
  HFSUniStr255 outName;        // [esp+856h] [ebp-462h] BYREF
  _BYTE __src[350];            // [esp+A56h] [ebp-262h] BYREF
  FSCatalogInfo buffer_270;    // [esp+BB4h] [ebp-104h] BYREF
  FSRef buffer_414;            // [esp+C44h] [ebp-74h] BYREF
  ItemCount buffer_494;        // [esp+C94h] [ebp-24h] BYREF
  FSIterator buffer_498;       // [esp+C98h] [ebp-20h] BYREF
  Boolean buffer_505;          // [esp+C9Fh] [ebp-19h] BYREF

  if (!a1 || !__b)
    return -1;
  MacFiles::CleanPath(a1, __big, 0);
  memset(__b, 0, 0x14Cu);
  v2 = strstr(__big, "*.*");
  if (!v2) {
    v2 = strstr(__big, "*.");
    if (v2) {
      v20 = 2;
      goto LABEL_5;
    }
    if (strcmp(__big, "*")) {
      if (FSPathMakeRef((const UInt8 *)__big, &buffer_414, 0) &&
              MacFolders::GetDataFolderItemRef((MacFolders *)__big,
                                               &buffer_414) ||
          FSGetCatalogInfo(&buffer_414, 0x4042u, &buffer_270, &outName, 0, 0)) {
        return -1;
      }
      *(_DWORD *)__b = (buffer_270.nodeFlags & 0x10) != 0 ? 0x10 : 0;
      MacStrings::GetCString(&outName.length, (HFSUniStr255 *)(__b + 44),
                             (char *)0x104);
      *((_DWORD *)__b + 5) =
          *(_DWORD *)((char *)&buffer_270.contentModDate + 2);
      *((_DWORD *)__b + 6) = LOWORD(buffer_270.contentModDate);
      *((_DWORD *)__b + 7) = LODWORD(buffer_270.dataLogicalSize[1]);
      *((_DWORD *)__b + 8) = LODWORD(buffer_270.dataLogicalSize[0]);
      result = operator new(0x30u);
      *(_DWORD *)(result + 36) = 0;
      *(_DWORD *)(result + 40) = 0;
      *(_BYTE *)(result + 44) = 0;
      *(_DWORD *)result = 0;
      return result;
    }
    v2 = "*";
  }
  v20 = 1;
LABEL_5:
  v3 = strrchr(__big, 47);
  if (v3) {
    v4 = v3 - __big;
    strncpy((char *)__dst, __big, v3 - __big);
    __dst[v4] = 0;
    if (FSPathMakeRef(__dst, &buffer_414, 0) &&
        MacFolders::GetDataFolderItemRef((MacFolders *)__dst, &buffer_414))
      return -1;
  } else {
    if (getcwd((char *)__dst, 0x400u))
      Ref = FSPathMakeRef(__dst, &buffer_414, 0);
    else
      Ref = MacFolders::GetDataFolderItemRef((MacFolders *)__dst, &buffer_414);
    if (Ref)
      return -1;
  }
  if (FSGetCatalogInfo(&buffer_414, 0x42u, &buffer_270, &outName, 0, 0))
    return -1;
  if ((buffer_270.nodeFlags & 0x10) != 0) {
    v21 = (void *)operator new(0x30u);
    *((_DWORD *)v21 + 9) = 0;
    *((_DWORD *)v21 + 10) = 0;
    *((_BYTE *)v21 + 44) = 0;
    *(_DWORD *)v21 = v20;
    strcpy((char *)v21 + 4, v2);
    if (!FSOpenIterator(&buffer_414, 0, &buffer_498)) {
      catalogInfos = (FSCatalogInfo *)operator new[](0x1C20u);
      refs = (FSRef *)operator new[](0xFA0u);
      names = (HFSUniStr255 *)operator new[](0x6400u);
      v5 = (_DWORD *)operator new(0xCu);
      *v5 = 0;
      v5[1] = 0;
      v5[2] = 0;
      *((_DWORD *)v21 + 9) = v5;
      do {
        v6 = FSGetCatalogInfoBulk(buffer_498, 0x32u, &buffer_494, &buffer_505,
                                  0x42u, catalogInfos, refs, 0, names);
        v19 = v6;
        if (v6 && v6 != -1417)
          break;
        if (buffer_494) {
          v26 = refs;
          p_length = &names->length;
          v14 = catalogInfos;
          v22 = 0;
          for (i = refs;; i = v26) {
            memcpy(__src, i, 0x50u);
            MacStrings::GetCString(p_length, (HFSUniStr255 *)&__src[80],
                                   (char *)0x104);
            contentModDate_high = HIDWORD(v14->contentModDate);
            *(_DWORD *)&__src[340] = v14->contentModDate;
            *(_DWORD *)&__src[344] = contentModDate_high;
            *(_WORD *)&__src[348] = v14->nodeFlags;
            if (__src[80] != 46) {
              v17 = (int *)*((_DWORD *)v21 + 9);
              v18 = (char *)v17[1];
              if (v18 == (char *)v17[2]) {
                std::vector<FFItem>::_M_insert_aux(v17, v18, __src);
              } else {
                if (v18) {
                  memcpy(v18, __src, 0x15Eu);
                  v18 = (char *)v17[1];
                }
                v17[1] = (int)(v18 + 350);
              }
            }
            ++v22;
            ++v26;
            p_length += 256;
            ++v14;
            if (v22 >= buffer_494)
              break;
          }
        }
      } while (!v19);
      FSCloseIterator(buffer_498);
      if (names)
        operator delete[](names);
      if (refs)
        operator delete[](refs);
      if (catalogInfos)
        operator delete[](catalogInfos);
    }
    if (FindNextFileA((int)v21, (int)__b)) {
      return (int)v21;
    } else {
      v7 = (void **)*((_DWORD *)v21 + 9);
      if (v7) {
        v8 = (char *)v7[1];
        v9 = (char *)*v7;
        if (v8 != *v7) {
          do
            v9 += 350;
          while (v8 != v9);
        }
        if (*v7)
          operator delete(*v7);
        operator delete(v7);
        v10 = v21;
      } else {
        v10 = v21;
      }
      operator delete(v10);
      return -1;
    }
  } else {
    *(_DWORD *)__b = 0;
    MacStrings::GetCString(&outName.length, (HFSUniStr255 *)(__b + 44),
                           (char *)0x104);
    *((_DWORD *)__b + 5) = *(_DWORD *)((char *)&buffer_270.contentModDate + 2);
    *((_DWORD *)__b + 6) = LOWORD(buffer_270.contentModDate);
    return 0;
  }
}

int __cdecl SetWinCursor(int a1) {
  int v1;                            // edi
  _DWORD *v3;                        // ebx
  int *v4;                           // edx
  int v5;                            // eax
  UInt32 v6;                         // eax
  int v7;                            // ecx
  int v8;                            // edx
  OpaqueEventLoopRef *MainEventLoop; // eax
  int QDGlobalsArrow;                // eax
  _BYTE v11[92];                     // [esp+2Ch] [ebp-5Ch] BYREF

  v1 = SetWinCursor::sCurrentWinCursor;
  if (SetWinCursor::sCurrentWinCursor == a1)
    return v1;
  if (sSavedWinCursor)
    return a1;
  SetWinCursor::sCurrentWinCursor = a1;
  if (a1) {
    v3 = sCursorList;
    if ((void *)dword_334C04 != sCursorList) {
      if (a1 == *(_DWORD *)sCursorList) {
      LABEL_11:
        v3[14] = 0;
        v6 = TickCount();
        v7 = v3[14];
        v8 = v3[13];
        v3[15] = *(_DWORD *)(v8 + 4 * v7) + v6;
        *((_BYTE *)v3 + 64) = 1;
        QDSetNamedPixMapCursor(
            *(_DWORD *)(v3[11] + 4 * *(_DWORD *)(v8 + 4 * v7)));
        sCurrentCursor = (int)v3;
      LABEL_12:
        if (!SetWinCursor::sVisibleCursor) {
          ShowCursor();
          SetWinCursor::sVisibleCursor = 1;
        }
        if (!SetWinCursor::sTimerRef) {
          MainEventLoop = GetMainEventLoop();
          InstallEventLoopTimer(MainEventLoop, 0.0, 0.01666666666666667,
                                (EventLoopTimerUPP)CursorTimerProc, 0,
                                &SetWinCursor::sTimerRef);
        }
        return v1;
      }
      v4 = (int *)((char *)sCursorList + 68);
      while (1) {
        v3 += 17;
        if (v3 == (_DWORD *)dword_334C04)
          break;
        v5 = *v4;
        v4 += 17;
        if (a1 == v5)
          goto LABEL_11;
      }
    }
    QDGlobalsArrow = GetQDGlobalsArrow(v11);
    SetCursor(QDGlobalsArrow);
    goto LABEL_12;
  }
  if (SetWinCursor::sVisibleCursor) {
    HideCursor();
    SetWinCursor::sVisibleCursor = 0;
  }
  return v1;
}

int SwitchToWinCursor(void) {
  int v0; // eax

  v0 = sSavedWinCursor;
  sSavedWinCursor = 0;
  return SetWinCursor(v0);
}

void SwitchToMacCursor(void) {
  if (!sSavedWinCursor)
    sSavedWinCursor = SetWinCursor(-1);
}

void __cdecl CursorTimerProc() {
  int v0;          // ebx
  UInt32 v1;       // ecx
  unsigned int v2; // edx

  v0 = sCurrentCursor;
  if (sCurrentCursor && !sSavedWinCursor &&
      (*(_DWORD *)(sCurrentCursor + 12) > 1u ||
       *(_BYTE *)(sCurrentCursor + 64))) {
    v1 = TickCount();
    if (v1 >= *(_DWORD *)(v0 + 60)) {
      v2 = *(_DWORD *)(v0 + 56) + 1;
      *(_DWORD *)(v0 + 56) = v2;
      if (v2 >= *(_DWORD *)(v0 + 16)) {
        v2 = 0;
        *(_DWORD *)(v0 + 56) = 0;
      }
      *(_DWORD *)(v0 + 60) = *(_DWORD *)(*(_DWORD *)(v0 + 48) + 4 * v2) + v1;
      QDSetNamedPixMapCursor(
          *(_DWORD *)(*(_DWORD *)(v0 + 44) +
                      4 * *(_DWORD *)(*(_DWORD *)(v0 + 52) + 4 * v2)));
      *(_BYTE *)(v0 + 64) = 0;
    }
  }
}

uint32_t __cdecl LoadCursorFromFileA(char *__src) {
  char *v1;         // edi
  int v2;           // edi
  uint32_t mHandle; // ebx
  int v4;           // edi
  char __dst[1024]; // [esp+28h] [ebp-460h] BYREF
  WinCursor v7;     // [esp+428h] [ebp-60h] BYREF
  char v8[25];      // [esp+46Fh] [ebp-19h] BYREF

  strcpy(__dst, __src);
  MacFiles::CleanPath((MacFiles *)__dst, 0);
  strlwr(__dst);
  if (!strstr(__dst, ".ani"))
    return 0;
  v1 = (char *)sCursorList;
  if (sCursorList == (void *)dword_334C04) {
  LABEL_5:
    *(_DWORD *)v7.mName = (char *)&std::string::_Rep::_S_empty_rep_storage + 12;
    v7.mHandle = WinCursor::WinCursor(void)::sNextHandle++;
    memset(&v7.mHeader, 0, 57);
    if (WinCursor::Load(&v7, __dst)) {
      v2 = dword_334C04;
      if (dword_334C04 == dword_334C08) {
        std::vector<WinCursor>::_M_insert_aux(&sCursorList,
                                              (char *)dword_334C04, (int *)&v7);
      } else {
        if (dword_334C04) {
          *(_DWORD *)(dword_334C04 + 4) =
              (char *)&std::string::_Rep::_S_empty_rep_storage + 12;
          *(_DWORD *)v2 = v7.mHandle;
          std::string::assign((std::string *)(v2 + 4),
                              (const std::string *)v7.mName);
          *(ANIHeader *)(v2 + 8) = v7.mHeader;
          *(_DWORD *)(v2 + 44) = v7.mIcons;
          *(_DWORD *)(v2 + 48) = v7.mRate;
          *(_DWORD *)(v2 + 52) = v7.mSequence;
          *(_DWORD *)(v2 + 56) = v7.mStep;
          *(_DWORD *)(v2 + 60) = v7.mNextTime;
          *(_BYTE *)(v2 + 64) = v7.mFirstTime;
          v2 = dword_334C04;
        }
        dword_334C04 = v2 + 68;
      }
      mHandle = v7.mHandle;
    } else {
      mHandle = 0;
    }
    v4 = *(_DWORD *)v7.mName - 12;
    if (&std::string::_Rep::_S_empty_rep_storage !=
            (_UNKNOWN *)(*(_DWORD *)v7.mName - 12) &&
        (int)__gnu_cxx::__exchange_and_add(
            (volatile int *)(*(_DWORD *)v7.mName - 4), -1) <= 0) {
      std::string::_Rep::_M_destroy(v4, v8);
    }
    return mHandle;
  } else {
    while (std::string::compare((std::string *)(v1 + 4), __dst)) {
      v1 += 68;
      if (v1 == (char *)dword_334C04)
        goto LABEL_5;
    }
    return *(_DWORD *)v1;
  }
}

int __cdecl TranslateKeyCodeToVK(unsigned int a1) {
  char *v1;             // eax
  __int32 LanguageCode; // eax
  char *v4;             // edx

  if (TranslateKeyCodeToVK(unsigned long)::sCachedVKMap) {
    v1 = (char *)TranslateKeyCodeToVK(unsigned long)::sCachedVKMap;
  } else if (MacResources::GetLanguageCode() == 1) {
    TranslateKeyCodeToVK(unsigned long)::sCachedVKMap = (int)sFrench_ISO_VK_Map;
    v1 = sFrench_ISO_VK_Map;
  } else {
    LanguageCode = MacResources::GetLanguageCode();
    v4 = sGerman_ISO_VK_Map;
    if (LanguageCode != 2)
      v4 = sANSI_VK_Map;
    TranslateKeyCodeToVK(unsigned long)::sCachedVKMap = (int)v4;
    v1 = v4;
  }
  return (unsigned __int8)v1[a1];
}

int __cdecl CreateVolumeTexture(MacOpenGLUtils *a1, unsigned int a2,
                                unsigned int a3, int a4, int a5, int a6, int a7,
                                int *a8) {
  int v8; // esi

  v8 = operator new(0x6Cu);
  CDirect3DVolumeTexture::CDirect3DVolumeTexture(v8, a1, a2, a3, a4, a5, a6);
  *a8 = v8;
  return 0;
}

_DWORD *__cdecl D3DXMatrixMultiply(_DWORD *a1, float *a2, float *a3) {
  int v3;         // edi
  float i;        // xmm4_4
  float v6;       // xmm7_4
  float v7;       // xmm6_4
  float v8;       // xmm5_4
  float *v9;      // eax
  int v10;        // ecx
  float *v11;     // edx
  float j;        // xmm1_4
  float v13;      // xmm2_4
  float v14;      // xmm3_4
  float v15;      // xmm0_4
  float v16;      // xmm1_4
  float *v18;     // [esp+Ch] [ebp-7Ch]
  float v19;      // [esp+10h] [ebp-78h]
  float v20;      // [esp+14h] [ebp-74h]
  float v21;      // [esp+18h] [ebp-70h]
  float v22;      // [esp+1Ch] [ebp-6Ch]
  float v23;      // [esp+20h] [ebp-68h]
  float v24;      // [esp+24h] [ebp-64h]
  float v25;      // [esp+28h] [ebp-60h]
  float v26;      // [esp+2Ch] [ebp-5Ch]
  _DWORD v27[3];  // [esp+30h] [ebp-58h] BYREF
  _DWORD v28[19]; // [esp+3Ch] [ebp-4Ch] BYREF

  v3 = 0;
  v22 = *a3;
  v19 = a3[4];
  v20 = a3[8];
  v21 = a3[12];
  v18 = (float *)v28;
  for (i = v21;; i = v21) {
    v23 = *a2;
    v24 = a2[1];
    v25 = a2[2];
    v26 = a2[3];
    v6 = v22;
    v7 = v19;
    v8 = v20;
    v9 = a3;
    v10 = 1;
    v11 = (float *)&v27[v3];
    for (j = v26;; j = v26) {
      v13 = v23 * v6;
      v14 = v24 * v7;
      v15 = v25 * v8;
      v16 = j * i;
      v6 = v9[1];
      v7 = v9[5];
      v8 = v9[9];
      i = v9[13];
      *v11 = v16 + (float)(v15 + (float)(v13 + v14));
      ++v10;
      ++v11;
      ++v9;
      if (v10 == 4)
        break;
    }
    *v18 = (float)(i * v26) +
           (float)((float)(v8 * v25) +
                   (float)((float)(v6 * v23) + (float)(v7 * v24)));
    v3 += 4;
    a2 += 4;
    v18 += 4;
    if (v3 == 16)
      break;
  }
  *a1 = v27[0];
  a1[1] = v27[1];
  a1[2] = v27[2];
  a1[3] = v28[0];
  a1[4] = v28[1];
  a1[5] = v28[2];
  a1[6] = v28[3];
  a1[7] = v28[4];
  a1[8] = v28[5];
  a1[9] = v28[6];
  a1[10] = v28[7];
  a1[11] = v28[8];
  a1[12] = v28[9];
  a1[13] = v28[10];
  a1[14] = v28[11];
  a1[15] = v28[12];
  return a1;
}

float *__cdecl D3DXVec4Transform(float *a1, float *a2, float *a3) {
  float *result; // eax
  float v4;      // xmm4_4
  float v5;      // xmm3_4
  float v6;      // xmm1_4

  result = a1;
  v4 = (float)((float)((float)(*a2 * a3[1]) + (float)(a2[1] * a3[5])) +
               (float)(a2[2] * a3[9])) +
       (float)(a2[3] * a3[13]);
  v5 = (float)((float)((float)(*a2 * a3[2]) + (float)(a2[1] * a3[6])) +
               (float)(a2[2] * a3[10])) +
       (float)(a2[3] * a3[14]);
  v6 = (float)((float)((float)(*a2 * a3[3]) + (float)(a2[1] * a3[7])) +
               (float)(a2[2] * a3[11])) +
       (float)(a2[3] * a3[15]);
  *a1 = (float)((float)((float)(*a2 * *a3) + (float)(a2[1] * a3[4])) +
                (float)(a2[2] * a3[8])) +
        (float)(a2[3] * a3[12]);
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  return result;
}

int DXGetErrorDescription9A() { return 0; }

int __cdecl D3DXMatrixInverse(int a1, _DWORD *a2, int a3) {
  int v3;            // edi
  int v4;            // esi
  float v6;          // xmm4_4
  float v7;          // xmm5_4
  float v8;          // xmm6_4
  float v9;          // xmm0_4
  int v10;           // eax
  int v11;           // edx
  float v12;         // xmm1_4
  float v13;         // xmm2_4
  float v14;         // xmm2_4
  int v15;           // edx
  float v16;         // xmm0_4
  float v17;         // xmm3_4
  int v18;           // edx
  float v19;         // xmm3_4
  float v20;         // xmm0_4
  float v21;         // xmm2_4
  int v22;           // [esp+1Ch] [ebp-9Ch]
  COpenGLMatrix v23; // [esp+20h] [ebp-98h] BYREF
  COpenGLMatrix v24; // [esp+60h] [ebp-58h] BYREF

  v3 = *(_DWORD *)(a3 + 28);
  v4 = *(_DWORD *)(a3 + 12);
  v22 = *(_DWORD *)(a3 + 44);
  if (!(v22 | v3 | v4) && *(_DWORD *)(a3 + 60) == 1065353216) {
    v6 = *(float *)(a3 + 48);
    v7 = *(float *)(a3 + 52);
    v8 = *(float *)(a3 + 56);
    v9 = *(float *)a3;
    v10 = *(_DWORD *)(a3 + 16);
    v11 = *(_DWORD *)(a3 + 32);
    v12 = *(float *)(a3 + 4);
    v13 = *(float *)(a3 + 8);
    *(_DWORD *)a1 = *(_DWORD *)a3;
    *(_DWORD *)(a1 + 4) = v10;
    *(_DWORD *)(a1 + 8) = v11;
    *(float *)(a1 + 48) =
        -(float)((float)((float)(v9 * v6) + (float)(v12 * v7)) +
                 (float)(v13 * v8));
    v14 = *(float *)(a3 + 20);
    v15 = *(_DWORD *)(a3 + 36);
    v16 = *(float *)(a3 + 16);
    v17 = *(float *)(a3 + 24);
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a3 + 4);
    *(float *)(a1 + 20) = v14;
    *(_DWORD *)(a1 + 24) = v15;
    *(float *)(a1 + 52) =
        -(float)((float)((float)(v16 * v6) + (float)(v14 * v7)) +
                 (float)(v17 * v8));
    v18 = *(_DWORD *)(a3 + 24);
    v19 = *(float *)(a3 + 40);
    v20 = *(float *)(a3 + 32);
    v21 = *(float *)(a3 + 36);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a3 + 8);
    *(_DWORD *)(a1 + 36) = v18;
    *(float *)(a1 + 40) = v19;
    *(float *)(a1 + 56) =
        -(float)((float)((float)(v6 * v20) + (float)(v7 * v21)) +
                 (float)(v8 * v19));
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 44) = 0;
    *(_DWORD *)(a1 + 60) = 1065353216;
  } else {
    *(_DWORD *)v24.m = *(_DWORD *)a3;
    *(_DWORD *)&v24.m[4] = *(_DWORD *)(a3 + 4);
    *(_DWORD *)&v24.m[8] = *(_DWORD *)(a3 + 8);
    *(_DWORD *)&v24.m[12] = v4;
    *(_DWORD *)&v24.m[16] = *(_DWORD *)(a3 + 16);
    *(_DWORD *)&v24.m[20] = *(_DWORD *)(a3 + 20);
    *(_DWORD *)&v24.m[24] = *(_DWORD *)(a3 + 24);
    *(_DWORD *)&v24.m[28] = v3;
    *(_DWORD *)&v24.m[32] = *(_DWORD *)(a3 + 32);
    *(_DWORD *)&v24.m[36] = *(_DWORD *)(a3 + 36);
    *(_DWORD *)&v24.m[40] = *(_DWORD *)(a3 + 40);
    *(_DWORD *)&v24.m[44] = v22;
    *(_DWORD *)&v24.m[48] = *(_DWORD *)(a3 + 48);
    *(_DWORD *)&v24.m[52] = *(_DWORD *)(a3 + 52);
    *(_DWORD *)&v24.m[56] = *(_DWORD *)(a3 + 56);
    *(_DWORD *)&v24.m[60] = *(_DWORD *)(a3 + 60);
    COpenGLMatrix::Inverse(&v24, &v23);
    *(COpenGLMatrix *)a1 = v23;
  }
  if (a2)
    *a2 = 0;
  return a1;
}

void __cdecl ViewSingleTexture(GLuint texture) {
  int v1;          // ebx
  GLfloat *v2;     // esi
  GLint v3;        // ebx
  GLfloat *v4;     // esi
  GLint v5;        // ebx
  GLfloat m[128];  // [esp+2Ch] [ebp-21Ch] BYREF
  GLint params[7]; // [esp+22Ch] [ebp-1Ch] BYREF

  glPushAttrib(0xFFFFFu);
  glPushClientAttrib(0xFFFFFFFF);
  glDisable((GLenum)&loc_861E + 2);
  if (MacDisplay::GetCardType() == 2) {
    glDisable(0x86DEu);
    glDisable(0x8522u);
  } else if (MacDisplay::GetCardType() == 1) {
    glDisable(0x8200u);
  }
  if ((unsigned int)MacOpenGLUtils::GetPCPixelShaderVersion() > 0xFFFF01FF)
    glDisable(0x8804u);
  glMatrixMode(0x1700u);
  glPushMatrix();
  glLoadIdentity();
  glMatrixMode(0x1701u);
  glPushMatrix();
  glLoadIdentity();
  gluOrtho2D(0, 0, 0, 1073217536, 0, 0, 0, 1073217536);
  glDisable(0xB50u);
  glDisable(0xBE2u);
  glDisable(0xBC0u);
  glDisable(0xB71u);
  glDisable(0xBD0u);
  glColorMask(1u, 1u, 1u, 1u);
  glDrawBuffer(0x405u);
  glDepthMask(1u);
  glDisable(0xB44u);
  glDisable(0xB60u);
  glGetIntegerv(0x84E2u, params);
  glMatrixMode(0x1702u);
  if (params[0] - 1 >= 0) {
    v1 = params[0] - 1;
    v2 = &m[16 * params[0] - 16];
    do {
      glActiveTextureARB(v1 + 33984);
      glGetFloatv(0xBA8u, v2);
      glLoadIdentity();
      --v1;
      v2 -= 16;
    } while (v1 != -1);
  }
  glDisable(0xB90u);
  if (params[0] > 0) {
    v5 = 0;
    do {
      glActiveTextureARB(v5 + 33984);
      glDisable(0xC60u);
      glDisable(0xC61u);
      glDisable(0xC62u);
      glDisable(0xC63u);
      glBindTexture(0xDE1u, texture);
      if (v5) {
        glDisable(0xDE1u);
        glDisable(0x84F5u);
        glDisable(0x806Fu);
        glDisable(0x8513u);
      } else {
        glEnable(0xDE1u);
        glDisable(0x84F5u);
        glDisable(0x806Fu);
        glDisable(0x8513u);
        glTexEnvi(0x2300u, 0x8571u, 7681);
        glTexEnvi(0x2300u, 0x8572u, 7681);
        glTexEnvi(0x2300u, 0x8580u, 5890);
        glTexEnvi(0x2300u, 0x8590u, 768);
        glTexEnvi(0x2300u, 0x8588u, 5890);
        glTexEnvi(0x2300u, 0x8598u, 770);
        glTexEnvf(0x2300u, 0x8573u, 1.0);
        glTexEnvf(0x2300u, 0xD1Cu, 1.0);
      }
      ++v5;
    } while (v5 < params[0]);
  }
  glBegin(7u);
  glColor4f(1.0, 1.0, 1.0, 1.0);
  glTexCoord2f(0.0, 0.0);
  glVertex3f(0.0, 0.0, 0.0);
  glTexCoord2f(1.0, 0.0);
  glVertex3f(1.0, 0.0, 0.0);
  glTexCoord2f(1.0, 1.0);
  glVertex3f(1.0, 1.0, 0.0);
  glTexCoord2f(0.0, 1.0);
  glVertex3f(0.0, 1.0, 0.0);
  glEnd();
  glMatrixMode(0x1702u);
  if (params[0] > 0) {
    v3 = 0;
    v4 = m;
    do {
      glActiveTextureARB(v3 + 33984);
      glLoadMatrixf(v4);
      ++v3;
      v4 += 16;
    } while (v3 < params[0]);
  }
  glMatrixMode(0x1701u);
  glPopMatrix();
  glMatrixMode(0x1700u);
  glPopMatrix();
  glPopClientAttrib();
  glPopAttrib();
}

void ShowShadowCookies(void) {
  int v0;          // ebx
  GLfloat *v1;     // esi
  unsigned int v2; // edi
  GLint v3;        // esi
  GLint v4;        // ebx
  GLfloat *v5;     // esi
  GLfloat x;       // [esp+44h] [ebp-234h]
  GLfloat x_4;     // [esp+48h] [ebp-230h]
  int v8;          // [esp+4Ch] [ebp-22Ch]
  GLfloat m[128];  // [esp+5Ch] [ebp-21Ch] BYREF
  GLint params[7]; // [esp+25Ch] [ebp-1Ch] BYREF

  glPushAttrib(0xFFFFFu);
  glDisable((GLenum)&loc_861E + 2);
  if (MacDisplay::GetCardType() == 2) {
    glDisable(0x86DEu);
    glDisable(0x8522u);
  } else if (MacDisplay::GetCardType() == 1) {
    glDisable(0x8200u);
  }
  if ((unsigned int)MacOpenGLUtils::GetPCPixelShaderVersion() > 0xFFFF01FF)
    glDisable(0x8804u);
  glMatrixMode(0x1700u);
  glPushMatrix();
  glLoadIdentity();
  glMatrixMode(0x1701u);
  glPushMatrix();
  glLoadIdentity();
  gluOrtho2D(0, 0, 0, 1072693248, 0, 1072693248, 0, 0);
  glDisable(0xB50u);
  glDisable(0xBE2u);
  glDisable(0xBC0u);
  glDisable(0xB71u);
  glDisable(0xBD0u);
  glColorMask(1u, 1u, 1u, 1u);
  glDrawBuffer(0x405u);
  glDepthMask(1u);
  glDisable(0xB44u);
  glDisable(0xB60u);
  glGetIntegerv(0x84E2u, params);
  glMatrixMode(0x1702u);
  if (params[0] - 1 >= 0) {
    v0 = params[0] - 1;
    v1 = &m[16 * params[0] - 16];
    do {
      glActiveTextureARB(v0 + 33984);
      glGetFloatv(0xBA8u, v1);
      glLoadIdentity();
      --v0;
      v1 -= 16;
    } while (v0 != -1);
  }
  glDisable(0xB90u);
  if (g_NumShadowCookies) {
    v2 = 0;
    v8 = 0;
    do {
      if (params[0] > 0) {
        v3 = 0;
        do {
          glActiveTextureARB(v3 + 33984);
          glDisable(0xC60u);
          glDisable(0xC61u);
          glDisable(0xC62u);
          glDisable(0xC63u);
          glTexImage2D(0x84F5u, 0, 6408, 1024, 768, 0, 0x1908u, 0x1401u,
                       (char *)g_ShadowCookieMemory + v8);
          if (v3) {
            glDisable(0xDE1u);
            glDisable(0x84F5u);
            glDisable(0x806Fu);
            glDisable(0x8513u);
          } else {
            glEnable(0xDE1u);
            glEnable(0x84F5u);
            glDisable(0x806Fu);
            glDisable(0x8513u);
            glTexEnvi(0x2300u, 0x8571u, 7681);
            glTexEnvi(0x2300u, 0x8572u, 7681);
            glTexEnvi(0x2300u, 0x8580u, 5890);
            glTexEnvi(0x2300u, 0x8590u, 768);
            glTexEnvi(0x2300u, 0x8588u, 5890);
            glTexEnvi(0x2300u, 0x8598u, 770);
            glTexEnvf(0x2300u, 0x8573u, 1.0);
            glTexEnvf(0x2300u, 0xD1Cu, 1.0);
          }
          ++v3;
        } while (v3 < params[0]);
      }
      x = (float)((float)(v2 & 7) * 0.125) + 0.0;
      x_4 = (float)((float)(v2 >> 3) * 0.125) + 0.0;
      glBegin(7u);
      glColor4f(1.0, 1.0, 1.0, 1.0);
      glTexCoord2f(0.0, 0.0);
      glVertex3f(x, x_4, 0.0);
      glTexCoord2f(1024.0, 0.0);
      glVertex3f(x + 0.09375, x_4, 0.0);
      glTexCoord2f(1024.0, 768.0);
      glVertex3f(x + 0.09375, x_4 + 0.09375, 0.0);
      glTexCoord2f(0.0, 768.0);
      glVertex3f(x, x_4 + 0.09375, 0.0);
      glEnd();
      ++v2;
      v8 += 12582912;
    } while (v2 < g_NumShadowCookies);
  }
  glMatrixMode(0x1702u);
  if (params[0] > 0) {
    v4 = 0;
    v5 = m;
    do {
      glActiveTextureARB(v4 + 33984);
      glLoadMatrixf(v5);
      ++v4;
      v5 += 16;
    } while (v4 < params[0]);
  }
  glMatrixMode(0x1701u);
  glPopMatrix();
  glMatrixMode(0x1700u);
  glPopMatrix();
  glPopAttrib();
  g_NumShadowCookies = 0;
}

int __cdecl stricmp(const char *a1, const char *a2) {
  return strcasecmp(a1, a2);
}

int __cdecl strnicmp(const char *a1, const char *a2, size_t a3) {
  return strncasecmp(a1, a2, a3);
}

int __cdecl strcmpi(const char *a1, const char *a2) {
  return strcasecmp(a1, a2);
}

char *__cdecl strlwr(char *a1) {
  char v1;  // al
  char *v3; // ebx

  v1 = *a1;
  if (!*a1)
    return a1;
  v3 = a1;
  do {
    *v3++ = __tolower(v1);
    v1 = *v3;
  } while (*v3);
  return a1;
}

char *__cdecl strupr(char *a1) {
  char v1;  // al
  char *v3; // ebx

  v1 = *a1;
  if (!*a1)
    return a1;
  v3 = a1;
  do {
    *v3++ = __toupper(v1);
    v1 = *v3;
  } while (*v3);
  return a1;
}

char *__cdecl itoa(int a1, char *a2, int a3) {
  int v3;         // ecx
  char v4;        // si
  int v5;         // edi
  int v6;         // edx
  signed int v7;  // ebx
  char *v8;       // edi
  int v9;         // esi
  char v10;       // cl
  signed int v11; // eax

  if (a1 < 0) {
    v3 = -a1;
    v4 = 1;
  } else {
    v3 = a1;
    v4 = 0;
  }
  v5 = 0;
  do {
    while (1) {
      v6 = v3 % a3;
      if (v3 % a3 <= 9)
        break;
      a2[v5++] = v6 + 55;
      v3 /= a3;
      if (!v3)
        goto LABEL_7;
    }
    a2[v5++] = v6 + 48;
    v3 /= a3;
  } while (v3);
LABEL_7:
  if (v4)
    a2[v5++] = 45;
  a2[v5] = 0;
  v7 = strlen(a2) - 1;
  if (v7 > 0) {
    v8 = &a2[v7];
    v9 = 1;
    do {
      v10 = a2[v9 - 1];
      a2[v9 - 1] = *v8;
      *v8 = v10;
      v11 = v9;
      --v7;
      ++v9;
      --v8;
    } while (v7 > v11);
  }
  return a2;
}

int __cdecl main(int argc, const char **argv, const char **envp) {
  CMacGameEngine *MacGameEngine; // eax

  MacTools::SetCursorID((MacTools *)4);
  MacGameEngine = GetMacGameEngine();
  CMacGameEngine::Run(MacGameEngine, argc, (char **)argv);
  return 0;
}

_DWORD *__cdecl unzReOpen(const char *a1, void *__src) {
  FILE *v2;   // esi
  _DWORD *v3; // ebx

  v2 = FS_FileOpen(a1, "rb");
  if (!v2)
    return 0;
  v3 = malloc(0x80u);
  Com_Memcpy(v3, __src, 0x80u);
  *v3 = v2;
  v3[31] = 0;
  return v3;
}

int __cdecl unzGetGlobalInfo(int a1, _DWORD *a2) {
  int v2; // edx

  if (!a1)
    return -102;
  v2 = *(_DWORD *)(a1 + 8);
  *a2 = *(_DWORD *)(a1 + 4);
  a2[1] = v2;
  return 0;
}

int __cdecl unzGetCurrentFileInfoPosition(int a1, _DWORD *a2) {
  if (!a1)
    return -102;
  *a2 = *(_DWORD *)(a1 + 20);
  return 0;
}

int __cdecl unzReadCurrentFile(int a1, int a2, unsigned int a3) {
  int v3;           // edi
  int v5;           // esi
  unsigned int v6;  // eax
  unsigned int v7;  // eax
  unsigned int v8;  // ebx
  unsigned int v9;  // edx
  unsigned int v10; // eax
  int i;            // ecx
  int v12;          // ebx
  int v13;          // eax
  int v14;          // ebx
  int v15;          // [esp+1Ch] [ebp-1Ch]

  if (!a1)
    return -102;
  v5 = *(_DWORD *)(a1 + 124);
  if (!v5)
    return -102;
  if (!*(_DWORD *)v5)
    return -100;
  if (a3) {
    *(_DWORD *)(v5 + 16) = a2;
    *(_DWORD *)(v5 + 20) = a3;
    v6 = *(_DWORD *)(v5 + 84);
    if (a3 > v6)
      *(_DWORD *)(v5 + 20) = v6;
    v15 = 0;
    while (1) {
      if (!*(_DWORD *)(v5 + 20))
        return v15;
      if (!*(_DWORD *)(v5 + 8)) {
        v7 = *(_DWORD *)(v5 + 80);
        if (v7) {
          v14 = 0x4000;
          if (v7 <= 0x3FFF)
            v14 = *(_DWORD *)(v5 + 80);
          if (FS_FileSeek(*(_DWORD *)(v5 + 88),
                          *(_DWORD *)(v5 + 96) + *(_DWORD *)(v5 + 60), 0) ||
              FS_FileRead(*(_DWORD *)v5, v14, 1, *(_DWORD *)(v5 + 88)) != 1) {
            return -1;
          }
          *(_DWORD *)(v5 + 60) += v14;
          *(_DWORD *)(v5 + 80) -= v14;
          *(_DWORD *)(v5 + 4) = *(_DWORD *)v5;
          *(_DWORD *)(v5 + 8) = v14;
        }
      }
      if (*(_DWORD *)(v5 + 92)) {
        v12 = *(_DWORD *)(v5 + 24);
        v3 = inflate((z_streamp)(v5 + 4), 2);
        v13 = *(_DWORD *)(v5 + 24) - v12;
        *(_DWORD *)(v5 + 84) -= v13;
        v15 += v13;
        if (v3 == 1)
          return v15;
        if (v3)
          return v3;
      } else {
        v8 = *(_DWORD *)(v5 + 20);
        v9 = v8;
        v10 = *(_DWORD *)(v5 + 8);
        if (v8 >= v10)
          v8 = *(_DWORD *)(v5 + 8);
        if (v8) {
          for (i = 0; i != v8; ++i)
            *(_BYTE *)(*(_DWORD *)(v5 + 16) + i) =
                *(_BYTE *)(*(_DWORD *)(v5 + 4) + i);
          v9 = *(_DWORD *)(v5 + 20);
          v10 = *(_DWORD *)(v5 + 8);
        }
        *(_DWORD *)(v5 + 84) -= v8;
        *(_DWORD *)(v5 + 8) = v10 - v8;
        *(_DWORD *)(v5 + 20) = v9 - v8;
        *(_DWORD *)(v5 + 16) += v8;
        *(_DWORD *)(v5 + 4) += v8;
        *(_DWORD *)(v5 + 24) += v8;
        v15 += v8;
      }
    }
  }
  return 0;
}

int __cdecl unztell(int a1) {
  int v2; // eax

  if (a1 && (v2 = *(_DWORD *)(a1 + 124)) != 0)
    return *(_DWORD *)(v2 + 24);
  else
    return -102;
}

int __cdecl unzCloseCurrentFile(int a1) {
  int v2; // ebx

  if (!a1)
    return -102;
  v2 = *(_DWORD *)(a1 + 124);
  if (!v2)
    return -102;
  free(*(void **)v2);
  *(_DWORD *)v2 = 0;
  if (*(_DWORD *)(v2 + 64))
    inflateEnd((z_streamp)(v2 + 4));
  *(_DWORD *)(v2 + 64) = 0;
  free((void *)v2);
  *(_DWORD *)(a1 + 124) = 0;
  return 0;
}

int __cdecl unzSetCurrentFileInfoPosition(_DWORD *a1, int a2) {
  if (!a1)
    return -102;
  a1[5] = a2;
  a1[6] = unzlocal_GetCurrentFileInfoInternal((int)a1, a1 + 10, a1 + 30, 0, 0,
                                              0, 0, 0, 0) == 0;
  return 0;
}

int __cdecl unzGoToNextFile(_DWORD *a1) {
  int CurrentFileInfoInternal; // edx
  int v3;                      // edx

  if (!a1)
    return -102;
  if (a1[6]) {
    v3 = a1[4] + 1;
    if (v3 != a1[1]) {
      a1[5] += a1[20] + a1[19] + a1[18] + 46;
      a1[4] = v3;
      CurrentFileInfoInternal = unzlocal_GetCurrentFileInfoInternal(
          (int)a1, a1 + 10, a1 + 30, 0, 0, 0, 0, 0, 0);
      a1[6] = CurrentFileInfoInternal == 0;
      return CurrentFileInfoInternal;
    }
  }
  return -100;
}

int __cdecl unzGoToFirstFile(_DWORD *a1) {
  int result; // eax

  if (!a1)
    return -102;
  a1[5] = a1[9];
  a1[4] = 0;
  result = unzlocal_GetCurrentFileInfoInternal((int)a1, a1 + 10, a1 + 30, 0, 0,
                                               0, 0, 0, 0);
  a1[6] = result == 0;
  return result;
}

int __cdecl unzGetCurrentFileInfo(int a1, _DWORD *a2, unsigned __int8 *a3,
                                  unz_file_info_s *a4,
                                  unz_file_info_internal_s *a5, char *a6,
                                  _BYTE *a7, void *a8) {
  return unzlocal_GetCurrentFileInfoInternal(a1, a2, 0, a3, a4, a5, a6, a7, a8);
}

_DWORD *__cdecl unzOpen(const char *a1) {
  FILE *v1;             // eax
  FILE *v2;             // esi
  __int32 v3;           // eax
  bool v4;              // zf
  int v5;               // eax
  __int16 v6;           // di
  int v8;               // eax
  unsigned int v9;      // edi
  size_t v10;           // ebx
  char *v11;            // edx
  signed __int32 v12;   // ecx
  _DWORD *v13;          // ebx
  char *v14;            // [esp+24h] [ebp-D4h]
  unsigned int v15;     // [esp+28h] [ebp-D0h]
  int v16;              // [esp+2Ch] [ebp-CCh]
  int v17;              // [esp+2Ch] [ebp-CCh]
  unsigned int v18;     // [esp+30h] [ebp-C8h]
  __int32 v19;          // [esp+34h] [ebp-C4h]
  __int16 v20;          // [esp+3Ah] [ebp-BEh]
  int v21;              // [esp+3Ch] [ebp-BCh]
  int v22;              // [esp+40h] [ebp-B8h]
  int v23;              // [esp+44h] [ebp-B4h]
  int v24;              // [esp+48h] [ebp-B0h]
  unsigned __int32 v25; // [esp+4Ch] [ebp-ACh]
  _DWORD __src[32];     // [esp+5Ch] [ebp-9Ch] BYREF
  __int16 v27[14];      // [esp+DCh] [ebp-1Ch] BYREF

  v1 = FS_FileOpen(a1, "rb");
  v2 = v1;
  if (!v1)
    return 0;
  if (FS_FileSeek(v1, 0, 2))
    goto LABEL_3;
  v25 = ftell(v2);
  v8 = 0xFFFF;
  if (v25 <= 0xFFFE)
    v8 = v25;
  v18 = v8;
  v14 = (char *)malloc(0x404u);
  if (!v14) {
  LABEL_3:
    v16 = -1;
    v15 = 0;
    v3 = 0;
  } else {
    if (v18 > 4) {
      v9 = 4;
      do {
        v9 += 1024;
        if (v18 < v9)
          v9 = v18;
        v19 = v25 - v9;
        v10 = v9;
        if (v9 >= 0x405)
          v10 = 1028;
        if (FS_FileSeek(v2, v19, 0) || FS_FileRead(v14, v10, 1u, v2) != 1)
          break;
        v11 = &v14[v10 - 3];
        v12 = v10 - 4;
        if ((int)(v10 - 4 + 1) > 0) {
          while (*(v11 - 1) != 80 || *v11 != 75 || v11[1] != 5 || v11[2] != 6) {
            --v11;
            if (v12-- <= 0)
              goto LABEL_25;
          }
          v15 = v19 + v12;
          if (v19 + v12)
            goto LABEL_27;
        }
      LABEL_25:;
      } while (v18 > v9);
    }
    v15 = 0;
  LABEL_27:
    free(v14);
    if (v15) {
      v3 = v15;
      v16 = 0;
    } else {
      v16 = -1;
      v3 = 0;
    }
  }
  v4 = FS_FileSeek(v2, v3, 0) == 0;
  v5 = -1;
  if (v4)
    v5 = v16;
  v17 = v5;
  FS_FileRead(v27, 4u, 1u, v2);
  FS_FileRead(v27, 2u, 1u, v2);
  v20 = v27[0];
  FS_FileRead(v27, 2u, 1u, v2);
  v6 = v27[0];
  FS_FileRead(v27, 2u, 1u, v2);
  v24 = v27[0];
  FS_FileRead(v27, 2u, 1u, v2);
  if (v24 != v27[0] || v6 || v20)
    v17 = -103;
  FS_FileRead(v27, 4u, 1u, v2);
  v22 = *(_DWORD *)v27;
  FS_FileRead(v27, 4u, 1u, v2);
  v21 = *(_DWORD *)v27;
  FS_FileRead(v27, 2u, 1u, v2);
  v23 = v27[0];
  if (v21 + v22 > v15 || v17) {
    FS_FileClose(v2);
    return 0;
  } else {
    v13 = malloc(0x80u);
    __src[31] = 0;
    __src[7] = v15;
    __src[3] = v15 - (v21 + v22);
    __src[0] = v2;
    __src[9] = v21;
    __src[8] = v22;
    __src[2] = v23;
    __src[1] = v24;
    memcpy(v13, __src, 0x80u);
    v13[5] = v13[9];
    v13[4] = 0;
    v13[6] = unzlocal_GetCurrentFileInfoInternal((int)v13, v13 + 10, v13 + 30,
                                                 0, 0, 0, 0, 0, 0) == 0;
    return v13;
  }
}

int __cdecl unzClose(FILE **a1) {
  FILE *v1; // ebx

  if (!a1)
    return -102;
  v1 = a1[31];
  if (v1) {
    free(v1->_p);
    v1->_p = 0;
    if (*(_DWORD *)v1->_ubuf)
      inflateEnd((z_streamp)&v1->_r);
    *(_DWORD *)v1->_ubuf = 0;
    free(v1);
    a1[31] = 0;
  }
  FS_FileClose(*a1);
  free(a1);
  return 0;
}

int __cdecl unzOpenCurrentFile(int a1) {
  int v2;          // esi
  int v3;          // edi
  char v4;         // si
  int v5;          // esi
  _DWORD *v6;      // esi
  int v7;          // eax
  int v8;          // [esp+14h] [ebp-34h]
  int v9;          // [esp+18h] [ebp-30h]
  int v10;         // [esp+1Ch] [ebp-2Ch]
  __int16 v11[14]; // [esp+2Ch] [ebp-1Ch] BYREF

  if (!a1 || !*(_DWORD *)(a1 + 24))
    return -102;
  v2 = *(_DWORD *)(a1 + 124);
  if (v2) {
    free(*(void **)v2);
    *(_DWORD *)v2 = 0;
    if (*(_DWORD *)(v2 + 64))
      inflateEnd((z_streamp)(v2 + 4));
    *(_DWORD *)(v2 + 64) = 0;
    free((void *)v2);
    *(_DWORD *)(a1 + 124) = 0;
  }
  if (FS_FileSeek(*(FILE **)a1, *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 120),
                  0))
    return -103;
  FS_FileRead(v11, 4u, 1u, *(FILE **)a1);
  v3 = -103;
  if (*(_DWORD *)v11 == 67324752)
    v3 = 0;
  FS_FileRead(v11, 2u, 1u, *(FILE **)a1);
  FS_FileRead(v11, 2u, 1u, *(FILE **)a1);
  v4 = v11[0];
  FS_FileRead(v11, 2u, 1u, *(FILE **)a1);
  if (!v3) {
    if (v11[0] == *(_DWORD *)(a1 + 52) && (!v11[0] || v11[0] == 8))
      v3 = 0;
    else
      v3 = -103;
  }
  FS_FileRead(v11, 4u, 1u, *(FILE **)a1);
  FS_FileRead(v11, 4u, 1u, *(FILE **)a1);
  if (!v3) {
    if (*(_DWORD *)v11 == *(_DWORD *)(a1 + 60) || (v4 & 8) != 0)
      v3 = 0;
    else
      v3 = -103;
  }
  FS_FileRead(v11, 4u, 1u, *(FILE **)a1);
  if (!v3) {
    if (*(_DWORD *)v11 == *(_DWORD *)(a1 + 64) || (v4 & 8) != 0)
      v3 = 0;
    else
      v3 = -103;
  }
  FS_FileRead(v11, 4u, 1u, *(FILE **)a1);
  if (!v3) {
    if (*(_DWORD *)v11 == *(_DWORD *)(a1 + 68) || (v4 & 8) != 0)
      v3 = 0;
    else
      v3 = -103;
  }
  FS_FileRead(v11, 2u, 1u, *(FILE **)a1);
  v5 = v11[0];
  if (!v3 && v11[0] != *(_DWORD *)(a1 + 72))
    v3 = -103;
  FS_FileRead(v11, 2u, 1u, *(FILE **)a1);
  v10 = v11[0];
  v9 = *(_DWORD *)(a1 + 120) + v5 + 30;
  v8 = v11[0] + v5;
  if (v3)
    return -103;
  v6 = malloc(0x64u);
  if (!v6)
    return -104;
  *v6 = malloc(0x4000u);
  v6[17] = v9;
  v6[18] = v10;
  v6[19] = 0;
  if (!*v6) {
    free(v6);
    return -104;
  }
  v6[16] = 0;
  v7 = *(_DWORD *)(a1 + 52);
  v6[23] = v7;
  v6[22] = *(_DWORD *)a1;
  v6[24] = *(_DWORD *)(a1 + 12);
  v6[6] = 0;
  if (v7) {
    v6[9] = 0;
    v6[10] = 0;
    v6[11] = 0;
    if (!inflateInit2_((z_streamp)(v6 + 1), -15, "1.1.4", 56))
      v6[16] = 1;
  }
  v6[20] = *(_DWORD *)(a1 + 64);
  v6[21] = *(_DWORD *)(a1 + 68);
  v6[15] = *(_DWORD *)(a1 + 120) + v8 + 30;
  v6[2] = 0;
  *(_DWORD *)(a1 + 124) = v6;
  return 0;
}

int __cdecl closesocket(int a1) { return close(a1); }

int __cdecl WSAStartup(__int16 a1, _WORD *__b) {
  memset(__b, 0, 0x190u);
  *__b = a1;
  return 0;
}

int WSAGetLastError() {
  int result; // eax

  result = *__error();
  if ((unsigned int)(result - 1) <= 0x57)
    result += 10000;
  return result;
}

_BOOL4 Sys_IsMainThread(void) { return GetCurrentThreadId() == threadId; }

void *__cdecl Sys_SetValue(int a1, void *a2) {
  void *result; // eax

  result = a2;
  g_threadValues[a1] = (int)a2;
  return result;
}

int __cdecl Sys_GetValue(int a1) { return g_threadValues[a1]; }

int __cdecl I_strncmp(char *a1, char *a2, int a3) {
  int i;   // edi
  char v6; // bl
  int v7;  // ecx

  for (i = 0;; ++i) {
    v6 = *a1++;
    v7 = *a2++;
    if (i == a3)
      return 0;
    if (v6 != v7)
      break;
    if (!v6)
      return 0;
  }
  return 2 * (v7 <= v6) - 1;
}

float *__cdecl OrientationPosToWorldPos(float *a1, float *a2, float *a3) {
  float *result; // eax

  result = a1;
  *a3 = (float)((float)((float)(*a2 * a1[3]) + *a1) + (float)(a2[1] * a1[6])) +
        (float)(a2[2] * a1[9]);
  a3[1] =
      (float)((float)((float)(*a2 * a1[4]) + a1[1]) + (float)(a2[1] * a1[7])) +
      (float)(a2[2] * a1[10]);
  a3[2] =
      (float)((float)((float)(*a2 * a1[5]) + a1[2]) + (float)(a2[1] * a1[8])) +
      (float)(a2[2] * a1[11]);
  return result;
}

float *__cdecl OrientationDirToWorldDir(float *a1, float *a2, float *a3) {
  float *result; // eax

  result = a2;
  *a3 = (float)((float)(*a2 * a1[3]) + (float)(a2[1] * a1[6])) +
        (float)(a2[2] * a1[9]);
  a3[1] = (float)((float)(*a2 * a1[4]) + (float)(a2[1] * a1[7])) +
          (float)(a2[2] * a1[10]);
  a3[2] = (float)((float)(*a2 * a1[5]) + (float)(a2[1] * a1[8])) +
          (float)(a2[2] * a1[11]);
  return result;
}

float *__cdecl OrientationPosFromWorldPos(float *a1, float *a2, float *a3) {
  float *result; // eax
  float v4;      // xmm2_4
  float v5;      // xmm3_4
  float v6;      // xmm4_4

  result = a1;
  v4 = *a2 - *a1;
  v5 = a2[1] - a1[1];
  v6 = a2[2] - a1[2];
  *a3 =
      (float)((float)(v4 * a1[3]) + (float)(v5 * a1[4])) + (float)(v6 * a1[5]);
  a3[1] =
      (float)((float)(v4 * a1[6]) + (float)(v5 * a1[7])) + (float)(v6 * a1[8]);
  a3[2] = (float)((float)(v4 * a1[9]) + (float)(v5 * a1[10])) +
          (float)(v6 * a1[11]);
  return result;
}

float *__cdecl OrientationDirFromWorldDir(float *a1, float *a2, float *a3) {
  float *result; // eax

  result = a2;
  *a3 = (float)((float)(*a2 * a1[3]) + (float)(a2[1] * a1[4])) +
        (float)(a2[2] * a1[5]);
  a3[1] = (float)((float)(*a2 * a1[6]) + (float)(a2[1] * a1[7])) +
          (float)(a2[2] * a1[8]);
  a3[2] = (float)((float)(*a2 * a1[9]) + (float)(a2[1] * a1[10])) +
          (float)(a2[2] * a1[11]);
  return result;
}

int __cdecl I_strnicmp(char *a1, char *a2, int a3) {
  int v5; // ebx
  int v6; // ecx
  int i;  // [esp+0h] [ebp-10h]

  for (i = 0;; ++i) {
    v5 = *a1++;
    v6 = *a2++;
    if (i == a3)
      return 0;
    if (v5 != v6) {
      if ((unsigned int)(v5 - 97) <= 0x19)
        v5 -= 32;
      if ((unsigned int)(v6 - 97) <= 0x19)
        v6 -= 32;
      if (v5 != v6)
        break;
    }
    if (!v5)
      return 0;
  }
  return 2 * (v6 <= v5) - 1;
}

void Swap_Init() {
  _LittleShort = (int)ShortNoSwap;
  _LittleLong = (int)LongNoSwap;
  _LittleLong64 = (int)Long64NoSwap;
  _LittleFloatRead = (int)FloatReadNoSwap;
  _LittleFloatWrite = (int)FloatWriteNoSwap;
}

int __cdecl I_strcmp(char *a1, char *a2) {
  int v4;  // esi
  char v5; // cl
  int v6;  // ebx

  v4 = 0x7FFFFFFF;
  while (1) {
    v5 = *a1++;
    v6 = *a2++;
    if (--v4 == -1)
      return 0;
    if (v5 != v6)
      break;
    if (!v5)
      return 0;
  }
  return 2 * (v6 <= v5) - 1;
}

int __cdecl I_stricmp(char *a1, char *a2) {
  int v4; // ecx
  int v5; // ebx
  int v7; // [esp+0h] [ebp-10h]

  v7 = 0x7FFFFFFF;
  while (1) {
    v4 = *a1++;
    v5 = *a2++;
    if (--v7 == -1)
      return 0;
    if (v4 != v5) {
      if ((unsigned int)(v4 - 97) <= 0x19)
        v4 -= 32;
      if ((unsigned int)(v5 - 97) <= 0x19)
        v5 -= 32;
      if (v4 != v5)
        break;
    }
    if (!v4)
      return 0;
  }
  return 2 * (v5 <= v4) - 1;
}

int __cdecl VecNCompareCustomEpsilon(float *a1, float *a2, float a3, int a4) {
  int v4; // eax

  if (a4 > 0) {
    if ((float)((float)(*a1 - *a2) * (float)(*a1 - *a2)) > (float)(a3 * a3))
      return 0;
    v4 = 0;
    while (a4 != ++v4) {
      if ((float)((float)(a1[v4] - a2[v4]) * (float)(a1[v4] - a2[v4])) >
          (float)(a3 * a3))
        return 0;
    }
  }
  return 1;
}

long double randomf(void) { return (float)((float)rand() * 4.6566129e-10); }

float *__cdecl Vec3Cross(float *a1, float *a2, float *a3) {
  float *result; // eax

  result = a1;
  *a3 = (float)(a1[1] * a2[2]) - (float)(a1[2] * a2[1]);
  a3[1] = (float)(a1[2] * *a2) - (float)(*a1 * a2[2]);
  a3[2] = (float)(*a1 * a2[1]) - (float)(a1[1] * *a2);
  return result;
}

float *__cdecl MatrixMultiply(float *a1, float *a2, float *a3) {
  float *result; // eax

  *a3 = (float)((float)(*a1 * *a2) + (float)(a1[1] * a2[3])) +
        (float)(a1[2] * a2[6]);
  a3[1] = (float)((float)(*a1 * a2[1]) + (float)(a1[1] * a2[4])) +
          (float)(a1[2] * a2[7]);
  a3[2] = (float)((float)(*a1 * a2[2]) + (float)(a1[1] * a2[5])) +
          (float)(a1[2] * a2[8]);
  a3[3] = (float)((float)(a1[3] * *a2) + (float)(a1[4] * a2[3])) +
          (float)(a1[5] * a2[6]);
  a3[4] = (float)((float)(a1[3] * a2[1]) + (float)(a1[4] * a2[4])) +
          (float)(a1[5] * a2[7]);
  a3[5] = (float)((float)(a1[3] * a2[2]) + (float)(a1[4] * a2[5])) +
          (float)(a1[5] * a2[8]);
  a3[6] = (float)((float)(a1[6] * *a2) + (float)(a1[7] * a2[3])) +
          (float)(a1[8] * a2[6]);
  a3[7] = (float)((float)(a1[6] * a2[1]) + (float)(a1[7] * a2[4])) +
          (float)(a1[8] * a2[7]);
  result = a2 + 3;
  a3[8] = (float)((float)(a1[6] * a2[2]) + (float)(a1[7] * a2[5])) +
          (float)(a1[8] * a2[8]);
  return result;
}

long double __cdecl PointToBoxDistSq(int a1, int a2, int a3) {
  float v3; // xmm2_4
  int i;    // edx
  float v5; // xmm1_4
  float v6; // xmm0_4

  v3 = 0.0;
  for (i = 1; i != 4; ++i) {
    v5 = *(float *)(a1 + 4 * i - 4);
    v6 = *(float *)(a2 + 4 * i - 4) - v5;
    if (v6 <= 0.0) {
      v6 = v5 - *(float *)(4 * i + a3 - 4);
      if (v6 <= 0.0)
        continue;
    }
    v3 = v3 + (float)(v6 * v6);
  }
  return v3;
}

_DWORD *__cdecl MatrixIdentity44(_DWORD *a1) {
  _DWORD *result; // eax

  result = a1;
  *a1 = identityMatrix44;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 1065353216;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
  a1[10] = 1065353216;
  a1[11] = 0;
  a1[12] = 0;
  a1[13] = 0;
  a1[14] = 0;
  a1[15] = 1065353216;
  return result;
}

int __cdecl MatrixSet44(int a1, _DWORD *a2, float *a3, float a4) {
  int result; // eax

  *(float *)a1 = a4 * *a3;
  *(float *)(a1 + 4) = a4 * a3[1];
  *(float *)(a1 + 8) = a4 * a3[2];
  *(_DWORD *)(a1 + 12) = 0;
  *(float *)(a1 + 16) = a4 * a3[3];
  *(float *)(a1 + 20) = a4 * a3[4];
  *(float *)(a1 + 24) = a4 * a3[5];
  *(_DWORD *)(a1 + 28) = 0;
  *(float *)(a1 + 32) = a4 * a3[6];
  *(float *)(a1 + 36) = a4 * a3[7];
  *(float *)(a1 + 40) = a4 * a3[8];
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = *a2;
  *(_DWORD *)(a1 + 52) = a2[1];
  result = a2[2];
  *(_DWORD *)(a1 + 56) = result;
  *(_DWORD *)(a1 + 60) = 1065353216;
  return result;
}

float *__cdecl MatrixMultiply43(float *a1, float *a2, float *a3) {
  float *result; // eax

  *a3 = (float)((float)(*a1 * *a2) + (float)(a1[1] * a2[3])) +
        (float)(a1[2] * a2[6]);
  a3[3] = (float)((float)(a1[3] * *a2) + (float)(a1[4] * a2[3])) +
          (float)(a1[5] * a2[6]);
  a3[6] = (float)((float)(a1[6] * *a2) + (float)(a1[7] * a2[3])) +
          (float)(a1[8] * a2[6]);
  a3[1] = (float)((float)(*a1 * a2[1]) + (float)(a1[1] * a2[4])) +
          (float)(a1[2] * a2[7]);
  a3[4] = (float)((float)(a1[3] * a2[1]) + (float)(a1[4] * a2[4])) +
          (float)(a1[5] * a2[7]);
  a3[7] = (float)((float)(a1[6] * a2[1]) + (float)(a1[7] * a2[4])) +
          (float)(a1[8] * a2[7]);
  a3[2] = (float)((float)(*a1 * a2[2]) + (float)(a1[1] * a2[5])) +
          (float)(a1[2] * a2[8]);
  a3[5] = (float)((float)(a1[3] * a2[2]) + (float)(a1[4] * a2[5])) +
          (float)(a1[5] * a2[8]);
  a3[8] = (float)((float)(a1[6] * a2[2]) + (float)(a1[7] * a2[5])) +
          (float)(a1[8] * a2[8]);
  a3[9] = (float)((float)((float)(a1[9] * *a2) + (float)(a1[10] * a2[3])) +
                  (float)(a1[11] * a2[6])) +
          a2[9];
  a3[10] = (float)((float)((float)(a1[9] * a2[1]) + (float)(a1[10] * a2[4])) +
                   (float)(a1[11] * a2[7])) +
           a2[10];
  result = a2 + 3;
  a3[11] = (float)((float)((float)(a1[9] * a2[2]) + (float)(a1[10] * a2[5])) +
                   (float)(a1[11] * a2[8])) +
           a2[11];
  return result;
}

float *__cdecl MatrixMultiply44(float *a1, float *a2, float *a3) {
  float *result; // eax

  *a3 = (float)((float)((float)(*a1 * *a2) + (float)(a1[1] * a2[4])) +
                (float)(a1[2] * a2[8])) +
        (float)(a1[3] * a2[12]);
  a3[1] = (float)((float)((float)(*a1 * a2[1]) + (float)(a1[1] * a2[5])) +
                  (float)(a1[2] * a2[9])) +
          (float)(a1[3] * a2[13]);
  a3[2] = (float)((float)((float)(*a1 * a2[2]) + (float)(a1[1] * a2[6])) +
                  (float)(a1[2] * a2[10])) +
          (float)(a1[3] * a2[14]);
  a3[3] = (float)((float)((float)(*a1 * a2[3]) + (float)(a1[1] * a2[7])) +
                  (float)(a1[2] * a2[11])) +
          (float)(a1[3] * a2[15]);
  a3[4] = (float)((float)((float)(a1[4] * *a2) + (float)(a1[5] * a2[4])) +
                  (float)(a1[6] * a2[8])) +
          (float)(a1[7] * a2[12]);
  a3[5] = (float)((float)((float)(a1[4] * a2[1]) + (float)(a1[5] * a2[5])) +
                  (float)(a1[6] * a2[9])) +
          (float)(a1[7] * a2[13]);
  a3[6] = (float)((float)((float)(a1[4] * a2[2]) + (float)(a1[5] * a2[6])) +
                  (float)(a1[6] * a2[10])) +
          (float)(a1[7] * a2[14]);
  a3[7] = (float)((float)((float)(a1[4] * a2[3]) + (float)(a1[5] * a2[7])) +
                  (float)(a1[6] * a2[11])) +
          (float)(a1[7] * a2[15]);
  a3[8] = (float)((float)((float)(a1[8] * *a2) + (float)(a1[9] * a2[4])) +
                  (float)(a1[10] * a2[8])) +
          (float)(a1[11] * a2[12]);
  a3[9] = (float)((float)((float)(a1[8] * a2[1]) + (float)(a1[9] * a2[5])) +
                  (float)(a1[10] * a2[9])) +
          (float)(a1[11] * a2[13]);
  a3[10] = (float)((float)((float)(a1[8] * a2[2]) + (float)(a1[9] * a2[6])) +
                   (float)(a1[10] * a2[10])) +
           (float)(a1[11] * a2[14]);
  a3[11] = (float)((float)((float)(a1[8] * a2[3]) + (float)(a1[9] * a2[7])) +
                   (float)(a1[10] * a2[11])) +
           (float)(a1[11] * a2[15]);
  result = a1 + 12;
  a3[12] = (float)((float)((float)(a1[12] * *a2) + (float)(a1[13] * a2[4])) +
                   (float)(a1[14] * a2[8])) +
           (float)(a1[15] * a2[12]);
  a3[13] = (float)((float)((float)(a1[12] * a2[1]) + (float)(a1[13] * a2[5])) +
                   (float)(a1[14] * a2[9])) +
           (float)(a1[15] * a2[13]);
  a3[14] = (float)((float)((float)(a1[12] * a2[2]) + (float)(a1[13] * a2[6])) +
                   (float)(a1[14] * a2[10])) +
           (float)(a1[15] * a2[14]);
  a3[15] = (float)((float)((float)(a1[12] * a2[3]) + (float)(a1[13] * a2[7])) +
                   (float)(a1[14] * a2[11])) +
           (float)(a1[15] * a2[15]);
  return result;
}

int __cdecl MatrixTranspose(_DWORD *a1, _DWORD *a2) {
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[3];
  a2[2] = a1[6];
  a2[3] = a1[1];
  a2[4] = a1[4];
  a2[5] = a1[7];
  a2[6] = a1[2];
  a2[7] = a1[5];
  result = a1[8];
  a2[8] = result;
  return result;
}

int __cdecl MatrixTranspose44(_DWORD *a1, _DWORD *a2) {
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[4];
  a2[2] = a1[8];
  a2[3] = a1[12];
  a2[4] = a1[1];
  a2[5] = a1[5];
  a2[6] = a1[9];
  a2[7] = a1[13];
  a2[8] = a1[2];
  a2[9] = a1[6];
  a2[10] = a1[10];
  a2[11] = a1[14];
  a2[12] = a1[3];
  a2[13] = a1[7];
  a2[14] = a1[11];
  result = a1[15];
  a2[15] = result;
  return result;
}

float *__cdecl MatrixInverse(float *a1, float *a2) {
  float *result; // eax
  float v3;      // xmm5_4
  float v4;      // xmm2_4
  float v5;      // xmm4_4
  float v6;      // xmm3_4

  result = a1;
  v3 = a1[4];
  v4 = a1[5];
  v5 = (float)(a1[8] * v3) - (float)(a1[7] * v4);
  v6 =
      1.0 / (float)((float)((float)(v5 * *a1) -
                            (float)((float)((float)(a1[8] * a1[1]) -
                                            (float)(a1[7] * a1[2])) *
                                    a1[3])) +
                    (float)((float)((float)(v4 * a1[1]) - (float)(v3 * a1[2])) *
                            a1[6]));
  *a2 = v5 * v6;
  a2[1] = (float)-(float)((float)(a1[8] * a1[1]) - (float)(a1[7] * a1[2])) * v6;
  a2[2] = (float)((float)(a1[5] * a1[1]) - (float)(a1[4] * a1[2])) * v6;
  a2[3] = (float)-(float)((float)(a1[8] * a1[3]) - (float)(a1[6] * a1[5])) * v6;
  a2[4] = (float)((float)(a1[8] * *a1) - (float)(a1[6] * a1[2])) * v6;
  a2[5] = (float)-(float)((float)(a1[5] * *a1) - (float)(a1[3] * a1[2])) * v6;
  a2[6] = (float)((float)(a1[7] * a1[3]) - (float)(a1[6] * a1[4])) * v6;
  a2[7] = (float)-(float)((float)(a1[7] * *a1) - (float)(a1[6] * a1[1])) * v6;
  a2[8] = v6 * (float)((float)(a1[4] * *a1) - (float)(a1[3] * a1[1]));
  return result;
}

float *__cdecl MatrixTransformVector(float *a1, float *a2, float *a3) {
  float *result; // eax

  result = a1;
  *a3 = (float)((float)(*a1 * *a2) + (float)(a1[1] * a2[3])) +
        (float)(a1[2] * a2[6]);
  a3[1] = (float)((float)(*a1 * a2[1]) + (float)(a1[1] * a2[4])) +
          (float)(a1[2] * a2[7]);
  a3[2] = (float)((float)(*a1 * a2[2]) + (float)(a1[1] * a2[5])) +
          (float)(a1[2] * a2[8]);
  return result;
}

float *__cdecl MatrixInverse44(float *a1, float *a2) {
  int i;         // ecx
  float v4;      // xmm6_4
  float v5;      // xmm7_4
  float v6;      // xmm5_4
  float v7;      // xmm4_4
  float v8;      // xmm3_4
  float v9;      // xmm6_4
  float v10;     // xmm7_4
  float v11;     // xmm4_4
  float v12;     // xmm5_4
  float v13;     // xmm1_4
  int v14;       // edx
  float *result; // eax
  float v16;     // [esp+Ch] [ebp-BCh]
  float v17;     // [esp+10h] [ebp-B8h]
  float v18;     // [esp+14h] [ebp-B4h]
  float v19;     // [esp+18h] [ebp-B0h]
  float v20;     // [esp+1Ch] [ebp-ACh]
  float v21;     // [esp+20h] [ebp-A8h]
  float v22;     // [esp+24h] [ebp-A4h]
  float v23;     // [esp+28h] [ebp-A0h]
  float v24;     // [esp+2Ch] [ebp-9Ch]
  float v25;     // [esp+30h] [ebp-98h]
  float v26;     // [esp+34h] [ebp-94h]
  float v27;     // [esp+38h] [ebp-90h]
  float v28;     // [esp+3Ch] [ebp-8Ch]
  float v29;     // [esp+40h] [ebp-88h]
  float v30;     // [esp+44h] [ebp-84h]
  float v31;     // [esp+48h] [ebp-80h]
  float v32;     // [esp+4Ch] [ebp-7Ch]
  float v33;     // [esp+50h] [ebp-78h]
  float v34;     // [esp+54h] [ebp-74h]
  float v35;     // [esp+58h] [ebp-70h]
  float v36;     // [esp+5Ch] [ebp-6Ch]
  float v37;     // [esp+60h] [ebp-68h]
  float v38;     // [esp+64h] [ebp-64h]
  float v39;     // [esp+68h] [ebp-60h]
  float v40;     // [esp+6Ch] [ebp-5Ch]
  float v41;     // [esp+70h] [ebp-58h]
  float v42;     // [esp+74h] [ebp-54h]
  float v43;     // [esp+78h] [ebp-50h]
  float v44;     // [esp+7Ch] [ebp-4Ch]
  float v45;     // [esp+80h] [ebp-48h] BYREF
  float v46;     // [esp+84h] [ebp-44h]
  float v47;     // [esp+88h] [ebp-40h]
  float v48;     // [esp+8Ch] [ebp-3Ch]
  float v49;     // [esp+90h] [ebp-38h]
  float v50;     // [esp+94h] [ebp-34h]
  float v51;     // [esp+98h] [ebp-30h]
  float v52;     // [esp+9Ch] [ebp-2Ch]
  float v53;     // [esp+A0h] [ebp-28h]
  float v54;     // [esp+A4h] [ebp-24h]
  float v55;     // [esp+A8h] [ebp-20h]
  float v56;     // [esp+ACh] [ebp-1Ch]
  float v57;     // [esp+B0h] [ebp-18h]
  float v58;     // [esp+B4h] [ebp-14h]
  float v59;     // [esp+B8h] [ebp-10h]
  float v60;     // [esp+BCh] [ebp-Ch]

  for (i = 0; i != 16; i += 4) {
    *(float *)((char *)&v45 + i) = *a1;
    *(float *)((char *)&v49 + i) = a1[1];
    *(float *)((char *)&v53 + i) = a1[2];
    *(float *)((char *)&v57 + i) = a1[3];
    a1 += 4;
  }
  v16 = v55;
  v17 = v60;
  v4 = v55 * v60;
  v18 = v56;
  v19 = v59;
  v36 = v56 * v59;
  v20 = v54;
  v35 = v60 * v54;
  v21 = v58;
  v5 = v56 * v58;
  v34 = v59 * v54;
  v33 = v55 * v58;
  v22 = v53;
  v32 = v60 * v53;
  v23 = v57;
  v31 = v56 * v57;
  v30 = v59 * v53;
  v29 = v55 * v57;
  v28 = v58 * v53;
  v27 = v54 * v57;
  v6 = v50;
  v7 = v52;
  *a2 = (float)((float)((float)((float)(v55 * v60) * v50) +
                        (float)(v51 * (float)(v56 * v58))) +
                (float)((float)(v59 * v54) * v52)) -
        (float)((float)((float)((float)(v56 * v59) * v50) +
                        (float)((float)(v60 * v54) * v51)) +
                (float)((float)(v55 * v58) * v52));
  a2[1] = (float)((float)((float)(v36 * v49) + (float)(v32 * v51)) +
                  (float)(v29 * v7)) -
          (float)((float)((float)(v49 * v4) + (float)(v31 * v51)) +
                  (float)(v30 * v7));
  a2[2] = (float)((float)((float)(v35 * v49) + (float)(v31 * v6)) +
                  (float)(v28 * v7)) -
          (float)((float)((float)(v49 * v5) + (float)(v32 * v6)) +
                  (float)(v27 * v7));
  a2[3] = (float)((float)((float)(v33 * v49) + (float)(v30 * v6)) +
                  (float)(v27 * v51)) -
          (float)((float)((float)(v34 * v49) + (float)(v29 * v6)) +
                  (float)(v28 * v51));
  v24 = v46;
  v25 = v47;
  v26 = v48;
  a2[4] = (float)((float)((float)(v36 * v46) + (float)(v35 * v47)) +
                  (float)(v33 * v48)) -
          (float)((float)((float)(v46 * v4) + (float)(v47 * v5)) +
                  (float)(v34 * v48));
  v8 = v45;
  a2[5] = (float)((float)((float)(v4 * v45) + (float)(v31 * v25)) +
                  (float)(v30 * v26)) -
          (float)((float)(v29 * v26) +
                  (float)((float)(v32 * v25) + (float)(v36 * v45)));
  a2[6] = (float)((float)((float)(v5 * v8) + (float)(v32 * v24)) +
                  (float)(v27 * v26)) -
          (float)((float)(v28 * v26) +
                  (float)((float)(v35 * v8) + (float)(v31 * v24)));
  a2[7] = (float)((float)((float)(v34 * v8) + (float)(v29 * v24)) +
                  (float)(v28 * v25)) -
          (float)((float)((float)(v33 * v8) + (float)(v30 * v24)) +
                  (float)(v27 * v25));
  v9 = v25 * v7;
  v10 = v51 * v26;
  v44 = v24 * v7;
  v43 = v26 * v6;
  v42 = v51 * v24;
  v41 = v25 * v6;
  v11 = v7 * v8;
  v40 = v49 * v26;
  v39 = v51 * v8;
  v38 = v49 * v25;
  v12 = v6 * v8;
  v37 = v49 * v24;
  a2[8] =
      (float)((float)((float)(v21 * v9) + (float)(v19 * v43)) +
              (float)(v17 * (float)(v51 * v24))) -
      (float)((float)((float)(v21 * (float)(v51 * v26)) + (float)(v19 * v44)) +
              (float)(v17 * v41));
  a2[9] = (float)((float)((float)(v23 * v10) + (float)(v19 * v11)) +
                  (float)(v17 * v38)) -
          (float)((float)((float)(v23 * v9) + (float)(v19 * v40)) +
                  (float)(v17 * v39));
  a2[10] = (float)((float)((float)(v23 * v44) + (float)(v21 * v40)) +
                   (float)(v17 * v12)) -
           (float)((float)((float)(v23 * v43) + (float)(v21 * v11)) +
                   (float)(v17 * v37));
  a2[11] = (float)((float)((float)(v23 * v41) + (float)(v21 * v39)) +
                   (float)(v19 * v37)) -
           (float)((float)((float)(v23 * v42) + (float)(v21 * v38)) +
                   (float)(v19 * v12));
  a2[12] = (float)((float)((float)(v16 * v44) + (float)(v18 * v41)) +
                   (float)(v20 * v10)) -
           (float)((float)((float)(v18 * v42) + (float)(v20 * v9)) +
                   (float)(v16 * v43));
  a2[13] = (float)((float)((float)(v18 * v39) + (float)(v9 * v22)) +
                   (float)(v16 * v40)) -
           (float)((float)((float)(v16 * v11) + (float)(v18 * v38)) +
                   (float)(v10 * v22));
  a2[14] = (float)((float)((float)(v11 * v20) + (float)(v18 * v37)) +
                   (float)(v22 * v43)) -
           (float)((float)((float)(v18 * v12) + (float)(v22 * v44)) +
                   (float)(v20 * v40));
  a2[15] = (float)((float)((float)(v12 * v16) + (float)(v22 * v42)) +
                   (float)(v20 * v38)) -
           (float)((float)((float)(v20 * v39) + (float)(v16 * v37)) +
                   (float)(v22 * v41));
  v13 =
      1.0 / (float)((float)((float)((float)(v8 * *a2) + (float)(v24 * a2[1])) +
                            (float)(v25 * a2[2])) +
                    (float)(v26 * a2[3]));
  v14 = 1;
  result = a2 + 1;
  do {
    *(result - 1) = v13 * *(result - 1);
    ++v14;
    ++result;
  } while (v14 != 17);
  return result;
}

float *__cdecl MatrixTransformVector44(float *a1, float *a2, float *a3) {
  float *result; // eax

  result = a1;
  *a3 = (float)((float)((float)(*a1 * *a2) + (float)(a1[1] * a2[4])) +
                (float)(a1[2] * a2[8])) +
        (float)(a1[3] * a2[12]);
  a3[1] = (float)((float)((float)(*a1 * a2[1]) + (float)(a1[1] * a2[5])) +
                  (float)(a1[2] * a2[9])) +
          (float)(a1[3] * a2[13]);
  a3[2] = (float)((float)((float)(*a1 * a2[2]) + (float)(a1[1] * a2[6])) +
                  (float)(a1[2] * a2[10])) +
          (float)(a1[3] * a2[14]);
  a3[3] = (float)((float)((float)(*a1 * a2[3]) + (float)(a1[1] * a2[7])) +
                  (float)(a1[2] * a2[11])) +
          (float)(a1[3] * a2[15]);
  return result;
}

__int64 __cdecl MatrixTransposeTransformVector(__int64 a1, float *a2) {
  __int64 result; // rax

  result = a1;
  *a2 = (float)((float)(*(float *)a1 * *(float *)HIDWORD(a1)) +
                (float)(*(float *)(a1 + 4) * *(float *)(HIDWORD(a1) + 4))) +
        (float)(*(float *)(a1 + 8) * *(float *)(HIDWORD(a1) + 8));
  a2[1] = (float)((float)(*(float *)a1 * *(float *)(HIDWORD(a1) + 12)) +
                  (float)(*(float *)(a1 + 4) * *(float *)(HIDWORD(a1) + 16))) +
          (float)(*(float *)(a1 + 8) * *(float *)(HIDWORD(a1) + 20));
  a2[2] = (float)((float)(*(float *)a1 * *(float *)(HIDWORD(a1) + 24)) +
                  (float)(*(float *)(a1 + 4) * *(float *)(HIDWORD(a1) + 28))) +
          (float)(*(float *)(a1 + 8) * *(float *)(HIDWORD(a1) + 32));
  return result;
}

float *__cdecl InfinitePerspectiveMatrix(float *a1, float a2, float a3,
                                         int a4) {
  float v4;       // xmm0_4
  float v5;       // xmm0_4
  float *result;  // eax
  long double v7; // [esp+0h] [ebp-38h]
  long double v8; // [esp+0h] [ebp-38h]

  memset(a1, 0, 0x40u);
  *(double *)&v7 = (float)((float)(a2 * -0.5) + 90.0) * 0.0174532925199433;
  v4 = (double)tan(v7) * 0.9995002746582031;
  *a1 = v4;
  *(double *)&v8 = (float)((float)(a3 * -0.5) + 90.0) * 0.0174532925199433;
  v5 = (double)tan(v8) * 0.9995002746582031;
  a1[5] = v5;
  result = a1 + 8;
  a1[10] = 0.99950027;
  a1[11] = 1.0;
  a1[14] = 0.99950027 * COERCE_FLOAT(a4 ^ 0x80000000);
  return result;
}

int __cdecl MatrixForViewer(int a1, float *a2, int a3) {
  float v3;   // xmm2_4
  float v4;   // xmm2_4
  float v5;   // xmm2_4
  int result; // eax

  *(float *)a1 = -*(float *)(a3 + 12);
  *(float *)(a1 + 16) = -*(float *)(a3 + 16);
  v3 = -*(float *)(a3 + 20);
  *(float *)(a1 + 32) = v3;
  *(float *)(a1 + 48) = -(float)((float)((float)(*a2 * *(float *)a1) +
                                         (float)(a2[1] * *(float *)(a1 + 16))) +
                                 (float)(v3 * a2[2]));
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a3 + 24);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a3 + 28);
  v4 = *(float *)(a3 + 32);
  *(float *)(a1 + 36) = v4;
  *(float *)(a1 + 52) = -(float)((float)((float)(*a2 * *(float *)(a1 + 4)) +
                                         (float)(a2[1] * *(float *)(a1 + 20))) +
                                 (float)(v4 * a2[2]));
  *(_DWORD *)(a1 + 8) = *(_DWORD *)a3;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a3 + 4);
  v5 = *(float *)(a3 + 8);
  *(float *)(a1 + 40) = v5;
  *(float *)(a1 + 56) = -(float)((float)((float)(*a2 * *(float *)(a1 + 8)) +
                                         (float)(a2[1] * *(float *)(a1 + 24))) +
                                 (float)(v5 * a2[2]));
  result = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 60) = 1065353216;
  return result;
}

float *__cdecl AddPointToBounds(float *a1, float *a2, float *a3) {
  float *result; // eax
  float v4;      // xmm1_4
  float v5;      // xmm1_4
  float v6;      // xmm1_4

  result = a2;
  v4 = *a1;
  if (*a2 > *a1) {
    *a2 = v4;
    v4 = *a1;
  }
  if (v4 > *a3)
    *a3 = v4;
  v5 = a1[1];
  if (a2[1] > v5) {
    a2[1] = v5;
    v5 = a1[1];
  }
  if (v5 > a3[1])
    a3[1] = v5;
  v6 = a1[2];
  if (a2[2] > v6) {
    a2[2] = v6;
    v6 = a1[2];
  }
  if (v6 > a3[2])
    a3[2] = v6;
  return result;
}

__int64 __cdecl ExpandBounds(int a1, int a2, __int64 a3) {
  __int64 result; // rax
  float v4;       // xmm1_4
  float v5;       // xmm0_4
  float v6;       // xmm1_4
  float v7;       // xmm0_4

  result = a3;
  if (*(float *)a3 > *(float *)a1)
    *(_DWORD *)a3 = *(_DWORD *)a1;
  if (*(float *)a2 > *(float *)HIDWORD(a3))
    *(_DWORD *)HIDWORD(a3) = *(_DWORD *)a2;
  v4 = *(float *)(a1 + 4);
  if (*(float *)(a3 + 4) > v4)
    *(float *)(a3 + 4) = v4;
  v5 = *(float *)(a2 + 4);
  if (v5 > *(float *)(HIDWORD(a3) + 4))
    *(float *)(HIDWORD(a3) + 4) = v5;
  v6 = *(float *)(a1 + 8);
  if (*(float *)(a3 + 8) > v6)
    *(float *)(a3 + 8) = v6;
  v7 = *(float *)(a2 + 8);
  if (v7 > *(float *)(HIDWORD(a3) + 8))
    *(float *)(HIDWORD(a3) + 8) = v7;
  return result;
}

float *__cdecl AxisTransformVector(float *a1, float a2, float a3, float a4,
                                   float *a5) {
  float *result; // eax

  result = a1;
  *a5 = (float)((float)(a2 * *a1) + (float)(a3 * a1[3])) + (float)(a4 * a1[6]);
  a5[1] =
      (float)((float)(a2 * a1[1]) + (float)(a3 * a1[4])) + (float)(a4 * a1[7]);
  a5[2] =
      (float)((float)(a2 * a1[2]) + (float)(a3 * a1[5])) + (float)(a4 * a1[8]);
  return result;
}

int __cdecl BoxOnPlaneSide(float *a1, float *a2, int a3) {
  unsigned __int8 v3; // al
  float v4;           // xmm3_4
  int v5;             // eax
  float v7;           // xmm3_4
  float v8;           // xmm4_4
  float v9;           // xmm0_4
  _BOOL4 v10;         // edx

  v3 = *(_BYTE *)(a3 + 16);
  if (v3 > 2u) {
    switch (*(_BYTE *)(a3 + 17)) {
    case 0:
      v8 = (float)((float)(*(float *)a3 * *a2) +
                   (float)(*(float *)(a3 + 4) * a2[1])) +
           (float)(*(float *)(a3 + 8) * a2[2]);
      v7 = (float)((float)(*(float *)a3 * *a1) +
                   (float)(*(float *)(a3 + 4) * a1[1])) +
           (float)(*(float *)(a3 + 8) * a1[2]);
      break;
    case 1:
      v8 = (float)((float)(*(float *)a3 * *a1) +
                   (float)(*(float *)(a3 + 4) * a2[1])) +
           (float)(*(float *)(a3 + 8) * a2[2]);
      v7 = (float)((float)(*(float *)a3 * *a2) +
                   (float)(*(float *)(a3 + 4) * a1[1])) +
           (float)(*(float *)(a3 + 8) * a1[2]);
      break;
    case 2:
      v8 = (float)((float)(*(float *)a3 * *a2) +
                   (float)(*(float *)(a3 + 4) * a1[1])) +
           (float)(*(float *)(a3 + 8) * a2[2]);
      v7 = (float)((float)(*(float *)a3 * *a1) +
                   (float)(*(float *)(a3 + 4) * a2[1])) +
           (float)(*(float *)(a3 + 8) * a1[2]);
      break;
    case 3:
      v8 = (float)((float)(*(float *)a3 * *a1) +
                   (float)(*(float *)(a3 + 4) * a1[1])) +
           (float)(*(float *)(a3 + 8) * a2[2]);
      v7 = (float)((float)(*(float *)a3 * *a2) +
                   (float)(*(float *)(a3 + 4) * a2[1])) +
           (float)(*(float *)(a3 + 8) * a1[2]);
      break;
    case 4:
      v8 = (float)((float)(*(float *)a3 * *a2) +
                   (float)(*(float *)(a3 + 4) * a2[1])) +
           (float)(*(float *)(a3 + 8) * a1[2]);
      v7 = (float)((float)(*(float *)a3 * *a1) +
                   (float)(*(float *)(a3 + 4) * a1[1])) +
           (float)(*(float *)(a3 + 8) * a2[2]);
      break;
    case 5:
      v8 = (float)((float)(*(float *)a3 * *a1) +
                   (float)(*(float *)(a3 + 4) * a2[1])) +
           (float)(*(float *)(a3 + 8) * a1[2]);
      v7 = (float)((float)(*(float *)a3 * *a2) +
                   (float)(*(float *)(a3 + 4) * a1[1])) +
           (float)(*(float *)(a3 + 8) * a2[2]);
      break;
    case 6:
      v8 = (float)((float)(*(float *)a3 * *a2) +
                   (float)(*(float *)(a3 + 4) * a1[1])) +
           (float)(*(float *)(a3 + 8) * a1[2]);
      v7 = (float)((float)(*(float *)a3 * *a1) +
                   (float)(*(float *)(a3 + 4) * a2[1])) +
           (float)(*(float *)(a3 + 8) * a2[2]);
      break;
    case 7:
      v8 = (float)((float)(*(float *)a3 * *a1) +
                   (float)(*(float *)(a3 + 4) * a1[1])) +
           (float)(*(float *)(a3 + 8) * a1[2]);
      v7 = (float)((float)(*(float *)a3 * *a2) +
                   (float)(*(float *)(a3 + 4) * a2[1])) +
           (float)(*(float *)(a3 + 8) * a2[2]);
      break;
    default:
      v7 = 0.0;
      v8 = 0.0;
      break;
    }
    v9 = *(float *)(a3 + 12);
    v10 = v8 >= v9;
    if (v9 > v7)
      return (v8 >= v9) | 2;
    return v10;
  } else {
    v4 = *(float *)(a3 + 12);
    v5 = v3;
    if (a1[v5] >= v4)
      return 1;
    else
      return 3 - (v4 >= a2[v5]);
  }
}

int __cdecl AxisCopy(_DWORD *a1, _DWORD *a2) {
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = a1[3];
  a2[4] = a1[4];
  a2[5] = a1[5];
  a2[6] = a1[6];
  a2[7] = a1[7];
  result = a1[8];
  a2[8] = result;
  return result;
}

long double __cdecl Vec3DistanceSq(float *a1, float *a2) {
  return (
      float)((float)((float)((float)(*a2 - *a1) * (float)(*a2 - *a1)) +
                     (float)((float)(a2[1] - a1[1]) * (float)(a2[1] - a1[1]))) +
             (float)((float)(a2[2] - a1[2]) * (float)(a2[2] - a1[2])));
}

int __cdecl GetRotatedBounds(int a1, int a2, int a3, float *a4) {
  float *v4;  // edx
  float *v5;  // ecx
  float *v6;  // esi
  int v7;     // ebx
  int v8;     // eax
  int v9;     // eax
  int result; // eax
  int v11;    // [esp+Ch] [ebp-24h]
  int v12;    // [esp+18h] [ebp-18h]

  v11 = a3 + 12;
  v4 = a4;
  v5 = a4 + 3;
  v6 = (float *)(a3 + 24);
  v12 = 0;
  v7 = 0;
  do {
    *v4 = *(float *)(v7 + a2);
    *v5 = *(float *)(v7 + a2);
    v8 = (*(int *)(v7 + a3) >> 31) & 0xC;
    *v4 = (float)(*(float *)(a1 + v8) * *(float *)(v7 + a3)) + *v4;
    *v5 = (float)(*(float *)(a1 + 12 - v8) * *(float *)(v7 + a3)) + *v5;
    v9 = (*(int *)(v7 + v11) >> 31) & 0xC;
    *v4 = (float)(*(float *)(a1 + v9 + 4) * *(float *)(v7 + v11)) + *v4;
    *v5 = (float)(*(float *)(a1 + 16 - v9) * *(float *)(v7 + v11)) + *v5;
    result = (*(int *)(v7 + a3 + 24) >> 31) & 0xC;
    *v4 = (float)(*(float *)(a1 + result + 8) * *v6) + *v4;
    *v5 = (float)(*(float *)(a1 + 20 - result) * *v6) + *v5;
    ++v12;
    v7 += 4;
    ++v4;
    ++v5;
    ++v6;
  } while (v12 != 3);
  return result;
}

int __cdecl ClearBounds(_DWORD *a1, _DWORD *a2) {
  int result; // eax

  *a1 = 1207959552;
  a1[1] = 1207959552;
  a1[2] = 1207959552;
  result = -939524096;
  *a2 = -939524096;
  a2[1] = -939524096;
  a2[2] = -939524096;
  return result;
}

long double __cdecl Vec3Normalize(float *a1) {
  float v1; // xmm3_4
  float v2; // xmm2_4

  v1 = *a1;
  v2 = fsqrt((float)((float)(v1 * v1) + (float)(a1[1] * a1[1])) +
             (float)(a1[2] * a1[2]));
  if (v2 != 0.0) {
    *a1 = v1 * (float)(1.0 / v2);
    a1[1] = (float)(1.0 / v2) * a1[1];
    a1[2] = (float)(1.0 / v2) * a1[2];
  }
  return v2;
}

long double __cdecl Vec2Normalize(float *a1) {
  float v1; // xmm2_4
  float v2; // xmm1_4

  v1 = *a1;
  v2 = fsqrt((float)(v1 * v1) + (float)(a1[1] * a1[1]));
  if (v2 != 0.0) {
    *a1 = v1 * (float)(1.0 / v2);
    a1[1] = (float)(1.0 / v2) * a1[1];
  }
  return v2;
}

long double __cdecl Vec3NormalizeTo(float *a1, float *a2) {
  float v2; // xmm3_4
  float v3; // xmm2_4

  v2 = *a1;
  v3 = fsqrt((float)((float)(v2 * v2) + (float)(a1[1] * a1[1])) +
             (float)(a1[2] * a1[2]));
  if (v3 == 0.0) {
    *a2 = 0.0;
    a2[1] = 0.0;
    a2[2] = 0.0;
  } else {
    *a2 = v2 * (float)(1.0 / v3);
    a2[1] = (float)(1.0 / v3) * a1[1];
    a2[2] = (float)(1.0 / v3) * a1[2];
  }
  return v3;
}

int __cdecl Vec3MajorAxis(float *a1) {
  float v1;    // xmm0_4
  int result;  // eax
  float v3[2]; // [esp+4h] [ebp-Ch]
  float v4;    // [esp+Ch] [ebp-4h]

  v3[0] = *a1 * *a1;
  v1 = a1[1] * a1[1];
  v3[1] = v1;
  v4 = a1[2] * a1[2];
  result = 2;
  if (v4 <= v3[v1 > v3[0]])
    return v1 > v3[0];
  return result;
}

long double __cdecl Vec3Distance(float *a1, float *a2) {
  return fsqrt(
      (float)((float)((float)(*a2 - *a1) * (float)(*a2 - *a1)) +
              (float)((float)(a2[1] - a1[1]) * (float)(a2[1] - a1[1]))) +
      (float)((float)(a2[2] - a1[2]) * (float)(a2[2] - a1[2])));
}

int __cdecl MatrixInverseOrthogonal43(int a1, int a2) {
  float v2;   // xmm3_4
  float v3;   // xmm4_4
  float v4;   // xmm2_4
  int result; // eax

  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 32);
  v2 = 0.0 - *(float *)(a1 + 36);
  v3 = 0.0 - *(float *)(a1 + 40);
  v4 = 0.0 - *(float *)(a1 + 44);
  result = a2 + 36;
  *(float *)(a2 + 36) =
      (float)((float)(v2 * *(float *)a2) + (float)(v3 * *(float *)(a2 + 12))) +
      (float)(v4 * *(float *)(a2 + 24));
  *(float *)(a2 + 40) = (float)((float)(v2 * *(float *)(a2 + 4)) +
                                (float)(v3 * *(float *)(a2 + 16))) +
                        (float)(v4 * *(float *)(a2 + 28));
  *(float *)(a2 + 44) = (float)((float)(v2 * *(float *)(a2 + 8)) +
                                (float)(v3 * *(float *)(a2 + 20))) +
                        (float)(v4 * *(float *)(a2 + 32));
  return result;
}

float *__cdecl MakeNormalVectors(float *a1, float *a2, float *a3) {
  float v3;      // xmm1_4
  float *v4;     // esi
  float v5;      // xmm2_4
  float *v6;     // ebx
  float v7;      // xmm0_4
  float v8;      // xmm4_4
  float v9;      // xmm1_4
  float v10;     // xmm0_4
  float v11;     // xmm2_4
  float *result; // eax
  float *v13;    // [esp+0h] [ebp-14h]
  float *v14;    // [esp+4h] [ebp-10h]

  v13 = a2 + 1;
  v3 = -*a1;
  a2[1] = v3;
  v4 = a2 + 2;
  v14 = a1 + 1;
  v5 = a1[1];
  a2[2] = v5;
  v6 = a1 + 2;
  *a2 = a1[2];
  v7 = -(float)((float)((float)(*a1 * *a2) + (float)(v3 * a1[1])) +
                (float)(v5 * a1[2]));
  v8 = (float)(*a1 * v7) + *a2;
  *a2 = v8;
  v9 = (float)(v7 * a1[1]) + a2[1];
  a2[1] = v9;
  v10 = (float)(v7 * a1[2]) + a2[2];
  a2[2] = v10;
  v11 =
      fsqrt((float)((float)(v8 * v8) + (float)(v9 * v9)) + (float)(v10 * v10));
  if (v11 != 0.0) {
    *a2 = v8 * (float)(1.0 / v11);
    a2[1] = (float)(1.0 / v11) * a2[1];
    a2[2] = (float)(1.0 / v11) * a2[2];
  }
  *a3 = (float)(*v13 * *v6) - (float)(*v4 * *v14);
  a3[1] = (float)(*v4 * *a1) - (float)(*a2 * *v6);
  result = a2 + 1;
  a3[2] = (float)(*a2 * *v14) - (float)(*v13 * *a1);
  return result;
}

_BOOL4 __cdecl PerpendicularVector(float *a1, float *a2) {
  float v2;      // xmm2_4
  _BOOL4 result; // eax
  int v4;        // edx
  int v5;        // edx
  float v6;      // xmm0_4
  float v7;      // xmm3_4
  float v8;      // xmm1_4
  float v9;      // [esp+4h] [ebp-10h]
  float v10;     // [esp+8h] [ebp-Ch]
  float v11;     // [esp+Ch] [ebp-8h]

  v2 = *a1;
  v9 = v2 * v2;
  v10 = a1[1] * a1[1];
  v11 = a1[2] * a1[2];
  result = (float)(v2 * v2) > v10;
  v4 = 2;
  if (*(&v9 + result) <= v11)
    v4 = (float)(v2 * v2) > v10;
  v5 = v4;
  v6 = -a1[v5];
  *a2 = v2 * v6;
  a2[1] = v6 * a1[1];
  a2[2] = v6 * a1[2];
  a2[v5] = a2[v5] + 1.0;
  v7 = *a2;
  v8 = fsqrt((float)((float)(v7 * v7) + (float)(a2[1] * a2[1])) +
             (float)(a2[2] * a2[2]));
  if (v8 != 0.0) {
    *a2 = v7 * (float)(1.0 / v8);
    a2[1] = (float)(1.0 / v8) * a2[1];
    a2[2] = (float)(1.0 / v8) * a2[2];
  }
  return result;
}

int __cdecl YawToAxis(float a1, int a2) {
  float v2;   // xmm0_4
  int result; // eax
  float v4;   // [esp+14h] [ebp-14h]
  float v5;   // [esp+18h] [ebp-10h]

  v2 = a1 * 0.0174532925199433;
  v4 = sinf(v2);
  v5 = cosf(v2);
  if (a2) {
    *(float *)a2 = v5;
    *(float *)(a2 + 4) = v4;
    *(_DWORD *)(a2 + 8) = 0;
  }
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 1065353216;
  result = a2 + 12;
  *(float *)(a2 + 12) = 0.0 - v4;
  *(float *)(a2 + 16) = v5 + 0.0;
  *(_DWORD *)(a2 + 20) = 0;
  return result;
}

void __cdecl AngleVectors(float *a1, float *a2, float *a3, float *a4) {
  float v4;  // xmm0_4
  float v5;  // xmm0_4
  float v6;  // xmm0_4
  float v7;  // [esp+1Ch] [ebp-3Ch]
  float v8;  // [esp+24h] [ebp-34h]
  float v9;  // [esp+28h] [ebp-30h]
  float v10; // [esp+2Ch] [ebp-2Ch]
  float v11; // [esp+30h] [ebp-28h]
  float v12; // [esp+34h] [ebp-24h]

  v4 = a1[1] * 0.0174532925199433;
  v10 = sinf(v4);
  v12 = cosf(v4);
  v5 = *a1 * 0.0174532925199433;
  v9 = sinf(v5);
  v11 = cosf(v5);
  if (a2) {
    *a2 = v12 * v11;
    a2[1] = v10 * v11;
    a2[2] = -v9;
  }
  if (a3 || a4) {
    v6 = a1[2] * 0.0174532925199433;
    v8 = sinf(v6);
    v7 = cosf(v6);
    if (a3) {
      *a3 = (float)(v12 * (float)(v9 * (float)-v8)) + (float)(v10 * v7);
      a3[1] = (float)((float)(v9 * (float)-v8) * v10) - (float)(v12 * v7);
      a3[2] = (float)-v8 * v11;
    }
    if (a4) {
      *a4 = (float)(v12 * (float)(v9 * v7)) + (float)(v10 * v8);
      a4[1] = (float)((float)(v9 * v7) * v10) - (float)(v8 * v12);
      a4[2] = v11 * v7;
    }
  }
}

float *__cdecl AnglesToAxis(float *a1, float *a2) {
  float *result; // eax
  float v3[5];   // [esp+14h] [ebp-14h] BYREF

  AngleVectors(a1, a2, v3, a2 + 6);
  result = a2 + 3;
  a2[3] = 0.0 - v3[0];
  a2[4] = 0.0 - v3[1];
  a2[5] = 0.0 - v3[2];
  return result;
}

void __cdecl AxisToAngles(float *a1, float *a2) {
  float v2;        // xmm0_4
  float v3;        // xmm0_4
  float v4;        // xmm2_4
  float v5;        // xmm1_4
  float v6;        // xmm0_4
  float v7;        // xmm0_4
  float v8;        // xmm1_4
  long double v9;  // [esp+0h] [ebp-68h]
  long double v10; // [esp+10h] [ebp-58h]
  float v11;       // [esp+1Ch] [ebp-4Ch]
  float v12;       // [esp+3Ch] [ebp-2Ch]
  float v13;       // [esp+40h] [ebp-28h]
  float v14;       // [esp+48h] [ebp-20h]
  float v15;       // [esp+4Ch] [ebp-1Ch]
  float v16;       // [esp+50h] [ebp-18h]
  float v17;       // [esp+54h] [ebp-14h]
  float v18;       // [esp+5Ch] [ebp-Ch]

  vectoangles(a1, a2);
  v17 = a1[3];
  v16 = a1[4];
  v15 = a1[5];
  v2 = (float)-a2[1] * 0.0174532925199433;
  v13 = sinf(v2);
  v11 = cosf(v2);
  v14 = (float)(v17 * v11) - (float)(v16 * v13);
  v18 = (float)(v17 * v13) + (float)(v11 * v16);
  v3 = (float)-*a2 * 0.0174532925199433;
  v12 = sinf(v3);
  *((float *)&v10 + 3) = cosf(v3);
  v4 = (float)(v15 * v12) + (float)(v14 * *((float *)&v10 + 3));
  v5 = (float)(*((float *)&v10 + 3) * v15) - (float)(v14 * v12);
  v6 = v18;
  if (v18 != 0.0)
    goto LABEL_9;
  if (v4 != 0.0) {
    v6 = v18;
  LABEL_9:
    *((double *)&v9 + 1) = fsqrt((float)(v4 * v4) + (float)(v6 * v6));
    *(double *)&v9 = v5;
    v7 = (double)atan2(v9, v10) * -180.0 / 3.141592653589793;
    goto LABEL_10;
  }
  if (v5 <= 0.0) {
    v7 = 90.0;
  LABEL_10:
    if (v18 < 0.0)
      goto LABEL_5;
  LABEL_11:
    a2[2] = -v7;
    return;
  }
  v7 = -90.0;
  if (v18 >= 0.0)
    goto LABEL_11;
LABEL_5:
  if (v7 < 0.0)
    v8 = 180.0;
  else
    v8 = -180.0;
  a2[2] = v7 + v8;
}

int Com_EndRedirect(void) {
  int result; // eax

  if (rd_flush)
    result = rd_flush(rd_buffer);
  rd_buffer = 0;
  rd_buffersize = 0;
  rd_flush = 0;
  return result;
}

void __cdecl Com_SetRecommended(int a1) {
  int ConfigureDvarNames; // esi
  int32_t v2;             // edi
  char *v3;               // ebx
  char v4;                // al
  char *v5;               // eax
  long double v6;         // fst7
  char *v7;               // eax
  int v8;                 // eax
  int32_t v9;             // ebx
  double v10;             // xmm0_8
  char *v11;              // ecx
  char *v12;              // eax
  int v13;                // ecx
  int v14;                // edx
  int v15;                // esi
  char *v16;              // eax
  char v17;               // al
  char v18;               // al
  int v19;                // esi
  int v20;                // eax
  char *v21;              // edi
  char *v22;              // ebx
  char v24;               // [esp+8h] [ebp-1E80h]
  char v25;               // [esp+8h] [ebp-1E80h]
  double v26;             // [esp+8h] [ebp-1E80h]
  signed int File;        // [esp+2Ch] [ebp-1E5Ch]
  char v28;               // [esp+33h] [ebp-1E55h]
  int v29;                // [esp+34h] [ebp-1E54h]
  char v30;               // [esp+3Bh] [ebp-1E4Dh]
  char *v31;              // [esp+3Ch] [ebp-1E4Ch]
  double v32;             // [esp+40h] [ebp-1E48h]
  double v33;             // [esp+48h] [ebp-1E40h]
  _BYTE v34[2048];        // [esp+58h] [ebp-1E30h] BYREF
  dvar_s v35[56];         // [esp+858h] [ebp-1630h] BYREF
  _QWORD __dst[256];      // [esp+1058h] [ebp-E30h] BYREF
  _QWORD __src[128];      // [esp+1858h] [ebp-630h] BYREF
  SysInfo v38;            // [esp+1C58h] [ebp-230h] BYREF
  int v39;                // [esp+1E68h] [ebp-20h] BYREF
  char v40[4];            // [esp+1E6Ch] [ebp-1Ch] BYREF

  Com_Printf("========= autoconfigure\n");
  Sys_GetInfo(&v38);
  *(double *)&v38.cpuGHz = 1.02 * *(double *)&v38.cpuGHz;
  if (v38.sysMB > 127) {
    v38.sysMB += 8;
    File = FS_ReadFile("configure_mp.csv", (char **)&v39);
    if (File >= 0)
      goto LABEL_3;
  LABEL_36:
    Com_Error(0, "EXE_ERR_NOT_FOUND\x15configure_mp.csv", v24);
    goto LABEL_3;
  }
  v38.sysMB = 128;
  File = FS_ReadFile("configure_mp.csv", (char **)&v39);
  if (File < 0)
    goto LABEL_36;
LABEL_3:
  *(_DWORD *)v40 = v39;
  Com_BeginParseSession("configure_mp.csv");
  Com_SetCSV(1);
  ConfigureDvarNames = 0;
  v28 = 0;
  v2 = 0;
  v32 = -1.0;
LABEL_4:
  while (1) {
    v3 = Com_Parse((char **)v40);
    v4 = *v3;
    if (*v3)
      break;
  LABEL_13:
    Com_SkipRestOfLine((unsigned __int8 **)v40);
  }
  while (1) {
    if (v4 == 35)
      goto LABEL_13;
    if (!stricmp(v3, "gpu"))
      break;
    if (ConfigureDvarNames) {
      v6 = atof(v3);
      v33 = v6;
      if ((double)v6 < 0.0) {
        v26 = v6;
        Com_Error(
            0,
            "\x15configure_mp.csv: cpu ghz %g not allowed to be less than 0\n",
            SLOBYTE(v26));
      }
      v7 = Com_ParseOnLine((char **)v40);
      v8 = atoi(v7);
      v9 = v8;
      if (v8 <= 127)
        Com_Error(
            0,
            "\x15configure_mp.csv: sys mb %i not allowed to be less than 128\n",
            v8);
      if (*(double *)&v38.cpuGHz < v33 || v9 > v38.sysMB)
        goto LABEL_22;
      v10 = v6;
      if (v33 > v32)
        goto LABEL_34;
      if (v32 == v33 && v2 < v9) {
        v10 = v6;
      LABEL_34:
        LODWORD(__src[1]) = v9;
        *(double *)__src = v10;
        memcpy(__dst, __src, 0x210u);
        v2 = __dst[1];
        v32 = *(double *)__dst;
        v11 = v34;
        v28 = 1;
      } else {
      LABEL_22:
        v11 = 0;
      }
      Com_GetConfigureDvarValues(ConfigureDvarNames, (char **)v40, v11);
      goto LABEL_4;
    }
    if (stricmp(v3, "cpu ghz"))
      Com_Error(
          0, "\x15configure_mp.csv: \"cpu ghz\" should be the first column\n",
          v24);
    v5 = Com_ParseOnLine((char **)v40);
    if (stricmp(v5, "sys mb"))
      Com_Error(
          0, "\x15configure_mp.csv: \"sys mb\" should be the second column\n",
          v24);
    ConfigureDvarNames = Com_GetConfigureDvarNames((char **)v40, v35[0].name);
    v3 = Com_Parse((char **)v40);
    v4 = *v3;
    if (!*v3)
      goto LABEL_13;
  }
  Com_UngetToken();
  if (v28) {
    Com_Printf("configure_mp.csv: using CPU configuration %.0f GHz %i MB\n",
               v32, v2);
    Cbuf_AddText("exec configure_mp.cfg");
    Cbuf_Execute();
    Com_SetConfigureDvars(ConfigureDvarNames, v35, (DvarValue)v34);
  } else {
    Sys_GetInfo(&v38);
    Com_Error(0,
              "\x15configure_mp.csv: \x14EXE_ERR_COULDNT_CONFIGURE\x15 %.0f "
              "GHz %i MB\n",
              v38.cpuGHz);
  }
  v12 = Com_Parse((char **)v40);
  if (stricmp(v12, "gpu")) {
    Com_UngetToken();
    goto LABEL_28;
  }
  v29 = Com_GetConfigureDvarNames((char **)v40, v35[0].name);
  v30 = 0;
LABEL_43:
  v16 = Com_Parse((char **)v40);
  v31 = v16;
  if (!*(_DWORD *)v40)
    goto LABEL_53;
  do {
    v17 = *v16;
    if (!v17 || v17 == 35) {
      Com_SkipRestOfLine((unsigned __int8 **)v40);
      goto LABEL_43;
    }
    if (v30)
      goto LABEL_52;
    LOBYTE(__src[0]) = 42;
    v18 = *v31;
    if (!*v31) {
      v19 = 1;
      v20 = 0;
      goto LABEL_49;
    }
    v21 = v31;
    v22 = v31 + 1;
    v19 = 1;
    do {
      while (!((v18 & 0xFFFFFF80) != 0
                   ? __maskrune(v18, 0x4000) != 0
                   : (_DefaultRuneLocale.__runetype[v18] >> 14) & 1)) {
        *((_BYTE *)__src + v19++) = *v21;
        if (v19 == 1023)
          goto LABEL_64;
      LABEL_58:
        v21 = v22;
        v18 = *v22++;
        if (!v18)
          goto LABEL_65;
      }
      if (*((_BYTE *)&__dst[255] + v19 + 7) == 32)
        goto LABEL_58;
      *((_BYTE *)__src + v19++) = 32;
      if (v19 != 1023)
        goto LABEL_58;
    LABEL_64:
      Com_Error(0, "\x15configure_mp.csv: \"find\" string is too long\n", v25);
      v21 = v22;
      v18 = *v22++;
    } while (v18);
  LABEL_65:
    v20 = v19 - 1;
  LABEL_49:
    if (*((_BYTE *)__src + v20) != 42)
      *((_BYTE *)__src + v19++) = 42;
    *((_BYTE *)__src + v19) = 0;
    if (!Com_GpuStringCompare((char *)__src, v38.gpuDescription)) {
      Com_Printf("configure_mp.csv: using GPU configuration \"%s\"\n", v31);
      Com_GetConfigureDvarValues(v29, (char **)v40, (char *)__dst);
      Com_SetConfigureDvars(v29, v35, (DvarValue)__dst);
      v30 = 1;
      goto LABEL_43;
    }
  LABEL_52:
    Com_GetConfigureDvarValues(v29, (char **)v40, 0);
    v16 = Com_Parse((char **)v40);
    v31 = v16;
  } while (*(_DWORD *)v40);
LABEL_53:
  if (!v30)
  LABEL_28:
    Com_Error(
        0, "\x15configure_mp.csv: \x14EXE_ERR_COULDNT_CONFIGURE\x15 \"%s\"\n",
        (char)v38.gpuDescription);
  Com_EndParseSession();
  if (File > 0) {
    v13 = 0;
    v14 = 0;
    do
      v14 = 31337 * v14 + *(char *)(v39 + v13++);
    while (File != v13);
    v15 = v14 & 0xFFFFFFF;
    FS_FreeFile((void *)v39);
    Sys_ArchiveInfo(v15 + 1);
    if (a1)
      goto LABEL_40;
  } else {
    FS_FreeFile((void *)v39);
    Sys_ArchiveInfo(1);
    if (!a1)
      return;
  LABEL_40:
    if ((unsigned __int8)Dvar_AnyLatchedValues())
      Cbuf_AddText("snd_restart\n");
  }
}

void Com_CheckSetRecommended(void) {
  signed int File; // ebx
  int v1;          // ecx
  int v2;          // edx
  int v3;          // ebx
  char v4;         // [esp+8h] [ebp-20h]
  int v5;          // [esp+1Ch] [ebp-Ch] BYREF

  if (!com_recommendedSet->current.enabled)
    goto LABEL_8;
  File = FS_ReadFile("configure_mp.csv", (char **)&v5);
  if (File < 0)
    Com_Error(0, "EXE_ERR_NOT_FOUND\x15configure_mp.csv", v4);
  if (File > 0) {
    v1 = 0;
    v2 = 0;
    do
      v2 = 31337 * v2 + *(char *)(v5 + v1++);
    while (File != v1);
    v3 = v2 & 0xFFFFFFF;
    FS_FreeFile((void *)v5);
    if (!Sys_HasConfigureChecksumChanged(v3 + 1))
      goto LABEL_9;
    goto LABEL_8;
  }
  FS_FreeFile((void *)v5);
  if (Sys_HasConfigureChecksumChanged(1)) {
  LABEL_8:
    Com_SetRecommended(0);
    Dvar_SetBool(com_recommendedSet, 1);
  }
LABEL_9:
  if ((unsigned __int8)Sys_HasInfoChanged())
    Com_SetRecommended(0);
}

int SEH_Init_StringEd(void) { return SE_Init(); }

void SEH_Shutdown_StringEd(void) { SE_ShutDown(); }

_BOOL4 FS_Initialized(void) { return fs_searchpaths != 0; }

_BOOL4 __cdecl FS_UseSearchPath(const searchpath_s *a1) {
  _BOOL4 result;    // eax
  int32_t language; // ebx

  result = 1;
  if (a1->bLocalized) {
    if (*(_BYTE *)(fs_ignoreLocalized + 8))
      return 0;
    language = a1->language;
    if (language != SEH_GetCurrentLanguage())
      return 0;
  }
  return result;
}

int __cdecl FS_LanguageHasAssets(int a1) {
  searchpath_s *v1; // eax

  v1 = fs_searchpaths;
  if (!fs_searchpaths)
    return 0;
  while (!v1->bLocalized || v1->language != a1) {
    v1 = (searchpath_s *)v1->next;
    if (!v1)
      return 0;
  }
  return 1;
}

int __cdecl FS_HandleForFile(int a1) {
  int v1;         // esi
  int v2;         // edi
  int v3;         // eax
  char *v4;       // ecx
  int v5;         // edx
  int v6;         // eax
  int v8;         // ebx
  const char *v9; // esi
  char v10;       // [esp+8h] [ebp-20h]

  if (a1) {
    v1 = 61;
    v2 = 13;
    v3 = 17324;
    if (unk_FFC5EC)
      goto LABEL_3;
    return v1;
  }
  v1 = 1;
  v2 = 60;
  v3 = 284;
  if (!*(_DWORD *)&byte_FF825C[256])
    return v1;
LABEL_3:
  v4 = (char *)&fsh + v3;
  v5 = 0;
  while (v2 != ++v5) {
    v6 = *((_DWORD *)v4 + 71);
    v4 += 284;
    if (!v6)
      return v5 + v1;
  }
  v8 = 1;
  v9 = (const char *)&unk_FF8378;
  do {
    Com_Printf("FILE %2i: '%s'\n", v8++, v9);
    v9 += 284;
  } while (v8 != 74);
  Com_Error(1, "\x15FS_HandleForFile: none free", v10);
  return -1;
}

int __cdecl FS_Remove(char *a1) { return remove(a1); }

int __cdecl FS_FilenameCompare(const char *a1, const char *a2) {
  int v3; // esi
  int v4; // ebx

  do {
    v3 = *a1++;
    v4 = *a2++;
    if (I_islower(v3))
      v3 -= 32;
    if (I_islower(v4))
      v4 -= 32;
    if (v3 == 92 || v3 == 58) {
      v3 = 47;
      if (v4 == 92)
        goto LABEL_13;
    } else if (v4 == 92) {
      goto LABEL_13;
    }
    if (v4 != 58) {
      if (v3 != v4)
        return -1;
      continue;
    }
  LABEL_13:
    if (v3 != 47)
      return -1;
  } while (v3);
  return 0;
}

_BOOL4 __cdecl FS_PureIgnoresExtension(char *a1) {
  char *v1; // ebx

  v1 = a1;
  if (*a1 == 46)
    v1 = a1 + 1;
  return !stricmp(v1, "cfg") || !I_stricmp(v1, "menu") ||
         !I_stricmp(v1, "str") || !I_stricmp(v1, "roq") ||
         !I_stricmp(v1, ".dm_NETWORK_PROTOCOL_VERSION");
}

void FS_ShutdownServerIwdNames(void) {
  int v0;    // esi
  void **v1; // ebx

  if (fs_numServerIwds > 0) {
    v0 = 0;
    v1 = (void **)&fs_serverIwdNames;
    do {
      if (*v1)
        Z_FreeInternal(*v1);
      *v1 = 0;
      ++v0;
      ++v1;
    } while (v0 < fs_numServerIwds);
  }
  fs_numServerIwds = 0;
}

void FS_ShutdownServerReferencedIwds(void) {
  int v0;    // esi
  void **v1; // ebx

  if (fs_numServerReferencedIwds > 0) {
    v0 = 0;
    v1 = (void **)&fs_serverReferencedIwdNames;
    do {
      if (*v1)
        Z_FreeInternal(*v1);
      *v1 = 0;
      ++v0;
      ++v1;
    } while (v0 < fs_numServerReferencedIwds);
  }
  fs_numServerReferencedIwds = 0;
}

int FS_RegisterDvars(void) {
  const gentity_s *v1; // eax
  char *v2;            // eax
  _BYTE *integer;      // eax

  if (fs_debug)
    return 0;
  fs_debug = (int)Dvar_RegisterInt("fs_debug", 0, 0, 2, 0x1000u);
  fs_copyfiles = (int)Dvar_RegisterBool("fs_copyfiles", 0, 0x1010u);
  v1 = Sys_DefaultCDPath();
  fs_cdpath = (int)Dvar_RegisterString("fs_cdpath", (DvarValue)v1, 0x1010u);
  v2 = Sys_DefaultInstallPath();
  fs_basepath = Dvar_RegisterString("fs_basepath", (DvarValue)v2, 0x1010u);
  fs_basegame =
      (int)Dvar_RegisterString("fs_basegame", (DvarValue)&inData, 0x1010u);
  fs_useOldAssets = (int)Dvar_RegisterBool("fs_useOldAssets", 0, 0x1000u);
  integer = (_BYTE *)Sys_DefaultHomePath();
  if (!integer || !*integer)
    integer = (_BYTE *)fs_basepath->current.integer;
  fs_homepath =
      (int)Dvar_RegisterString("fs_homepath", (DvarValue)integer, 0x1010u);
  fs_gameDirVar = Dvar_RegisterString("fs_game", (DvarValue)&inData, 0x101Cu);
  fs_restrict = Dvar_RegisterBool("fs_restrict", 0, 0x1010u);
  fs_ignoreLocalized = (int)Dvar_RegisterBool("fs_ignoreLocalized", 0, 0x10A0u);
  return 1;
}

void __cdecl FS_FreeFile(void *a1) {
  --fs_loadStack;
  Hunk_FreeTempMemory(a1);
}

void __cdecl FS_FreeFileList(void **a1) {
  void *v1;  // eax
  void **v2; // ebx

  if (a1) {
    v1 = *a1;
    if (*a1) {
      v2 = a1;
      do {
        Z_FreeInternal(v1);
        v1 = v2[1];
        ++v2;
      } while (v1);
    }
    Z_FreeInternal(a1);
  }
}

void __cdecl FS_Shutdown() {
  int v0;             // esi
  FILE **v1;          // ebx
  searchpath_s *v2;   // ebx
  searchpath_s *next; // esi
  int32_t pack;       // eax

  SND_StopSounds(SND_STOP_STREAMED);
  SEH_Shutdown_StringEd();
  v0 = 1;
  v1 = &fsh;
  do {
    while (!v1[74]) {
      ++v0;
      v1 += 71;
      if (v0 == 74)
        goto LABEL_5;
    }
    FS_FCloseFile(v0++);
    v1 += 71;
  } while (v0 != 74);
LABEL_5:
  v2 = fs_searchpaths;
  if (fs_searchpaths) {
    while (1) {
      next = (searchpath_s *)v2->next;
      pack = v2->pack;
      if (pack) {
        unzClose(*(FILE ***)(pack + 768));
        Z_FreeInternal(*(void **)(v2->pack + 796));
        Z_FreeInternal((void *)v2->pack);
      }
      if (v2->dir)
        Z_FreeInternal((void *)v2->dir);
      Z_FreeInternal(v2);
      if (!next)
        break;
      v2 = next;
    }
  }
  fs_searchpaths = 0;
  Cmd_RemoveCommand("path");
  Cmd_RemoveCommand("fullpath");
  Cmd_RemoveCommand("dir");
  Cmd_RemoveCommand("fdir");
  Cmd_RemoveCommand("touchFile");
}

FILE *__cdecl FS_FileExists(const char *a1) {
  FILE *result;    // eax
  char __dst[264]; // [esp+10h] [ebp-108h] BYREF

  FS_BuildOSPath_Internal(*(const char **)(fs_homepath + 8), fs_gamedir, a1,
                          __dst, 0);
  result = FS_FileOpen(__dst, "rb");
  if (result) {
    FS_FileClose(result);
    return (FILE *)1;
  }
  return result;
}

char *__cdecl FS_ShortOSFilePath(const char *a1) {
  searchpath_s *v1; // esi
  const char *dir;  // eax
  const char *v3;   // ebx
  FILE *v4;         // eax
  int32_t language; // ebx
  char __dst[280];  // [esp+10h] [ebp-118h] BYREF

  v1 = fs_searchpaths;
  if (fs_searchpaths) {
    while (1) {
      if (!v1->bLocalized)
        goto LABEL_6;
      if (*(_BYTE *)(fs_ignoreLocalized + 8))
        goto LABEL_4;
      language = v1->language;
      if (language == SEH_GetCurrentLanguage()) {
      LABEL_6:
        dir = (const char *)v1->dir;
        if (dir) {
          v3 = dir + 256;
          FS_BuildOSPath_Internal(dir, dir + 256, a1, __dst, 0);
          v4 = FS_FileOpen(__dst, "rb");
          if (v4) {
            FS_FileClose(v4);
            return va("%s/%s", v3, a1);
          }
        }
      LABEL_4:
        v1 = (searchpath_s *)v1->next;
        if (!v1)
          return 0;
      } else {
        v1 = (searchpath_s *)v1->next;
        if (!v1)
          return 0;
      }
    }
  }
  return 0;
}

int __cdecl FS_GetFileOsPath(const char *a1, char *__dst) {
  searchpath_s *v3; // esi
  FILE *v4;         // eax
  int32_t language; // ebx
  char v6[280];     // [esp+10h] [ebp-118h] BYREF

  if (!(unsigned __int8)FS_SanitizeFilename((int)a1, (int)v6))
    return -1;
  v3 = fs_searchpaths;
  if (!fs_searchpaths)
    return -1;
  while (1) {
    if (!v3->bLocalized ||
        !*(_BYTE *)(fs_ignoreLocalized + 8) &&
            (language = v3->language, language == SEH_GetCurrentLanguage())) {
      if (!v3->pack) {
        FS_BuildOSPath_Internal((const char *)v3->dir,
                                (const char *)(v3->dir + 256), v6, __dst, 0);
        v4 = FS_FileOpen(__dst, "rb");
        if (v4)
          break;
      }
    }
    v3 = (searchpath_s *)v3->next;
    if (!v3)
      return -1;
  }
  FS_FileClose(v4);
  return 0;
}

void __cdecl FS_DisplayPath(int a1) {
  DvarValue CurrentLanguage; // eax
  const char *LanguageName;  // eax
  searchpath_s *v3;          // esi
  int32_t pack;              // edx
  int v5;                    // edi
  int v6;                    // ecx
  int *v7;                   // edx
  int v8;                    // eax
  int v9;                    // ebx
  FILE **v10;                // esi
  const char *v11;           // edi
  const char *v12;           // eax
  const char *v13;           // eax
  int32_t language;          // ebx

  CurrentLanguage = SEH_GetCurrentLanguage();
  LanguageName = (const char *)SEH_GetLanguageName(CurrentLanguage.integer);
  Com_Printf("Current language: %s\n", LanguageName);
  if (*(_BYTE *)(fs_ignoreLocalized + 8))
    Com_Printf("    localized assets are being ignored\n");
  Com_Printf("Current search path:\n");
  v3 = fs_searchpaths;
  if (fs_searchpaths) {
    while (1) {
      while (1) {
        if (!a1 || !v3->bLocalized ||
            !*(_BYTE *)(fs_ignoreLocalized + 8) &&
                (language = v3->language,
                 language == SEH_GetCurrentLanguage())) {
          pack = v3->pack;
          if (!pack) {
            Com_Printf("%s/%s\n", (const char *)v3->dir,
                       (const char *)(v3->dir + 256));
            if (v3->bLocalized) {
              v13 = (const char *)SEH_GetLanguageName(v3->language);
              Com_Printf("    localized assets game folder for %s\n", v13);
            }
            goto LABEL_7;
          }
          Com_Printf("%s (%i files)\n", (const char *)pack,
                     *(_DWORD *)(pack + 780));
          if (v3->bLocalized) {
            v12 = (const char *)SEH_GetLanguageName(v3->language);
            Com_Printf("    localized assets iwd file for %s\n", v12);
          }
          if (fs_numServerIwds)
            break;
        }
      LABEL_7:
        v3 = (searchpath_s *)v3->next;
        if (!v3)
          goto LABEL_19;
      }
      if (fs_numServerIwds <= 0)
        goto LABEL_24;
      v5 = *(_DWORD *)(v3->pack + 772);
      if (v5 != fs_serverIwds)
        break;
    LABEL_18:
      Com_Printf("    on the pure list\n");
      v3 = (searchpath_s *)v3->next;
      if (!v3)
        goto LABEL_19;
    }
    v6 = 0;
    v7 = &fs_serverIwds;
    while (fs_numServerIwds != ++v6) {
      v8 = v7[1];
      ++v7;
      if (v5 == v8)
        goto LABEL_18;
    }
  LABEL_24:
    Com_Printf("    not on the pure list\n");
    goto LABEL_7;
  }
LABEL_19:
  Com_Printf("\nFile Handles:\n");
  v9 = 1;
  v10 = &fsh;
  v11 = (const char *)&unk_FF8378;
  do {
    if (v10[71])
      Com_Printf("handle %i: %s\n", v9, v11);
    ++v9;
    v11 += 284;
    v10 += 71;
  } while (v9 != 74);
}

void FS_Path_f(void) { FS_DisplayPath(1); }

void FS_FullPath_f(void) { FS_DisplayPath(0); }

_DWORD *__cdecl FS_ListFilteredFiles(searchpath_s *a1, const char *a2,
                                     const char *a3, char *a4,
                                     FsListBehavior_e a5, int *a6) {
  const gentity_s *v6; // eax
  unsigned int v8;     // ecx
  char v9;             // al
  unsigned int v10;    // kr04_4
  char v11;            // al
  int v12;             // ebx
  int v13;             // esi
  int v14;             // edi
  int v15;             // eax
  searchpath_s *i;     // edx
  searchpath_s *v17;   // edx
  int v18;             // esi
  int v19;             // ecx
  int *v20;            // edx
  int v21;             // eax
  int32_t v22;         // edx
  char *v23;           // esi
  int j;               // ebx
  char *v25;           // eax
  char v26;            // al
  int v27;             // edi
  int v28;             // ebx
  int v29;             // eax
  int v30;             // eax
  int v31;             // ebx
  int v32;             // edx
  int32_t language;    // ebx
  const char *dir;     // ebx
  char **v35;          // eax
  int v36;             // edi
  char *v37;           // esi
  int v38;             // ebx
  _DWORD *v39;         // ecx
  int v40;             // eax
  int k;               // edx
  signed int v42;      // edx
  int v43;             // ebx
  int32_t pack;        // [esp+2Ch] [ebp-435Ch]
  int v45;             // [esp+30h] [ebp-4358h]
  searchpath_s *next;  // [esp+34h] [ebp-4354h]
  int v47;             // [esp+38h] [ebp-4350h]
  int v48;             // [esp+3Ch] [ebp-434Ch]
  int v49;             // [esp+40h] [ebp-4348h]
  int v50;             // [esp+40h] [ebp-4348h]
  bool v51;            // [esp+47h] [ebp-4341h]
  signed int v52;      // [esp+48h] [ebp-4340h]
  int v53;             // [esp+4Ch] [ebp-433Ch]
  char **v54;          // [esp+50h] [ebp-4338h]
  int v55;             // [esp+54h] [ebp-4334h]
  int v56;             // [esp+58h] [ebp-4330h]
  int v57;             // [esp+5Ch] [ebp-432Ch]
  _DWORD v58[4096];    // [esp+6Ch] [ebp-431Ch]
  char v59[256];       // [esp+406Ch] [ebp-31Ch] BYREF
  char __src[256];     // [esp+416Ch] [ebp-21Ch] BYREF
  char __dst[256];     // [esp+426Ch] [ebp-11Ch] BYREF
  int v62[7];          // [esp+436Ch] [ebp-1Ch] BYREF
  char *v63;           // [esp+4398h] [ebp+10h]

  if (!a2) {
    *a6 = 0;
    return 0;
  }
  v6 = &inData;
  if (a3)
    v6 = (const gentity_s *)a3;
  v63 = (char *)v6;
  if (!(unsigned __int8)FS_SanitizeFilename((int)a2, (int)__src)) {
    *a6 = 0;
    return 0;
  }
  v51 = I_stricmp(v63, "/") == 0;
  v8 = strlen(__src) + 1;
  v48 = v8 - 1;
  if (v8 != 1) {
    v9 = __src[v8 - 2];
    if (v9 == 92 || v9 == 47)
      v48 = v8 - 2;
  }
  v10 = strlen(v63) + 1;
  v52 = v10 - 1;
  __dst[0] = 0;
  v11 = __src[0];
  if (__src[0]) {
    v49 = 0;
    v32 = 0;
    v12 = 0;
    do {
      while (v11 != 47 && v11 != 92) {
        v11 = __src[++v12];
        if (!v11)
          goto LABEL_68;
      }
      ++v49;
      v32 = v12++;
      v11 = __src[v12];
    } while (v11);
  LABEL_68:
    v13 = v32;
    v14 = v32 + 1;
  } else {
    v49 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 1;
  }
  strcpy(__dst, __src);
  __dst[v13] = 0;
  v15 = v49 - 1;
  if (v14 != v12)
    v15 = v49;
  v50 = v15 - ((__src[0] == 0) - 1);
  if (a1) {
    next = a1;
    v45 = 0;
    for (i = a1;; i = (searchpath_s *)v17->next) {
      if (i->bLocalized) {
        if (*(_BYTE *)(fs_ignoreLocalized + 8))
          goto LABEL_17;
        language = i->language;
        if (language != SEH_GetCurrentLanguage())
          goto LABEL_17;
        i = next;
      }
      pack = i->pack;
      if (pack)
        break;
      dir = (const char *)next->dir;
      if (dir) {
        if ((fs_restrict->current.enabled || fs_numServerIwds) &&
            a5 == FS_LIST_PURE_ONLY)
          goto LABEL_17;
        FS_BuildOSPath_Internal(dir, dir + 256, __src, v59, 0);
        v35 = (char **)Sys_ListFiles(v59, v63, a4, v62, v51);
        v54 = v35;
        if (v62[0] > 0) {
          v36 = 0;
          do {
            v37 = v54[v36];
            if (v45 != 4095) {
              if (v45 <= 0) {
              LABEL_93:
                v58[v45++] = CopyStringInternal(v37);
              } else {
                v38 = 0;
                while (I_stricmp(v37, (char *)v58[v38])) {
                  if (++v38 == v45)
                    goto LABEL_93;
                }
              }
            }
            ++v36;
          } while (v62[0] > v36);
          v35 = v54;
        }
        Sys_FreeFileList(v35);
        v17 = next;
      } else {
        v17 = next;
      }
    LABEL_18:
      next = (searchpath_s *)v17->next;
      if (!v17->next)
        goto LABEL_80;
    }
    if (next->bLocalized || !fs_numServerIwds) {
    LABEL_29:
      v22 = pack;
    } else {
      if (fs_numServerIwds <= 0) {
      LABEL_17:
        v17 = next;
        goto LABEL_18;
      }
      v18 = *(_DWORD *)(pack + 772);
      if (v18 != fs_serverIwds) {
        v19 = 0;
        v20 = &fs_serverIwds;
        while (fs_numServerIwds != ++v19) {
          v21 = v20[1];
          ++v20;
          if (v21 == v18)
            goto LABEL_29;
        }
        goto LABEL_17;
      }
      v22 = i->pack;
    }
    if (*(int *)(v22 + 780) > 0) {
      v57 = *(_DWORD *)(v22 + 796);
      v47 = 0;
      v23 = *(char **)(v57 + 4);
      if (a4) {
      LABEL_32:
        if (!(unsigned __int8)Com_FilterPath(a4, v23, 0))
          goto LABEL_40;
        if (v45 == 4095) {
        LABEL_76:
          v45 = 4095;
          goto LABEL_40;
        }
        if (v45 > 0) {
          for (j = 0; j != v45; ++j) {
            if (!I_stricmp(v23, (char *)v58[j]))
              goto LABEL_40;
          }
        }
      LABEL_38:
        v25 = CopyStringInternal(v23);
      LABEL_39:
        v58[v45++] = v25;
        goto LABEL_40;
      }
      while (2) {
        __dst[0] = 0;
        v26 = *v23;
        if (*v23) {
          v28 = 0;
          v53 = 0;
          v27 = 0;
          do {
            while (v26 != 47 && v26 != 92) {
              v26 = v23[++v28];
              if (!v26)
                goto LABEL_75;
            }
            ++v27;
            v53 = v28++;
            v26 = v23[v28];
          } while (v26);
        LABEL_75:
          v55 = v53;
          v56 = v53 + 1;
        } else {
          v27 = 0;
          v53 = 0;
          v28 = 0;
          v55 = 0;
          v56 = 1;
        }
        strcpy(__dst, v23);
        __dst[v55] = 0;
        if (v56 == v28)
          --v27;
        if (v27 == v50 && v48 <= v53) {
          if (v48 <= 0) {
            v29 = v48;
          LABEL_51:
            if (!I_strnicmp(v23, __src, v29)) {
              if (v51) {
                if (v23[strlen(v23) - 1] != 47)
                  goto LABEL_40;
              } else if (v10 != 1) {
                v42 = strlen(v23);
                if (v52 >= v42 || v23[v42 - v10] != 46 ||
                    I_stricmp(&v23[v42 - v52], v63))
                  goto LABEL_40;
              }
              if (v48)
                v30 = v48 + 1;
              else
                v30 = 0;
              if (v51) {
                strcpy(v59, &v23[v30]);
                *((_BYTE *)&v58[4095] + strlen(v59) + 3) = 0;
                if (v45 == 4095)
                  goto LABEL_76;
                if (v45 <= 0) {
                LABEL_119:
                  v25 = CopyStringInternal(v59);
                  goto LABEL_39;
                }
                v43 = 0;
                while (I_stricmp(v59, (char *)v58[v43])) {
                  if (v45 == ++v43)
                    goto LABEL_119;
                }
              } else {
                v23 += v30;
                if (v45 == 4095)
                  goto LABEL_76;
                if (v45 <= 0)
                  goto LABEL_38;
                v31 = 0;
                while (I_stricmp(v23, (char *)v58[v31])) {
                  if (v45 == ++v31)
                    goto LABEL_38;
                }
              }
            }
          } else if (v23[v48] == 47) {
            v29 = v48;
            goto LABEL_51;
          }
        }
      LABEL_40:
        ++v47;
        v57 += 12;
        if (v47 >= *(_DWORD *)(pack + 780))
          goto LABEL_17;
        v23 = *(char **)(v57 + 4);
        if (a4)
          goto LABEL_32;
        continue;
      }
    }
    goto LABEL_17;
  }
  v45 = 0;
LABEL_80:
  *a6 = v45;
  if (!v45)
    return 0;
  v39 = Z_MallocInternal(4 * v45 + 4);
  if (v45 > 0) {
    for (k = 0; k != v45; ++k)
      v39[k] = v58[k];
    v40 = k;
  } else {
    v40 = 0;
  }
  v39[v40] = 0;
  return v39;
}

_DWORD *__cdecl FS_ListFiles(char *a1, char *a2, FsListBehavior_e a3, int *a4) {
  return FS_ListFilteredFiles(fs_searchpaths, a1, a2, 0, a3, a4);
}

int __cdecl FS_GetFileList(char *a1, char *a2, FsListBehavior_e a3, char *__dst,
                           int a5) {
  char *v5;         // esi
  void *v7;         // eax
  void **v8;        // edi
  void **v9;        // ecx
  unsigned int v10; // ebx
  int v11;          // [esp+24h] [ebp-34h]
  int v12;          // [esp+28h] [ebp-30h]
  void **v13;       // [esp+2Ch] [ebp-2Ch]
  int v14[7];       // [esp+3Ch] [ebp-1Ch] BYREF

  v5 = __dst;
  *__dst = 0;
  v14[0] = 0;
  if (!I_stricmp(a1, "$modlist"))
    return FS_GetModList(__dst, a5);
  v13 = (void **)FS_ListFilteredFiles(fs_searchpaths, a1, a2, 0, a3, v14);
  if (v14[0] > 0) {
    v12 = 0;
    v11 = 0;
    do {
      v10 = strlen((const char *)v13[v11]) + 1;
      v12 += v10;
      if (v12 + 1 >= a5) {
        v14[0] = v11;
        goto LABEL_4;
      }
      strcpy(v5, (const char *)v13[v11]);
      v5 += v10;
      ++v11;
    } while (v11 < v14[0]);
    if (v13)
      goto LABEL_5;
  } else {
  LABEL_4:
    if (v13) {
    LABEL_5:
      v7 = *v13;
      if (*v13) {
        v8 = v13;
        do {
          Z_FreeInternal(v7);
          v7 = v8[1];
          ++v8;
        } while (v7);
        v9 = v13;
      } else {
        v9 = v13;
      }
      Z_FreeInternal(v9);
    }
  }
  return v14[0];
}

void __cdecl FS_SortFileList(const char **a1, int a2) {
  _DWORD *v2;     // eax
  int i;          // edx
  int v4;         // eax
  int v5;         // ecx
  char *v6;       // ecx
  const char *v7; // edi
  bool v8;        // cc
  int v9;         // esi
  int v10;        // ebx
  _DWORD *v11;    // edx
  int v12;        // ecx
  int v13;        // [esp+1Ch] [ebp-2Ch]
  int v14;        // [esp+1Ch] [ebp-2Ch]
  int v15;        // [esp+20h] [ebp-28h]
  _DWORD *__src;  // [esp+24h] [ebp-24h]
  char *v17;      // [esp+28h] [ebp-20h]
  _DWORD *v18;    // [esp+2Ch] [ebp-1Ch]

  v2 = Z_MallocInternal(4 * a2 + 4);
  __src = v2;
  *v2 = 0;
  if (a2 > 0) {
    v18 = v2;
    v13 = 0;
    v15 = 0;
    for (i = 0;; i = v15) {
      __src[v13] = a1[i];
      ++v15;
      ++v18;
      v4 = v15;
      if (a2 == v15)
        break;
      while (1) {
        v14 = 0;
        if (v4 > 0)
          break;
      LABEL_24:
        __src[v14] = a1[v15++];
        ++v18;
        v4 = v15;
        if (a2 == v15)
          goto LABEL_25;
      }
      v5 = 0;
      while (2) {
        v6 = (char *)__src[v5];
        v7 = a1[v15];
        while (1) {
          v9 = *v7++;
          v10 = *v6;
          v17 = v6 + 1;
          if (I_islower(v9))
            v9 -= 32;
          if (I_islower(v10))
            v10 -= 32;
          if (v9 == 92 || v9 == 58) {
            v9 = 47;
            if (v10 == 92)
              goto LABEL_20;
          } else if (v10 == 92) {
            goto LABEL_20;
          }
          if (v10 != 58) {
            v8 = v9 <= v10;
            if (v9 < v10)
              goto LABEL_21;
            goto LABEL_11;
          }
        LABEL_20:
          v8 = v9 <= 47;
          if (v9 < 47) {
          LABEL_21:
            if (v15 > v14) {
              v11 = v18 - 1;
              v12 = v15;
              do {
                v11[1] = *v11;
                --v12;
                --v11;
              } while (v12 > v14);
            }
            goto LABEL_24;
          }
        LABEL_11:
          if (!v8 || !v9)
            break;
          v6 = v17;
        }
        if (v15 != ++v14) {
          v5 = v14;
          continue;
        }
        break;
      }
      v13 = v15;
    }
  }
LABEL_25:
  Com_Memcpy(a1, __src, 4 * a2);
  Z_FreeInternal(__src);
}

int __cdecl iwdsort(char **a1, char **a2) {
  const char *v2;  // eax
  char *v3;        // esi
  bool v4;         // cc
  int v5;          // ebx
  int v6;          // edi
  int v8;          // ebx
  int v9;          // ebx
  char *v10;       // ebx
  int v11;         // esi
  char *v13;       // edi
  char v14;        // al
  int v15;         // esi
  char *v17;       // edi
  char v18;        // al
  const char *v19; // [esp+10h] [ebp-28h]
  char *v20;       // [esp+14h] [ebp-24h]
  char *v21;       // [esp+18h] [ebp-20h]
  char *v22;       // [esp+1Ch] [ebp-1Ch]

  v19 = *a1;
  v20 = *a2;
  if (I_strncmp(*a1, "          ", 10) || I_strncmp(v20, "          ", 10))
    goto LABEL_3;
  v8 = IwdFileLanguage(char const *)::iString ^ 1;
  IwdFileLanguage(char const *)::iString ^= 1u;
  if (strlen(v19) > 9) {
    memset(&IwdFileLanguage(char const *)::szIwdLanguageName[64 * v8], 0,
           0x40u);
    v11 = 0;
    while (1) {
      v13 = (char *)&v19[v11 + 10];
      v14 = *v13;
      if (!*v13)
        break;
      if (!((v14 & 0xFFFFFF80) != 0
                ? __maskrune(v14, 256) != 0
                : (_DefaultRuneLocale.__runetype[v14] >> 8) & 1))
        break;
      v8 = IwdFileLanguage(char const *)::iString;
      IwdFileLanguage(char const *)::szIwdLanguageName
          [64 * IwdFileLanguage(char const *)::iString + v11++] = *v13;
      if (v11 == 54)
        goto LABEL_22;
    }
    v8 = IwdFileLanguage(char const *)::iString;
  } else {
    IwdFileLanguage(char const *)::szIwdLanguageName[64 * v8] = 0;
  }
LABEL_22:
  v21 = (char *)((v8 << 6) + 3395104);
  v9 = v8 ^ 1;
  IwdFileLanguage(char const *)::iString = v9;
  if (strlen(v20) > 9) {
    memset(&IwdFileLanguage(char const *)::szIwdLanguageName[64 * v9], 0,
           0x40u);
    v15 = 0;
    while (1) {
      v17 = &v20[v15 + 10];
      v18 = *v17;
      if (!*v17)
        break;
      if (!((v18 & 0xFFFFFF80) != 0
                ? __maskrune(v18, 256) != 0
                : (_DefaultRuneLocale.__runetype[v18] >> 8) & 1))
        break;
      v9 = IwdFileLanguage(char const *)::iString;
      IwdFileLanguage(char const *)::szIwdLanguageName
          [64 * IwdFileLanguage(char const *)::iString + v15++] = *v17;
      if (v15 == 54)
        goto LABEL_24;
    }
    v9 = IwdFileLanguage(char const *)::iString;
  } else {
    IwdFileLanguage(char const *)::szIwdLanguageName[64 * v9] = 0;
  }
LABEL_24:
  v10 = (char *)((v9 << 6) + 3395104);
  if (I_stricmp(v21, "english")) {
    if (!I_stricmp(v10, "english"))
      return 1;
  LABEL_3:
    v2 = v19;
    v3 = v20;
    while (1) {
      v5 = *v2;
      v22 = (char *)(v2 + 1);
      v6 = *v3++;
      if (I_islower(v5))
        v5 -= 32;
      if (I_islower(v6))
        v6 -= 32;
      if (v5 == 92 || v5 == 58) {
        v5 = 47;
        if (v6 == 92)
          goto LABEL_17;
      } else if (v6 == 92) {
        goto LABEL_17;
      }
      if (v6 != 58) {
        v4 = v5 <= v6;
        if (v5 < v6)
          return -1;
        goto LABEL_8;
      }
    LABEL_17:
      v4 = v5 <= 47;
      if (v5 < 47)
        return -1;
    LABEL_8:
      if (!v4)
        return 1;
      if (!v5)
        return 0;
      v2 = v22;
    }
  }
  if (!I_stricmp(v10, "english"))
    goto LABEL_3;
  return -1;
}

void __cdecl FS_AddIwdFilesForGameDirectory(const char *a1, char *__src) {
  signed __int32 v2;        // eax
  size_t v3;                // edx
  char *i;                  // ecx
  signed __int32 v5;        // eax
  int v6;                   // ebx
  int v7;                   // edx
  unsigned int v8;          // edi
  int v9;                   // eax
  char *v10;                // esi
  unsigned int v11;         // edx
  unsigned int v12;         // ecx
  size_t v13;               // ebx
  searchpath_s *v14;        // edx
  searchpath_s **v15;       // ecx
  searchpath_s *v16;        // eax
  int v17;                  // esi
  char *v18;                // edi
  char v19;                 // al
  int v20;                  // ebx
  int v21;                  // edx
  char v22;                 // al
  int v23;                  // ebx
  int v24;                  // eax
  int v25;                  // edx
  unsigned int v26;         // ebx
  int v27;                  // esi
  int v28;                  // ebx
  char *v29;                // esi
  signed __int32 v30;       // eax
  char *v31;                // eax
  unsigned int j;           // ebx
  const char *LanguageName; // eax
  char *v34;                // [esp+20h] [ebp-12B8h]
  int v35;                  // [esp+24h] [ebp-12B4h]
  char **v36;               // [esp+28h] [ebp-12B0h]
  const char *v37;          // [esp+2Ch] [ebp-12ACh]
  char *v38;                // [esp+30h] [ebp-12A8h]
  _DWORD *v39;              // [esp+34h] [ebp-12A4h]
  _DWORD *v40;              // [esp+38h] [ebp-12A0h]
  int v41;                  // [esp+3Ch] [ebp-129Ch]
  unsigned __int8 *v42;     // [esp+40h] [ebp-1298h]
  char *__dst;              // [esp+44h] [ebp-1294h]
  int v44;                  // [esp+48h] [ebp-1290h]
  int v45;                  // [esp+4Ch] [ebp-128Ch]
  _DWORD *v46;              // [esp+50h] [ebp-1288h]
  int v47;                  // [esp+54h] [ebp-1284h]
  unsigned int v48;         // [esp+58h] [ebp-1280h]
  int v49;                  // [esp+5Ch] [ebp-127Ch]
  char __base[4];           // [esp+60h] [ebp-1278h] BYREF
  char v51[4092];           // [esp+64h] [ebp-1274h] BYREF
  char v52[256];            // [esp+1060h] [ebp-278h] BYREF
  char v53[256];            // [esp+1160h] [ebp-178h] BYREF
  _DWORD v54[20];           // [esp+1260h] [ebp-78h] BYREF
  unsigned int v55;         // [esp+12B0h] [ebp-28h] BYREF
  int v56;                  // [esp+12B8h] [ebp-20h] BYREF
  size_t __nel[7];          // [esp+12BCh] [ebp-1Ch] BYREF

  FS_BuildOSPath_Internal(a1, __src, (const char *)&inData, v53, 0);
  v52[strlen(v53) + 255] = 0;
  v36 = (char **)Sys_ListFiles(v53, "iwd", 0, (int *)__nel, 0);
  v2 = __nel[0];
  if ((int)__nel[0] > 1024) {
    Com_Printf("WARNING: Exceeded max number of iwd files in %s/%s (%1/%1)\n",
               a1, __src, __nel[0], 1024);
    __nel[0] = 1024;
    v2 = 1024;
  }
  v3 = v2;
  if (v2 > 0) {
    v28 = 1;
    v29 = v51;
    do {
      v31 = v36[v28 - 1];
      *((_DWORD *)v29 - 1) = v31;
      if (!I_strncmp(v31, "localized_", 10))
        memset(*((void **)v29 - 1), 32, 10);
      v30 = v28;
      v3 = __nel[0];
      ++v28;
      v29 += 4;
    } while ((int)__nel[0] > v30);
  }
  qsort(__base, v3, 4u, (int(__cdecl *)(const void *, const void *))iwdsort);
  if ((int)__nel[0] > 0) {
    v47 = 1;
    v34 = v51;
    for (i = v51;; i = v34) {
      if (I_strncmp(*((char **)i - 1), "          ", 10)) {
        v56 = 0;
        v35 = 0;
      } else {
        qmemcpy(*((void **)v34 - 1), "localized_", 10);
        v37 = (const char *)*((_DWORD *)v34 - 1);
        v6 = IwdFileLanguage(char const *)::iString ^ 1;
        IwdFileLanguage(char const *)::iString ^= 1u;
        if (strlen(v37) > 9) {
          memset(&IwdFileLanguage(char const *)::szIwdLanguageName[64 * v6], 0,
                 0x40u);
          v17 = 0;
          while (1) {
            v18 = (char *)&v37[v17 + 10];
            v19 = *v18;
            if (!*v18)
              break;
            if ((v19 & 0xFFFFFF80) != 0) {
              if (!__maskrune(v19, 256))
                break;
            } else if (((_DefaultRuneLocale.__runetype[v19] >> 8) & 1) == 0) {
              break;
            }
            v6 = IwdFileLanguage(char const *)::iString;
            IwdFileLanguage(char const *)::szIwdLanguageName
                [64 * IwdFileLanguage(char const *)::iString + v17++] = *v18;
            if (v17 == 54)
              goto LABEL_14;
          }
          v6 = IwdFileLanguage(char const *)::iString;
        } else {
          IwdFileLanguage(char const *)::szIwdLanguageName[64 * v6] = 0;
        }
      LABEL_14:
        if (!IwdFileLanguage(char const *)::szIwdLanguageName[64 * v6]) {
          Com_Printf("WARNING: Localized assets iwd file %s/%s/%s has invalid "
                     "name (no language specified). Proper naming conventi"
                     "on is: localized_[language]_iwd#.iwd\n",
                     a1, __src, *((const char **)v34 - 1));
          goto LABEL_9;
        }
        if (!SEH_GetLanguageIndexForName(
                &IwdFileLanguage(char const *)::szIwdLanguageName[64 * v6],
                &v56)) {
          Com_Printf("WARNING: Localized assets iwd file %s/%s/%s has invalid "
                     "name (bad language name specified). Proper naming co"
                     "nvention is: localized_[language]_iwd#.iwd\n",
                     a1, __src, *((const char **)v34 - 1));
          if (!FS_AddIwdFilesForGameDirectory(char const *,
                                              char const *)::bLanguagesListed) {
            Com_Printf("Supported languages are:\n");
            for (j = 0; j != 14; ++j) {
              LanguageName = (const char *)SEH_GetLanguageName(j);
              Com_Printf("    %s\n", LanguageName);
            }
            FS_AddIwdFilesForGameDirectory(char const *,
                                           char const *)::bLanguagesListed = 1;
          }
          goto LABEL_9;
        }
        v35 = 1;
      }
      FS_BuildOSPath_Internal(a1, __src, *((const char **)v34 - 1), v53, 0);
      v38 = (char *)*((_DWORD *)v34 - 1);
      v40 = unzOpen(v53);
      if (!unzGetGlobalInfo((int)v40, &v55)) {
        fs_packFiles += v55;
        unzGoToFirstFile(v40);
        if (v55) {
          v26 = 0;
          v27 = 0;
          do {
            if (unzGetCurrentFileInfo((int)v40, v54, (unsigned __int8 *)v52,
                                      (unz_file_info_s *)0x100, 0, 0, 0, 0))
              break;
            v27 += strlen(v52) + 1;
            unzGoToNextFile(v40);
            ++v26;
          } while (v55 > v26);
          v7 = v27;
        } else {
          v7 = 0;
        }
        v39 = Z_MallocInternal(v7 + 12 * v55);
        __dst = (char *)&v39[3 * v55];
        v42 = (unsigned __int8 *)Z_MallocInternal(4 * v55);
        v8 = 1;
        v9 = 11;
        do {
          if (v55 < v8)
            break;
          v8 *= 2;
          --v9;
        } while (v9);
        v10 = (char *)Z_MallocInternal(4 * v8 + 800);
        *((_DWORD *)v10 + 197) = v8;
        *((_DWORD *)v10 + 198) = v10 + 800;
        if (v8) {
          v11 = 0;
          do
            *(_DWORD *)(*((_DWORD *)v10 + 198) + 4 * v11++) = 0;
          while (*((_DWORD *)v10 + 197) > v11);
        }
        I_strncpyz(v10, v53, 256);
        I_strncpyz(v10 + 256, v38, 256);
        v12 = strlen(v10 + 256) + 1;
        if (v12 - 1 > 4 && !I_stricmp(&v10[v12 + 251], ".iwd"))
          v10[strlen(v10 + 256) + 252] = 0;
        *((_DWORD *)v10 + 192) = v40;
        *((_DWORD *)v10 + 195) = v55;
        unzGoToFirstFile(v40);
        if (v55) {
          v46 = v39;
          v48 = 0;
          v41 = 0;
          do {
            if (unzGetCurrentFileInfo((int)v40, v54, (unsigned __int8 *)v52,
                                      (unz_file_info_s *)0x100, 0, 0, 0, 0))
              break;
            if (v54[7])
              *(_DWORD *)&v42[4 * v41++] = v54[5];
            I_strlwr(v52);
            v44 = *((_DWORD *)v10 + 197);
            v22 = v52[0];
            if (v52[0]) {
              v49 = 0;
              v23 = 119;
              while (1) {
                v24 = __tolower(v22);
                v25 = v24;
                if (v24 == 46)
                  break;
                if (v24 == 92)
                  v25 = 47;
                v49 += v23 * v25;
                v22 = v51[v23++ + 3974];
                if (!v22) {
                  v45 = v49 >> 10;
                  v20 = v49 >> 20;
                  goto LABEL_46;
                }
              }
              v45 = v49 >> 10;
              v20 = v49 >> 20;
            } else {
              v49 = 0;
              v45 = 0;
              v20 = 0;
            }
          LABEL_46:
            v46[1] = __dst;
            strcpy(__dst, v52);
            __dst += strlen(v52) + 1;
            unzGetCurrentFileInfoPosition((int)v40, v46);
            v21 = 4 * ((v44 - 1) & (v49 ^ v45 ^ v20));
            v46[2] = *(_DWORD *)(*((_DWORD *)v10 + 198) + v21);
            *(_DWORD *)(v21 + *((_DWORD *)v10 + 198)) = v46;
            unzGoToNextFile(v40);
            ++v48;
            v46 += 3;
          } while (v48 < v55);
          v13 = 4 * v41;
        } else {
          v13 = 0;
        }
        *((_DWORD *)v10 + 193) = Com_BlockChecksum(v42, v13);
        *((_DWORD *)v10 + 194) =
            Com_BlockChecksumKey(v42, v13, *(_DWORD *)&fs_checksumFeed);
        Z_FreeInternal(v42);
        *((_DWORD *)v10 + 199) = v39;
        strcpy(v10 + 512, __src);
        v14 = (searchpath_s *)Z_MallocInternal(0x14u);
        v14->pack = (int32_t)v10;
        v14->bLocalized = v35;
        v14->language = v56;
        if (v35 && (v16 = fs_searchpaths) != 0 && !fs_searchpaths->bLocalized) {
          while (1) {
            v15 = (searchpath_s **)v16;
            v16 = (searchpath_s *)v16->next;
            if (!v16)
              break;
            if (v16->bLocalized) {
              v14->next = (int32_t)*v15;
              *v15 = v14;
              goto LABEL_9;
            }
          }
        } else {
          v15 = &fs_searchpaths;
          v16 = fs_searchpaths;
        }
        v14->next = (int32_t)v16;
        *v15 = v14;
      }
    LABEL_9:
      v5 = v47++;
      v34 += 4;
      if (v5 >= (int)__nel[0])
        break;
    }
  }
  Sys_FreeFileList(v36);
}

void __usercall FS_AddGameDirectory(char *a1 @<eax>, char *a2 @<edx>,
                                    int32_t a3 @<ecx>, const char *a4) {
  const char *LanguageName; // eax
  searchpath_s *v8;         // edi
  char *dir;                // eax
  int32_t bLocalized;       // edx
  const char *v11;          // eax
  searchpath_s *v12;        // edi
  char *v13;                // eax
  searchpath_s *v14;        // eax
  searchpath_s **v15;       // edx
  _BYTE v16[2];             // [esp+1Eh] [ebp-15Ah]
  char __dst[256];          // [esp+20h] [ebp-158h] BYREF
  char __src[88];           // [esp+120h] [ebp-58h] BYREF

  if (a3) {
    LanguageName = (const char *)SEH_GetLanguageName((unsigned int)a4);
    Com_sprintf(__src, 0x40u, "%s/%s", a2, LanguageName);
  } else {
    I_strncpyz(__src, a2, 64);
  }
  v8 = fs_searchpaths;
  if (fs_searchpaths) {
    while (1) {
      dir = (char *)v8->dir;
      if (dir) {
        if (!I_stricmp(dir, a1) && !I_stricmp((char *)(v8->dir + 256), __src))
          break;
      }
      v8 = (searchpath_s *)v8->next;
      if (!v8)
        goto LABEL_16;
    }
    bLocalized = v8->bLocalized;
    if (a3 != bLocalized) {
      v11 = "localized";
      if (!bLocalized)
        v11 = "non-localized";
      Com_Printf("WARNING: game folder %s/%s added as both localized & "
                 "non-localized. Using folder as %s\n",
                 a1, __src, v11);
    }
    if (v8->bLocalized && a4 != (const char *)v8->language)
      Com_Printf("WARNING: game golder %s/%s re-added as localized folder with "
                 "different language\n",
                 a1, __src);
  } else {
  LABEL_16:
    if (a3) {
      FS_BuildOSPath_Internal(a1, __src, (const char *)&inData, __dst, 0);
      v16[strlen(__dst) + 1] = 0;
      if (!Sys_DirectoryHasContents(__dst))
        return;
    } else {
      I_strncpyz(fs_gamedir, __src, 256);
    }
    v12 = (searchpath_s *)Z_MallocInternal(0x14u);
    v13 = (char *)Z_MallocInternal(0x200u);
    v12->dir = (int32_t)v13;
    I_strncpyz(v13, a1, 256);
    I_strncpyz((char *)(v12->dir + 256), __src, 256);
    v12->bLocalized = a3;
    v12->language = (int32_t)a4;
    if (a3 && (v14 = fs_searchpaths) != 0 && !fs_searchpaths->bLocalized) {
      while (1) {
        v15 = (searchpath_s **)v14;
        v14 = (searchpath_s *)v14->next;
        if (!v14)
          break;
        if (v14->bLocalized) {
          v14 = *v15;
          break;
        }
      }
    } else {
      v15 = &fs_searchpaths;
      v14 = fs_searchpaths;
    }
    v12->next = (int32_t)v14;
    *v15 = v12;
    FS_AddIwdFilesForGameDirectory(a1, __src);
  }
}

void __cdecl FS_CopyFile(char *a1, char *__big) {
  FILE *v2;  // eax
  FILE *v3;  // ebx
  size_t v4; // edi
  char v5;   // al
  char *v6;  // ebx
  FILE *v7;  // eax
  FILE *v8;  // ebx
  char v9;   // [esp+8h] [ebp-30h]
  char v10;  // [esp+8h] [ebp-30h]
  void *v11; // [esp+1Ch] [ebp-1Ch]

  v2 = FS_FileOpen(a1, "rb");
  v3 = v2;
  if (v2) {
    FS_FileSeek(v2, 0, 2);
    v4 = ftell(v3);
    FS_FileSeek(v3, 0, 0);
    v11 = malloc(v4);
    if (v4 != FS_FileRead(v11, 1u, v4, v3))
      Com_Error(0, "\x15Short read in FS_CopyFile()\n", v9);
    FS_FileClose(v3);
    if (strstr(__big, "..") || strstr(__big, "::")) {
      Com_Printf("WARNING: refusing to create relative path \"%s\"\n", __big);
    } else {
      v5 = __big[1];
      if (v5) {
        v6 = __big + 1;
        do {
          if (v5 == 47) {
            *v6 = 0;
            Sys_Mkdir(__big);
            *v6 = 47;
          }
          v5 = *++v6;
        } while (v5);
      }
      v7 = FS_FileOpen(__big, "wb");
      v8 = v7;
      if (v7) {
        if (v4 != FS_FileWrite(v11, 1u, v4, v7))
          Com_Error(0, "\x15Short write in FS_CopyFile()\n", v10);
        FS_FileClose(v8);
      }
    }
    free(v11);
  }
}

int __cdecl FS_TouchFile(char *a1) {
  char *ExtensionSubString; // eax
  int result;               // eax
  int Internal;             // eax
  int v4[3];                // [esp+1Ch] [ebp-Ch] BYREF

  com_fileAccessed = 1;
  ExtensionSubString = (char *)Com_GetExtensionSubString(a1);
  if (!FS_PureIgnoresExtension(ExtensionSubString) ||
      (Internal = FS_FOpenFileRead_Internal(a1, v4, 0, 0, (int *)1),
       Internal == -2 || Internal == -1)) {
    FS_FOpenFileRead_Internal(a1, v4, 0, 0, 0);
  }
  result = v4[0];
  if (v4[0]) {
    FS_FCloseFile(v4[0]);
    return 1;
  }
  return result;
}

unsigned int __cdecl FS_ReadFile(char *a1, char **a2) {
  char *ExtensionSubString; // eax
  unsigned int Internal;    // esi
  int v4;                   // eax
  char *TempMemoryInternal; // ebx
  char *v7;                 // eax
  char v8;                  // [esp+8h] [ebp-30h]
  int v9[7];                // [esp+1Ch] [ebp-1Ch] BYREF

  if (a1 && *a1) {
    com_fileAccessed = 1;
    ExtensionSubString = (char *)Com_GetExtensionSubString(a1);
    if (!FS_PureIgnoresExtension(ExtensionSubString)) {
    LABEL_4:
      Internal = FS_FOpenFileRead_Internal(a1, v9, 0, 0, 0);
      goto LABEL_5;
    }
  } else {
    Com_Error(0, "\x15FS_ReadFile with empty name\n", v8);
    com_fileAccessed = 1;
    v7 = (char *)Com_GetExtensionSubString(a1);
    if (!FS_PureIgnoresExtension(v7))
      goto LABEL_4;
  }
  Internal = FS_FOpenFileRead_Internal(a1, v9, 0, 0, (int *)1);
  if (Internal == -2 || Internal == -1)
    goto LABEL_4;
LABEL_5:
  v4 = v9[0];
  if (v9[0]) {
    if (a2) {
      ++fs_loadStack;
      TempMemoryInternal =
          (char *)Hunk_AllocateTempMemoryInternal(Internal + 1);
      *a2 = TempMemoryInternal;
      FS_Read(TempMemoryInternal, Internal, v9[0]);
      TempMemoryInternal[Internal] = 0;
      v4 = v9[0];
    }
    FS_FCloseFile(v4);
  } else {
    if (a2)
      *a2 = 0;
    return -1;
  }
  return Internal;
}

void __cdecl FS_Startup(char *a1) {
  char *integer; // esi
  char *v2;      // esi
  char *v3;      // esi
  char *v4;      // esi
  char *v5;      // esi
  char *v6;      // esi
  char *v7;      // esi
  char *v8;      // edi
  int i11;       // ebx
  char *v10;     // esi
  char *v11;     // edi
  int i12;       // ebx
  char *v13;     // edx
  char *v14;     // edi
  char *v15;     // esi
  int i13;       // ebx
  char *v17;     // esi
  int v18;       // ebx
  char *i8;      // edx
  char *v20;     // esi
  int v21;       // ebx
  char *i9;      // edx
  char *v23;     // edx
  char *v24;     // esi
  int i10;       // ebx
  int i6;        // ebx
  char *v27;     // esi
  int i7;        // ebx
  int i1;        // ebx
  char *v30;     // esi
  int i2;        // ebx
  char *v32;     // esi
  int i3;        // ebx
  char *v34;     // esi
  int i4;        // ebx
  char *v36;     // esi
  int i5;        // ebx
  int jj;        // ebx
  char *v39;     // esi
  int kk;        // ebx
  char *v41;     // esi
  int mm;        // ebx
  char *v43;     // esi
  int nn;        // ebx
  int k;         // ebx
  char *v46;     // esi
  int m;         // ebx
  char *v48;     // esi
  int n;         // ebx
  char *v50;     // esi
  int ii;        // ebx
  int j;         // ebx
  int i;         // ebx
  char *v54;     // [esp+14h] [ebp-24h]
  char *v55;     // [esp+18h] [ebp-20h]
  char *v56;     // [esp+1Ch] [ebp-1Ch]

  Com_Printf("----- FS_Startup -----\n");
  FS_RegisterDvars();
  if (*(_BYTE *)(fs_useOldAssets + 8)) {
    integer = (char *)fs_basepath->current.integer;
    if (!*integer) {
      v2 = *(char **)(fs_homepath + 8);
      if (!*v2)
        goto LABEL_4;
      goto LABEL_79;
    }
    for (i = 13; i != -1; --i)
      FS_AddGameDirectory(integer, "tempcod", 1, (const char *)i);
    FS_AddGameDirectory(integer, "tempcod", 0, 0);
    v2 = *(char **)(fs_homepath + 8);
    if (*v2) {
    LABEL_79:
      for (j = 13; j != -1; --j)
        FS_AddGameDirectory(v2, "tempcod", 1, (const char *)j);
      FS_AddGameDirectory(v2, "tempcod", 0, 0);
    }
  }
LABEL_4:
  v3 = (char *)fs_basepath->current.integer;
  if (*v3) {
    for (k = 13; k != -1; --k)
      FS_AddGameDirectory(v3, "devraw_shared", 1, (const char *)k);
    FS_AddGameDirectory(v3, "devraw_shared", 0, 0);
    v46 = (char *)fs_basepath->current.integer;
    for (m = 13; m != -1; --m)
      FS_AddGameDirectory(v46, "devraw", 1, (const char *)m);
    FS_AddGameDirectory(v46, "devraw", 0, 0);
    v48 = (char *)fs_basepath->current.integer;
    for (n = 13; n != -1; --n)
      FS_AddGameDirectory(v48, "raw_shared", 1, (const char *)n);
    FS_AddGameDirectory(v48, "raw_shared", 0, 0);
    v50 = (char *)fs_basepath->current.integer;
    for (ii = 13; ii != -1; --ii)
      FS_AddGameDirectory(v50, "raw", 1, (const char *)ii);
    FS_AddGameDirectory(v50, "raw", 0, 0);
  }
  v4 = *(char **)(fs_homepath + 8);
  if (*v4) {
    for (jj = 13; jj != -1; --jj)
      FS_AddGameDirectory(v4, "devraw_shared", 1, (const char *)jj);
    FS_AddGameDirectory(v4, "devraw_shared", 0, 0);
    v39 = *(char **)(fs_homepath + 8);
    for (kk = 13; kk != -1; --kk)
      FS_AddGameDirectory(v39, "devraw", 1, (const char *)kk);
    FS_AddGameDirectory(v39, "devraw", 0, 0);
    v41 = *(char **)(fs_homepath + 8);
    for (mm = 13; mm != -1; --mm)
      FS_AddGameDirectory(v41, "raw_shared", 1, (const char *)mm);
    FS_AddGameDirectory(v41, "raw_shared", 0, 0);
    v43 = *(char **)(fs_homepath + 8);
    for (nn = 13; nn != -1; --nn)
      FS_AddGameDirectory(v43, "raw", 1, (const char *)nn);
    FS_AddGameDirectory(v43, "raw", 0, 0);
  }
  v5 = *(char **)(fs_cdpath + 8);
  if (*v5) {
    for (i1 = 13; i1 != -1; --i1)
      FS_AddGameDirectory(v5, "devraw_shared", 1, (const char *)i1);
    FS_AddGameDirectory(v5, "devraw_shared", 0, 0);
    v30 = *(char **)(fs_cdpath + 8);
    for (i2 = 13; i2 != -1; --i2)
      FS_AddGameDirectory(v30, "devraw", 1, (const char *)i2);
    FS_AddGameDirectory(v30, "devraw", 0, 0);
    v32 = *(char **)(fs_cdpath + 8);
    for (i3 = 13; i3 != -1; --i3)
      FS_AddGameDirectory(v32, "raw_shared", 1, (const char *)i3);
    FS_AddGameDirectory(v32, "raw_shared", 0, 0);
    v34 = *(char **)(fs_cdpath + 8);
    for (i4 = 13; i4 != -1; --i4)
      FS_AddGameDirectory(v34, "raw", 1, (const char *)i4);
    FS_AddGameDirectory(v34, "raw", 0, 0);
    v36 = *(char **)(fs_cdpath + 8);
    for (i5 = 13; i5 != -1; --i5)
      FS_AddGameDirectory(v36, a1, 1, (const char *)i5);
    FS_AddGameDirectory(v36, a1, 0, 0);
  }
  v6 = (char *)fs_basepath->current.integer;
  if (*v6) {
    for (i6 = 13; i6 != -1; --i6)
      FS_AddGameDirectory(v6, a1, 1, (const char *)i6);
    FS_AddGameDirectory(v6, a1, 0, 0);
    if (*(_BYTE *)fs_basepath->current.integer) {
      if (I_stricmp(*(char **)(fs_homepath + 8),
                    (char *)fs_basepath->current.integer)) {
        v27 = *(char **)(fs_homepath + 8);
        for (i7 = 13; i7 != -1; --i7)
          FS_AddGameDirectory(v27, a1, 1, (const char *)i7);
        FS_AddGameDirectory(v27, a1, 0, 0);
      }
    }
  }
  if (**(_BYTE **)(fs_basegame + 8) && !I_stricmp(a1, "main") &&
      I_stricmp(*(char **)(fs_basegame + 8), a1)) {
    v17 = *(char **)(fs_cdpath + 8);
    if (*v17) {
      v54 = *(char **)(fs_basegame + 8);
      v18 = 13;
      for (i8 = v54;; i8 = v54) {
        FS_AddGameDirectory(v17, i8, 1, (const char *)v18--);
        if (v18 == -1)
          break;
      }
      FS_AddGameDirectory(v17, v54, 0, 0);
    }
    v20 = (char *)fs_basepath->current.integer;
    if (*v20) {
      v55 = *(char **)(fs_basegame + 8);
      v21 = 13;
      for (i9 = v55;; i9 = v55) {
        FS_AddGameDirectory(v20, i9, 1, (const char *)v21--);
        if (v21 == -1)
          break;
      }
      FS_AddGameDirectory(v20, v55, 0, 0);
    }
    v23 = *(char **)(fs_homepath + 8);
    if (*v23 && I_stricmp(v23, (char *)fs_basepath->current.integer)) {
      v56 = *(char **)(fs_basegame + 8);
      v24 = *(char **)(fs_homepath + 8);
      for (i10 = 13; i10 != -1; --i10)
        FS_AddGameDirectory(v24, v56, 1, (const char *)i10);
      FS_AddGameDirectory(v24, v56, 0, 0);
    }
  }
  if (*(_BYTE *)fs_gameDirVar->current.integer && !I_stricmp(a1, "main") &&
      I_stricmp((char *)fs_gameDirVar->current.integer, a1)) {
    v7 = *(char **)(fs_cdpath + 8);
    if (*v7) {
      v8 = (char *)fs_gameDirVar->current.integer;
      for (i11 = 13; i11 != -1; --i11)
        FS_AddGameDirectory(v7, v8, 1, (const char *)i11);
      FS_AddGameDirectory(v7, v8, 0, 0);
    }
    v10 = (char *)fs_basepath->current.integer;
    if (*v10) {
      v11 = (char *)fs_gameDirVar->current.integer;
      for (i12 = 13; i12 != -1; --i12)
        FS_AddGameDirectory(v10, v11, 1, (const char *)i12);
      FS_AddGameDirectory(v10, v11, 0, 0);
    }
    v13 = *(char **)(fs_homepath + 8);
    if (*v13 && I_stricmp(v13, (char *)fs_basepath->current.integer)) {
      v14 = (char *)fs_gameDirVar->current.integer;
      v15 = *(char **)(fs_homepath + 8);
      for (i13 = 13; i13 != -1; --i13)
        FS_AddGameDirectory(v15, v14, 1, (const char *)i13);
      FS_AddGameDirectory(v15, v14, 0, 0);
    }
  }
  Com_ReadCDKey();
  FS_AddCommands();
  FS_DisplayPath(1);
  Dvar_ClearModified(fs_gameDirVar);
  Com_Printf("----------------------\n");
  Com_Printf("%d files in iwd files\n", fs_packFiles);
}

size_t __cdecl FS_FileRead(void *a1, size_t a2, size_t a3, FILE *a4) {
  return fread(a1, a2, a3, a4);
}

size_t __cdecl FS_FileWrite(const void *a1, size_t a2, size_t a3, FILE *a4) {
  return fwrite(a1, a2, a3, a4);
}

FILE *__cdecl FS_FileOpen(const char *__filename, const char *__mode) {
  return fopen(__filename, __mode);
}

int __cdecl FS_FileClose(FILE *a1) { return fclose(a1); }

int __cdecl FS_FileSeek(FILE *a1, __int32 a2, int a3) {
  return fseek(a1, a2, a3);
}

void __cdecl Z_FreeInternal(void *a1) { free(a1); }

int __cdecl Z_VirtualFreeInternal(void *a1) {
  return VirtualFree(a1, 0, 0x8000);
}

int __cdecl Z_VirtualDecommitInternal(void *a1, int a2) {
  return VirtualFree(a1, a2, 0x4000);
}

void *__cdecl Z_MallocGarbageInternal(size_t __size) {
  void *result; // eax

  result = malloc(__size);
  if (!result)
    Sys_OutOfMemErrorInternal("/Users/kevin/Development/i5works/COD2/Project/"
                              "PC/universal/com_memory.cpp",
                              220);
  return result;
}

void *__cdecl Z_VirtualReserveInternal(size_t a1) {
  return VirtualAlloc(0, a1);
}

void *__cdecl Z_VirtualCommitInternal(void *a1, size_t a2) {
  void *result; // eax

  result = VirtualAlloc(a1, a2);
  if (!result)
    Sys_OutOfMemErrorInternal("/Users/kevin/Development/i5works/COD2/Project/"
                              "PC/universal/com_memory.cpp",
                              549);
  return result;
}

void Com_TouchMemory() {
  int v0;     // esi
  int v1;     // eax
  int v2;     // ebx
  int v3;     // edx
  _DWORD *v4; // eax
  int v5;     // eax

  v0 = Sys_Milliseconds();
  if (hunk_low >> 2 <= 0) {
    v2 = 0;
  } else {
    v1 = 0;
    v2 = 0;
    do {
      v2 += *(_DWORD *)(s_hunkData + 4 * v1);
      v1 += 64;
    } while (hunk_low >> 2 > v1);
  }
  v3 = (s_hunkTotal - hunk_high) >> 2;
  if (v3 < hunk_high >> 2) {
    v4 = (_DWORD *)(s_hunkData + 4 * v3);
    do {
      v2 += *v4;
      v3 += 64;
      v4 += 64;
    } while (hunk_high >> 2 > v3);
  }
  v5 = Sys_Milliseconds();
  Com_Printf("Com_TouchMemory: %i msec. Using sum: %d\n", v5 - v0, v2);
}

int __cdecl Hunk_FindDataForFile(int a1, char *a2) {
  int v2; // ebx

  v2 = com_fileDataHashTable[FS_HashFileName(a2, 1024)];
  if (!v2)
    return 0;
  while (a1 != *(unsigned __int8 *)(v2 + 8) ||
         stricmp((const char *)(v2 + 9), a2)) {
    v2 = *(_DWORD *)(v2 + 4);
    if (!v2)
      return 0;
  }
  return *(_DWORD *)v2;
}

_BOOL4 __cdecl Hunk_DataOnHunk(unsigned int a1) {
  return a1 >= s_hunkData && a1 < s_hunkTotal + s_hunkData;
}

int __cdecl Hunk_OverrideDataForFile(int a1, char *a2, int a3) {
  int result; // eax
  int v4;     // ebx

  result = FS_HashFileName(a2, 1024);
  v4 = com_fileDataHashTable[result];
  if (v4) {
    while (1) {
      result = *(unsigned __int8 *)(v4 + 8);
      if (result == a1) {
        result = stricmp((const char *)(v4 + 9), a2);
        if (!result)
          break;
      }
      v4 = *(_DWORD *)(v4 + 4);
      if (!v4)
        return result;
    }
    result = a3;
    *(_DWORD *)v4 = a3;
  }
  return result;
}

int Hunk_SetMark() { return hunk_high; }

int Hunk_Used() { return hunk_high + hunk_low; }

int Hunk_ClearTempMemoryHigh() {
  int result; // eax

  result = hunk_high;
  dword_3BCF84 = hunk_high;
  return result;
}

int Hunk_ClearTempMemory() {
  int result; // eax

  result = s_hunkData;
  if (s_hunkData) {
    result = hunk_low;
    dword_3BCF8C = hunk_low;
  }
  return result;
}

int Hunk_HideTempMemory() {
  int result; // eax

  result = hunk_low;
  hunk_low = dword_3BCF8C;
  return result;
}

int __cdecl Hunk_ShowTempMemory(int a1) {
  int result; // eax

  result = a1;
  hunk_low = a1;
  return result;
}

void *__cdecl Z_TryMallocInternal(size_t __size) {
  void *v1; // eax
  void *v2; // ebx

  v1 = malloc(__size);
  v2 = v1;
  if (v1)
    Com_Memset(v1, 0, __size);
  return v2;
}

void __cdecl Hunk_FreeTempMemory(void *a1) {
  char v1; // [esp+8h] [ebp-10h]

  if (s_hunkData) {
    if (*((_DWORD *)a1 - 4) != -1991018350)
      Com_Error(0, "\x15Hunk_FreeTempMemory: bad magic", v1);
    *((_DWORD *)a1 - 4) = -1991018349;
    dword_3BCF8C -= *((_DWORD *)a1 - 3);
  } else {
    free(a1);
  }
}

void *__cdecl Z_VirtualAllocInternal(size_t a1) {
  void *result; // eax

  result = VirtualAlloc(0, a1);
  if (!result)
    Sys_OutOfMemErrorInternal("/Users/kevin/Development/i5works/COD2/Project/"
                              "PC/universal/com_memory.cpp",
                              524);
  return result;
}

void *__cdecl Z_MallocInternal(size_t __size) {
  void *v1; // eax
  void *v2; // ebx

  v1 = malloc(__size);
  v2 = v1;
  if (!v1)
    Sys_OutOfMemErrorInternal("/Users/kevin/Development/i5works/COD2/Project/"
                              "PC/universal/com_memory.cpp",
                              220);
  Com_Memset(v1, 0, __size);
  return v2;
}

void __usercall Hunk_Clear(float a1 @<xmm0>) {
  hunk_low = 0;
  dword_3BCF8C = 0;
  hunk_high = 0;
  dword_3BCF84 = 0;
  Hunk_ClearData(a1);
}

void __usercall Hunk_ClearToMarkLow(float a1 @<xmm0>, int a2) {
  dword_3BCF8C = a2;
  hunk_low = a2;
  Hunk_ClearData(a1);
}

void __usercall Hunk_ClearToMark(float a1 @<xmm0>, int a2) {
  dword_3BCF84 = a2;
  hunk_high = a2;
  Hunk_ClearData(a1);
}

void __usercall Com_InitHunkMemory(long double a1 @<st0>, float a2 @<xmm0>,
                                   __m128 a3 @<xmm1>, __m128 a4 @<xmm2>,
                                   __m128 a5 @<xmm3>, __m128 a6 @<xmm4>,
                                   __m128 a7 @<xmm6>) {
  DvarValue current; // eax
  size_t v8;         // eax
  void *v9;          // eax

  if (FS_LoadStack())
    Com_Error(
        a1, a2, a3, a4, a5, a6, a7, 0,
        "\x15Hunk initialization failed. File system load stack not zero");
  current = Dvar_RegisterInt("com_hunkMegs", 160, 1, 512, 0x1021u)->current;
  if (current.integer <= 79) {
    Com_Printf("Minimum com_hunkMegs for a dedicated server is %i, allocating "
               "%i megs.\n",
               80, 80);
    s_hunkTotal = 83886080;
    v8 = 83886080;
  } else {
    v8 = current.integer << 20;
    s_hunkTotal = v8;
  }
  v9 = VirtualAlloc(0, v8);
  s_hunkData = (int)v9;
  if (!v9)
    Sys_OutOfMemErrorInternal("/Users/kevin/Development/i5works/COD2/Project/"
                              "PC/universal/com_memory.cpp",
                              843);
  s_origHunkData = (int)v9;
  hunk_low = 0;
  dword_3BCF8C = 0;
  hunk_high = 0;
  dword_3BCF84 = 0;
  Hunk_ClearData(a2);
  Cmd_AddCommand("meminfo", Com_Meminfo_f);
}

char *__cdecl CopyStringInternal(char *__src) {
  size_t v1; // ebx
  char *v2;  // eax
  char *v3;  // edi

  v1 = strlen(__src) + 1;
  v2 = (char *)malloc(v1);
  v3 = v2;
  if (!v2)
    Sys_OutOfMemErrorInternal("/Users/kevin/Development/i5works/COD2/Project/"
                              "PC/universal/com_memory.cpp",
                              220);
  Com_Memset(v2, 0, v1);
  strcpy(v3, __src);
  return v3;
}

char *__cdecl ReplaceStringInternal(const char **a1, char *__src) {
  size_t v2;   // ebx
  char *v4;    // eax
  char *v5;    // edi
  char *__dst; // [esp+1Ch] [ebp-1Ch]

  v2 = strlen(__src) + 1;
  __dst = (char *)*a1;
  if (*a1) {
    if (strlen(*a1) >= v2 - 1)
      return strcpy(__dst, __src);
    free(__dst);
  }
  v4 = (char *)malloc(v2);
  v5 = v4;
  if (!v4)
    Sys_OutOfMemErrorInternal("/Users/kevin/Development/i5works/COD2/Project/"
                              "PC/universal/com_memory.cpp",
                              220);
  Com_Memset(v4, 0, v2);
  *a1 = v5;
  return strcpy(v5, __src);
}

void *__cdecl Hunk_AllocateTempMemoryInternal(size_t __size) {
  int v1;          // edi
  unsigned int v2; // eax
  _DWORD *v3;      // esi
  void *v4;        // ebx

  if (s_hunkData) {
    v1 = dword_3BCF8C;
    v2 = (dword_3BCF8C + 15) & 0xFFFFFFF0;
    v3 = (_DWORD *)(s_hunkData + v2);
    dword_3BCF8C = v2 + __size + 16;
    if (dword_3BCF8C + dword_3BCF84 > s_hunkTotal)
      Com_Error(1,
                "\x15Hunk_AllocateTempMemory: failed on %i bytes (total %i MB, "
                "low %i MB, high %i MB), needs %i more hunk bytes",
                __size + 16);
    v4 = v3 + 4;
    *v3 = -1991018350;
    v3[1] = dword_3BCF8C - v1;
  } else {
    v4 = malloc(__size);
    if (!v4)
      Sys_OutOfMemErrorInternal("/Users/kevin/Development/i5works/COD2/Project/"
                                "PC/universal/com_memory.cpp",
                                220);
    Com_Memset(v4, 0, __size);
  }
  return v4;
}

void *__cdecl Hunk_AllocXAnimPrecache(size_t __len) {
  return Hunk_AllocAlignInternal(__len, 4);
}

int __cdecl SL_TransferRefToUser(int a1, unsigned __int8 a2) {
  int v2;             // ecx
  unsigned __int8 v3; // dl
  int result;         // eax

  v2 = scrMemTreePub + 8 * a1;
  v3 = *(_BYTE *)(v2 + 1);
  result = v3;
  if ((a2 & v3) != 0)
    --*(_WORD *)(v2 + 2);
  else
    *(_BYTE *)(v2 + 1) = a2 | v3;
  return result;
}

int __cdecl SL_GetStringOfLen(char *__src, unsigned __int8 a2, size_t __n) {
  char *v3;             // ecx
  unsigned int v4;      // ebx
  unsigned int v5;      // edx
  size_t v6;            // ebx
  int v7;               // ebx
  __int16 *v8;          // edx
  __int16 v9;           // si
  int i;                // ebx
  int v11;              // edi
  int v12;              // esi
  int v13;              // ecx
  __int16 *v14;         // ecx
  int v15;              // ebx
  int v17;              // ecx
  int v18;              // edx
  unsigned __int8 *v19; // ebx
  __int16 *v20;         // ebx
  int v21;              // eax
  const char *v22;      // ecx
  int v23;              // ebx
  int v24;              // ecx
  __int16 v25;          // ax
  char v26;             // [esp+8h] [ebp-80h]
  __int16 v27;          // [esp+48h] [ebp-40h]
  int v28;              // [esp+4Ch] [ebp-3Ch]
  __int16 *v29;         // [esp+50h] [ebp-38h]
  __int16 v30;          // [esp+54h] [ebp-34h]
  size_t v31;           // [esp+58h] [ebp-30h]
  int v32;              // [esp+64h] [ebp-24h]
  size_t v33;           // [esp+68h] [ebp-20h]
  const char *v34;      // [esp+6Ch] [ebp-1Ch]

  if (__n > 0xFF) {
    v31 =
        (__n >> 2) -
        0x3FFF *
            ((unsigned int)(((unsigned int)((__n >> 2) -
                                            ((262161 *
                                              (unsigned __int64)(__n >> 2)) >>
                                             32)) >>
                             1) +
                            ((262161 * (unsigned __int64)(__n >> 2)) >> 32)) >>
             13) +
        1;
    v6 = v31;
  } else {
    if (__n) {
      v3 = __src;
      v4 = 0;
      do
        v4 = *v3++ + 31 * v4;
      while (&__src[__n] != v3);
      v5 = v4 % 0x3FFF;
    } else {
      v5 = 0;
    }
    v31 = v5 + 1;
    v6 = v5 + 1;
  }
  v7 = 2 * v6;
  v29 = &scrStringGlob[v7];
  v9 = scrStringGlob[v7];
  v27 = v9;
  if ((v9 & 0xC000) != 0x8000) {
    if ((v9 & 0xC000) != 0) {
      v30 = v9 & 0x3FFF;
      for (i = v9 & 0x3FFF; v31 != (scrStringGlob[2 * i] & 0x3FFF);
           i = scrStringGlob[2 * i] & 0x3FFF)
        ;
      v11 = (unsigned __int16)scrStringGlob[0];
      if (!scrStringGlob[0]) {
        Scr_DumpScriptThreads();
        Scr_DumpScriptVariables();
        Com_Error(1, "\x15exceeded maximum number of script strings\n", v26);
      }
      v12 = (unsigned __int16)MT_AllocIndex(__n + 4);
      v13 = 2 * v11;
      scrStringGlob[0] = scrStringGlob[2 * v11] & 0x3FFF;
      scrStringGlob[2 * (unsigned __int16)scrStringGlob[0] + 1] = 0;
      scrStringGlob[2 * i] = v11 | scrStringGlob[2 * i] & 0xC000;
      scrStringGlob[v13] = v30 | 0x4000;
      word_3E6682[v13] = v29[1];
      v14 = v29;
    } else {
      v12 = (unsigned __int16)MT_AllocIndex(__n + 4);
      v17 = (unsigned __int16)v29[1];
      v18 = scrStringGlob[v7] & 0x3FFF;
      scrStringGlob[2 * v17] = v18 | scrStringGlob[2 * v17] & 0xC000;
      word_3E6682[2 * v18] = v17;
      v14 = &scrStringGlob[v7];
    }
    *v14 = v31 | 0x8000;
  LABEL_16:
    v29[1] = v12;
    v15 = scrMemTreePub + 8 * v12;
    memcpy((void *)(v15 + 4), __src, __n);
    *(_BYTE *)(v15 + 1) = a2;
    *(_WORD *)(v15 + 2) = 1;
    *(_BYTE *)v15 = __n;
    return v12;
  }
  v8 = &scrStringGlob[v7];
  v19 = (unsigned __int8 *)(scrMemTreePub +
                            8 * (unsigned __int16)scrStringGlob[v7 + 1]);
  if ((unsigned __int8)__n == *v19 &&
      !memcmp((const char *)v19 + 4, __src, __n)) {
    if ((v19[1] & a2) != 0) {
      return (unsigned __int16)v8[1];
    } else {
      v19[1] |= a2;
      ++*((_WORD *)v19 + 1);
      return (unsigned __int16)v29[1];
    }
  } else {
    v32 = v27 & 0x3FFF;
    v20 = &scrStringGlob[2 * v32];
    if (v29 == v20) {
    LABEL_30:
      v23 = (unsigned __int16)scrStringGlob[0];
      if (!scrStringGlob[0]) {
        Scr_DumpScriptThreads();
        Scr_DumpScriptVariables();
        Com_Error(1, "\x15exceeded maximum number of script strings\n", v26);
      }
      v12 = (unsigned __int16)MT_AllocIndex(__n + 4);
      v24 = 2 * v23;
      scrStringGlob[0] = scrStringGlob[2 * v23] & 0x3FFF;
      scrStringGlob[2 * (unsigned __int16)scrStringGlob[0] + 1] = 0;
      v25 = *v29 & 0x3FFF;
      HIBYTE(v25) |= 0x40u;
      scrStringGlob[v24] = v25;
      *v29 = v23 & 0x3FFF | *v29 & 0xC000;
      word_3E6682[v24] = v29[1];
      goto LABEL_16;
    }
    v33 = v31;
    while (1) {
      v28 = (unsigned __int16)v20[1];
      v22 = (const char *)(scrMemTreePub + 8 * v28);
      v34 = v22;
      if ((unsigned __int8)__n == *(unsigned __int8 *)v22 &&
          !memcmp(v22 + 4, __src, __n))
        break;
      v21 = *v20 & 0x3FFF;
      v20 = &scrStringGlob[2 * v21];
      if (v29 == v20)
        goto LABEL_30;
      v33 = v32;
      v32 = v21;
    }
    scrStringGlob[2 * v33] = *v20 & 0x3FFF | scrStringGlob[2 * v33] & 0xC000;
    *v20 = *v29 & 0x3FFF | *v20 & 0xC000;
    *v29 = v32 | *v29 & 0xC000;
    v12 = v28;
    v20[1] = v29[1];
    v29[1] = v28;
    if ((v34[1] & a2) == 0) {
      *((_BYTE *)v34 + 1) |= a2;
      ++*((_WORD *)v34 + 1);
    }
  }
  return v12;
}

int __cdecl SL_GetString_(char *__src, unsigned __int8 a2) {
  return SL_GetStringOfLen(__src, a2, strlen(__src) + 1);
}

void *__cdecl zcalloc(int a1, int a2, int a3) {
  return Z_MallocInternal(a2 * a3);
}

void __cdecl zcfree(int a1, void *a2) { Z_FreeInternal(a2); }

int __cdecl XModelPartsFindData(char *a1) {
  return Hunk_FindDataForFile(3, a1);
}

int __cdecl XModelSurfsFindData(char *a1) {
  return Hunk_FindDataForFile(2, a1);
}

int __cdecl FS_SV_FOpenFileWrite(char *__src) {
  int v1;          // edi
  FILE **v2;       // ebx
  int v4;          // [esp+1Ch] [ebp-11Ch]
  char __big[280]; // [esp+20h] [ebp-118h] BYREF

  FS_CheckFileSystemStarted();
  FS_BuildOSPath(*(const char **)(fs_homepath + 8), __src,
                 (const char *)&inData, __big);
  __big[strlen(__big) - 1] = 0;
  v1 = FS_HandleForFile(0);
  v4 = 284 * v1;
  v2 = &fsh + 71 * v1;
  v2[5] = 0;
  if (*(_DWORD *)(fs_debug + 8))
    Com_Printf("FS_SV_FOpenFileWrite: %s\n", __big);
  if (FS_CreatePath(__big))
    return 0;
  Com_DPrintf("writing to: %s\n", __big);
  *v2 = FS_FileOpen(__big, "wb");
  I_strncpyz((char *)&fsh + v4 + 28, __src, 256);
  v2[2] = 0;
  if (!*v2)
    return 0;
  else
    return v1;
}

unsigned __int8 *__cdecl FS_SV_FOpenFileRead(char *__src, int *a2) {
  int v2;       // esi
  FILE **v3;    // ebx
  FILE *v4;     // eax
  int v6;       // ebx
  FILE *v7;     // eax
  _BYTE v8[2];  // [esp+Eh] [ebp-11Ah]
  char v9[280]; // [esp+10h] [ebp-118h] BYREF

  FS_CheckFileSystemStarted();
  v2 = FS_HandleForFile(0);
  v3 = &fsh + 71 * v2;
  v3[5] = 0;
  I_strncpyz((char *)v3 + 28, __src, 256);
  FS_BuildOSPath(*(const char **)(fs_homepath + 8), __src,
                 (const char *)&inData, v9);
  v8[strlen(v9) + 1] = 0;
  if (*(_DWORD *)(fs_debug + 8))
    Com_Printf("FS_SV_FOpenFileRead (fs_homepath): %s\n", v9);
  v4 = FS_FileOpen(v9, "rb");
  *v3 = v4;
  v3[2] = 0;
  if (!v4) {
    if (I_stricmp(*(char **)(fs_homepath + 8),
                  (char *)fs_basepath->current.integer)) {
      FS_BuildOSPath((const char *)fs_basepath->current.integer, __src,
                     (const char *)&inData, v9);
      v8[strlen(v9) + 1] = 0;
      if (*(_DWORD *)(fs_debug + 8))
        Com_Printf("FS_SV_FOpenFileRead (fs_basepath): %s\n", v9);
      v7 = FS_FileOpen(v9, "rb");
      *v3 = v7;
      v3[2] = 0;
      if (v7)
        goto LABEL_4;
      v2 = 0;
    }
    v6 = 284 * v2;
    if (!*(&fsh + 71 * v2)) {
      FS_BuildOSPath(*(const char **)(fs_cdpath + 8), __src,
                     (const char *)&inData, v9);
      v8[strlen(v9) + 1] = 0;
      if (*(_DWORD *)(fs_debug + 8))
        Com_Printf("FS_SV_FOpenFileRead (fs_cdpath) : %s\n", v9);
      *(FILE **)((char *)&fsh + v6) = FS_FileOpen(v9, "rb");
      *(FILE **)((char *)&fsh + v6 + 8) = 0;
      if (!*(FILE **)((char *)&fsh + v6))
        v2 = 0;
    }
  }
LABEL_4:
  *a2 = v2;
  if (v2)
    return FS_filelength(v2);
  else
    return 0;
}

int __cdecl FS_SV_Rename(char *a1, char *a2) {
  int result;      // eax
  _BYTE v3[2];     // [esp+Eh] [ebp-21Ah]
  char __new[256]; // [esp+10h] [ebp-218h] BYREF
  char __old[280]; // [esp+110h] [ebp-118h] BYREF

  FS_CheckFileSystemStarted();
  FS_BuildOSPath(*(const char **)(fs_homepath + 8), a1, (const char *)&inData,
                 __old);
  FS_BuildOSPath(*(const char **)(fs_homepath + 8), a2, (const char *)&inData,
                 __new);
  __new[strlen(__old) + 255] = 0;
  v3[strlen(__new) + 1] = 0;
  if (*(_DWORD *)(fs_debug + 8))
    Com_Printf("FS_SV_Rename: %s --> %s\n", __old, __new);
  result = rename(__old, __new);
  if (result) {
    FS_CopyFile(__old, __new);
    return FS_Remove(__old);
  }
  return result;
}

char *__cdecl FS_ShiftStr(const char *a1, char a2) {
  int v2; // ecx
  int v4; // edx

  v2 = strlen(a1);
  if (v2 > 0) {
    v4 = 0;
    do {
      FS_ShiftStr(char const *, int)::buf[v4] = a1[v4] + a2;
      ++v4;
    } while (v4 != v2);
    FS_ShiftStr(char const *, int)::buf[v2] = 0;
    return FS_ShiftStr(char const *, int)::buf;
  } else {
    FS_ShiftStr(char const *, int)::buf[0] = 0;
    return FS_ShiftStr(char const *, int)::buf;
  }
}

void FS_Dir_f(void) {
  char *v0;      // ebx
  gentity_s *v1; // esi
  void **v2;     // esi
  int v3;        // ebx
  int v4[3];     // [esp+2Ch] [ebp-Ch] BYREF

  if (Cmd_Argc() > 1 && Cmd_Argc() <= 3) {
    if (Cmd_Argc() == 2) {
      v0 = (char *)Cmd_Argv(1);
      v1 = (gentity_s *)&inData;
    } else {
      v0 = (char *)Cmd_Argv(1);
      v1 = (gentity_s *)Cmd_Argv(2);
    }
    Com_Printf("Directory of %s %s\n", v0, (const char *)v1);
    Com_Printf("---------------\n");
    v2 = (void **)FS_ListFiles(v0, (char *)v1, FS_LIST_PURE_ONLY, v4);
    if (v4[0] > 0) {
      v3 = 0;
      do
        Com_Printf("%s\n", (const char *)v2[v3++]);
      while (v4[0] > v3);
    }
    FS_FreeFileList(v2);
  } else {
    Com_Printf("usage: dir <directory> [extension]\n");
  }
}

void FS_NewDir_f(void) {
  char *v0;        // ebx
  const char **v1; // edi
  int v2;          // edx
  int v3;          // esi
  const char **v4; // ebx
  int v5;          // eax
  int v6[7];       // [esp+2Ch] [ebp-1Ch] BYREF

  if (Cmd_Argc() <= 1) {
    Com_Printf("usage: fdir <filter>\n");
    Com_Printf("example: fdir *q3dm*.bsp\n");
  } else {
    v0 = (char *)Cmd_Argv(1);
    Com_Printf("---------------\n");
    v1 = (const char **)FS_ListFilteredFiles(
        fs_searchpaths, (const char *)&inData, (const char *)&inData, v0,
        FS_LIST_PURE_ONLY, v6);
    FS_SortFileList(v1, v6[0]);
    v2 = v6[0];
    if (v6[0] > 0) {
      v3 = 1;
      v4 = v1 + 1;
      do {
        FS_ConvertPath((char *)*(v4 - 1));
        Com_Printf("%s\n", *(v4 - 1));
        v5 = v3;
        v2 = v6[0];
        ++v3;
        ++v4;
      } while (v6[0] > v5);
    }
    Com_Printf("%d files listed\n", v2);
    FS_FreeFileList((void **)v1);
  }
}

void FS_TouchFile_f(void) {
  char *v0; // eax

  if (Cmd_Argc() == 2) {
    v0 = (char *)Cmd_Argv(1);
    FS_TouchFile(v0);
  } else {
    Com_Printf("Usage: touchFile <file>\n");
  }
}

int __cdecl FS_iwIwd(char *__big, char *a2) {
  int i;          // ebx
  char *v3;       // eax
  char *v5;       // ebx
  char *v6;       // eax
  int v7;         // ebx
  char *v8;       // eax
  char __dst[88]; // [esp+10h] [ebp-58h] BYREF

  for (i = 0; i != 25; ++i) {
    v3 = va("%s/iw_%02d", a2, i);
    if (!FS_FilenameCompare(__big, v3))
      return 1;
  }
  v5 = strstr(__big, "localized_");
  if (v5) {
    strcpy(__dst, __big);
    __dst[v5 - __big + 10] = 0;
    v6 = va("%s/localized_", a2);
    if (!FS_FilenameCompare(__dst, v6)) {
      strcpy(__dst, v5 + 10);
      I_strlwr(__dst);
      v7 = 0;
      while (1) {
        v8 = va("_iw%02d", v7);
        if (strstr(__dst, v8))
          break;
        if (++v7 == 25)
          return 0;
      }
      return 1;
    }
  }
  return 0;
}

void FS_AddCommands(void) {
  Cmd_AddCommand("path", FS_Path_f);
  Cmd_AddCommand("fullpath", FS_FullPath_f);
  Cmd_AddCommand("dir", FS_Dir_f);
  Cmd_AddCommand("fdir", FS_NewDir_f);
  Cmd_AddCommand("touchFile", FS_TouchFile_f);
}

void __cdecl FS_PureServerSetLoadedIwds(char *a1, char *a2) {
  int i;              // ebx
  const char *v3;     // eax
  int v4;             // eax
  int v5;             // edi
  int v6;             // ebx
  char *v7;           // eax
  int v8;             // esi
  int *v9;            // ebx
  int j;              // ebx
  char v11;           // [esp+8h] [ebp-2030h]
  int v12;            // [esp+14h] [ebp-2024h]
  char **v13;         // [esp+18h] [ebp-2020h]
  int v14;            // [esp+1Ch] [ebp-201Ch]
  _DWORD v15[1024];   // [esp+20h] [ebp-2018h] BYREF
  _DWORD __src[1030]; // [esp+1020h] [ebp-1018h] BYREF

  Cmd_TokenizeString(a1);
  v12 = Cmd_Argc();
  if (v12 <= 1024) {
    if (v12 <= 0)
      goto LABEL_5;
  } else {
    v12 = 1024;
  }
  for (i = 0; i != v12; ++i) {
    v3 = (const char *)Cmd_Argv(i);
    __src[i] = atoi(v3);
  }
LABEL_5:
  Cmd_TokenizeString(a2);
  v4 = Cmd_Argc();
  v5 = v4;
  if (v4 <= 1024) {
    if (v4 <= 0)
      goto LABEL_9;
  } else {
    v5 = 1024;
  }
  v6 = 0;
  do {
    v7 = (char *)Cmd_Argv(v6);
    v15[v6++] = CopyStringInternal(v7);
  } while (v5 != v6);
LABEL_9:
  if (v12 != v5)
    Com_Error(1, "iwd sum/name mismatch", v11);
  if (v12 != fs_numServerIwds) {
  LABEL_12:
    SND_StopSounds(SND_STOP_STREAMED);
    FS_ShutdownServerIwdNames();
    fs_numServerIwds = v12;
    if (v12) {
      Com_DPrintf("Connected to a pure server.\n");
      Com_Memcpy(&fs_serverIwds, __src, 4 * fs_numServerIwds);
      Com_Memcpy(&fs_serverIwdNames, v15, 4 * fs_numServerIwds);
      fs_fakeChkSum = 0;
    }
    return;
  }
  if (v12 > 0) {
    v14 = 0;
    while (fs_numServerIwds > 0) {
      v8 = 0;
      v9 = &fs_serverIwds;
      v13 = (char **)&fs_serverIwdNames;
      while (__src[v14] != *v9 || I_stricmp((char *)v15[v14], *v13)) {
        ++v8;
        ++v9;
        ++v13;
        if (v8 >= fs_numServerIwds)
          goto LABEL_12;
      }
      if (v12 == ++v14)
        goto LABEL_27;
    }
    goto LABEL_12;
  }
LABEL_27:
  if (v5 > 0) {
    for (j = 0; j != v5; ++j)
      Z_FreeInternal((void *)v15[j]);
  }
}

int *__cdecl FS_PureServerSetReferencedIwds(char *a1, char *a2) {
  int v2;         // edi
  int *result;    // eax
  int v4;         // ebx
  int *v5;        // esi
  const char *v6; // eax
  int v7;         // esi
  int v8;         // ebx
  char *v9;       // eax
  char v10;       // [esp+8h] [ebp-30h]
  char **v11;     // [esp+1Ch] [ebp-1Ch]

  Cmd_TokenizeString(a1);
  v2 = Cmd_Argc();
  if (v2 >= 1025)
    v2 = 1024;
  FS_ShutdownServerReferencedIwds();
  if (v2 > 0) {
    v4 = 0;
    v5 = (int *)&fs_serverReferencedIwds;
    do {
      v6 = (const char *)Cmd_Argv(v4);
      *v5 = atoi(v6);
      ++v4;
      ++v5;
    } while (v2 != v4);
  }
  if (a2 && *a2) {
    Cmd_TokenizeString(a2);
    v7 = Cmd_Argc();
    if (v7 >= 1025)
      v7 = 1024;
    if (v2 != v7)
      Com_Error(1, "iwd sum/name mismatch", v10);
    if (v7 > 0) {
      v8 = 0;
      v11 = (char **)&fs_serverReferencedIwdNames;
      do {
        v9 = (char *)Cmd_Argv(v8);
        *v11 = CopyStringInternal(v9);
        ++v8;
        ++v11;
      } while (v7 != v8);
    }
    goto LABEL_7;
  }
  if (!v2) {
  LABEL_7:
    result = &fs_numServerReferencedIwds;
    fs_numServerReferencedIwds = v2;
    return result;
  }
  Com_Error(1, "iwd sum/name mismatch", v10);
  result = &fs_numServerReferencedIwds;
  fs_numServerReferencedIwds = v2;
  return result;
}

int __cdecl FS_GetModList(char *a1, int a2) {
  char **v2;          // edi
  char **v3;          // esi
  char *v4;           // eax
  char **v5;          // ebx
  int v6;             // eax
  int v7;             // ecx
  int v8;             // edx
  int v9;             // edx
  char *v10;          // ecx
  char **v11;         // eax
  char **v12;         // edx
  char *v13;          // ecx
  char **v14;         // eax
  char *v15;          // ecx
  char **v16;         // eax
  int v17;            // eax
  char **v18;         // eax
  unsigned int v19;   // esi
  int v21;            // ebx
  FILE *v22;          // ebx
  signed __int32 v23; // eax
  char **v24;         // eax
  char **v25;         // eax
  unsigned int v26;   // [esp+20h] [ebp-248h]
  int v27;            // [esp+24h] [ebp-244h]
  int v28;            // [esp+28h] [ebp-240h]
  int v29;            // [esp+2Ch] [ebp-23Ch]
  char *__src;        // [esp+30h] [ebp-238h]
  int v31;            // [esp+34h] [ebp-234h]
  int v32;            // [esp+38h] [ebp-230h]
  char **v33;         // [esp+3Ch] [ebp-22Ch]
  char __dst[256];    // [esp+44h] [ebp-224h] BYREF
  char v35[256];      // [esp+144h] [ebp-124h] BYREF
  int v36;            // [esp+244h] [ebp-24h] BYREF
  int v37;            // [esp+248h] [ebp-20h] BYREF
  int v38[7];         // [esp+24Ch] [ebp-1Ch] BYREF

  *a1 = 0;
  v2 = (char **)Sys_ListFiles(*(char **)(fs_homepath + 8), 0, 0, &v36, 1);
  v3 = (char **)Sys_ListFiles((char *)fs_basepath->current.integer, 0, 0, &v36,
                              1);
  v4 = *(char **)(fs_cdpath + 8);
  if (v4 && *v4) {
    v5 = (char **)Sys_ListFiles(v4, 0, 0, &v36, 1);
    if (!v2)
      goto LABEL_55;
  } else {
    v5 = 0;
    if (!v2)
      goto LABEL_55;
  }
  if (*v2) {
    v6 = 0;
    do
      ++v6;
    while (v2[v6]);
    v7 = v6;
    if (!v3)
      goto LABEL_56;
    goto LABEL_8;
  }
LABEL_55:
  v7 = 0;
  if (!v3)
    goto LABEL_56;
LABEL_8:
  if (*v3) {
    v8 = 0;
    do
      ++v8;
    while (v3[v8]);
    v7 += v8;
    if (!v5)
      goto LABEL_57;
    goto LABEL_12;
  }
LABEL_56:
  if (!v5)
    goto LABEL_57;
LABEL_12:
  if (*v5) {
    v9 = 0;
    do
      ++v9;
    while (v5[v9]);
    v33 = (char **)Z_MallocInternal(4 * (v7 + v9) + 4);
    if (!v2)
      goto LABEL_58;
    goto LABEL_16;
  }
LABEL_57:
  v33 = (char **)Z_MallocInternal(4 * v7 + 4);
  if (!v2)
    goto LABEL_58;
LABEL_16:
  v10 = *v2;
  if (!*v2) {
  LABEL_58:
    v12 = v33;
    goto LABEL_19;
  }
  v11 = v2;
  v12 = v33;
  do {
    *v12++ = v10;
    v10 = v11[1];
    ++v11;
  } while (v10);
LABEL_19:
  if (v3) {
    v13 = *v3;
    if (*v3) {
      v14 = v3;
      do {
        *v12++ = v13;
        v13 = v14[1];
        ++v14;
      } while (v13);
    }
  }
  if (v5) {
    v15 = *v5;
    if (*v5) {
      v16 = v5;
      do {
        *v12++ = v15;
        v15 = v16[1];
        ++v16;
      } while (v15);
    }
  }
  *v12 = 0;
  if (v2)
    Z_FreeInternal(v2);
  if (v3)
    Z_FreeInternal(v3);
  if (v5)
    Z_FreeInternal(v5);
  if (v33) {
    if (*v33) {
      v17 = 0;
      do
        ++v17;
      while (v33[v17]);
      v32 = v17;
      if (v17 > 0) {
        v31 = 0;
        v29 = 0;
        v28 = 0;
        v27 = 0;
        while (1) {
          __src = v33[v28];
          if (!v28)
            break;
          if (v28 > 0) {
            v21 = 0;
            while (I_stricmp(v33[v21], __src)) {
              if (v28 == ++v21)
                goto LABEL_40;
            }
            v31 = 1;
            goto LABEL_41;
          }
        LABEL_40:
          v31 = 0;
          if (I_strnicmp(__src, ".", 1))
            goto LABEL_45;
        LABEL_41:
          if (v32 == ++v28)
            goto LABEL_53;
        }
        if (v31 || !I_strnicmp(__src, ".", 1))
          goto LABEL_41;
      LABEL_45:
        FS_BuildOSPath((const char *)fs_basepath->current.integer, __src,
                       (const char *)&inData, v35);
        v38[0] = 0;
        v18 = (char **)Sys_ListFiles(v35, "iwd", 0, v38, 0);
        Sys_FreeFileList(v18);
        if (v38[0] > 0)
          goto LABEL_46;
        FS_BuildOSPath(*(const char **)(fs_cdpath + 8), __src,
                       (const char *)&inData, v35);
        v38[0] = 0;
        v24 = (char **)Sys_ListFiles(v35, "iwd", 0, v38, 0);
        Sys_FreeFileList(v24);
        if (v38[0] > 0 ||
            (FS_BuildOSPath(*(const char **)(fs_homepath + 8), __src,
                            (const char *)&inData, v35),
             v38[0] = 0, v25 = (char **)Sys_ListFiles(v35, "iwd", 0, v38, 0),
             Sys_FreeFileList(v25), v38[0] > 0)) {
        LABEL_46:
          v26 = strlen(__src) + 1;
          strcpy(__dst, __src);
          I_strncat(__dst, 256, "/description.txt");
          if ((int)FS_SV_FOpenFileRead(__dst, &v37) > 0 && v37) {
            v22 = (FILE *)FS_FileForHandle(v37);
            Com_Memset(__dst, 0, 0x100u);
            v23 = FS_FileRead(__dst, 1u, 0x30u, v22);
            if (v23 >= 0)
              __dst[v23] = 0;
            FS_FCloseFile(v37);
          } else if (I_stricmp(__src, "main")) {
            strcpy(__dst, __src);
          } else {
            strcpy(__dst, "Call of Duty 2 Multiplayer");
          }
          v19 = strlen(__dst) + 1;
          if ((int)(v19 + v26 + v29 + 2) >= a2)
            goto LABEL_53;
          strcpy(a1, __src);
          strcpy(&a1[v26], __dst);
          a1 += v19 + v26;
          v29 += v19 + v26;
          ++v27;
        }
        goto LABEL_41;
      }
    }
  }
  v27 = 0;
LABEL_53:
  Sys_FreeFileList(v33);
  return v27;
}

int __cdecl FS_CompareIwds(char *a1, int a2, int a3) {
  const char *v3;  // eax
  const char **v5; // ebx
  _DWORD *v6;      // esi
  searchpath_s *i; // edx
  int32_t pack;    // eax
  char *v9;        // eax
  char *v10;       // eax
  FILE *v11;       // eax
  char *v12;       // eax
  FILE *v13;       // eax
  int v14;         // [esp+2Ch] [ebp-11Ch]
  char __str[280]; // [esp+30h] [ebp-118h] BYREF

  if (!fs_numServerReferencedIwds)
    return 0;
  *a1 = 0;
  if (fs_numServerReferencedIwds <= 0) {
    v3 = a1;
    if (*a1)
      goto LABEL_5;
    return 0;
  }
  v14 = 0;
  v5 = (const char **)&fs_serverReferencedIwdNames;
  v6 = &fs_serverReferencedIwds;
  do {
    while (1) {
      if (!FS_iwIwd((char *)*v5, "main")) {
        for (i = fs_searchpaths; i; i = (searchpath_s *)i->next) {
          pack = i->pack;
          if (pack) {
            if (*(_DWORD *)(pack + 772) == *v6)
              goto LABEL_18;
          }
        }
        v9 = (char *)*v5;
        if (*v5) {
          if (*v9)
            break;
        }
      }
    LABEL_18:
      ++v14;
      ++v5;
      ++v6;
      if (v14 >= fs_numServerReferencedIwds)
        goto LABEL_19;
    }
    if (!a3) {
      I_strncat(a1, a2, v9);
      I_strncat(a1, a2, ".iwd");
      v10 = va("%s.iwd", *v5);
      FS_BuildOSPath(*(const char **)(fs_homepath + 8), v10,
                     (const char *)&inData, __str);
      __str[strlen(__str) - 1] = 0;
      v11 = FS_FileOpen(__str, "rb");
      if (v11) {
        FS_FileClose(v11);
        I_strncat(a1, a2, " (local file exists with wrong checksum)");
      }
      I_strncat(a1, a2, "\n");
      goto LABEL_18;
    }
    I_strncat(a1, a2, "@");
    I_strncat(a1, a2, (char *)*v5);
    I_strncat(a1, a2, ".iwd");
    I_strncat(a1, a2, "@");
    v12 = va("%s.iwd", *v5);
    FS_BuildOSPath(*(const char **)(fs_homepath + 8), v12,
                   (const char *)&inData, __str);
    __str[strlen(__str) - 1] = 0;
    v13 = FS_FileOpen(__str, "rb");
    if (v13) {
      FS_FileClose(v13);
      Com_sprintf(__str, 0x100u, "%s.%08x.iwd", *v5, *v6);
      I_strncat(a1, a2, __str);
    } else {
      I_strncat(a1, a2, (char *)*v5);
      I_strncat(a1, a2, ".iwd");
    }
    ++v14;
    ++v5;
    ++v6;
  } while (v14 < fs_numServerReferencedIwds);
LABEL_19:
  v3 = a1;
  if (!*a1)
    return 0;
LABEL_5:
  Com_Printf("Need iwds: %s\n", v3);
  return 1;
}

void *__cdecl Com_Memcpy(void *__dst, void *__src, size_t __n) {
  return memcpy(__dst, __src, __n);
}

char *__cdecl SE_GetFoundFile(const char **a1) {
  char *v2;        // eax
  unsigned int v3; // eax

  if (!**a1)
    return 0;
  strncpy(SE_GetFoundFile(std::string &)::sTemp, *a1, 0x3Fu);
  byte_482FFF = 0;
  v2 = strchr(SE_GetFoundFile(std::string &)::sTemp, 59);
  if (v2) {
    *v2 = 0;
    v3 = v2 - (char *)&unk_482FBF;
    if (v3 >= *((_DWORD *)*a1 - 3))
      v3 = *((_DWORD *)*a1 - 3);
    std::string::_M_mutate((std::string *)a1, 0, v3, 0);
  } else {
    std::string::_M_mutate((std::string *)a1, 0, *((_DWORD *)*a1 - 3), 0);
  }
  return SE_GetFoundFile(std::string &)::sTemp;
}

char *__cdecl SE_Load(char *__src, char a2) {
  char *FileData;    // eax
  char *v3;          // esi
  char *v4;          // ebx
  char __dst[16384]; // [esp+2Ch] [ebp-401Ch] BYREF
  char *v7;          // [esp+402Ch] [ebp-1Ch] BYREF

  FileData = (char *)SE_LoadFileData(__src);
  v3 = FileData;
  if (!FileData)
    return va("Unable to load \"%s\"!", __src);
  v7 = FileData;
  CStringEdPackage::SetupNewFileParse(TheStringPackage, __src);
  while (
      CStringEdPackage::ReadLine(TheStringPackage, (const char **)&v7, __dst)) {
    if (__dst[0]) {
      v4 = CStringEdPackage::ParseLine(TheStringPackage, __dst, a2);
      if (v4) {
        SE_FreeFileDataAfterLoad(v3);
        return v4;
      }
    }
  }
  SE_FreeFileDataAfterLoad(v3);
  if (*(_DWORD *)TheStringPackage)
    return 0;
  else
    return va("Truncated file, failed to find \"%s\" at file end!",
              "ENDMARKER");
}

char *__cdecl SE_LoadLanguage(char a1) {
  char *i;         // esi
  char *FoundFile; // eax
  const char *v3;  // ebx
  const char *v5;  // [esp+28h] [ebp-20h] BYREF
  _BYTE v6[25];    // [esp+2Fh] [ebp-19h] BYREF

  v5 = (char *)&std::string::_Rep::_S_empty_rep_storage + 12;
  CStringEdPackage::Clear((char **)TheStringPackage);
  SE_BuildFileList("localizedstrings", (std::string *)&v5);
  for (i = 0;; i = SE_Load(FoundFile, a1)) {
    FoundFile = SE_GetFoundFile(&v5);
    if (!FoundFile || i)
      break;
  }
  v3 = v5 - 12;
  if (&std::string::_Rep::_S_empty_rep_storage != (_UNKNOWN *)(v5 - 12) &&
      (int)__gnu_cxx::__exchange_and_add((volatile int *)v5 - 1, -1) <= 0) {
    std::string::_Rep::_M_destroy(v3, v6);
  }
  return i;
}

int SE_Init(void) {
  CStringEdPackage *v0; // eax

  v0 = (CStringEdPackage *)Z_MallocInternal(0x28u);
  *((_DWORD *)v0 + 1) = (char *)&std::string::_Rep::_S_empty_rep_storage + 12;
  *((_DWORD *)v0 + 2) = (char *)&std::string::_Rep::_S_empty_rep_storage + 12;
  *((_DWORD *)v0 + 3) = (char *)&std::string::_Rep::_S_empty_rep_storage + 12;
  *((_DWORD *)v0 + 9) = 0;
  *((_DWORD *)v0 + 5) = 0;
  *((_DWORD *)v0 + 6) = 0;
  *((_DWORD *)v0 + 7) = (char *)v0 + 20;
  *((_DWORD *)v0 + 8) = (char *)v0 + 20;
  TheStringPackage = v0;
  return CStringEdPackage::Clear((char **)v0);
}

void SE_ShutDown(void) {
  CStringEdPackage *v0; // ebx
  int v1;               // eax
  int v2;               // esi
  int v3;               // eax
  int v4;               // esi
  int v5;               // eax
  int v6;               // esi
  char v7;              // [esp+2Dh] [ebp-1Bh] BYREF
  char v8;              // [esp+2Eh] [ebp-1Ah] BYREF
  _BYTE v9[25];         // [esp+2Fh] [ebp-19h] BYREF

  if (TheStringPackage) {
    CStringEdPackage::Clear((char **)TheStringPackage);
    v0 = TheStringPackage;
    if (TheStringPackage) {
      std::_Rb_tree<std::string, std::pair<std::string const, std::string>,
                    std::_Select1st<std::pair<std::string const, std::string>>,
                    std::less<std::string>,
                    std::allocator<std::pair<std::string const, std::string>>>::
          _M_erase((int)TheStringPackage + 16,
                   *((char **)TheStringPackage + 6));
      v1 = *((_DWORD *)v0 + 3);
      v2 = v1 - 12;
      if ((_UNKNOWN *)(v1 - 12) != &std::string::_Rep::_S_empty_rep_storage &&
          (int)__gnu_cxx::__exchange_and_add((volatile int *)(v1 - 4), -1) <=
              0) {
        std::string::_Rep::_M_destroy(v2, &v7);
      }
      v3 = *((_DWORD *)v0 + 2);
      v4 = v3 - 12;
      if (&std::string::_Rep::_S_empty_rep_storage != (_UNKNOWN *)(v3 - 12) &&
          (int)__gnu_cxx::__exchange_and_add((volatile int *)(v3 - 4), -1) <=
              0) {
        std::string::_Rep::_M_destroy(v4, &v8);
      }
      v5 = *((_DWORD *)v0 + 1);
      v6 = v5 - 12;
      if (&std::string::_Rep::_S_empty_rep_storage != (_UNKNOWN *)(v5 - 12) &&
          (int)__gnu_cxx::__exchange_and_add((volatile int *)(v5 - 4), -1) <=
              0) {
        std::string::_Rep::_M_destroy(v6, v9);
      }
      Z_FreeInternal(v0);
    }
    TheStringPackage = 0;
  }
}

_DWORD *__cdecl Cmd_GetAutoCompleteFileList(char *__s1, int *a2) {
  int v2;   // ebx
  char *v3; // eax
  char *v5; // edx

  *a2 = 0;
  v2 = cmd_functions;
  if (cmd_functions) {
    while (strcmp(__s1, *(const char **)(v2 + 4))) {
      v2 = *(_DWORD *)v2;
      if (!v2)
        goto LABEL_4;
    }
  } else {
  LABEL_4:
    v2 = 0;
  }
  v3 = *(char **)(v2 + 8);
  if (v3 && (v5 = *(char **)(v2 + 12)) != 0)
    return FS_ListFiles(v3, v5, FS_LIST_PURE_ONLY, a2);
  else
    return 0;
}

_BOOL4 __cdecl MSS_FileOpenCallback(const char *a1, unsigned int *a2) {
  return FS_FOpenFileReadStream(a1, (int *)a2, 1) >= 0;
}

void *__cdecl MSS_FileCloseCallback(int a1) { return FS_FCloseFile(a1); }

int __cdecl MSS_FileSeekCallback(unsigned int a1, int a2, unsigned int a3) {
  if (a3 == 1) {
    FS_Seek(a1, a2, 0);
    return FS_FTell(a1);
  } else if (a3) {
    if (a3 == 2) {
      FS_Seek(a1, a2, 1);
      return FS_FTell(a1);
    } else {
      return 0;
    }
  } else {
    FS_Seek(a1, a2, 2);
    return FS_FTell(a1);
  }
}

int __cdecl MSS_FileReadCallback(unsigned int a1, char *a2, unsigned int a3) {
  return FS_Read(a2, a3, a1);
}

void __usercall SND_LoadSoundFile(long double a1 @<st0>, float a2 @<xmm0>,
                                  __m128 a3 @<xmm1>, __m128 a4 @<xmm2>,
                                  __m128 a5 @<xmm3>, __m128 a6 @<xmm4>,
                                  __m128 a7 @<xmm6>, SoundFile *a8) {
  unsigned int v8;  // esi
  int v9;           // ecx
  int v10;          // edx
  unsigned int v11; // edi
  int v12;          // ebx
  _DWORD *v13;      // [esp+20h] [ebp-1A8h]
  int v14;          // [esp+24h] [ebp-1A4h]
  int v15;          // [esp+28h] [ebp-1A0h]
  char v16[256];    // [esp+34h] [ebp-194h] BYREF
  int v17;          // [esp+134h] [ebp-94h] BYREF
  void *__src;      // [esp+138h] [ebp-90h]
  size_t __n;       // [esp+13Ch] [ebp-8Ch]
  unsigned int v20; // [esp+140h] [ebp-88h]
  int v21;          // [esp+144h] [ebp-84h]
  int v22;          // [esp+148h] [ebp-80h]
  unsigned int v23; // [esp+14Ch] [ebp-7Ch]
  int v24;          // [esp+150h] [ebp-78h]
  int v25;          // [esp+1ACh] [ebp-1Ch] BYREF

  if (!g_snd[0]) {
    a8->fileMem = 0;
    return;
  }
  sprintf(v16, "sound/%s", *(const char **)a8->soundName);
  if ((FS_ReadFile(v16, (char **)&v25) & 0x80000000) == 0) {
    if (AIL_WAV_info(v25, &v17)) {
      if (__n == -36) {
        Com_Printf("^1ERROR: Sound file '%s' is zero length, invalid\n", v16);
        v13 = 0;
        goto LABEL_11;
      }
      v8 = v20;
      if (v20 > unk_FFD804) {
        v9 = v21;
        v10 = v22;
      } else {
        v9 = v21;
        if (v21 > unk_FFD808 && v17 != 17) {
          v10 = v22;
          goto LABEL_14;
        }
        v10 = v22;
        if (v22 <= dword_FFD80C) {
          v13 = (_DWORD *)Hunk_AllocNoZeroInternal(a1, a2, a3, a4, a5, a6, a7,
                                                   __n + 36);
          Com_Memcpy(v13 + 9, __src, __n);
          *v13 = v17;
          v13[1] = __src;
          v13[2] = __n;
          v13[3] = v20;
          v13[4] = v21;
          v13[5] = v22;
          v13[6] = v23;
          v13[7] = v24;
          v13[1] = v13 + 9;
          v13[8] = v13 + 9;
        LABEL_11:
          a8->fileMem = (int32_t)v13;
          FS_FreeFile((void *)v25);
          return;
        }
      }
    LABEL_14:
      v11 = v23;
      if (v20 > unk_FFD804) {
        do {
          v8 >>= 1;
          v11 >>= 1;
        } while (unk_FFD804 < v8);
      }
      if (v9 - unk_FFD808 >= 0)
        v9 = unk_FFD808;
      v14 = v9;
      if (v10 - dword_FFD80C >= 0)
        v10 = dword_FFD80C;
      v15 = v10;
      v12 = AIL_size_processed_digital_audio();
      v13 = (_DWORD *)Hunk_AllocNoZeroInternal(a1, a2, a3, a4, a5, a6, a7,
                                               v12 + 36);
      *v13 = v17;
      v13[1] = v13 + 9;
      v13[2] = v12;
      v13[3] = v8;
      v13[4] = v14;
      v13[5] = v15;
      v13[6] = v11;
      v13[7] = v24;
      v13[8] = v13 + 9;
      AIL_process_digital_audio();
      goto LABEL_11;
    }
    Com_Printf(
        "^1ERROR: Sound file '%s' is in an invalid or corrupted format\n", v16);
    v13 = 0;
    goto LABEL_11;
  }
  Com_Printf("^1ERROR: Sound file '%s' not found\n", v16);
  a8->fileMem = 0;
}

void __cdecl FX_AddCameraShake(EffectPrimitive *a1, EffectPrimitive *a2,
                               float *a3) {
  FxRange *primTemp; // ebx
  float v4[5];       // [esp+34h] [ebp-14h] BYREF

  FX_CalcOriginAndAxis((int)a1, v4, a3, a2);
  primTemp = (FxRange *)a1->primTemp;
  FxRange::GetVal(primTemp + 11);
  FxRange::GetVal(primTemp + 29);
  FxRange::GetVal(primTemp + 80);
  FxHelper::CameraShake(theFxHelper);
}

int __cdecl FX_AddFxRunner(EffectPrimitive *a1, EffectPrimitive *a2,
                           float *a3) {
  MediaHandles *primTemp;       // eax
  const FxBoltInfo *v4;         // ebx
  const EffectTemplate *Effect; // eax
  const EffectTemplate *v7;     // eax
  float v8[9];                  // [esp+24h] [ebp-24h] BYREF

  FX_CalcOriginAndAxis((int)a1, v8, a3, a2);
  primTemp = (MediaHandles *)a1->primTemp;
  if (a1->boltFrame) {
    v4 = (const FxBoltInfo *)(a1->boltFrame + 60);
    Effect = (const EffectTemplate *)MediaHandles::GetEffect(primTemp + 17);
    return FxScheduler::PlayEffect(theFxScheduler, Effect, v8, 0, v4);
  } else {
    v7 = (const EffectTemplate *)MediaHandles::GetEffect(primTemp + 17);
    return FxScheduler::PlayEffect(theFxScheduler, v7, v8,
                                   (const float(*)[3])a2, 0);
  }
}

void *__cdecl FX_AddDecal(EffectPrimitive *a1, EffectPrimitive *a2, float *a3) {
  float v4[9]; // [esp+14h] [ebp-24h] BYREF

  FX_CalcOriginAndAxis((int)a1, v4, a3, a2);
  return FxScheduler::CreateDecalEffect(theFxScheduler,
                                        (const PrimitiveTemplate *)a1->primTemp,
                                        v4, (float(*)[3])a2);
}

void __cdecl FX_AddCloud(FxBoltFramePtr *a1, EffectPrimitive *a2,
                         EffectPrimitive *a3, int a4, PrimitiveTemplate *a5) {
  void *v5;          // eax
  int v6;            // ebx
  int32_t mFramePtr; // esi
  float v8;          // [esp+10h] [ebp-38h]
  float v9[3];       // [esp+28h] [ebp-20h] BYREF
  float v10;         // [esp+34h] [ebp-14h] BYREF
  float v11;         // [esp+38h] [ebp-10h]
  float v12;         // [esp+3Ch] [ebp-Ch]

  v5 = (void *)operator new[](0x27Cu);
  v6 = (int)v5;
  if (v5)
    memset(v5, 0, 0x27Cu);
  Cloud::Cloud((Cloud *)v6);
  if (v6) {
    if ((unsigned __int8)FX_AddPrimitive(a1, v6, (int)a3)) {
      FX_InitParticle((int)a1, v6, &v10, a3, a2);
      mFramePtr = (int32_t)a1[1].mFramePtr;
      FX_SetMaterialAndSequenceParams(
          mFramePtr, v6, *(_DWORD *)(v6 + 188) - *(_DWORD *)(v6 + 184), a5);
      if (a4 > 0) {
        v8 = (float)a4 * 0.001;
        Particle::IntegrateTotalVelocity((Particle *)v6, a4, v9);
        v10 = (float)(v8 * v9[0]) + v10;
        v11 = (float)(v8 * v9[1]) + v11;
        v12 = (float)(v8 * v9[2]) + v12;
      }
      *(float *)(v6 + 4) = v10;
      *(float *)(v6 + 8) = v11;
      *(float *)(v6 + 12) = v12;
      *(float *)(v6 + 608) = flrand(0.0, 1.0);
      *(_BYTE *)(v6 + 604) = *(_BYTE *)(mFramePtr + 157);
    } else {
      (*(void(__cdecl **)(int))(*(_DWORD *)v6 + 4))(v6);
    }
  }
}

void __cdecl FX_AddLight(FxBoltFramePtr *a1, EffectPrimitive *a2, float *a3) {
  void *v3;          // eax
  int v4;            // ebx
  int32_t mFramePtr; // esi
  int v6;            // eax
  float v7[5];       // [esp+14h] [ebp-14h] BYREF

  v3 = (void *)operator new[](0xFCu);
  v4 = (int)v3;
  if (v3)
    memset(v3, 0, 0xFCu);
  Light::Light((Light *)v4);
  if (v4) {
    if ((unsigned __int8)FX_AddPrimitive(a1, v4, (int)a3)) {
      FX_CalcOriginAndAxis((int)a1, v7, a3, a2);
      *(float *)(v4 + 4) = v7[0];
      *(float *)(v4 + 8) = v7[1];
      *(float *)(v4 + 12) = v7[2];
      mFramePtr = (int32_t)a1[1].mFramePtr;
      v6 = *(_DWORD *)(mFramePtr + 144);
      if ((v6 & 0x2000) != 0) {
        *(float *)(v4 + 196) = flrand(0.0, 1.0);
        v6 = *(_DWORD *)(mFramePtr + 144);
      }
      if ((v6 & 0x8000u) != 0)
        *(float *)(v4 + 200) = flrand(0.0, 1.0);
    } else {
      (*(void(__cdecl **)(int))(*(_DWORD *)v4 + 4))(v4);
    }
  }
}

void __cdecl FX_AddCylinder(FxBoltFramePtr *a1, EffectPrimitive *a2,
                            EffectPrimitive *a3, int a4,
                            PrimitiveTemplate *a5) {
  void *v5;                   // eax
  int v6;                     // ebx
  int32_t fx;                 // edx
  orientation_t *Orientation; // eax
  float v9;                   // [esp+14h] [ebp-54h]
  float v10;                  // [esp+18h] [ebp-50h]
  float v11;                  // [esp+1Ch] [ebp-4Ch]
  float v12[3];               // [esp+2Ch] [ebp-3Ch] BYREF
  int32_t v13;                // [esp+38h] [ebp-30h] BYREF
  int32_t primTemp;           // [esp+3Ch] [ebp-2Ch]
  int32_t boltFrame;          // [esp+40h] [ebp-28h]
  float v16[9];               // [esp+44h] [ebp-24h] BYREF

  v5 = (void *)operator new[](0x278u);
  v6 = (int)v5;
  if (v5)
    memset(v5, 0, 0x278u);
  Cylinder::Cylinder((Cylinder *)v6);
  if (v6) {
    if ((unsigned __int8)FX_AddPrimitive(a1, v6, (int)a3)) {
      FX_InitParticle((int)a1, v6, v16, a3, a2);
      FX_SetMaterialAndSequenceParams(
          (int)a1[1].mFramePtr, v6,
          *(_DWORD *)(v6 + 188) - *(_DWORD *)(v6 + 184), a5);
      v11 = v16[0];
      v10 = v16[1];
      v9 = v16[2];
      fx = a2->fx;
      v13 = a2->fx;
      primTemp = a2->primTemp;
      boltFrame = a2->boltFrame;
      if (a1[2].mFramePtr) {
        Orientation =
            FxBoltFrame::GetOrientation((FxBoltFrame *)a1[2].mFramePtr);
        OrientationDirFromWorldDir(Orientation->origin, (float *)&v13, v12);
        *(float *)(v6 + 72) = v12[0];
        *(float *)(v6 + 76) = v12[1];
        *(float *)(v6 + 80) = v12[2];
      } else {
        *(_DWORD *)(v6 + 72) = fx;
        *(_DWORD *)(v6 + 76) = primTemp;
        *(_DWORD *)(v6 + 80) = boltFrame;
      }
      *(float *)(v6 + 4) = v11;
      *(float *)(v6 + 8) = v10;
      *(float *)(v6 + 12) = v9;
    } else {
      (*(void(__cdecl **)(int))(*(_DWORD *)v6 + 4))(v6);
    }
  }
}

void __cdecl FX_AddLine(FxBoltFramePtr *a1, EffectPrimitive *a2, float *a3) {
  void *v3;                     // eax
  int v4;                       // esi
  float v5;                     // edi
  int Handle;                   // ebx
  uint32_t mAttributeFlags;     // eax
  orientation_t *Orientation;   // eax
  PrimitiveTemplate *mFramePtr; // [esp+24h] [ebp-54h]
  float v10;                    // [esp+28h] [ebp-50h]
  float v11;                    // [esp+2Ch] [ebp-4Ch]
  float v12[3];                 // [esp+30h] [ebp-48h] BYREF
  float v13;                    // [esp+3Ch] [ebp-3Ch] BYREF
  float v14;                    // [esp+40h] [ebp-38h]
  float v15;                    // [esp+44h] [ebp-34h]
  float v16[3];                 // [esp+48h] [ebp-30h] BYREF
  float v17[9];                 // [esp+54h] [ebp-24h] BYREF

  v3 = (void *)operator new[](0x258u);
  v4 = (int)v3;
  if (v3)
    memset(v3, 0, 0x258u);
  Line::Line((Line *)v4);
  if (v4) {
    if ((unsigned __int8)FX_AddPrimitive(a1, v4, (int)a3)) {
      FX_CalcOriginAndAxis((int)a1, v17, a3, a2);
      Particle::SetAxis((Particle *)v4, (float(*)[3])a2);
      mFramePtr = (PrimitiveTemplate *)a1[1].mFramePtr;
      FX_CalcOrigin2(mFramePtr, v17, v16, a3, (float(*)[3])a2);
      v5 = v17[0];
      v11 = v17[1];
      v10 = v17[2];
      v13 = v16[0];
      v14 = v16[1];
      v15 = v16[2];
      Handle = MediaHandles::GetHandle(&mFramePtr->mMediaHandles);
      if (a1[2].mFramePtr) {
        Orientation =
            FxBoltFrame::GetOrientation((FxBoltFrame *)a1[2].mFramePtr);
        OrientationPosFromWorldPos(Orientation->origin, &v13, v12);
        *(float *)(v4 + 588) = v12[0];
        *(float *)(v4 + 592) = v12[1];
        *(float *)(v4 + 596) = v12[2];
      } else {
        *(float *)(v4 + 588) = v13;
        *(float *)(v4 + 592) = v14;
        *(float *)(v4 + 596) = v15;
      }
      *(float *)(v4 + 4) = v5;
      *(float *)(v4 + 8) = v11;
      *(float *)(v4 + 12) = v10;
      *(_DWORD *)(v4 + 64) = Handle;
      mAttributeFlags = mFramePtr->mAttributeFlags;
      if ((mAttributeFlags & 0x2000) != 0) {
        *(float *)(v4 + 280) = flrand(0.0, 1.0);
        mAttributeFlags = mFramePtr->mAttributeFlags;
      }
      if ((mAttributeFlags & 0x4000) != 0) {
        *(float *)(v4 + 284) = flrand(0.0, 1.0);
        mAttributeFlags = mFramePtr->mAttributeFlags;
      }
      if ((mAttributeFlags & 0x8000u) != 0) {
        *(float *)(v4 + 288) = flrand(0.0, 1.0);
        mAttributeFlags = mFramePtr->mAttributeFlags;
      }
      if ((mAttributeFlags & 0x10000) != 0)
        *(float *)(v4 + 292) = flrand(0.0, 1.0);
      *(_DWORD *)(v4 + 176) = 0;
      if (*(_DWORD *)(v4 + 64)) {
        if ((unsigned __int8)FxHelper::IsMaterialRefractive(
                theFxHelper, *(Material **)(v4 + 64)))
          *(_DWORD *)(v4 + 176) = -1;
      }
    } else {
      (*(void(__cdecl **)(int))(*(_DWORD *)v4 + 4))(v4);
    }
  }
}

void __cdecl FX_AddParticle(FxBoltFramePtr *a1, EffectPrimitive *a2,
                            EffectPrimitive *a3, int a4,
                            PrimitiveTemplate *a5) {
  void *v5;    // eax
  int v6;      // ebx
  float v7;    // [esp+10h] [ebp-38h]
  float v8[3]; // [esp+28h] [ebp-20h] BYREF
  float v9;    // [esp+34h] [ebp-14h] BYREF
  float v10;   // [esp+38h] [ebp-10h]
  float v11;   // [esp+3Ch] [ebp-Ch]

  v5 = (void *)operator new[](0x24Cu);
  v6 = (int)v5;
  if (v5)
    memset(v5, 0, 0x24Cu);
  Particle::Particle((Particle *)v6);
  if (v6) {
    if ((unsigned __int8)FX_AddPrimitive(a1, v6, (int)a3)) {
      FX_InitParticle((int)a1, v6, &v9, a3, a2);
      FX_SetMaterialAndSequenceParams(
          (int)a1[1].mFramePtr, v6,
          *(_DWORD *)(v6 + 188) - *(_DWORD *)(v6 + 184), a5);
      if (a4 > 0) {
        v7 = (float)a4 * 0.001;
        Particle::IntegrateTotalVelocity((Particle *)v6, a4, v8);
        v9 = (float)(v7 * v8[0]) + v9;
        v10 = (float)(v7 * v8[1]) + v10;
        v11 = (float)(v7 * v8[2]) + v11;
      }
      *(float *)(v6 + 4) = v9;
      *(float *)(v6 + 8) = v10;
      *(float *)(v6 + 12) = v11;
    } else {
      (*(void(__cdecl **)(int))(*(_DWORD *)v6 + 4))(v6);
    }
  }
}

void __cdecl FX_AddTail(FxBoltFramePtr *a1, EffectPrimitive *a2,
                        EffectPrimitive *a3, int a4, PrimitiveTemplate *a5) {
  void *v5;     // eax
  int v6;       // ebx
  float v7;     // xmm3_4
  float v8;     // xmm1_4
  float v9;     // xmm0_4
  float v10;    // [esp+10h] [ebp-48h]
  float v11[3]; // [esp+28h] [ebp-30h] BYREF
  float v12;    // [esp+34h] [ebp-24h] BYREF
  float v13;    // [esp+38h] [ebp-20h]
  float v14;    // [esp+3Ch] [ebp-1Ch]

  v5 = (void *)operator new[](0x278u);
  v6 = (int)v5;
  if (v5)
    memset(v5, 0, 0x278u);
  Tail::Tail((Tail *)v6);
  if (v6) {
    if ((unsigned __int8)FX_AddPrimitive(a1, v6, (int)a3)) {
      FX_InitParticle((int)a1, v6, &v12, a3, a2);
      FX_SetMaterialAndSequenceParams(
          (int)a1[1].mFramePtr, v6,
          *(_DWORD *)(v6 + 188) - *(_DWORD *)(v6 + 184), a5);
      if (a4 > 0) {
        v10 = (float)a4 * 0.001;
        Particle::IntegrateTotalVelocity((Particle *)v6, a4, v11);
        v12 = (float)(v10 * v11[0]) + v12;
        v13 = (float)(v10 * v11[1]) + v13;
        v14 = (float)(v10 * v11[2]) + v14;
      }
      v7 = v12 - *(float *)&a2->fx;
      v8 = v13 - *(float *)&a2->primTemp;
      v9 = v14 - *(float *)&a2->boltFrame;
      *(float *)(v6 + 4) = v12;
      *(float *)(v6 + 8) = v13;
      *(float *)(v6 + 12) = v14;
      *(float *)(v6 + 588) = v7;
      *(float *)(v6 + 592) = v8;
      *(float *)(v6 + 596) = v9;
      *(float *)(v6 + 604) = flrand(0.0, 1.0);
      Tail::InitEndPoint((Tail *)v6);
    } else {
      (*(void(__cdecl **)(int))(*(_DWORD *)v6 + 4))(v6);
    }
  }
}

void __cdecl FX_AddEmitter(FxBoltFramePtr *a1, EffectPrimitive *a2,
                           EffectPrimitive *a3, int a4) {
  void *v4;                   // eax
  int v5;                     // ebx
  int32_t mFramePtr;          // esi
  orientation_t *Orientation; // eax
  float v8;                   // [esp+1Ch] [ebp-8Ch]
  float v9;                   // [esp+20h] [ebp-88h]
  int Handle;                 // [esp+38h] [ebp-70h]
  int Effect;                 // [esp+3Ch] [ebp-6Ch]
  float v12;                  // [esp+40h] [ebp-68h]
  float v13;                  // [esp+44h] [ebp-64h]
  float v14;                  // [esp+48h] [ebp-60h]
  float v15;                  // [esp+4Ch] [ebp-5Ch]
  float v16;                  // [esp+50h] [ebp-58h]
  float Val;                  // [esp+54h] [ebp-54h]
  float v18;                  // [esp+54h] [ebp-54h]
  float v19;                  // [esp+58h] [ebp-50h]
  float v20;                  // [esp+58h] [ebp-50h]
  float v21;                  // [esp+5Ch] [ebp-4Ch]
  float v22;                  // [esp+5Ch] [ebp-4Ch]
  float v23[3];               // [esp+60h] [ebp-48h] BYREF
  float v24[3];               // [esp+6Ch] [ebp-3Ch] BYREF
  float v25;                  // [esp+78h] [ebp-30h] BYREF
  float v26;                  // [esp+7Ch] [ebp-2Ch]
  float v27;                  // [esp+80h] [ebp-28h]
  float v28[9];               // [esp+84h] [ebp-24h] BYREF

  v4 = (void *)operator new[](0x29Cu);
  v5 = (int)v4;
  if (v4)
    memset(v4, 0, 0x29Cu);
  Emitter::Emitter((Emitter *)v5);
  if (v5) {
    if ((unsigned __int8)FX_AddPrimitive(a1, v5, (int)a3)) {
      FX_InitParticle((int)a1, v5, &v25, a3, a2);
      mFramePtr = (int32_t)a1[1].mFramePtr;
      if (a4 > 0) {
        v9 = (float)a4 * 0.001;
        Particle::IntegrateTotalVelocity((Particle *)v5, a4, v23);
        v25 = (float)(v9 * v23[0]) + v25;
        v26 = (float)(v9 * v23[1]) + v26;
        v27 = (float)(v9 * v23[2]) + v27;
      }
      Val = FxRange::GetVal((FxRange *)(mFramePtr + 568));
      v19 = FxRange::GetVal((FxRange *)(mFramePtr + 560));
      v21 = FxRange::GetVal((FxRange *)(mFramePtr + 552));
      vectoangles((float *)&a2->fx, v28);
      v22 = v21 + v28[0];
      v20 = v19 + v28[1];
      v18 = Val + v28[2];
      v14 = FxRange::GetVal((FxRange *)(mFramePtr + 592));
      v15 = FxRange::GetVal((FxRange *)(mFramePtr + 584));
      v16 = FxRange::GetVal((FxRange *)(mFramePtr + 576));
      Handle = MediaHandles::GetHandle((MediaHandles *)(mFramePtr + 104));
      Effect = MediaHandles::GetEffect((MediaHandles *)(mFramePtr + 128));
      v12 = FxRange::GetVal((FxRange *)(mFramePtr + 608));
      v13 = FxRange::GetVal((FxRange *)(mFramePtr + 616));
      if (a1[2].mFramePtr) {
        Orientation =
            FxBoltFrame::GetOrientation((FxBoltFrame *)a1[2].mFramePtr);
        if (Orientation) {
          *(float *)(v5 + 612) = Orientation->origin[0];
          *(float *)(v5 + 616) = Orientation->origin[1];
          *(float *)(v5 + 620) = Orientation->origin[2];
        } else {
          *(_DWORD *)(v5 + 612) = 0;
          *(_DWORD *)(v5 + 616) = 0;
          *(_DWORD *)(v5 + 620) = 0;
        }
      } else {
        *(_DWORD *)(v5 + 612) = 0;
        *(_DWORD *)(v5 + 616) = 0;
        *(_DWORD *)(v5 + 620) = 0;
      }
      if (!Handle)
        *(_DWORD *)(v5 + 168) &= ~0x10u;
      Particle::GetTotalVelocityAtTime0((Particle *)v5, v24);
      *(float *)(v5 + 4) = v25;
      *(float *)(v5 + 8) = v26;
      *(float *)(v5 + 12) = v27;
      *(float *)(v5 + 588) = v25;
      *(float *)(v5 + 592) = v26;
      *(float *)(v5 + 596) = v27;
      *(float *)(v5 + 600) = v24[0];
      *(float *)(v5 + 604) = v24[1];
      *(float *)(v5 + 608) = v24[2];
      *(float *)(v5 + 632) = v22;
      *(float *)(v5 + 636) = v20;
      *(float *)(v5 + 640) = v18;
      *(float *)(v5 + 644) = v16;
      *(float *)(v5 + 648) = v15;
      *(float *)(v5 + 652) = v14;
      *(_DWORD *)(v5 + 180) = Handle;
      *(_DWORD *)(v5 + 656) = Effect;
      *(float *)(v5 + 660) = v12;
      *(float *)(v5 + 664) = v13;
      *(_DWORD *)(v5 + 624) = theFxHelper->mTime;
      v8 = crandom();
      *(float *)(v5 + 628) = (float)(v8 * *(float *)(v5 + 664)) + v12;
    } else {
      (*(void(__cdecl **)(int))(*(_DWORD *)v5 + 4))(v5);
    }
  }
}

void __cdecl FX_AddOrientedParticle(FxBoltFramePtr *a1, EffectPrimitive *a2,
                                    EffectPrimitive *a3, int a4,
                                    PrimitiveTemplate *a5) {
  void *v5;                   // eax
  int v6;                     // ebx
  int32_t fx;                 // edx
  orientation_t *Orientation; // eax
  float v9;                   // [esp+10h] [ebp-58h]
  float v10[3];               // [esp+20h] [ebp-48h] BYREF
  float v11[3];               // [esp+2Ch] [ebp-3Ch] BYREF
  int32_t v12;                // [esp+38h] [ebp-30h] BYREF
  int32_t primTemp;           // [esp+3Ch] [ebp-2Ch]
  int32_t boltFrame;          // [esp+40h] [ebp-28h]
  float v15;                  // [esp+44h] [ebp-24h] BYREF
  float v16;                  // [esp+48h] [ebp-20h]
  float v17;                  // [esp+4Ch] [ebp-1Ch]

  v5 = (void *)operator new[](0x258u);
  v6 = (int)v5;
  if (v5)
    memset(v5, 0, 0x258u);
  OrientedParticle::OrientedParticle((OrientedParticle *)v6);
  if (v6) {
    if ((unsigned __int8)FX_AddPrimitive(a1, v6, (int)a3)) {
      FX_InitParticle((int)a1, v6, &v15, a3, a2);
      FX_SetMaterialAndSequenceParams(
          (int)a1[1].mFramePtr, v6,
          *(_DWORD *)(v6 + 188) - *(_DWORD *)(v6 + 184), a5);
      if (a4 > 0) {
        v9 = (float)a4 * 0.001;
        Particle::IntegrateTotalVelocity((Particle *)v6, a4, v10);
        v15 = (float)(v9 * v10[0]) + v15;
        v16 = (float)(v9 * v10[1]) + v16;
        v17 = (float)(v9 * v10[2]) + v17;
      }
      fx = a2->fx;
      v12 = a2->fx;
      primTemp = a2->primTemp;
      boltFrame = a2->boltFrame;
      if (a1[2].mFramePtr) {
        Orientation =
            FxBoltFrame::GetOrientation((FxBoltFrame *)a1[2].mFramePtr);
        OrientationDirFromWorldDir(Orientation->origin, (float *)&v12, v11);
        *(float *)(v6 + 588) = v11[0];
        *(float *)(v6 + 592) = v11[1];
        *(float *)(v6 + 596) = v11[2];
      } else {
        *(_DWORD *)(v6 + 588) = fx;
        *(_DWORD *)(v6 + 592) = primTemp;
        *(_DWORD *)(v6 + 596) = boltFrame;
      }
      *(float *)(v6 + 4) = v15;
      *(float *)(v6 + 8) = v16;
      *(float *)(v6 + 12) = v17;
    } else {
      (*(void(__cdecl **)(int))(*(_DWORD *)v6 + 4))(v6);
    }
  }
}

void __cdecl FX_CleanTemplate(EffectTemplate *a1) {
  EffectTemplate *v1; // ebx
  signed int v2;      // esi

  if ((int)a1->mPrimitiveCount > 0) {
    v1 = a1;
    v2 = 0;
    do {
      PrimitiveTemplate::Shutdown(*(PrimitiveTemplate **)v1->mPrimitives);
      ++v2;
      v1 = (EffectTemplate *)((char *)v1 + 4);
    } while ((signed int)a1->mPrimitiveCount > v2);
  }
}

void Server_SwitchToValidFxScheduler(void) { ; }

void FX_InitTemplates(void) { effectTemplateArrayCount = 0; }

void *__cdecl CM_Hunk_Alloc(size_t __len) { return Hunk_AllocInternal(__len); }

void CM_Hunk_CheckTempMemoryClear(void) { ; }

void CM_Hunk_CheckTempMemoryHighClear(void) { ; }

int CM_Hunk_ClearTempMemory(void) { return Hunk_ClearTempMemory(); }

int CM_Hunk_ClearTempMemoryHigh(void) { return Hunk_ClearTempMemoryHigh(); }

void __usercall CM_SaveLump(long double a1 @<st0>, float a2 @<xmm0>,
                            __m128 a3 @<xmm1>, __m128 a4 @<xmm2>,
                            __m128 a5 @<xmm3>, __m128 a6 @<xmm4>,
                            __m128 a7 @<xmm6>, int a8, unsigned __int8 *a9,
                            int a10, int *a11) {
  unsigned int v11; // ebx
  int i;            // eax
  int v13;          // ecx
  int j;            // edx
  int k;            // eax
  int m;            // eax
  int v17;          // esi
  int v18;          // ebx
  size_t v19;       // ecx
  char *v20;        // edx
  size_t v21;       // edx
  size_t File;      // eax
  _BYTE v23[320];   // [esp+14h] [ebp-2A4h] BYREF
  _DWORD __dst[80]; // [esp+154h] [ebp-164h] BYREF
  int v25;          // [esp+294h] [ebp-24h] BYREF
  int v26;          // [esp+298h] [ebp-20h] BYREF
  void *__src;      // [esp+29Ch] [ebp-1Ch] BYREF

  v11 = FS_FOpenFileRead(cm, &v25, 0);
  if (!v25)
    Com_Error(a1, a2, a3, a4, a5, a6, a7, 1, "EXE_ERR_COULDNT_LOAD\x15%s", cm);
  __src = Z_MallocInternal(v11 + 1);
  FS_Read((char *)__src, v11, v25);
  *((_BYTE *)__src + v11) = 0;
  FS_FCloseFile(v25);
  memcpy(__dst, __src, sizeof(__dst));
  if (__dst[1] == 4 || __dst[1] == 61) {
    for (i = 1; i != 40; ++i)
      ;
    memcpy(v23, __dst, sizeof(v23));
    v25 = FS_OpenFileOverwrite(a1, a2, a3, a4, a5, a6, a7, cm);
    if (v25) {
      v13 = 320;
      for (j = 0; j != 39; ++j) {
        while (a8 != j) {
          __dst[2 * j + 3] = v13;
          v13 += (__dst[2 * j++ + 2] + 3) & 0xFFFFFFFC;
          if (j == 39)
            goto LABEL_14;
        }
        __dst[2 * a8 + 2] = a10;
        __dst[2 * j + 3] = v13;
        v13 += (__dst[2 * j + 2] + 3) & 0xFFFFFFFC;
      }
    LABEL_14:
      for (k = 1; k != 40; ++k)
        ;
      FS_Write((char *)__dst, 0x140u, v25);
      for (m = 1; m != 40; ++m)
        ;
      v26 = 0;
      v17 = 0;
      v18 = 0;
      do {
        while (1) {
          v19 = __dst[v18 + 2];
          if (v19) {
            v20 = a8 == v17 ? (char *)a9
                            : (char *)__src + *(_DWORD *)&v23[v18 * 4 + 12];
            FS_Write(v20, v19, v25);
            v21 = ((__dst[v18 + 2] + 3) & 0xFFFFFFFC) - __dst[v18 + 2];
            if (v21)
              break;
          }
          ++v17;
          v18 += 2;
          if (v17 == 39)
            goto LABEL_25;
        }
        FS_Write((char *)&v26, v21, v25);
        ++v17;
        v18 += 2;
      } while (v17 != 39);
    LABEL_25:
      FS_FCloseFile(v25);
      Z_FreeInternal(__src);
      if (a11) {
        File = FS_ReadFile(cm, (char **)&__src);
        *a11 = Com_BlockChecksum((unsigned __int8 *)__src, File);
        FS_FreeFile(__src);
      }
    } else {
      Com_Error(a1, a2, a3, a4, a5, a6, a7, 1,
                "Failed to open file %s for writing", cm);
    }
  } else {
    Com_Error(a1, a2, a3, a4, a5, a6, a7, 1, "bad bsp version %d", __dst[1]);
  }
}

int __cdecl DObjBad(const DObj_s *a1) {
  int v1;            // eax
  const XModel **v2; // ebx
  int v3;            // esi
  int numModels;     // edi

  v1 = a1->numModels - 1;
  if (v1 < 0)
    return 0;
  v2 = (const XModel **)&a1->models[4 * v1];
  v3 = 0;
  numModels = a1->numModels;
  while (!XModelBad(*v2)) {
    ++v3;
    --v2;
    if (v3 == numModels)
      return 0;
  }
  return 1;
}

int Win_InitLocalization(void) {
  FILE *v0;  // eax
  FILE *v1;  // esi
  size_t v2; // ebx
  size_t v3; // ebx
  char *v4;  // eax
  char *v5;  // edx
  char v6;   // cl
  int v8[3]; // [esp+1Ch] [ebp-Ch] BYREF

  localization = 0;
  dword_4E9604 = 0;
  v0 = FS_FileOpen("localization.txt", "r");
  v1 = v0;
  if (!v0)
    return 0;
  FS_FileSeek(v0, 0, 2);
  v2 = ftell(v1);
  FS_FileSeek(v1, 0, 0);
  localization = (char *)&language_buffer;
  v3 = FS_FileRead(&language_buffer, 1u, v2, v1);
  FS_FileClose(v1);
  if (!v3) {
    localization = 0;
    return 0;
  }
  v4 = localization;
  localization[v3] = 0;
  v8[0] = 0;
  if (*v4) {
    if (*v4 == 10) {
    LABEL_8:
      *v4 = 0;
      dword_4E9604 = (int)(v4 + 1);
      SEH_GetLanguageIndexForName(localization, v8);
    } else {
      v5 = v4 + 1;
      while (1) {
        v4 = v5;
        v6 = *v5;
        if (!*v5)
          break;
        ++v5;
        if (v6 == 10)
          goto LABEL_8;
      }
    }
  }
  return v8[0];
}

void Win_ShutdownLocalization(void) {
  localization = 0;
  dword_4E9604 = 0;
}

char *__cdecl Win_LocalizeRef(char *__s2) {
  char *v1;    // eax
  int v2;      // esi
  char *v3;    // ebx
  char *v5[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  Com_BeginParseSession("localization");
  v5[0] = (char *)dword_4E9604;
  while (1) {
    v1 = Com_Parse(v5);
    if (!*v1)
      break;
    v2 = strcmp(v1, __s2);
    v3 = Com_Parse(v5);
    if (!*v3)
      break;
    if (!v2) {
      Com_EndParseSession();
      return va("%s", v3);
    }
  }
  Com_EndParseSession();
  return va("%s", __s2);
}

void CM_Cleanup(void) { dword_4EA68C = 0; }

int __cdecl CM_GetPlaneNum(int a1) { return dword_4EA688 + 20 * a1; }

void *__cdecl Hunk_AllocXAnimTreePrecache(size_t __len) {
  return Hunk_AllocAlignInternal(__len, 4);
}

playerState_s *__cdecl Jump_ClearState(playerState_s *a1) {
  playerState_s *result; // eax

  result = a1;
  a1->pm_flags &= ~0x80000u;
  a1->jumpOriginZ = 0;
  return result;
}

int __cdecl Jump_GetStepHeight(playerState_s *a1, const float *a2, float *a3) {
  int v3;   // edx
  float v4; // xmm0_4
  float v5; // xmm2_4
  float v6; // xmm1_4

  v3 = jump_height;
  if ((float)(*(float *)&a1->jumpOriginZ + *(float *)(jump_height + 8)) <=
      a2[2])
    return 0;
  v4 = *(float *)(jump_stepSize + 8);
  *a3 = v4;
  v5 = a2[2];
  v6 = *(float *)&a1->jumpOriginZ + *(float *)(v3 + 8);
  if ((float)(v4 + v5) > v6)
    *a3 = v6 - v5;
  return 1;
}

_BOOL4 __cdecl Jump_IsPlayerAboveMax(playerState_s *a1) {
  return a1->origin[2] >=
         (float)(*(float *)&a1->jumpOriginZ + *(float *)(jump_height + 8));
}

playerState_s *__cdecl Jump_ActivateSlowdown(playerState_s *a1) {
  playerState_s *result; // eax

  result = a1;
  if (!a1->pm_time) {
    a1->pm_flags |= 0x80000u;
    a1->pm_time = 1800;
  }
  return result;
}

float *__cdecl Jump_ApplySlowdown(playerState_s *a1) {
  signed int pm_time; // eax
  float v2;           // xmm1_4
  float *result;      // eax

  pm_time = a1->pm_time;
  if (pm_time <= 1800) {
    if (pm_time) {
      v2 = 1.0;
    } else if ((float)(*(float *)&a1->jumpOriginZ + 18.0) > a1->origin[2]) {
      a1->pm_time = 1800;
      v2 = 0.64999998;
    } else {
      a1->pm_time = 1200;
      v2 = 0.5;
    }
  } else {
    a1->pm_flags &= ~0x80000u;
    a1->jumpOriginZ = 0;
    v2 = 0.64999998;
  }
  if (!*(_BYTE *)(jump_slowdownEnable + 8))
    v2 = 1.0;
  result = a1->velocity;
  a1->velocity[0] = v2 * a1->velocity[0];
  a1->velocity[1] = v2 * a1->velocity[1];
  a1->velocity[2] = v2 * a1->velocity[2];
  return result;
}

long double __cdecl Jump_ReduceFriction(playerState_s *a1) {
  signed int pm_time; // edx

  pm_time = a1->pm_time;
  if (pm_time > 1800) {
    a1->pm_flags &= ~0x80000u;
    a1->jumpOriginZ = 0;
    return 1.0;
  }
  if (!*(_BYTE *)(jump_slowdownEnable + 8))
    return 1.0;
  if (pm_time > 1699)
    return 2.5;
  else
    return (float)((float)((float)((float)pm_time * 1.5) * 0.00058823527) +
                   1.0);
}

const float *__cdecl Jump_ClampVelocity(playerState_s *a1, const float *a2) {
  const float *result; // eax
  float v3;            // xmm1_4
  float v4;            // xmm1_4

  result = a2;
  if ((float)(a1->origin[2] - a2[2]) > 0.0) {
    result = (const float *)jump_height;
    v3 = (float)(*(float *)&a1->jumpOriginZ + *(float *)(jump_height + 8)) -
         a1->origin[2];
    if (v3 >= 0.1) {
      v4 = fsqrt((float)(v3 + v3) * (float)a1->gravity);
      if (a1->velocity[2] > v4)
        a1->velocity[2] = v4;
    } else {
      a1->velocity[2] = 0.0;
    }
  }
  return result;
}

void *__cdecl MantleXAnimPrecacheAlloc(size_t __len) {
  return Hunk_AllocAlignInternal(__len, 4);
}

_DWORD *__cdecl FxCurve_AllocAndCreateWithKeys(const float *__src, int a2,
                                               int a3) {
  bool v3;     // bl
  bool v4;     // di
  _DWORD *v5;  // esi
  int v6;      // ebx
  int v7;      // eax
  int v8;      // eax
  int v9;      // ecx
  int v10;     // edx
  _DWORD *v12; // edx
  int i;       // ecx
  int v14;     // [esp+1Ch] [ebp-1Ch]

  v14 = a2 + 1;
  v3 = *__src != 0.0;
  v4 = *(const float *)((char *)__src + (a2 + 1) * (4 * a3 - 4)) != 1.0;
  v5 = Hunk_AllocAlignInternal(4 * (a2 + 1) * (a3 + v3 + v4) + 8, 4);
  *v5 = a2;
  if (v3) {
    v5[2] = 0;
    if (a2) {
      v12 = v5;
      for (i = 0; i != a2; ++i) {
        v12[3] = LODWORD(__src[i + 1]);
        ++v12;
      }
    }
    v7 = a2 + 1;
    v6 = 1;
  } else {
    v6 = 0;
    v7 = 0;
  }
  memcpy(&v5[v7 + 2], __src, 4 * a3 * v14);
  if (v4) {
    v8 = v14 * (v6 + a3);
    v5[v8 + 2] = 1065353216;
    if (a2) {
      v9 = 0;
      v10 = (int)&v5[v8 + 2];
      do {
        *(float *)(v10 + 4) = __src[++v9];
        v10 += 4;
      } while (a2 != v9);
    }
    v5[1] = a3;
    return v5;
  } else {
    v5[1] = a3;
    return v5;
  }
}

FxRange *__cdecl FxChannel_CreateDefault(FxChannel *a1, int a2, float a3,
                                         float a4) {
  int v4;      // ecx
  float *v5;   // eax
  float *v6;   // edx
  float __src; // [esp+10h] [ebp-58h] BYREF
  char v9;     // [esp+14h] [ebp-54h] BYREF

  __src = 0.0;
  *(&__src + a2 + 1) = 1.0;
  if (a2) {
    v4 = 0;
    v5 = &__src + a2 + 1;
    v6 = (float *)&v9;
    do {
      *v6 = a3;
      v5[1] = a4;
      ++v4;
      ++v6;
      ++v5;
    } while (v4 != a2);
  }
  a1->curve = (int32_t)FxCurve_AllocAndCreateWithKeys(&__src, a2, 2);
  return FxRange::SetRange((FxRange *)&a1->scaleRange, 1065353216, 1065353216);
}

_DWORD *__cdecl FxChannel_CreateViaMigration(FxRange *a1, int a2, float a3,
                                             char a4, FxChannel *a5) {
  float v5;         // xmm2_4
  float v6;         // xmm0_4
  float *p_mMin;    // edi
  FxRange *v8;      // esi
  float v9;         // xmm0_4
  float v10;        // xmm0_4
  uint32_t mMin;    // eax
  int v12;          // esi
  float v13;        // xmm4_4
  int v14;          // edi
  float v15;        // xmm3_4
  float v16;        // xmm2_4
  float *v17;       // ebx
  int m;            // edx
  float v19;        // xmm1_4
  float v20;        // xmm4_4
  _DWORD *result;   // eax
  int v22;          // eax
  float *v23;       // ebx
  float *v24;       // ecx
  int v25;          // edx
  int v26;          // ebx
  float *v27;       // edx
  int v28;          // ecx
  __m128 v29;       // xmm2
  __m128 v30;       // rt1
  __m128 v31;       // xmm2
  float v32;        // xmm1_4
  float v33;        // eax
  int k;            // edx
  int v35;          // eax
  float v36;        // [esp+1Ch] [ebp-2BCh]
  float v37;        // [esp+1Ch] [ebp-2BCh]
  float v38;        // [esp+1Ch] [ebp-2BCh]
  float v39;        // [esp+1Ch] [ebp-2BCh]
  unsigned int v40; // [esp+1Ch] [ebp-2BCh]
  char v41;         // [esp+77h] [ebp-261h]
  int v42;          // [esp+7Ch] [ebp-25Ch]
  float ValPct;     // [esp+80h] [ebp-258h]
  int i;            // [esp+88h] [ebp-250h]
  float v45;        // [esp+8Ch] [ebp-24Ch]
  float v46;        // [esp+90h] [ebp-248h]
  float v47;        // [esp+94h] [ebp-244h]
  int v48;          // [esp+98h] [ebp-240h]
  int j;            // [esp+9Ch] [ebp-23Ch]
  float __src[140]; // [esp+A8h] [ebp-230h] BYREF

  if (a4 || (ValPct = FxRange::GetValPct(a1 + 3, 0.5),
             *(float *)&v40 = FxRange::GetValPct(a1, 0.5), v29 = (__m128)v40,
             v29.f32[0] = *(float *)&v40 - ValPct, v30.i32[0] = 0,
             v31 = _mm_cmplt_ss(v29, v30),
             v5 = COERCE_FLOAT(_mm_andnot_ps(v31, (__m128)v40).u32[0] |
                               LODWORD(ValPct) & v31.i32[0]) *
                  1.3333334,
             v5 < 1.0)) {
    v45 = 1.0;
    v5 = 1.0;
  } else {
    v45 = 1.0 / v5;
  }
  v6 = (float)(*(float *)&a1->mMax - *(float *)&a1->mMin) * 0.5;
  FxRange::SetRange((FxRange *)&a5->scaleRange, COERCE_INT32_T(v5 - v6),
                    COERCE_INT32_T(v5 + v6));
  if (a2) {
    v42 = 0;
    p_mMin = (float *)&a1[3].mMin;
    v8 = a1;
    do {
      v36 = FxRange::GetValPct(v8, 0.5);
      __src[v42 + 131] = v36 * v45;
      v37 = FxRange::GetValPct((FxRange *)p_mMin, 0.5);
      __src[v42 + 128] = v37 * v45;
      v38 = FxRange::GetValPct(a1 + 6, 0.5);
      v9 = v38 * v45;
      ++v42;
      ++v8;
      p_mMin += 2;
    } while (a2 != v42);
    v46 = v9 * 0.0099999998;
    v10 = v9 * 0.003141593;
  } else {
    v46 = 0.0;
    v10 = 0.0;
  }
  mMin = a1[7].mMin;
  v41 = mMin & 1;
  if ((mMin & 1) == 0) {
    v12 = mMin & 0xC;
    if (v12 != 4)
      goto LABEL_9;
    v22 = a2 + 1;
    __src[0] = 0.0;
    __src[v22] = v46;
    __src[2 * v22] = 1.0;
    if (a2) {
      LOWORD(v12) = 0;
      v23 = &__src[v22];
      v24 = &__src[2 * v22];
      v25 = 0;
      do {
        ++v12;
        ++v25;
        __src[v25] = __src[v25 + 130];
        v23[1] = __src[v25 + 130];
        v24[1] = __src[v25 + 127];
        ++v23;
        ++v24;
      } while (a2 != v12);
    }
    result = FxCurve_AllocAndCreateWithKeys(__src, a2, 3);
  LABEL_41:
    a5->curve = (int32_t)result;
    return result;
  }
  v12 = mMin & 0xC;
  if ((mMin & 0xC) == 0) {
    __src[0] = 0.0;
    __src[a2 + 1] = 1.0;
    if (a2) {
      v26 = 0;
      v27 = &__src[a2 + 1];
      v28 = 0;
      do {
        ++v26;
        ++v28;
        __src[v28] = __src[v28 + 130];
        v27[1] = __src[v28 + 127];
        ++v27;
      } while (a2 != v26);
    }
    result = FxCurve_AllocAndCreateWithKeys(__src, a2, 2);
    goto LABEL_41;
  }
LABEL_9:
  v48 = (mMin >> 1) & 1;
  v13 = 0.0;
  v14 = 0;
  if (!v41)
    goto LABEL_23;
LABEL_10:
  v15 = 1.0 - v13;
  if (v12 != 4) {
  LABEL_11:
    if (v12 != 8) {
      if (v12 != 12) {
        v16 = v15;
        goto LABEL_14;
      }
      v16 = 0.0;
      if (v46 > v13)
        v16 = (float)(v46 - v13) / v46;
      goto LABEL_26;
    }
    v39 = cosf((float)(v10 * a3) * v13);
    v16 = v39 * v15;
    goto LABEL_14;
  }
  while (1) {
    v16 = 1.0;
    if (v13 > v46)
      v16 = 1.0 - (float)((float)(v13 - v46) / (float)(1.0 - v46));
  LABEL_26:
    if (v41)
      v16 = (float)(v16 * 0.5) + (float)(v15 * 0.5);
  LABEL_14:
    v17 = &__src[v14 * (a2 + 1)];
    *v17 = v13;
    if (a2) {
      v47 = 1.0 - v16;
      if (v48) {
        if (v16 > 1.0) {
          for (i = 0; i != a2; ++i) {
            v33 = 1.0;
            if ((float)((float)(v16 * __src[i + 131]) +
                        (float)(v47 * __src[i + 128])) < 0.0)
              v33 = 0.0;
            v17[i + 1] = flrand(0.0, v33);
          }
        } else {
          for (j = 0; j != a2; ++j) {
            v32 = (float)(v16 * __src[j + 131]) + (float)(v47 * __src[j + 128]);
            if (v32 < 0.0)
              v32 = 0.0;
            v17[j + 1] = flrand(0.0, v32);
          }
        }
      } else if (v16 > 1.0) {
        for (k = 0; k != a2; ++k) {
          if ((float)((float)(v16 * __src[k + 131]) +
                      (float)(v47 * __src[k + 128])) < 0.0)
            v35 = 0;
          else
            v35 = 1065353216;
          LODWORD(v17[k + 1]) = v35;
        }
      } else {
        for (m = 0; m != a2; ++m) {
          while (1) {
            v19 = (float)(v47 * __src[m + 128]) + (float)(v16 * __src[m + 131]);
            if (v19 < 0.0)
              break;
            v17[++m] = v19;
            if (a2 == m)
              goto LABEL_21;
          }
          v17[m + 1] = 0.0;
        }
      }
    }
  LABEL_21:
    ++v14;
    v20 = v13 + 0.06666667;
    if (v14 == 16)
      break;
    v13 = fminf(1.0, v20);
    if (v41)
      goto LABEL_10;
  LABEL_23:
    v15 = 1.0;
    if (v12 != 4)
      goto LABEL_11;
  }
  result = FxCurve_AllocAndCreateWithKeys(__src, a2, 16);
  a5->curve = (int32_t)result;
  return result;
}

void __usercall Com_LoadSoundAliases(long double a1 @<st0>, float a2 @<xmm0>,
                                     __m128 a3 @<xmm1>, __m128 a4 @<xmm2>,
                                     __m128 a5 @<xmm3>, __m128 a6 @<xmm4>,
                                     __m128 a7 @<xmm6>, char *__src,
                                     const char *a9, snd_alias_system_t a10) {
  void **v10;           // esi
  int v11;              // edi
  int SoundAliasSounds; // edx
  char *v13;            // eax
  void **v14;           // ebx
  char *v15;            // esi
  int v16;              // ebx
  SndCurve *v17;        // [esp+34h] [ebp-74h]
  void **v18;           // [esp+38h] [ebp-70h]
  int v19;              // [esp+3Ch] [ebp-6Ch]
  char __dst[64];       // [esp+48h] [ebp-60h] BYREF
  char v21[4];          // [esp+88h] [ebp-20h] BYREF
  int v22[7];           // [esp+8Ch] [ebp-1Ch] BYREF

  if (!byte_114F530) {
    memset(&stru_114F534, 0, 0x480u);
    Com_InitDefaultSoundAliasVolumeFalloffCurve(&stru_114F534);
    v18 = (void **)FS_ListFiles("soundaliases", "vfcurve", FS_LIST_PURE_ONLY,
                                (int *)v21);
    if (*(int *)v21 > 15)
      Com_Error(a1, a2, a3, a4, a5, a6, a7, 1,
                "\x15Snd_Alias Curve initialization: '.vfcurve' file count "
                "(%d) exceeds maximum (%d)",
                *(_DWORD *)v21, 15);
    v19 = 0;
    v17 = &stru_114F534;
    v14 = v18;
    v15 = (char *)&unk_114F9B4;
    while (v19 < *(int *)v21) {
      while (1) {
        ++v19;
        v15 += 64;
        ++v14;
        ++v17;
        I_strncpyz(v15, (char *)*(v14 - 1),
                   strlen((const char *)*(v14 - 1)) - 7);
        if ((unsigned __int8)Com_LoadVolumeFalloffCurve(v15, v17))
          break;
        Com_Error(a1, a2, a3, a4, a5, a6, a7, 0,
                  "\x15Failed to load sndcurve file '%s'",
                  (const char *)*(v14 - 1));
        if (v19 >= *(int *)v21)
          goto LABEL_27;
      }
    }
  LABEL_27:
    FS_FreeFileList(v18);
    byte_114F530 = 1;
  }
  if (!strnicmp(__src, "maps/mp/", 8u)) {
    Com_StripExtension(__src + 8, __dst);
  } else {
    if (strnicmp(__src, "maps/", 5u)) {
      strcpy(__dst, __src);
      strlwr(__dst);
      if (a10 != SASYS_CGAME)
        goto LABEL_5;
      goto LABEL_14;
    }
    Com_StripExtension(__src + 5, __dst);
  }
  strlwr(__dst);
  if (a10 != SASYS_CGAME)
    goto LABEL_5;
LABEL_14:
  if (*(_BYTE *)(com_sv_running + 8)) {
    dword_114F4B8 = dword_114F4C8;
    dword_114F4BC = dword_114F4CC;
    dword_114F4C0 = dword_114F4D0;
    dword_114F4C4 = dword_114F4D4;
    dword_114F4E0 = dword_114F4E8;
    dword_114F4E4 = dword_114F4EC;
  LABEL_16:
    if (!g_sa[0])
      Cmd_AddCommand("snd_list", Com_SoundList_f);
    goto LABEL_8;
  }
LABEL_5:
  v10 = (void **)FS_ListFiles("soundaliases", "csv", FS_LIST_PURE_ONLY, v22);
  if (!v22[0]) {
    Com_Printf(
        "WARNING: can't find any sound alias files (soundaliases/*.csv)\n");
    return;
  }
  v11 = Hunk_HideTempMemory();
  Com_InitSoundAlias();
  if (v22[0] > 0) {
    v16 = 0;
    do
      Com_LoadSoundAliasFile(a1, a2, a3, a4, a5, a6, a7, __dst, a9,
                             (char *)v10[v16++]);
    while (v16 < v22[0]);
  }
  Com_MakeSoundAliasesPermanent((snd_alias_list_t *)(16 * a10 + 18150568),
                                &stru_114F4D8 + a10);
  Hunk_ClearTempMemory();
  Hunk_ShowTempMemory(v11);
  FS_FreeFileList(v10);
  if ((unsigned int)a10 <= SASYS_CGAME)
    goto LABEL_16;
LABEL_8:
  *((_BYTE *)g_sa + a10) = 1;
  if ((unsigned int)a10 <= SASYS_CGAME) {
    SoundAliasSounds = Com_LoadSoundAliasSounds(a1, a2, a3, a4, a5, a6, a7,
                                                &stru_114F4D8 + a10);
    if (SoundAliasSounds) {
      if (*(_BYTE *)(snd_errorOnMissing[0] + 8)) {
        v13 = va("\x15%i sound file(s) are missing or in a bad format\n",
                 SoundAliasSounds);
        Com_Error(a1, a2, a3, a4, a5, a6, a7, a10 != SASYS_UI, v13);
      }
    }
  }
}

void *__cdecl Com_AllocateTempSoundMemory(size_t __size) {
  return Hunk_AllocateTempMemoryInternal(__size);
}

void *__cdecl Com_AllocSoundMemory(size_t __len) {
  return Hunk_AllocInternal(__len);
}

int __cdecl Com_UnloadSoundAliasSounds(snd_alias_system_t a1) {
  int result; // eax
  int v2;     // edi
  int i;      // esi
  int v4;     // ebx
  int v5;     // edx
  int j;      // ecx
  int v7;     // edx
  int v8;     // [esp+1Ch] [ebp-2Ch]
  int v9;     // [esp+2Ch] [ebp-1Ch]

  SND_StopSounds(SND_STOP_ALL);
  result = 16 * a1;
  v9 = dword_114F4AC[4 * a1];
  if (dword_114F4B0[4 * a1] > 0) {
    v8 = dword_114F4AC[4 * a1];
    v2 = 0;
    for (i = v8;; i = v8) {
      v4 = (*(_DWORD *)(i + 44) & 0x60) >> 5;
      if (v4 == 1 || v4 == 3) {
        if (v2 <= 0) {
          result = *(_DWORD *)(v8 + 12);
          v7 = result;
        } else {
          v5 = v9;
          for (j = 0; j != v2; ++j) {
            result = *(_DWORD *)(v5 + 12);
            if (*(_DWORD *)result == **(_DWORD **)(v8 + 12)) {
              result = (*(_DWORD *)(v5 + 44) & 0x60) >> 5;
              if (v4 == result)
                break;
            }
            v5 += 68;
          }
          v7 = *(_DWORD *)(v8 + 12);
        }
        *(_DWORD *)(v7 + 4) = 0;
        ++v2;
        v8 += 68;
        if (dword_114F4B0[4 * a1] <= v2)
          return result;
      } else {
        ++v2;
        v8 += 68;
        if (dword_114F4B0[4 * a1] <= v2)
          return result;
      }
    }
  }
  return result;
}

void __cdecl Com_UnloadSoundAliases(snd_alias_system_t a1) {
  __int32 v1; // eax

  if (*((_BYTE *)&g_sa + a1)) {
    if (a1 != SASYS_GAME)
      Com_UnloadSoundAliasSounds(a1);
    v1 = 16 * a1;
    if (dword_114F4AC[4 * a1]) {
      *(_DWORD *)((char *)&unk_114F4A0 + v1 + 12) = 0;
      *(_DWORD *)((char *)&unk_114F4A0 + v1 + 16) = 0;
      memset(dword_114E4A8, 0, 0x1000u);
    }
    *((_BYTE *)&g_sa + a1) = 0;
    if ((unsigned int)a1 <= SASYS_CGAME && !g_sa)
      Cmd_RemoveCommand("snd_list");
  }
}

void __usercall Com_LoadedSoundList(int a1 @<eax>) {
  int v1;            // eax
  float v2;          // xmm0_4
  int v3;            // ebx
  int v4;            // edi
  int v5;            // edx
  int v6;            // ecx
  int v7;            // esi
  int SoundFileSize; // eax
  int v10;           // [esp+18h] [ebp-20h]
  int v11;           // [esp+1Ch] [ebp-1Ch]

  if (!*((_BYTE *)g_sa + a1))
    return;
  v1 = 4 * a1;
  v10 = dword_114F4AC[v1];
  v2 = 0.0;
  if (dword_114F4B0[v1] <= 0)
    goto LABEL_15;
  v3 = dword_114F4AC[v1];
  v4 = 0;
  v11 = 0;
  do {
    while ((*(_DWORD *)(v3 + 44) & 0x60) != 0x20) {
    LABEL_4:
      ++v4;
      v3 += 68;
      if (v4 >= dword_114F4B0[4 * a1])
        goto LABEL_14;
    }
    if (v4 <= 0) {
      v7 = *(_DWORD *)(v3 + 12);
      if (*(_DWORD *)(v7 + 4))
        goto LABEL_13;
    LABEL_18:
      Com_Printf("%-64s FAILED TO LOAD\n", *(const char **)v7);
      goto LABEL_4;
    }
    v5 = v10;
    v6 = 0;
    v7 = *(_DWORD *)(v3 + 12);
    do {
      while ((*(_DWORD *)(v5 + 44) & 0x60) != 0x20) {
        ++v6;
        v5 += 68;
        if (v4 == v6)
          goto LABEL_12;
      }
      if (**(_DWORD **)(v5 + 12) == *(_DWORD *)v7)
        goto LABEL_4;
      ++v6;
      v5 += 68;
    } while (v4 != v6);
  LABEL_12:
    if (!*(_DWORD *)(v7 + 4))
      goto LABEL_18;
  LABEL_13:
    SoundFileSize = SND_GetSoundFileSize(*(_DWORD **)(v7 + 4));
    v11 += SoundFileSize;
    Com_Printf("%-64s %7.1f KB\n", **(const char ***)(v3 + 12),
               (float)((float)SoundFileSize * 0.0009765625));
    ++v4;
    v3 += 68;
  } while (v4 < dword_114F4B0[4 * a1]);
LABEL_14:
  v2 = (float)v11;
LABEL_15:
  Com_Printf("\ntotal usage %7.3f MB\n", (float)(v2 * 0.00000095367432));
}

void Com_SoundList_f(void) {
  Com_Printf("\n________________________________________\ncurrently streamed "
             "menu sounds:\n");
  Com_StreamedSoundList(0);
  Com_Printf("\n________________________________________\ncurrently streamed "
             "in-game sounds:\n");
  Com_StreamedSoundList(1u);
  Com_Printf("________________________________________\ncurrently loaded menu "
             "sounds:\n");
  Com_LoadedSoundList(0);
  Com_Printf("\n________________________________________\ncurrently loaded "
             "in-game sounds:\n");
  Com_LoadedSoundList(1);
  Com_Printf("\n");
}

int __cdecl Com_AddAliasList(char *a1, snd_alias_list_t *a2) {
  char v2;    // al
  int v3;     // esi
  int32_t v4; // eax
  int32_t v5; // ebx
  char *v7;   // esi
  int v8;     // ebx

  v2 = *a1;
  if (*a1) {
    v7 = a1;
    v8 = 0;
    do {
      v8 = 31337 * v8 + __tolower(v2);
      v2 = *++v7;
    } while (v2);
    v3 = v8 & 0x3FF;
  } else {
    v3 = 0;
  }
  v4 = dword_114E4A8[v3];
  v5 = v4;
  if (v4) {
    while (I_stricmp(a1, *(char **)v5)) {
      v5 = *(_DWORD *)(v5 + 12);
      if (!v5) {
        v4 = dword_114E4A8[v3];
        goto LABEL_7;
      }
    }
    return 0;
  } else {
  LABEL_7:
    a2->pHashNext = v4;
    *(_DWORD *)&g_sa[2 * v3 + 4] = a2;
    return 1;
  }
}

__int16 *__cdecl Com_DuplicateSoundAlias(snd_alias_list_t *a1, char *__src) {
  char v2;              // al
  int v3;               // eax
  int v4;               // ebx
  snd_alias_list_t *v5; // ebx
  char *v6;             // esi
  __int16 *result;      // eax
  char *v8;             // esi
  int v9;               // ebx
  char *v10;            // edx
  int v11;              // [esp+1Ch] [ebp-1Ch]

  v2 = *__src;
  if (*__src) {
    v8 = __src;
    v9 = 0;
    do {
      v9 = 31337 * v9 + __tolower(v2);
      v2 = *++v8;
    } while (v2);
    v11 = v9 & 0x3FF;
    v3 = v11;
  } else {
    v11 = 0;
    v3 = 0;
  }
  v4 = dword_114E4A8[v3];
  if (v4) {
    while (I_stricmp(__src, *(char **)v4)) {
      v4 = *(_DWORD *)(v4 + 12);
      if (!v4)
        goto LABEL_6;
    }
    v10 = *(char **)v4;
    *(_DWORD *)v4 = *(_DWORD *)a1->aliasName;
    *(_DWORD *)(v4 + 4) = a1->head;
    *(_DWORD *)(v4 + 8) = a1->count;
    result = (__int16 *)a1->pHashNext;
    *(_DWORD *)(v4 + 12) = result;
    *(_DWORD *)v4 = v10;
  } else {
  LABEL_6:
    v5 = (snd_alias_list_t *)Hunk_AllocInternal(0x10u);
    *v5 = *a1;
    v6 = (char *)Hunk_AllocInternal(strlen(__src) + 1);
    strcpy(v6, __src);
    *(_DWORD *)v5->aliasName = v6;
    v5->pHashNext = dword_114E4A8[v11];
    result = g_sa;
    *(_DWORD *)&g_sa[2 * v11 + 4] = v5;
  }
  return result;
}

char *__cdecl Com_BeginParseSession(char *__src) {
  char *v1;       // eax
  int v3;         // ebx
  const char *v4; // esi

  if (dword_30F120 == 15) {
    Com_Printf("Already parsing:\n");
    if (dword_30F120 > 0) {
      v3 = 0;
      v4 = (const char *)&unk_30AF7C;
      do {
        Com_Printf("%i. %s\n", v3++, v4);
        v4 += 1116;
      } while (dword_30F120 > v3);
    }
    Com_Error(
        0, "\x15Com_BeginParseSession: session overflow trying to parse %s\n",
        (char)__src);
  }
  ++dword_30F120;
  v1 = &g_parse[1116 * dword_30F120];
  *((_DWORD *)v1 + 256) = 1;
  v1[1028] = 0;
  v1[1029] = 1;
  v1[1030] = 0;
  v1[1031] = 0;
  v1[1032] = 0;
  *((_DWORD *)v1 + 259) = &inData;
  *((_DWORD *)v1 + 260) = &inData;
  *((_DWORD *)v1 + 261) = 0;
  *((_DWORD *)v1 + 262) = 0;
  return I_strncpyz(v1 + 1052, __src, 64);
}

int Com_EndParseSession() {
  int result; // eax
  char v1;    // [esp+8h] [ebp-10h]

  if (!dword_30F120)
    result = Com_Error(0, "\x15Com_EndParseSession: session underflow", v1);
  --dword_30F120;
  return result;
}

void Com_ResetParseSessions() { dword_30F120 = 0; }

int __cdecl Com_SetSpaceDelimited(int a1) {
  int result; // eax

  result = 9 * dword_30F120;
  byte_30AF65[1116 * dword_30F120] = a1 != 0;
  return result;
}

int __cdecl Com_SetKeepStringQuotes(int a1) {
  int result; // eax

  result = a1;
  byte_30AF66[1116 * dword_30F120] = a1 != 0;
  return result;
}

int __cdecl Com_SetCSV(int a1) {
  int result; // eax

  result = a1;
  byte_30AF67[1116 * dword_30F120] = a1 != 0;
  return result;
}

int Com_GetCurrentParseLine() { return dword_30AF60[279 * dword_30F120]; }

void Com_ScriptWarning(char *a1, ...) {
  char *v1;      // esi
  char v2[4096]; // [esp+2Ch] [ebp-100Ch] BYREF
  va_list v3;    // [esp+102Ch] [ebp-Ch]
  va_list va;    // [esp+1044h] [ebp+Ch] BYREF

  va_start(va, a1);
  v1 = &g_parse[1116 * dword_30F120];
  va_copy(v3, va);
  vsprintf(v2, a1, va);
  if (dword_30F120)
    Com_Printf("%sFile %s, line %i: %s", *((const char **)v1 + 260), v1 + 1052,
               *((_DWORD *)v1 + 256), v2);
  else
    Com_Printf("%s", v2);
}

int Com_UngetToken() {
  char *v0;   // ebx
  int result; // eax

  v0 = &g_parse[1116 * dword_30F120];
  if (v0[1028])
    Com_ScriptError("UngetToken called twice");
  v0[1028] = 1;
  result = dword_30F128;
  dword_30F124 = dword_30F128;
  return result;
}

char *__cdecl Com_Parse(char **a1) {
  char *v1; // edx

  v1 = &g_parse[1116 * dword_30F120];
  if (v1[1028]) {
    v1[1028] = 0;
    *a1 = (char *)*((_DWORD *)v1 + 262);
    *((_DWORD *)v1 + 256) = *((_DWORD *)v1 + 261);
  }
  return Com_ParseExt(a1, 1);
}

char *__cdecl Com_ParseOnLine(char **a1) {
  char *v1; // edx

  v1 = &g_parse[1116 * dword_30F120];
  if (v1[1028]) {
    v1[1028] = 0;
    if (!v1[1029])
      return v1;
    *a1 = (char *)*((_DWORD *)v1 + 262);
    *((_DWORD *)v1 + 256) = *((_DWORD *)v1 + 261);
  }
  return Com_ParseExt(a1, 0);
}

int __cdecl Com_SkipRestOfLine(unsigned __int8 **a1) {
  int result;          // eax
  unsigned __int8 *v2; // edx

  result = 9 * dword_30F120;
  v2 = *a1;
  if (*a1) {
    while (1) {
      result = *v2;
      if (!(_BYTE)result)
        break;
      ++v2;
      if ((_BYTE)result == 10) {
        ++*(_DWORD *)&g_parse[1116 * dword_30F120 + 1024];
        break;
      }
    }
    *a1 = v2;
  }
  return result;
}

int __cdecl Com_MatchToken(char **a1, char *__s2, int a3) {
  char *v3; // edx
  char *v4; // ebx

  v3 = &g_parse[1116 * dword_30F120];
  if (v3[1028]) {
    v3[1028] = 0;
    *a1 = (char *)*((_DWORD *)v3 + 262);
    *((_DWORD *)v3 + 256) = *((_DWORD *)v3 + 261);
  }
  v4 = Com_ParseExt(a1, 1);
  if (!strcmp(v4, __s2))
    return 1;
  if (a3)
    Com_ScriptWarning("MatchToken: %s != %s\n", v4, __s2);
  else
    Com_ScriptError("MatchToken: %s != %s\n", v4, __s2);
  return 0;
}

long double __cdecl Com_ParseFloat(char **a1) {
  char *v1; // edx
  char *v2; // eax

  v1 = &g_parse[1116 * dword_30F120];
  if (v1[1028]) {
    v1[1028] = 0;
    *a1 = (char *)*((_DWORD *)v1 + 262);
    *((_DWORD *)v1 + 256) = *((_DWORD *)v1 + 261);
  }
  v2 = Com_ParseExt(a1, 1);
  return (float)atof(v2);
}

int __cdecl Com_ParseInt(char **a1) {
  char *v1; // edx
  char *v2; // eax

  v1 = &g_parse[1116 * dword_30F120];
  if (v1[1028]) {
    v1[1028] = 0;
    *a1 = (char *)*((_DWORD *)v1 + 262);
    *((_DWORD *)v1 + 256) = *((_DWORD *)v1 + 261);
  }
  v2 = Com_ParseExt(a1, 1);
  return atoi(v2);
}

int __cdecl node1_(int a1) { return a1; }

int __cdecl node_pos(int a1) { return a1; }

int Sys_Milliseconds(void) {
  if (!Sys_Milliseconds(void)::initialized) {
    sys_timeBase = timeGetTime();
    Sys_Milliseconds(void)::initialized = 1;
  }
  return timeGetTime() - sys_timeBase;
}

unsigned __int64 Sys_MillisecondsRaw(void) { return timeGetTime(); }

int __cdecl Sys_SnapVector(float *a1) {
  int result; // eax

  *a1 = (float)(int)*a1;
  a1[1] = (float)(int)a1[1];
  result = (int)a1[2];
  a1[2] = (float)result;
  return result;
}

int __cdecl Scr_ScanFile(_BYTE *a1, int a2) {
  int v2;  // ecx
  char v4; // dl
  int v5;  // eax
  int v6;  // ecx

  if (a2 <= 0)
    return 0;
  v4 = *unk_114CF3C;
  ++unk_114CF3C;
  if (v4) {
    if (v4 == 10) {
      v6 = 1;
      *a1 = 10;
      return v6;
    }
    v2 = 0;
    while (1) {
      a1[v2++] = v4;
      if (a2 == v2)
        break;
      v4 = *unk_114CF3C;
      ++unk_114CF3C;
      if (!v4)
        goto LABEL_7;
      if (v4 == 10) {
        v5 = v2;
        v6 = v2 + 1;
        a1[v5] = 10;
        return v6;
      }
    }
  } else {
    v2 = 0;
  }
  if (v4)
    return v2;
LABEL_7:
  if (!unk_114CF40) {
    --unk_114CF3C;
    return v2;
  }
  unk_114CF3C = unk_114CF40;
  unk_114CF40 = 0;
  return v2;
}

int __cdecl ROQ_StopCinematicFromHandle(unsigned int a1) {
  if (a1 > 0xF)
    return 2;
  if (dword_4F3A3C[115 * a1] == 2)
    return 2;
  currentHandle = a1;
  Com_DPrintf("trFMV::stop(), closing %s\n",
              (const char *)(460 * a1 + 5191936));
  if (!dword_4F3AC4[115 * currentHandle])
    return 2;
  if (dword_4F3A24[115 * currentHandle] && *(_DWORD *)clc != 1)
    return dword_4F3A3C[115 * currentHandle];
  dword_4F3A30[115 * currentHandle + 3] = 2;
  RoQShutdown();
  return 2;
}

int __cdecl ROQ_SetExtentsFromHandle(unsigned int a1, int a2, int a3, int a4,
                                     int a5) {
  int result; // eax
  int v6;     // edx

  if (a1 <= 0xF) {
    result = 459 * a1;
    v6 = 115 * a1;
    if (dword_4F3A3C[115 * a1] != 2) {
      dword_4F3A00[v6 + 2] = a2;
      dword_4F3A00[v6 + 3] = a3;
      result = a4;
      dword_4F3A10[115 * a1] = a4;
      dword_4F3A14[115 * a1] = a5;
      dword_4F3A20[115 * a1] = 1;
    }
  }
  return result;
}

int __cdecl ROQ_UploadCinematicFromHandle(unsigned int a1) {
  int result; // eax
  int v2;     // edx

  if (a1 <= 0xF) {
    result = 460 * a1;
    if (dword_4F3AC4[115 * a1]) {
      v2 = dword_4F3AC0[115 * a1];
      if (v2 <= 0 && dword_4F3A20[115 * a1]) {
        if (v2) {
          if (v2 == -1)
            dword_4F3AC0[115 * a1] = -2;
          else
            dword_4F3A20[115 * a1] = 0;
        } else {
          dword_4F3AC0[115 * a1] = -1;
        }
      }
      result = cl_inGameVideo;
      if (!*(_BYTE *)(cl_inGameVideo + 8)) {
        result = 460 * a1;
        if (dword_4F3AC0[115 * a1] == 1)
          dword_4F3AC0[115 * a1] = 0;
      }
    }
  }
  return result;
}

unsigned __int8 **__cdecl blitVQQuad32fs(unsigned __int8 **a1,
                                         unsigned __int8 *a2) {
  int v2;                   // edx
  unsigned int v3;          // esi
  int v4;                   // edi
  unsigned __int8 **result; // eax
  unsigned __int16 v6;      // ax
  int v7;                   // edi
  __int16 v8;               // ax
  int v9;                   // eax
  unsigned __int8 *v10;     // ecx
  int v11;                  // edx
  int v12;                  // edx
  unsigned __int8 *v13;     // ecx
  int v14;                  // edx
  int v15;                  // edx
  unsigned __int8 *v16;     // ecx
  int v17;                  // edx
  int v18;                  // edx
  unsigned __int8 *v19;     // ecx
  int v20;                  // edx
  unsigned __int8 *v21;     // ebx
  unsigned __int8 *v22;     // ecx
  int v23;                  // edx
  int v24;                  // edx
  int v25;                  // edx
  int v26;                  // edx
  unsigned __int8 *v27;     // ecx
  unsigned __int8 *v28;     // ebx
  int v29;                  // edx
  int v30;                  // edx
  int v31;                  // edx
  int v32;                  // edx
  unsigned __int8 *v33;     // ecx
  unsigned __int8 *v34;     // ebx
  int v35;                  // edx
  int v36;                  // edx
  int v37;                  // edx
  int v38;                  // edx
  unsigned __int8 *v39;     // ecx
  unsigned __int8 *v40;     // ebx
  int v41;                  // edx
  int v42;                  // edx
  int v43;                  // edx
  int v44;                  // edx
  unsigned __int8 *v45;     // ecx
  unsigned __int8 *v46;     // ebx
  int v47;                  // edx
  int v48;                  // edx
  int v49;                  // edx
  int v50;                  // edx
  unsigned __int8 *v51;     // ecx
  unsigned __int8 *v52;     // ebx
  int v53;                  // edx
  int v54;                  // edx
  int v55;                  // edx
  int v56;                  // edx
  unsigned __int8 *v57;     // ecx
  unsigned __int8 *v58;     // ebx
  int v59;                  // edx
  int v60;                  // edx
  int v61;                  // edx
  int v62;                  // edx
  unsigned __int8 *v63;     // ecx
  unsigned __int8 *v64;     // ebx
  int v65;                  // edx
  int v66;                  // edx
  int v67;                  // edx
  unsigned __int8 *v68;     // ecx
  int v69;                  // edx
  int v70;                  // edx
  int v71;                  // edx
  int v72;                  // edx
  unsigned __int8 *v73;     // ecx
  int v74;                  // edx
  int v75;                  // edx
  int v76;                  // edx
  int v77;                  // edx
  unsigned __int8 *v78;     // ecx
  int v79;                  // edx
  int v80;                  // edx
  int v81;                  // edx
  int v82;                  // edx
  unsigned __int8 *v83;     // ecx
  int v84;                  // edx
  int v85;                  // edx
  int v86;                  // edx
  int v87;                  // edx
  unsigned __int8 *v88;     // ecx
  int v89;                  // edx
  int v90;                  // edx
  int v91;                  // edx
  int v92;                  // edx
  unsigned __int8 *v93;     // ecx
  int v94;                  // edx
  int v95;                  // edx
  int v96;                  // edx
  int v97;                  // edx
  unsigned __int8 *v98;     // ecx
  int v99;                  // edx
  int v100;                 // edx
  int v101;                 // edx
  int v102;                 // edx
  unsigned __int8 *v103;    // ecx
  int v104;                 // edx
  int v105;                 // edx
  int v106;                 // edx
  int v107;                 // ecx
  unsigned __int8 *v108;    // ebx
  int v109;                 // edx
  int v110;                 // edx
  int v111;                 // ecx
  unsigned __int8 *v112;    // ebx
  int v113;                 // edx
  int v114;                 // edx
  int v115;                 // ecx
  unsigned __int8 *v116;    // ebx
  int v117;                 // edx
  int v118;                 // edx
  int v119;                 // ecx
  unsigned __int8 *v120;    // ebx
  int v121;                 // edx
  unsigned __int8 *v122;    // ecx
  unsigned __int8 *v123;    // ebx
  int v124;                 // edx
  int v125;                 // edx
  unsigned __int8 *v126;    // ebx
  unsigned __int8 *v127;    // ecx
  int v128;                 // edx
  int v129;                 // edx
  unsigned __int8 *v130;    // ebx
  unsigned __int8 *v131;    // ecx
  int v132;                 // edx
  int v133;                 // edx
  unsigned __int8 *v134;    // ebx
  unsigned __int8 *v135;    // ecx
  int v136;                 // edx
  _DWORD *v137;             // [esp+0h] [ebp-24h]
  int v138;                 // [esp+4h] [ebp-20h]
  __int16 i;                // [esp+Ah] [ebp-1Ah]
  int v140;                 // [esp+Ch] [ebp-18h]
  int v141;                 // [esp+10h] [ebp-14h]
  unsigned __int8 **v142;   // [esp+14h] [ebp-10h]

  v2 = 432 * currentHandle;
  v3 = dword_4F3A64[115 * currentHandle] & 0xFFFFFFF8;
  v138 = 2 * dword_4F3A64[115 * currentHandle];
  v140 = 0;
LABEL_2:
  LOWORD(v2) = *a2;
  v4 = v2 + (a2[1] << 8);
  a2 += 2;
  for (i = 7;; --i) {
    v6 = v4 & 0xC000;
    v4 *= 4;
    if (v6 != 0x4000)
      break;
    v21 = a1[v140];
    v22 = &v21[dword_7057C0[*a2]];
    v23 = *((_DWORD *)v22 + 1);
    *(_DWORD *)v21 = *(_DWORD *)v22;
    *((_DWORD *)v21 + 1) = v23;
    v24 = *((_DWORD *)v22 + 3);
    *((_DWORD *)v21 + 2) = *((_DWORD *)v22 + 2);
    *((_DWORD *)v21 + 3) = v24;
    v25 = *((_DWORD *)v22 + 5);
    *((_DWORD *)v21 + 4) = *((_DWORD *)v22 + 4);
    *((_DWORD *)v21 + 5) = v25;
    v26 = *((_DWORD *)v22 + 7);
    *((_DWORD *)v21 + 6) = *((_DWORD *)v22 + 6);
    *((_DWORD *)v21 + 7) = v26;
    v27 = &v22[v3];
    v28 = &v21[v3];
    v29 = *((_DWORD *)v27 + 1);
    *(_DWORD *)v28 = *(_DWORD *)v27;
    *((_DWORD *)v28 + 1) = v29;
    v30 = *((_DWORD *)v27 + 3);
    *((_DWORD *)v28 + 2) = *((_DWORD *)v27 + 2);
    *((_DWORD *)v28 + 3) = v30;
    v31 = *((_DWORD *)v27 + 5);
    *((_DWORD *)v28 + 4) = *((_DWORD *)v27 + 4);
    *((_DWORD *)v28 + 5) = v31;
    v32 = *((_DWORD *)v27 + 7);
    *((_DWORD *)v28 + 6) = *((_DWORD *)v27 + 6);
    *((_DWORD *)v28 + 7) = v32;
    v33 = &v27[v3];
    v34 = &v28[v3];
    v35 = *((_DWORD *)v33 + 1);
    *(_DWORD *)v34 = *(_DWORD *)v33;
    *((_DWORD *)v34 + 1) = v35;
    v36 = *((_DWORD *)v33 + 3);
    *((_DWORD *)v34 + 2) = *((_DWORD *)v33 + 2);
    *((_DWORD *)v34 + 3) = v36;
    v37 = *((_DWORD *)v33 + 5);
    *((_DWORD *)v34 + 4) = *((_DWORD *)v33 + 4);
    *((_DWORD *)v34 + 5) = v37;
    v38 = *((_DWORD *)v33 + 7);
    *((_DWORD *)v34 + 6) = *((_DWORD *)v33 + 6);
    *((_DWORD *)v34 + 7) = v38;
    v39 = &v33[v3];
    v40 = &v34[v3];
    v41 = *((_DWORD *)v39 + 1);
    *(_DWORD *)v40 = *(_DWORD *)v39;
    *((_DWORD *)v40 + 1) = v41;
    v42 = *((_DWORD *)v39 + 3);
    *((_DWORD *)v40 + 2) = *((_DWORD *)v39 + 2);
    *((_DWORD *)v40 + 3) = v42;
    v43 = *((_DWORD *)v39 + 5);
    *((_DWORD *)v40 + 4) = *((_DWORD *)v39 + 4);
    *((_DWORD *)v40 + 5) = v43;
    v44 = *((_DWORD *)v39 + 7);
    *((_DWORD *)v40 + 6) = *((_DWORD *)v39 + 6);
    *((_DWORD *)v40 + 7) = v44;
    v45 = &v39[v3];
    v46 = &v40[v3];
    v47 = *((_DWORD *)v45 + 1);
    *(_DWORD *)v46 = *(_DWORD *)v45;
    *((_DWORD *)v46 + 1) = v47;
    v48 = *((_DWORD *)v45 + 3);
    *((_DWORD *)v46 + 2) = *((_DWORD *)v45 + 2);
    *((_DWORD *)v46 + 3) = v48;
    v49 = *((_DWORD *)v45 + 5);
    *((_DWORD *)v46 + 4) = *((_DWORD *)v45 + 4);
    *((_DWORD *)v46 + 5) = v49;
    v50 = *((_DWORD *)v45 + 7);
    *((_DWORD *)v46 + 6) = *((_DWORD *)v45 + 6);
    *((_DWORD *)v46 + 7) = v50;
    v51 = &v45[v3];
    v52 = &v46[v3];
    v53 = *((_DWORD *)v51 + 1);
    *(_DWORD *)v52 = *(_DWORD *)v51;
    *((_DWORD *)v52 + 1) = v53;
    v54 = *((_DWORD *)v51 + 3);
    *((_DWORD *)v52 + 2) = *((_DWORD *)v51 + 2);
    *((_DWORD *)v52 + 3) = v54;
    v55 = *((_DWORD *)v51 + 5);
    *((_DWORD *)v52 + 4) = *((_DWORD *)v51 + 4);
    *((_DWORD *)v52 + 5) = v55;
    v56 = *((_DWORD *)v51 + 7);
    *((_DWORD *)v52 + 6) = *((_DWORD *)v51 + 6);
    *((_DWORD *)v52 + 7) = v56;
    v57 = &v51[v3];
    v58 = &v52[v3];
    v59 = *((_DWORD *)v57 + 1);
    *(_DWORD *)v58 = *(_DWORD *)v57;
    *((_DWORD *)v58 + 1) = v59;
    v60 = *((_DWORD *)v57 + 3);
    *((_DWORD *)v58 + 2) = *((_DWORD *)v57 + 2);
    *((_DWORD *)v58 + 3) = v60;
    v61 = *((_DWORD *)v57 + 5);
    *((_DWORD *)v58 + 4) = *((_DWORD *)v57 + 4);
    *((_DWORD *)v58 + 5) = v61;
    v62 = *((_DWORD *)v57 + 7);
    *((_DWORD *)v58 + 6) = *((_DWORD *)v57 + 6);
    *((_DWORD *)v58 + 7) = v62;
    v63 = &v57[v3];
    v64 = &v58[v3];
    v65 = v63[1];
    *(_DWORD *)v64 = *v63;
    *((_DWORD *)v64 + 1) = v65;
    v66 = v63[3];
    *((_DWORD *)v64 + 2) = v63[2];
    *((_DWORD *)v64 + 3) = v66;
    v67 = v63[5];
    *((_DWORD *)v64 + 4) = v63[4];
    *((_DWORD *)v64 + 5) = v67;
    v2 = v63[7];
    *((_DWORD *)v64 + 6) = v63[6];
    *((_DWORD *)v64 + 7) = v2;
    ++a2;
    v140 += 5;
    result = a1;
    if (!a1[v140])
      return result;
  LABEL_6:
    if (!i)
      goto LABEL_2;
  }
  if (v6 <= 0x4000u) {
    if (!v6)
      v140 += 5;
  } else if (v6 == 0x8000) {
    v137 = (_DWORD *)(*a2 << 8);
    v68 = a1[v140];
    v69 = *(int *)((char *)&dword_76EFE4 + (_DWORD)v137);
    *(_DWORD *)v68 = *(int *)((char *)&vq8 + (_DWORD)v137);
    *((_DWORD *)v68 + 1) = v69;
    v70 = v137[1948667];
    *((_DWORD *)v68 + 2) = v137[1948666];
    *((_DWORD *)v68 + 3) = v70;
    v71 = v137[1948669];
    *((_DWORD *)v68 + 4) = v137[1948668];
    *((_DWORD *)v68 + 5) = v71;
    v72 = v137[1948671];
    *((_DWORD *)v68 + 6) = v137[1948670];
    *((_DWORD *)v68 + 7) = v72;
    v73 = &v68[v3];
    v74 = v137[1948673];
    *(_DWORD *)v73 = v137[1948672];
    *((_DWORD *)v73 + 1) = v74;
    v75 = v137[1948675];
    *((_DWORD *)v73 + 2) = v137[1948674];
    *((_DWORD *)v73 + 3) = v75;
    v76 = v137[1948677];
    *((_DWORD *)v73 + 4) = v137[1948676];
    *((_DWORD *)v73 + 5) = v76;
    v77 = v137[1948679];
    *((_DWORD *)v73 + 6) = v137[1948678];
    *((_DWORD *)v73 + 7) = v77;
    v78 = &v73[v3];
    v79 = v137[1948681];
    *(_DWORD *)v78 = v137[1948680];
    *((_DWORD *)v78 + 1) = v79;
    v80 = v137[1948683];
    *((_DWORD *)v78 + 2) = v137[1948682];
    *((_DWORD *)v78 + 3) = v80;
    v81 = v137[1948685];
    *((_DWORD *)v78 + 4) = v137[1948684];
    *((_DWORD *)v78 + 5) = v81;
    v82 = v137[1948687];
    *((_DWORD *)v78 + 6) = v137[1948686];
    *((_DWORD *)v78 + 7) = v82;
    v83 = &v78[v3];
    v84 = v137[1948689];
    *(_DWORD *)v83 = v137[1948688];
    *((_DWORD *)v83 + 1) = v84;
    v85 = v137[1948691];
    *((_DWORD *)v83 + 2) = v137[1948690];
    *((_DWORD *)v83 + 3) = v85;
    v86 = v137[1948693];
    *((_DWORD *)v83 + 4) = v137[1948692];
    *((_DWORD *)v83 + 5) = v86;
    v87 = v137[1948695];
    *((_DWORD *)v83 + 6) = v137[1948694];
    *((_DWORD *)v83 + 7) = v87;
    v88 = &v83[v3];
    v89 = v137[1948697];
    *(_DWORD *)v88 = v137[1948696];
    *((_DWORD *)v88 + 1) = v89;
    v90 = v137[1948699];
    *((_DWORD *)v88 + 2) = v137[1948698];
    *((_DWORD *)v88 + 3) = v90;
    v91 = v137[1948701];
    *((_DWORD *)v88 + 4) = v137[1948700];
    *((_DWORD *)v88 + 5) = v91;
    v92 = v137[1948703];
    *((_DWORD *)v88 + 6) = v137[1948702];
    *((_DWORD *)v88 + 7) = v92;
    v93 = &v88[v3];
    v94 = v137[1948705];
    *(_DWORD *)v93 = v137[1948704];
    *((_DWORD *)v93 + 1) = v94;
    v95 = v137[1948707];
    *((_DWORD *)v93 + 2) = v137[1948706];
    *((_DWORD *)v93 + 3) = v95;
    v96 = v137[1948709];
    *((_DWORD *)v93 + 4) = v137[1948708];
    *((_DWORD *)v93 + 5) = v96;
    v97 = v137[1948711];
    *((_DWORD *)v93 + 6) = v137[1948710];
    *((_DWORD *)v93 + 7) = v97;
    v98 = &v93[v3];
    v99 = v137[1948713];
    *(_DWORD *)v98 = v137[1948712];
    *((_DWORD *)v98 + 1) = v99;
    v100 = v137[1948715];
    *((_DWORD *)v98 + 2) = v137[1948714];
    *((_DWORD *)v98 + 3) = v100;
    v101 = v137[1948717];
    *((_DWORD *)v98 + 4) = v137[1948716];
    *((_DWORD *)v98 + 5) = v101;
    v102 = v137[1948719];
    *((_DWORD *)v98 + 6) = v137[1948718];
    *((_DWORD *)v98 + 7) = v102;
    v103 = &v98[v3];
    v104 = v137[1948721];
    *(_DWORD *)v103 = v137[1948720];
    *((_DWORD *)v103 + 1) = v104;
    v105 = v137[1948723];
    *((_DWORD *)v103 + 2) = v137[1948722];
    *((_DWORD *)v103 + 3) = v105;
    v106 = v137[1948725];
    *((_DWORD *)v103 + 4) = v137[1948724];
    *((_DWORD *)v103 + 5) = v106;
    v2 = v137[1948727];
    *((_DWORD *)v103 + 6) = v137[1948726];
    *((_DWORD *)v103 + 7) = v2;
    ++a2;
    v140 += 5;
  } else if (v6 == 0xC000) {
    v142 = &a1[++v140];
    v141 = 4;
    if (i) {
      while (1) {
        --i;
        v8 = v4 & 0xC000;
        v4 *= 4;
        if (v8 != (__int16)0x8000)
          break;
      LABEL_20:
        v9 = *a2 << 6;
        v10 = *v142;
        v11 = *(int *)((char *)&dword_74EFE4 + v9);
        *(_DWORD *)v10 = *(int *)((char *)&vq4 + v9);
        *((_DWORD *)v10 + 1) = v11;
        v12 = *(int *)((char *)&vq4 + v9 + 12);
        *((_DWORD *)v10 + 2) = *(int *)((char *)&vq4 + v9 + 8);
        *((_DWORD *)v10 + 3) = v12;
        v13 = &v10[v3];
        v14 = *(int *)((char *)&vq4 + v9 + 20);
        *(_DWORD *)v13 = *(int *)((char *)&vq4 + v9 + 16);
        *((_DWORD *)v13 + 1) = v14;
        v15 = *(int *)((char *)&vq4 + v9 + 28);
        *((_DWORD *)v13 + 2) = *(int *)((char *)&vq4 + v9 + 24);
        *((_DWORD *)v13 + 3) = v15;
        v16 = &v13[v3];
        v17 = *(int *)((char *)&vq4 + v9 + 36);
        *(_DWORD *)v16 = *(int *)((char *)&vq4 + v9 + 32);
        *((_DWORD *)v16 + 1) = v17;
        v18 = *(int *)((char *)&vq4 + v9 + 44);
        *((_DWORD *)v16 + 2) = *(int *)((char *)&vq4 + v9 + 40);
        *((_DWORD *)v16 + 3) = v18;
        v19 = &v16[v3];
        v20 = *(int *)((char *)&vq4 + v9 + 52);
        *(_DWORD *)v19 = *(int *)((char *)&vq4 + v9 + 48);
        *((_DWORD *)v19 + 1) = v20;
        v2 = *(int *)((char *)&vq4 + v9 + 60);
        *((_DWORD *)v19 + 2) = *(int *)((char *)&vq4 + v9 + 56);
        *((_DWORD *)v19 + 3) = v2;
        ++a2;
      LABEL_17:
        ++v140;
        ++v142;
        if (!--v141)
          goto LABEL_5;
        if (!i)
          goto LABEL_13;
      }
    } else {
    LABEL_13:
      LOWORD(v2) = *a2;
      v7 = v2 + (a2[1] << 8);
      a2 += 2;
      i = 7;
      v8 = v7 & 0xC000;
      v4 = 4 * v7;
      if (v8 == (__int16)0x8000)
        goto LABEL_20;
    }
    if (v8 == -16384) {
      v107 = 4 * *a2;
      v108 = *v142;
      v109 = dword_746FE4[v107];
      *(_DWORD *)v108 = vq2[v107];
      *((_DWORD *)v108 + 1) = v109;
      v110 = dword_746FEC[v107];
      *(_DWORD *)&v108[v3] = dword_746FE8[v107];
      *(_DWORD *)&v108[v3 + 4] = v110;
      v111 = 4 * a2[1];
      v112 = *v142;
      v113 = dword_746FE4[v111];
      *((_DWORD *)v112 + 2) = vq2[v111];
      *((_DWORD *)v112 + 3) = v113;
      v114 = dword_746FEC[v111];
      *(_DWORD *)&v112[v3 + 8] = dword_746FE8[v111];
      *(_DWORD *)&v112[v3 + 12] = v114;
      v115 = 4 * a2[2];
      v116 = &(*v142)[v138];
      v117 = dword_746FE4[v115];
      *(_DWORD *)v116 = vq2[v115];
      *((_DWORD *)v116 + 1) = v117;
      v118 = dword_746FEC[v115];
      *(_DWORD *)&v116[v3] = dword_746FE8[v115];
      *(_DWORD *)&v116[v3 + 4] = v118;
      v119 = 4 * a2[3];
      v120 = &(*v142)[v138];
      v121 = dword_746FE4[v119];
      *((_DWORD *)v120 + 2) = vq2[v119];
      *((_DWORD *)v120 + 3) = v121;
      v2 = dword_746FEC[v119];
      *(_DWORD *)&v120[v3 + 8] = dword_746FE8[v119];
      *(_DWORD *)&v120[v3 + 12] = v2;
      a2 += 4;
    } else if (v8 == 0x4000) {
      v122 = *v142;
      v123 = &(*v142)[dword_7057C0[*a2]];
      v124 = *((_DWORD *)v123 + 1);
      *(_DWORD *)v122 = *(_DWORD *)v123;
      *((_DWORD *)v122 + 1) = v124;
      v125 = *((_DWORD *)v123 + 3);
      *((_DWORD *)v122 + 2) = *((_DWORD *)v123 + 2);
      *((_DWORD *)v122 + 3) = v125;
      v126 = &v123[v3];
      v127 = &v122[v3];
      v128 = *((_DWORD *)v126 + 1);
      *(_DWORD *)v127 = *(_DWORD *)v126;
      *((_DWORD *)v127 + 1) = v128;
      v129 = *((_DWORD *)v126 + 3);
      *((_DWORD *)v127 + 2) = *((_DWORD *)v126 + 2);
      *((_DWORD *)v127 + 3) = v129;
      v130 = &v126[v3];
      v131 = &v127[v3];
      v132 = *((_DWORD *)v130 + 1);
      *(_DWORD *)v131 = *(_DWORD *)v130;
      *((_DWORD *)v131 + 1) = v132;
      v133 = *((_DWORD *)v130 + 3);
      *((_DWORD *)v131 + 2) = *((_DWORD *)v130 + 2);
      *((_DWORD *)v131 + 3) = v133;
      v134 = &v130[v3];
      v135 = &v131[v3];
      v136 = *((_DWORD *)v134 + 1);
      *(_DWORD *)v135 = *(_DWORD *)v134;
      *((_DWORD *)v135 + 1) = v136;
      v2 = *((_DWORD *)v134 + 3);
      *((_DWORD *)v135 + 2) = *((_DWORD *)v134 + 2);
      *((_DWORD *)v135 + 3) = v2;
      ++a2;
    }
    goto LABEL_17;
  }
LABEL_5:
  result = a1;
  if (a1[v140])
    goto LABEL_6;
  return result;
}

int __cdecl ROQ_PlayCinematic(const char *a1, int a2, int a3, int a4, int a5,
                              unsigned int a6) {
  int v6;           // ebx
  int v7;           // esi
  int v8;           // edx
  char *v9;         // eax
  int v10;          // ebx
  int v11;          // edi
  int v12;          // edx
  int v13;          // ecx
  int v14;          // edx
  int v15;          // ebx
  int v16;          // esi
  int v17;          // ecx
  int v18;          // edx
  __int16 *v19;     // ecx
  int v20;          // ebx
  int v21;          // ecx
  int v22;          // eax
  int v23;          // eax
  int v24;          // edx
  _DWORD *v25;      // edx
  char v27;         // [esp+8h] [ebp-130h]
  char __src[280];  // [esp+20h] [ebp-118h] BYREF
  unsigned int v29; // [esp+154h] [ebp+1Ch]

  Com_sprintf(__src, 0x100u, "video/%s.roq", a1);
  if ((a6 & 1) != 0) {
  LABEL_5:
    Com_DPrintf("SCR_PlayCinematic( %s )\n", a1);
    Com_Memset(&cin, 0, 0x250614u);
    v8 = 0;
    v9 = cinTable;
    while (*v9) {
      ++v8;
      v9 += 460;
      if (v8 == 16) {
        Com_Error(1, "\x15CIN_HandleForVideo: none free", v27);
        v8 = 0;
        break;
      }
    }
    currentHandle = v8;
    dword_745BD0 = v8;
    strcpy(&cinTable[460 * v8], __src);
    v10 = 115 * currentHandle;
    dword_4F3A50[v10 + 1] = 0;
    dword_4F3A50[v10 + 1] =
        FS_FOpenFileRead(&cinTable[v10 * 4], &dword_4F3A38[v10], 1);
    v11 = currentHandle;
    v12 = 115 * currentHandle;
    if (dword_4F3A54[115 * currentHandle] <= 0) {
      Com_DPrintf("play(%s), ROQSize<=0\n", a1);
      cinTable[460 * currentHandle] = 0;
      return -1;
    } else {
      if ((unsigned int)currentHandle <= 0xF &&
          dword_4F3A3C[115 * currentHandle] != 2) {
        dword_4F3A00[v12 + 2] = a2;
        dword_4F3A00[v12 + 3] = a3;
        dword_4F3A10[v12] = a4;
        dword_4F3A10[v12 + 1] = a5;
        dword_4F3A20[v12] = 1;
      }
      if ((unsigned int)v11 <= 0xF && dword_4F3A3C[115 * v11] != 2)
        dword_4F3A10[115 * v11 + 2] = (a6 >> 1) & 1;
      v13 = 115 * v11;
      dword_4F3A10[v13 + 3] = (a6 >> 2) & 1;
      dword_4F3A20[v13 + 1] = a6 & 1;
      dword_4F3AC0[v13] = 1;
      dword_4F3A20[v13 + 2] = (a6 >> 3) & 1;
      v29 = a6 >> 4;
      dword_4F3A20[v13 + 3] = v29 & 1;
      dword_4F3A30[v13] = (v29 >> 1) & 1;
      dword_4F3A30[v13 + 1] = 0;
      if (dword_4F3A24[115 * v11]) {
        if (dword_1220A70) {
          UI_SetActiveMenu(0);
          v11 = currentHandle;
        }
      } else {
        dword_4F3AC0[115 * v11] = *(_BYTE *)(cl_inGameVideo + 8) != 0;
      }
      if (v11 >= 0) {
        v14 = 115 * v11;
        dword_4F3A70[v14 + 2] = (int)blitVQQuad32fs;
        dword_4F3A70[v14 + 3] = (int)blitVQQuad32fs;
        dword_4F3A80[v14] = 4;
        v15 = 0;
        v16 = -255;
        v17 = 0;
        do {
          ROQ_UB_tab[v17] =
              (int)(float)((float)((float)v16 * 57.203999) + 32.0);
          ROQ_VR_tab[v17] =
              (int)(float)((float)((float)v16 * 45.363998) + 32.0);
          ROQ_UG_tab[v17] = (int)(float)((float)v16 * -11.51248);
          ROQ_VG_tab[v17] =
              (int)(float)((float)((float)v16 * -23.35248) + 32.0);
          ROQ_YY_tab[v17] = (v15 >> 2) | (v15 << 6);
          ++v15;
          v16 += 2;
          ++v17;
        } while (v15 != 256);
        v18 = 0;
        v19 = word_7055C0;
        do {
          *v19 = v18 * v18;
          v19[128] = -(__int16)(v18 * v18);
          ++v18;
          ++v19;
        } while (v18 != 128);
      }
      FS_Read(&byte_6F55C0, 0x10u, dword_4F3A38[115 * v11]);
      if (((unsigned __int8)byte_6F55C1 << 8) + (unsigned __int8)byte_6F55C0 ==
          4228) {
        v20 = currentHandle;
        dword_4F3A40[115 * v20] = CL_ScaledMilliseconds();
        v21 = 115 * currentHandle;
        v22 = dword_4F3A40[115 * currentHandle];
        dword_4F3A40[v21 + 2] = v22;
        dword_4F3A40[v21 + 1] = v22;
        dword_4F3A50[v21] = 24;
        v23 = (unsigned __int8)byte_6F55C7 << 8;
        v24 = 30;
        if (v23 + (unsigned __int8)byte_6F55C6)
          v24 = v23 + (unsigned __int8)byte_6F55C6;
        dword_4F3ABC[v21] = v24;
        dword_4F3A60[v21] = -1;
        dword_4F3A68[v21] =
            ((unsigned __int8)byte_6F55C9 << 8) + (unsigned __int8)byte_6F55C8;
        dword_4F3A58[v21] = (((unsigned __int8)byte_6F55CB +
                              ((unsigned __int8)byte_6F55CC << 8))
                             << 8) +
                            (unsigned __int8)byte_6F55CA;
        dword_4F3AA8[v21] =
            ((unsigned __int8)byte_6F55CF << 8) + (unsigned __int8)byte_6F55CE;
        Sys_BeginStreamedFile();
        dword_4F3A30[115 * currentHandle + 3] = 1;
        Com_DPrintf("trFMV::play(), playing %s\n", a1);
        if (dword_4F3A24[115 * currentHandle]) {
          v25 = clc;
          dword_4F3AC8[115 * currentHandle] = *(_DWORD *)clc;
          *v25 = 1;
        }
        Con_Close();
        return currentHandle;
      } else {
        Com_DPrintf("trFMV::play(), invalid RoQ ID\n");
        RoQShutdown();
        return -1;
      }
    }
  } else {
    v6 = 0;
    v7 = 0;
    while (I_stricmp(&cinTable[v7 + v6], __src)) {
      ++v6;
      v7 += 459;
      if (v6 == 16)
        goto LABEL_5;
    }
  }
  return v6;
}

int __cdecl ROQ_DrawCinematicFromHandle(unsigned int a1) {
  int result;    // eax
  int v2;        // ebx
  int v3;        // ebx
  int v4;        // [esp+24h] [ebp-94h]
  float v5;      // [esp+30h] [ebp-88h]
  float v6;      // [esp+40h] [ebp-78h]
  float v7;      // [esp+40h] [ebp-78h]
  float v8;      // [esp+40h] [ebp-78h]
  float v9;      // [esp+5Ch] [ebp-5Ch]
  float v10;     // [esp+60h] [ebp-58h]
  float v11;     // [esp+64h] [ebp-54h]
  float v12;     // [esp+68h] [ebp-50h]
  float v13;     // [esp+6Ch] [ebp-4Ch]
  float v14;     // [esp+70h] [ebp-48h]
  int v15;       // [esp+74h] [ebp-44h]
  int v16;       // [esp+78h] [ebp-40h]
  int v17;       // [esp+7Ch] [ebp-3Ch]
  int v18;       // [esp+80h] [ebp-38h]
  int v19;       // [esp+84h] [ebp-34h]
  float v20[10]; // [esp+90h] [ebp-28h] BYREF

  if (a1 <= 0xF) {
    result = 460 * a1;
    if (dword_4F3A3C[115 * a1] != 2) {
      v19 = dword_4F3AC4[115 * a1];
      if (v19) {
        v5 = (float)dword_4F3A10[115 * a1] / (float)dword_4F3A14[115 * a1];
        CL_LookupColor(48, v20);
        if (v5 == unk_14C13D4) {
          v17 = dword_14C13C4;
          v18 = dword_14C13C8;
          v15 = 0;
          v16 = 0;
        } else if (v5 > unk_14C13D4) {
          v3 = dword_14C13C8;
          v8 =
              (float)((float)dword_14C13C8 - (float)((float)(unk_14C13D4 / v5) *
                                                     (float)dword_14C13C8)) *
              0.5;
          v14 = floorf(v8);
          v16 = (int)v14;
          v17 = dword_14C13C4;
          v13 = ceilf(v8);
          v18 = v3 - 2 * (int)v13;
          v15 = 0;
        } else {
          v2 = dword_14C13C4;
          v7 =
              (float)((float)dword_14C13C4 - (float)((float)(v5 / unk_14C13D4) *
                                                     (float)dword_14C13C4)) *
              0.5;
          v12 = floorf(v7);
          v15 = (int)v12;
          v11 = ceilf(v7);
          v17 = v2 - 2 * (int)v11;
          v18 = dword_14C13C8;
          v16 = 0;
        }
        (*(void(__cdecl **)(int, float *, _DWORD, _DWORD)) &
         algn_121C738[48])(1, v20, 0, 0);
        (*(void(__cdecl **)(int, int, int, int, int, int, int, unsigned int,
                            int)) &
         algn_121C738[4])(v15, v16, v17, v18, dword_4F3A00[115 * a1],
                          dword_4F3A04[115 * a1], v19, a1,
                          dword_4F3A20[115 * a1]);
        dword_4F3A20[115 * a1] = 0;
        result = dword_4F3A30[115 * a1];
        if (result) {
          v6 = (float)((float)dword_14C13C8 / 480.0) * 105.0;
          v10 = ceilf(v6);
          v4 = dword_14C13B8;
          v9 = floorf(v6);
          ((void(__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD,
                            _DWORD, _DWORD, _DWORD, _DWORD))dword_121C734)(
              (float)v15, (float)v16, (float)v17, (float)(int)v9, 0, 0, 0, 0,
              v20, v4);
          return (
              (int(__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD,
                              _DWORD, _DWORD, _DWORD, _DWORD))dword_121C734)(
              (float)v15, (float)(v18 + v16 - (int)v10), (float)v17,
              (float)(int)v10, 0, 0, 0, 0, v20, dword_14C13B8);
        }
      }
    }
  }
  return result;
}

int ROQ_DrawCinematic(void) {
  int result; // eax

  result = CL_handle;
  if ((unsigned int)CL_handle <= 0xF)
    return ROQ_DrawCinematicFromHandle(CL_handle);
  return result;
}

void RoQReset(void) {
  int v0; // eax
  int v1; // ebx
  int v2; // ecx
  int v3; // eax
  int v4; // eax
  int v5; // edx

  if (currentHandle >= 0) {
    Sys_EndStreamedFile();
    FS_FCloseFile(dword_4F3A38[115 * currentHandle]);
    v0 = 115 * currentHandle;
    dword_4F3A30[v0 + 2] = 0;
    FS_FOpenFileRead((char *)(v0 * 4 + 5191936), &dword_4F3A38[v0], 1);
    Sys_BeginStreamedFile();
    Sys_StreamedRead(&byte_6F55C0, 16, 1, dword_4F3A38[115 * currentHandle]);
    v1 = currentHandle;
    dword_4F3A40[115 * v1] = CL_ScaledMilliseconds();
    v2 = 115 * currentHandle;
    v3 = dword_4F3A40[115 * currentHandle];
    dword_4F3A40[v2 + 2] = v3;
    dword_4F3A40[v2 + 1] = v3;
    dword_4F3A50[v2] = 24;
    v4 = (unsigned __int8)byte_6F55C7 << 8;
    v5 = 30;
    if (v4 + (unsigned __int8)byte_6F55C6)
      v5 = v4 + (unsigned __int8)byte_6F55C6;
    dword_4F3ABC[v2] = v5;
    dword_4F3A60[v2] = -1;
    dword_4F3A68[v2] =
        ((unsigned __int8)byte_6F55C9 << 8) + (unsigned __int8)byte_6F55C8;
    dword_4F3A58[v2] =
        (((unsigned __int8)byte_6F55CB + ((unsigned __int8)byte_6F55CC << 8))
         << 8) +
        (unsigned __int8)byte_6F55CA;
    dword_4F3AA8[v2] =
        ((unsigned __int8)byte_6F55CF << 8) + (unsigned __int8)byte_6F55CE;
    dword_4F3A30[v2 + 3] = 5;
  }
}

void __usercall ROQ_StopCinematic(long double a1 @<st0>, float a2 @<xmm0>,
                                  __m128 a3 @<xmm1>, __m128 a4 @<xmm2>,
                                  __m128 a5 @<xmm3>, __m128 a6 @<xmm4>,
                                  __m128 a7 @<xmm6>) {
  if ((unsigned int)CL_handle <= 0xF) {
    if (dword_4F3A3C[115 * CL_handle] != 2) {
      currentHandle = CL_handle;
      Com_DPrintf("trFMV::stop(), closing %s\n",
                  (const char *)(460 * CL_handle + 5191936));
      if (dword_4F3AC4[115 * currentHandle]) {
        if (!dword_4F3A24[115 * currentHandle] || *(_DWORD *)clc == 1) {
          dword_4F3A30[115 * currentHandle + 3] = 2;
          RoQShutdown(a1, a2, a3, a4, a5, a6, a7);
        }
      }
    }
    SND_StopSounds(SND_STOP_ALL);
    CL_handle = -1;
  }
}

int __cdecl ROQ_RunCinematicFromHandle(unsigned int a1) {
  int v2;                       // ecx
  float v3;                     // xmm0_4
  int v4;                       // eax
  int v5;                       // esi
  signed int v6;                // ecx
  int v7;                       // ebx
  int v8;                       // ecx
  int v9;                       // edx
  int v10;                      // edx
  int v11;                      // esi
  int v12;                      // eax
  int v13;                      // ebx
  int v14;                      // edx
  int v15;                      // ecx
  int v16;                      // esi
  __int16 v17;                  // dx
  int v18;                      // ebx
  unsigned __int8 *v19;         // ecx
  int v20;                      // edx
  int v21;                      // esi
  int v22;                      // ebx
  unsigned __int8 *v23;         // esi
  int v24;                      // edi
  int v25;                      // eax
  __int16 v26;                  // bx
  __int16 v27;                  // cx
  unsigned __int8 *v28;         // edx
  unsigned int v29;             // edi
  unsigned __int8 *v30;         // esi
  int v31;                      // ebx
  int v32;                      // edi
  int v33;                      // edi
  unsigned __int16 v34;         // dx
  int v35;                      // edx
  int *v36;                     // ebx
  int *v37;                     // edi
  int *v38;                     // esi
  int v39;                      // eax
  int v40;                      // edx
  int v41;                      // eax
  char v42;                     // bl
  char v43;                     // cl
  char v44;                     // dl
  char v45;                     // al
  int v46;                      // ebx
  int v47;                      // edx
  int v48;                      // edi
  int v49;                      // ecx
  int v50;                      // esi
  int v51;                      // edx
  int v52;                      // edi
  int v53;                      // eax
  int v54;                      // esi
  int *v55;                     // ecx
  int v56;                      // ebx
  int v57;                      // eax
  int v58;                      // eax
  int v59;                      // eax
  int v60;                      // edi
  int v61;                      // ecx
  int v62;                      // esi
  int v63;                      // edx
  int v64;                      // edi
  int v65;                      // eax
  int v66;                      // esi
  int *v67;                     // ecx
  int v68;                      // ebx
  int v69;                      // eax
  int v70;                      // esi
  int v71;                      // edi
  int v72;                      // edx
  int v73;                      // eax
  int v74;                      // esi
  int v75;                      // edx
  int *v76;                     // esi
  int *v77;                     // ecx
  int v78;                      // eax
  int v79;                      // edx
  int *v80;                     // edi
  int *v81;                     // ebx
  int v82;                      // edx
  int v83;                      // eax
  int v84;                      // ecx
  int v85;                      // ebx
  int v86;                      // ecx
  int v87;                      // ecx
  unsigned int v88;             // edi
  int v89;                      // esi
  int v90;                      // edx
  int i;                        // ecx
  int v92;                      // ebx
  int *v93;                     // edx
  int j;                        // ecx
  int v95;                      // eax
  int v96;                      // edx
  int v97;                      // edx
  int *v98;                     // edi
  int *v99;                     // esi
  int v100;                     // eax
  int v101;                     // edx
  int *v102;                    // eax
  char v103;                    // bl
  char v104;                    // cl
  char v105;                    // dl
  char v106;                    // al
  char v107;                    // bl
  char v108;                    // cl
  char v109;                    // dl
  char v110;                    // al
  int v111;                     // eax
  int *v112;                    // edi
  int *v113;                    // esi
  int v114;                     // edx
  int v115;                     // eax
  int jj;                       // eax
  int v117;                     // ebx
  int v118;                     // ecx
  int v119;                     // edx
  int v120;                     // eax
  int v121;                     // ebx
  int v122;                     // ecx
  int v123;                     // edx
  int v124;                     // eax
  int *v125;                    // edi
  int *v126;                    // esi
  int v127;                     // edx
  int v128;                     // eax
  int i3;                       // eax
  int v130;                     // ebx
  int v131;                     // ecx
  int v132;                     // edx
  int v133;                     // eax
  int *v134;                    // ebx
  int *v135;                    // ecx
  int v136;                     // eax
  int v137;                     // edx
  int v138;                     // edi
  int v139;                     // esi
  __int16 v140;                 // dx
  __int16 v141;                 // ax
  int *v142;                    // ecx
  int *v143;                    // ebx
  int *v144;                    // ecx
  int v145;                     // eax
  int v146;                     // edx
  int v147;                     // edi
  int v148;                     // esi
  char v149;                    // dl
  char v150;                    // al
  unsigned __int8 *v151;        // ebx
  __int16 v152;                 // bx
  __int16 v153;                 // dx
  __int16 v154;                 // ax
  int v155;                     // edx
  int v156;                     // ebx
  int v157;                     // eax
  int v158;                     // edx
  int v159;                     // ebx
  int v160;                     // eax
  int v161;                     // esi
  __int16 v162;                 // cx
  __int16 v163;                 // ax
  __int16 v164;                 // dx
  int v165;                     // eax
  int v166;                     // edi
  unsigned __int8 *v167;        // edx
  int v168;                     // ebx
  int v169;                     // ecx
  int v170;                     // esi
  int v171;                     // edx
  int v172;                     // edi
  int v173;                     // ecx
  int v174;                     // ebx
  int v175;                     // edx
  int v176;                     // ecx
  int *v177;                    // edi
  int *v178;                    // esi
  int v179;                     // eax
  int v180;                     // edx
  int *v181;                    // eax
  __int16 v182;                 // bx
  __int16 v183;                 // cx
  __int16 v184;                 // dx
  __int16 v185;                 // ax
  int *v186;                    // edi
  int *v187;                    // esi
  int v188;                     // edx
  int v189;                     // eax
  int m;                        // eax
  __int16 v191;                 // bx
  __int16 v192;                 // cx
  __int16 v193;                 // dx
  __int16 v194;                 // ax
  __int16 v195;                 // bx
  __int16 v196;                 // cx
  __int16 v197;                 // dx
  __int16 v198;                 // ax
  int v199;                     // edx
  int v200;                     // ebx
  unsigned __int8 *v201;        // esi
  unsigned __int8 *nn;          // eax
  __int16 v203;                 // bx
  __int16 v204;                 // dx
  __int16 v205;                 // ax
  int v206;                     // edx
  int v207;                     // ebx
  int v208;                     // eax
  int v209;                     // edx
  int v210;                     // ebx
  int v211;                     // eax
  int v212;                     // edx
  __int16 v213;                 // bx
  __int16 v214;                 // cx
  __int16 v215;                 // ax
  int v216;                     // edx
  int v217;                     // ebx
  int v218;                     // eax
  int v219;                     // edx
  int v220;                     // ebx
  int v221;                     // eax
  int v222;                     // edx
  __int16 v223;                 // bx
  __int16 v224;                 // cx
  __int16 v225;                 // ax
  int v226;                     // edx
  int v227;                     // ebx
  int v228;                     // eax
  int v229;                     // edx
  int v230;                     // ebx
  int v231;                     // eax
  int v232;                     // edx
  __int16 v233;                 // bx
  __int16 v234;                 // cx
  __int16 v235;                 // ax
  int v236;                     // edx
  int v237;                     // ebx
  unsigned __int8 *v238;        // edi
  int v239;                     // eax
  int v240;                     // ecx
  int v241;                     // esi
  int v242;                     // edi
  int v243;                     // edx
  int v244;                     // ecx
  int v245;                     // ebx
  int v246;                     // edx
  int v247;                     // ecx
  unsigned __int8 *v248;        // ebx
  unsigned __int8 *v249;        // esi
  unsigned __int8 *v250;        // edi
  unsigned __int8 *v251;        // eax
  unsigned __int8 *k;           // edx
  __int16 v253;                 // bx
  __int16 v254;                 // ax
  __int16 v255;                 // dx
  int v256;                     // edx
  int v257;                     // ebx
  int v258;                     // eax
  int v259;                     // edx
  int v260;                     // ebx
  int v261;                     // eax
  int v262;                     // esi
  __int16 v263;                 // cx
  __int16 v264;                 // ax
  __int16 v265;                 // dx
  int v266;                     // edx
  int v267;                     // ebx
  int v268;                     // eax
  int v269;                     // edx
  int v270;                     // ebx
  int v271;                     // eax
  int v272;                     // esi
  __int16 v273;                 // cx
  __int16 v274;                 // ax
  __int16 v275;                 // dx
  int v276;                     // edx
  int v277;                     // ebx
  int v278;                     // eax
  int v279;                     // edx
  int v280;                     // ebx
  int v281;                     // eax
  int v282;                     // edx
  __int16 v283;                 // bx
  __int16 v284;                 // cx
  __int16 v285;                 // ax
  int v286;                     // edx
  int v287;                     // ebx
  int v288;                     // eax
  int v289;                     // edx
  int v290;                     // ebx
  int v291;                     // eax
  int v292;                     // edx
  __int16 v293;                 // bx
  __int16 v294;                 // cx
  __int16 v295;                 // ax
  int v296;                     // edx
  int v297;                     // ebx
  int v298;                     // eax
  int v299;                     // edx
  int v300;                     // ebx
  int v301;                     // eax
  int v302;                     // edx
  __int16 v303;                 // bx
  __int16 v304;                 // cx
  __int16 v305;                 // ax
  int v306;                     // edx
  int v307;                     // ebx
  int v308;                     // eax
  int v309;                     // edx
  int v310;                     // ebx
  int v311;                     // eax
  int v312;                     // edx
  __int16 v313;                 // bx
  __int16 v314;                 // cx
  __int16 v315;                 // ax
  int v316;                     // edx
  int v317;                     // ebx
  int v318;                     // eax
  int v319;                     // edx
  int v320;                     // ebx
  int v321;                     // eax
  int v322;                     // edx
  __int16 v323;                 // bx
  __int16 v324;                 // cx
  __int16 v325;                 // ax
  int v326;                     // ebx
  int v327;                     // eax
  int v328;                     // ecx
  int v329;                     // esi
  int v330;                     // edi
  int v331;                     // edx
  int v332;                     // ecx
  int v333;                     // ebx
  int v334;                     // edx
  int v335;                     // ecx
  unsigned __int8 *i7;          // ebx
  int v337;                     // ebx
  int v338;                     // edx
  int v339;                     // eax
  int v340;                     // eax
  int v341;                     // edx
  int v342;                     // ebx
  int v343;                     // eax
  int v344;                     // edx
  int v345;                     // ecx
  int v346;                     // ebx
  int v347;                     // eax
  int v348;                     // edx
  unsigned int v349;            // eax
  int v350;                     // edx
  int v351;                     // edx
  int v352;                     // eax
  int v353;                     // esi
  unsigned __int8 *v354;        // edi
  int v355;                     // ebx
  int v356;                     // ecx
  int v357;                     // edi
  int v358;                     // edx
  int v359;                     // esi
  int v360;                     // ecx
  int v361;                     // ebx
  int v362;                     // edx
  int v363;                     // ecx
  unsigned __int8 *i1;          // esi
  int v365;                     // ebx
  int v366;                     // eax
  int v367;                     // edx
  int v368;                     // ebx
  int v369;                     // edx
  int v370;                     // ebx
  int v371;                     // eax
  int v372;                     // edx
  int v373;                     // ecx
  int v374;                     // ebx
  int v375;                     // eax
  int v376;                     // edx
  int v377;                     // eax
  int v378;                     // edx
  int v379;                     // edx
  int v380;                     // ebx
  int v381;                     // eax
  int v382;                     // edx
  int v383;                     // ecx
  int v384;                     // ebx
  int v385;                     // eax
  int v386;                     // edx
  int v387;                     // eax
  int v388;                     // edx
  int v389;                     // edx
  int v390;                     // ebx
  int v391;                     // eax
  int v392;                     // edx
  int v393;                     // ecx
  int v394;                     // ebx
  int v395;                     // eax
  int v396;                     // edx
  unsigned int v397;            // eax
  int v398;                     // edx
  int v399;                     // ecx
  int v400;                     // ebx
  int v401;                     // edx
  int v402;                     // ecx
  int v403;                     // esi
  int v404;                     // edi
  int v405;                     // eax
  int v406;                     // ecx
  int v407;                     // ebx
  int v408;                     // eax
  int v409;                     // ecx
  unsigned __int8 *v410;        // esi
  unsigned __int8 *v411;        // edi
  unsigned __int8 *v412;        // eax
  unsigned __int8 *v413;        // edx
  unsigned __int8 *n;           // ecx
  int v415;                     // ebx
  int v416;                     // eax
  int v417;                     // edx
  int v418;                     // edx
  int v419;                     // edx
  int v420;                     // ebx
  int v421;                     // eax
  int v422;                     // edx
  int v423;                     // ecx
  int v424;                     // ebx
  int v425;                     // eax
  int v426;                     // edx
  int v427;                     // eax
  int v428;                     // edx
  int v429;                     // edx
  int v430;                     // edx
  int v431;                     // ebx
  int v432;                     // eax
  int v433;                     // edx
  int v434;                     // ebx
  int v435;                     // eax
  int v436;                     // edx
  int v437;                     // eax
  int v438;                     // edx
  int v439;                     // edx
  int v440;                     // edx
  int v441;                     // ebx
  int v442;                     // eax
  int v443;                     // edx
  int v444;                     // ebx
  int v445;                     // eax
  int v446;                     // edx
  int v447;                     // eax
  int v448;                     // edx
  int v449;                     // edx
  int v450;                     // edx
  int v451;                     // ebx
  int v452;                     // eax
  int v453;                     // edx
  int v454;                     // ebx
  int v455;                     // eax
  int v456;                     // edx
  int v457;                     // eax
  int v458;                     // edx
  int v459;                     // edx
  int v460;                     // ebx
  int v461;                     // eax
  int v462;                     // edx
  int v463;                     // ecx
  int v464;                     // ebx
  int v465;                     // eax
  int v466;                     // edx
  int v467;                     // eax
  int v468;                     // edx
  int v469;                     // edx
  int v470;                     // ebx
  int v471;                     // eax
  int v472;                     // edx
  int v473;                     // ecx
  int v474;                     // ebx
  int v475;                     // eax
  int v476;                     // edx
  int v477;                     // eax
  int v478;                     // edx
  int v479;                     // edx
  int v480;                     // ebx
  int v481;                     // eax
  int v482;                     // edx
  int v483;                     // ecx
  int v484;                     // ebx
  int v485;                     // eax
  int v486;                     // edx
  unsigned int v487;            // eax
  int v488;                     // edx
  int v489;                     // ecx
  int v490;                     // ebx
  int v491;                     // edx
  int v492;                     // ecx
  int v493;                     // esi
  int v494;                     // edi
  int v495;                     // eax
  int v496;                     // ecx
  int v497;                     // ebx
  int v498;                     // eax
  int v499;                     // ecx
  int v500;                     // edi
  unsigned __int8 *v501;        // esi
  unsigned __int8 *kk;          // eax
  int v503;                     // ecx
  int v504;                     // ebx
  int v505;                     // esi
  int v506;                     // ecx
  int v507;                     // edx
  unsigned __int8 *v508;        // edi
  int v509;                     // [esp+6Ch] [ebp-1020Ch]
  int v510;                     // [esp+6Ch] [ebp-1020Ch]
  int v511;                     // [esp+6Ch] [ebp-1020Ch]
  int v512;                     // [esp+74h] [ebp-10204h]
  int v513;                     // [esp+78h] [ebp-10200h]
  int v514;                     // [esp+7Ch] [ebp-101FCh]
  int v515;                     // [esp+80h] [ebp-101F8h]
  int v516;                     // [esp+84h] [ebp-101F4h]
  int v517;                     // [esp+88h] [ebp-101F0h]
  int v518;                     // [esp+8Ch] [ebp-101ECh]
  int v519;                     // [esp+90h] [ebp-101E8h]
  int v520;                     // [esp+94h] [ebp-101E4h]
  int v521;                     // [esp+98h] [ebp-101E0h]
  int v522;                     // [esp+9Ch] [ebp-101DCh]
  int v523;                     // [esp+A0h] [ebp-101D8h]
  int v524;                     // [esp+A4h] [ebp-101D4h]
  int v525;                     // [esp+A8h] [ebp-101D0h]
  int v526;                     // [esp+ACh] [ebp-101CCh]
  int v527;                     // [esp+B0h] [ebp-101C8h]
  int v528;                     // [esp+B4h] [ebp-101C4h]
  int v529;                     // [esp+B8h] [ebp-101C0h]
  int v530;                     // [esp+BCh] [ebp-101BCh]
  int v531;                     // [esp+C0h] [ebp-101B8h]
  int v532;                     // [esp+C4h] [ebp-101B4h]
  int v533;                     // [esp+C8h] [ebp-101B0h]
  int v534;                     // [esp+CCh] [ebp-101ACh]
  int v535;                     // [esp+D0h] [ebp-101A8h]
  int v536;                     // [esp+D4h] [ebp-101A4h]
  int v537;                     // [esp+D8h] [ebp-101A0h]
  int v538;                     // [esp+DCh] [ebp-1019Ch]
  int v539;                     // [esp+E0h] [ebp-10198h]
  int v540;                     // [esp+E4h] [ebp-10194h]
  int v541;                     // [esp+E8h] [ebp-10190h]
  int v542;                     // [esp+ECh] [ebp-1018Ch]
  int v543;                     // [esp+F0h] [ebp-10188h]
  int v544;                     // [esp+F4h] [ebp-10184h]
  int i9;                       // [esp+F8h] [ebp-10180h]
  int v546;                     // [esp+FCh] [ebp-1017Ch]
  int *v547;                    // [esp+100h] [ebp-10178h]
  int *v548;                    // [esp+104h] [ebp-10174h]
  int v549;                     // [esp+108h] [ebp-10170h]
  int v550;                     // [esp+10Ch] [ebp-1016Ch]
  int v551;                     // [esp+110h] [ebp-10168h]
  int v552;                     // [esp+114h] [ebp-10164h]
  int v553;                     // [esp+118h] [ebp-10160h]
  int v554;                     // [esp+11Ch] [ebp-1015Ch]
  int v555;                     // [esp+120h] [ebp-10158h]
  int v556;                     // [esp+124h] [ebp-10154h]
  int v557;                     // [esp+128h] [ebp-10150h]
  int v558;                     // [esp+12Ch] [ebp-1014Ch]
  int v559;                     // [esp+130h] [ebp-10148h]
  int v560;                     // [esp+134h] [ebp-10144h]
  int v561;                     // [esp+138h] [ebp-10140h]
  int v562;                     // [esp+13Ch] [ebp-1013Ch]
  int v563;                     // [esp+140h] [ebp-10138h]
  int v564;                     // [esp+144h] [ebp-10134h]
  unsigned int v565;            // [esp+148h] [ebp-10130h]
  unsigned __int8 *v566;        // [esp+14Ch] [ebp-1012Ch]
  int v567;                     // [esp+150h] [ebp-10128h]
  int v568;                     // [esp+154h] [ebp-10124h]
  int v569;                     // [esp+158h] [ebp-10120h]
  int v570;                     // [esp+15Ch] [ebp-1011Ch]
  int v571;                     // [esp+160h] [ebp-10118h]
  int v572;                     // [esp+164h] [ebp-10114h]
  int v573;                     // [esp+168h] [ebp-10110h]
  int *v574;                    // [esp+16Ch] [ebp-1010Ch]
  int *v575;                    // [esp+170h] [ebp-10108h]
  int *v576;                    // [esp+174h] [ebp-10104h]
  int *v577;                    // [esp+178h] [ebp-10100h]
  int v578;                     // [esp+17Ch] [ebp-100FCh]
  int v579;                     // [esp+180h] [ebp-100F8h]
  int *v580;                    // [esp+184h] [ebp-100F4h]
  int *v581;                    // [esp+188h] [ebp-100F0h]
  int v582;                     // [esp+18Ch] [ebp-100ECh]
  int v583;                     // [esp+190h] [ebp-100E8h]
  int *v584;                    // [esp+194h] [ebp-100E4h]
  int *v585;                    // [esp+198h] [ebp-100E0h]
  int v586;                     // [esp+19Ch] [ebp-100DCh]
  int v587;                     // [esp+1A0h] [ebp-100D8h]
  int *v588;                    // [esp+1A4h] [ebp-100D4h]
  int *v589;                    // [esp+1A8h] [ebp-100D0h]
  int v590;                     // [esp+1ACh] [ebp-100CCh]
  int v591;                     // [esp+1B0h] [ebp-100C8h]
  int *v592;                    // [esp+1B4h] [ebp-100C4h]
  int *v593;                    // [esp+1B8h] [ebp-100C0h]
  int *v594;                    // [esp+1BCh] [ebp-100BCh]
  int *v595;                    // [esp+1C0h] [ebp-100B8h]
  int *v596;                    // [esp+1C4h] [ebp-100B4h]
  int *v597;                    // [esp+1C8h] [ebp-100B0h]
  int *v598;                    // [esp+1CCh] [ebp-100ACh]
  int *v599;                    // [esp+1D0h] [ebp-100A8h]
  int *v600;                    // [esp+1D4h] [ebp-100A4h]
  int *v601;                    // [esp+1D8h] [ebp-100A0h]
  int *v602;                    // [esp+1DCh] [ebp-1009Ch]
  int *v603;                    // [esp+1E0h] [ebp-10098h]
  int *v604;                    // [esp+1E4h] [ebp-10094h]
  int *v605;                    // [esp+1E8h] [ebp-10090h]
  int *v606;                    // [esp+1ECh] [ebp-1008Ch]
  int *v607;                    // [esp+1F0h] [ebp-10088h]
  int *v608;                    // [esp+1F4h] [ebp-10084h]
  int i6;                       // [esp+1F8h] [ebp-10080h]
  int i10;                      // [esp+1FCh] [ebp-1007Ch]
  unsigned __int8 *v611;        // [esp+200h] [ebp-10078h]
  unsigned __int8 *v612;        // [esp+204h] [ebp-10074h]
  unsigned __int8 *v613;        // [esp+208h] [ebp-10070h]
  unsigned __int8 *v614;        // [esp+20Ch] [ebp-1006Ch]
  unsigned __int8 *v615;        // [esp+210h] [ebp-10068h]
  unsigned __int8 *v616;        // [esp+214h] [ebp-10064h]
  unsigned __int8 *v617;        // [esp+218h] [ebp-10060h]
  unsigned __int8 *v618;        // [esp+21Ch] [ebp-1005Ch]
  unsigned __int8 *v619;        // [esp+220h] [ebp-10058h]
  int v620;                     // [esp+224h] [ebp-10054h]
  int v621;                     // [esp+228h] [ebp-10050h]
  int i2;                       // [esp+22Ch] [ebp-1004Ch]
  int i4;                       // [esp+230h] [ebp-10048h]
  int v624;                     // [esp+234h] [ebp-10044h]
  int v625;                     // [esp+238h] [ebp-10040h]
  int v626;                     // [esp+23Ch] [ebp-1003Ch]
  int ii;                       // [esp+240h] [ebp-10038h]
  int v628;                     // [esp+244h] [ebp-10034h]
  int mm;                       // [esp+248h] [ebp-10030h]
  int v630;                     // [esp+24Ch] [ebp-1002Ch]
  int v631;                     // [esp+250h] [ebp-10028h]
  int i5;                       // [esp+254h] [ebp-10024h]
  int v633;                     // [esp+258h] [ebp-10020h]
  int i8;                       // [esp+25Ch] [ebp-1001Ch]
  unsigned __int8 __src[65560]; // [esp+260h] [ebp-10018h] BYREF

  if (a1 > 0xF || dword_4F3A3C[115 * a1] == 2)
    return 2;
  if (a1 != dword_745BD0) {
    currentHandle = a1;
    dword_745BD0 = a1;
    dword_4F3A3C[115 * a1] = 2;
    RoQReset();
  }
  if (dword_4F3AC0[115 * a1] < -1)
    return dword_4F3A3C[115 * a1];
  currentHandle = a1;
  if (dword_4F3A24[115 * a1]) {
    if (*(_DWORD *)clc != 1)
      return dword_4F3A3C[115 * a1];
  }
  if (!dword_4F3A3C[115 * a1])
    return 0;
  v539 = CL_ScaledMilliseconds();
  v514 = currentHandle;
  if (!dword_4F3A2C[115 * currentHandle])
    goto LABEL_124;
  v2 = v539 - dword_4F3A48[115 * currentHandle];
  if (v2 < 0)
    v3 = (float)(v2 & 1 | ((unsigned int)v2 >> 1)) +
         (float)(v2 & 1 | ((unsigned int)v2 >> 1));
  else
    v3 = (float)v2;
  v4 = (int)v3;
  if ((int)v3 <= -1)
    v4 = -(int)v3;
  if (v4 > 100) {
    dword_4F3A40[115 * currentHandle] += v2;
    v5 = v514;
  } else {
  LABEL_124:
    v5 = currentHandle;
  }
  if (dword_4F3A34[115 * v5]) {
    v111 = SND_RawSamplesTime();
    v514 = currentHandle;
    v6 = dword_4F3ABC[115 * currentHandle] * v111 / 1000 + 1;
    v7 = currentHandle;
  } else {
    v6 = dword_4F3ABC[115 * v5] * (v539 - dword_4F3A40[115 * v5]) / 0x3E8u;
    v7 = v514;
  }
  if (v6 <= dword_4F3A4C[115 * v7]) {
    if ((unsigned int)(dword_4F3ABC[115 * v7] *
                       (v539 - dword_4F3A44[115 * v7])) > 0xFA0)
      dword_4F3A3C[115 * v7] = 2;
  } else {
    dword_4F3A4C[115 * v7] = v6;
    dword_4F3A44[115 * v7] = v539;
  }
  v538 = dword_4F3A40[115 * v514];
  v8 = v514;
LABEL_24:
  v9 = 115 * v8;
  if (dword_4F3A4C[115 * v8] == dword_4F3A60[115 * v8])
    goto LABEL_33;
LABEL_25:
  if (dword_4F3A3C[v9] != 1)
    goto LABEL_33;
  if (v514 < 0)
    goto LABEL_39;
  Sys_StreamedRead(&byte_6F55C0, dword_4F3A58[v9] + 8, 1, dword_4F3A38[v9]);
  v514 = currentHandle;
  v10 = 115 * currentHandle;
  if (dword_4F3A50[115 * currentHandle] >= dword_4F3A54[115 * currentHandle]) {
    if (dword_4F3A1C[115 * currentHandle]) {
      dword_4F3A30[v10 + 3] = 0;
      v11 = v514;
      goto LABEL_31;
    }
    if (!dword_4F3A18[115 * currentHandle]) {
      dword_4F3A30[v10 + 3] = 2;
      v11 = v514;
      goto LABEL_31;
    }
    goto LABEL_96;
  }
  v566 = (unsigned __int8 *)&byte_6F55C0;
  while (2) {
    switch (dword_4F3A68[115 * v514]) {
    case 4097:
      v32 = 115 * v514;
      if (dword_4F3A60[115 * v514] == -1) {
        if (v514 >= 0) {
          v84 = (v566[1] << 8) + *v566;
          dword_4F3A80[v32 + 2] = v84;
          v85 = (v566[3] << 8) + v566[2];
          dword_4F3A80[v32 + 3] = v85;
          dword_4F3A90[115 * v514] = (v566[5] << 8) + v566[4];
          dword_4F3A90[v32 + 1] = (v566[7] << 8) + v566[6];
          dword_4F3A04[115 * v514] = v85;
          dword_4F3A00[115 * v514] = v84;
          v86 = dword_4F3A80[115 * v514] * v84;
          dword_4F3A64[115 * v514] = v86;
          v87 = dword_4F3A04[115 * v514] * v86;
          dword_4F3A6C[115 * v514] = v87;
          dword_4F3A90[v32 + 2] = 0;
          dword_4F3A90[v32 + 3] = 0;
          dword_4F3A70[115 * v514] = dword_4F3A78[115 * v514];
          dword_4F3A74[115 * v514] = dword_4F3A7C[115 * v514];
          dword_4F3AB4[115 * v514] = v87;
          dword_4F3AB8[115 * v514] = -v87;
        }
        if (dword_745BC0 || dword_745BC4 ||
            dword_4F3A8C[115 * v514] != dword_745BC8 ||
            dword_4F3A88[115 * v514] != dword_745BCC) {
          dword_745BC0 = 0;
          dword_745BC4 = 0;
          dword_745BC8 = dword_4F3A8C[115 * v514];
          dword_745BCC = dword_4F3A88[115 * v514];
          v88 = ((unsigned int)(dword_4F3A8C[115 * v514] * dword_745BCC) >> 4) +
                ((unsigned int)(dword_4F3A8C[115 * v514] * dword_745BCC) >> 6) +
                64;
          dword_4F3A5C[115 * v514] = 0;
          if (dword_4F3A8C[115 * v514] > 0) {
            v89 = 0;
            v90 = v514;
            for (i = v514;; v90 = i) {
              if (*(int *)((char *)dword_4F3A88 + 459 * v90 + i) > 0) {
                v92 = 0;
                do {
                  recurseQuad(v92, v89, 16, 0, 0);
                  v92 += 16;
                  v514 = currentHandle;
                  i = currentHandle;
                } while (v92 < dword_4F3A88[115 * currentHandle]);
              }
              v89 += 16;
              if (v89 >= dword_4F3A8C[115 * i])
                break;
            }
          }
          v93 = &dword_705BC0[v88 - 64];
          for (j = 0; j != 64; ++j) {
            *v93 = 0;
            *(_DWORD *)((char *)&loc_20000 + (_DWORD)v93++) = 0;
          }
        }
        v95 = CL_ScaledMilliseconds();
        v96 = 115 * v514;
        dword_4F3A48[v96] = v95;
        dword_4F3A40[v96] = v95;
        v514 = currentHandle;
        v33 = currentHandle;
      } else {
        v33 = v514;
      }
      if (dword_4F3A60[115 * v33] == 1) {
        v21 = v33;
      } else {
        dword_4F3A60[115 * v33] = 0;
        v21 = v514;
      }
      goto LABEL_49;
    case 4098:
      v34 = dword_4F3AA8[115 * v514];
      if (v34) {
        v546 = HIBYTE(v34);
        if (!HIBYTE(v34))
          v546 = 256;
        v567 = 2 * (unsigned __int8)v34;
      } else {
        v546 = 256;
        v567 = 512;
      }
      if (!dword_4F3A98[115 * v514]) {
        if (dword_4F3A9C[115 * v514]) {
          v97 = dword_4F3A80[115 * v514];
          switch (v97) {
          case 2:
            if (v546 > 0) {
              v604 = vq2;
              v624 = 0;
              v248 = v566;
              v249 = v566;
              v250 = v566;
              v251 = v566;
              for (k = v566;; k = v611) {
                v555 = *v248;
                v556 = v249[1];
                v557 = v250[2];
                v558 = v251[3];
                v326 = k[4];
                v327 = k[5];
                v611 = k + 6;
                v328 = ROQ_YY_tab[v555];
                v517 = ROQ_VR_tab[v327];
                v329 = v328 + v517;
                v526 = ROQ_UG_tab[v326];
                v330 = ROQ_VG_tab[v327];
                v331 = v330 + v328 + v526;
                v525 = ROQ_UB_tab[v326];
                v332 = v525 + v328;
                v333 = v329 >> 9;
                if (v329 >> 9 < 0)
                  v333 = 0;
                v334 = v331 >> 8;
                if (v334 < 0)
                  v334 = 0;
                v335 = v332 >> 9;
                if (v335 < 0)
                  v335 = 0;
                if (v333 > 31)
                  v253 = -2048;
                else
                  v253 = (_WORD)v333 << 11;
                if (v334 <= 63)
                  v254 = 32 * v334;
                else
                  v254 = 2016;
                v255 = 31;
                if (v335 < 32)
                  v255 = v335;
                *(_WORD *)v604 = v255 + v253 + v254;
                v256 = ROQ_YY_tab[v556];
                v257 = v256 + v517;
                v258 = v330 + v256 + v526;
                v259 = v525 + v256;
                v260 = v257 >> 9;
                if (v260 < 0)
                  v260 = 0;
                v261 = v258 >> 8;
                if (v261 < 0)
                  v261 = 0;
                v262 = v259 >> 9;
                if (v259 >> 9 < 0)
                  v262 = 0;
                if (v260 <= 31)
                  v263 = (_WORD)v260 << 11;
                else
                  v263 = -2048;
                if (v261 <= 63)
                  v264 = 32 * v261;
                else
                  v264 = 2016;
                v265 = 31;
                if (v262 < 32)
                  v265 = v262;
                *((_WORD *)v604 + 1) = v265 + v263 + v264;
                v266 = ROQ_YY_tab[(v557 + 3 * v555) >> 2];
                v267 = v266 + v517;
                v268 = v330 + v266 + v526;
                v269 = v525 + v266;
                v270 = v267 >> 9;
                if (v270 < 0)
                  v270 = 0;
                v271 = v268 >> 8;
                if (v271 < 0)
                  v271 = 0;
                v272 = v269 >> 9;
                if (v269 >> 9 < 0)
                  v272 = 0;
                if (v270 <= 31)
                  v273 = (_WORD)v270 << 11;
                else
                  v273 = -2048;
                if (v271 <= 63)
                  v274 = 32 * v271;
                else
                  v274 = 2016;
                v275 = 31;
                if (v272 < 32)
                  v275 = v272;
                *((_WORD *)v604 + 2) = v275 + v273 + v274;
                v276 = ROQ_YY_tab[(v558 + 3 * v556) >> 2];
                v277 = v276 + v517;
                v278 = v330 + v276 + v526;
                v279 = v525 + v276;
                v280 = v277 >> 9;
                if (v280 < 0)
                  v280 = 0;
                v281 = v278 >> 8;
                if (v281 < 0)
                  v281 = 0;
                v282 = v279 >> 9;
                if (v282 < 0)
                  v282 = 0;
                if (v280 <= 31)
                  v283 = (_WORD)v280 << 11;
                else
                  v283 = -2048;
                if (v281 <= 63)
                  v284 = 32 * v281;
                else
                  v284 = 2016;
                v285 = 31;
                if (v282 < 32)
                  v285 = v282;
                *((_WORD *)v604 + 3) = v283 + v284 + v285;
                v286 = ROQ_YY_tab[(v555 + 3 * v557) >> 2];
                v287 = v286 + v517;
                v288 = v330 + v286 + v526;
                v289 = v525 + v286;
                v290 = v287 >> 9;
                if (v290 < 0)
                  v290 = 0;
                v291 = v288 >> 8;
                if (v291 < 0)
                  v291 = 0;
                v292 = v289 >> 9;
                if (v292 < 0)
                  v292 = 0;
                if (v290 <= 31)
                  v293 = (_WORD)v290 << 11;
                else
                  v293 = -2048;
                if (v291 <= 63)
                  v294 = 32 * v291;
                else
                  v294 = 2016;
                v295 = 31;
                if (v292 < 32)
                  v295 = v292;
                *((_WORD *)v604 + 4) = v293 + v294 + v295;
                v296 = ROQ_YY_tab[(v556 + 3 * v558) >> 2];
                v297 = v296 + v517;
                v298 = v330 + v296 + v526;
                v299 = v525 + v296;
                v300 = v297 >> 9;
                if (v300 < 0)
                  v300 = 0;
                v301 = v298 >> 8;
                if (v301 < 0)
                  v301 = 0;
                v302 = v299 >> 9;
                if (v302 < 0)
                  v302 = 0;
                if (v300 <= 31)
                  v303 = (_WORD)v300 << 11;
                else
                  v303 = -2048;
                if (v301 <= 63)
                  v304 = 32 * v301;
                else
                  v304 = 2016;
                v305 = 31;
                if (v302 < 32)
                  v305 = v302;
                *((_WORD *)v604 + 5) = v303 + v304 + v305;
                v306 = ROQ_YY_tab[v557];
                v307 = v306 + v517;
                v308 = v330 + v306 + v526;
                v309 = v525 + v306;
                v310 = v307 >> 9;
                if (v310 < 0)
                  v310 = 0;
                v311 = v308 >> 8;
                if (v311 < 0)
                  v311 = 0;
                v312 = v309 >> 9;
                if (v312 < 0)
                  v312 = 0;
                if (v310 <= 31)
                  v313 = (_WORD)v310 << 11;
                else
                  v313 = -2048;
                if (v311 <= 63)
                  v314 = 32 * v311;
                else
                  v314 = 2016;
                v315 = 31;
                if (v312 < 32)
                  v315 = v312;
                *((_WORD *)v604 + 6) = v313 + v314 + v315;
                v316 = ROQ_YY_tab[v558];
                v317 = v316 + v517;
                v318 = v330 + v316 + v526;
                v319 = v525 + v316;
                v320 = v317 >> 9;
                if (v320 < 0)
                  v320 = 0;
                v321 = v318 >> 8;
                if (v321 < 0)
                  v321 = 0;
                v322 = v319 >> 9;
                if (v322 < 0)
                  v322 = 0;
                if (v320 <= 31)
                  v323 = (_WORD)v320 << 11;
                else
                  v323 = -2048;
                if (v321 <= 63)
                  v324 = 32 * v321;
                else
                  v324 = 2016;
                v325 = 31;
                if (v322 < 32)
                  v325 = v322;
                *((_WORD *)v604 + 7) = v323 + v324 + v325;
                v604 += 4;
                if (v546 == ++v624)
                  break;
                v248 = v611;
                v249 = v611;
                v250 = v611;
                v251 = v611;
              }
            } else {
              v611 = v566;
            }
            if (v567 > 0) {
              v625 = 0;
              v588 = &vq8;
              v589 = &vq4;
              do {
                v186 = v589;
                v187 = v588;
                v188 = 16 * *v611;
                v189 = 16 * v611[1];
                v611 += 2;
                v586 = v188 + 7630824;
                v587 = v189 + 7630824;
                v570 = 2;
                for (m = v188 + 7630824;; m = v586) {
                  v191 = *(_WORD *)(m - 8);
                  *(_WORD *)v186 = v191;
                  *(_WORD *)v187 = v191;
                  *((_WORD *)v187 + 1) = v191;
                  v192 = *(_WORD *)(m - 6);
                  *((_WORD *)v186 + 1) = v192;
                  *((_WORD *)v187 + 2) = v192;
                  *((_WORD *)v187 + 3) = v192;
                  v193 = *(_WORD *)(v587 - 8);
                  *((_WORD *)v186 + 2) = v193;
                  *((_WORD *)v187 + 4) = v193;
                  *((_WORD *)v187 + 5) = v193;
                  v194 = *(_WORD *)(v587 - 6);
                  *((_WORD *)v186 + 3) = v194;
                  *((_WORD *)v187 + 6) = v194;
                  *((_WORD *)v187 + 7) = v194;
                  *((_WORD *)v187 + 8) = v191;
                  *((_WORD *)v187 + 9) = v191;
                  *((_WORD *)v187 + 10) = v192;
                  *((_WORD *)v187 + 11) = v192;
                  *((_WORD *)v187 + 12) = v193;
                  *((_WORD *)v187 + 13) = v193;
                  *((_WORD *)v187 + 14) = v194;
                  *((_WORD *)v187 + 15) = v194;
                  v195 = *(_WORD *)(v586 - 4);
                  *((_WORD *)v186 + 4) = v195;
                  *((_WORD *)v187 + 16) = v195;
                  *((_WORD *)v187 + 17) = v195;
                  v196 = *(_WORD *)(v586 - 2);
                  *((_WORD *)v186 + 5) = v196;
                  *((_WORD *)v187 + 18) = v196;
                  *((_WORD *)v187 + 19) = v196;
                  v197 = *(_WORD *)(v587 - 4);
                  *((_WORD *)v186 + 6) = v197;
                  *((_WORD *)v187 + 20) = v197;
                  *((_WORD *)v187 + 21) = v197;
                  v198 = *(_WORD *)(v587 - 2);
                  *((_WORD *)v186 + 7) = v198;
                  v186 += 4;
                  *((_WORD *)v187 + 22) = v198;
                  *((_WORD *)v187 + 23) = v198;
                  *((_WORD *)v187 + 24) = v195;
                  *((_WORD *)v187 + 25) = v195;
                  *((_WORD *)v187 + 26) = v196;
                  *((_WORD *)v187 + 27) = v196;
                  *((_WORD *)v187 + 28) = v197;
                  *((_WORD *)v187 + 29) = v197;
                  *((_WORD *)v187 + 30) = v198;
                  *((_WORD *)v187 + 31) = v198;
                  v187 += 16;
                  v586 += 8;
                  v587 += 8;
                  if (!--v570)
                    break;
                }
                ++v625;
                v588 += 32;
                v589 += 8;
              } while (v567 != v625);
            }
            break;
          case 4:
            v606 = vq2;
            if (v546 > 0) {
              v626 = 0;
              v410 = v566;
              v411 = v566;
              v412 = v566;
              v413 = v566;
              for (n = v566;; n = v617) {
                v559 = *v410;
                v560 = v411[1];
                v561 = v412[2];
                v562 = v413[3];
                v490 = n[4];
                v491 = n[5];
                v617 = n + 6;
                v492 = ROQ_YY_tab[v559];
                v518 = ROQ_VR_tab[v491];
                v493 = v492 + v518;
                v528 = ROQ_UG_tab[v490];
                v494 = ROQ_VG_tab[v491];
                v495 = v494 + v492 + v528;
                v527 = ROQ_UB_tab[v490];
                v496 = v527 + v492;
                v497 = v493 >> 6;
                if (v493 >> 6 < 0)
                  v497 = 0;
                v498 = v495 >> 6;
                if (v498 < 0)
                  v498 = 0;
                v499 = v496 >> 6;
                if (v499 < 0)
                  v499 = 0;
                if (v497 > 255)
                  v415 = 65280;
                else
                  v415 = v497 << 8;
                if (v498 <= 255)
                  v416 = v498 << 16;
                else
                  v416 = (int)&unk_FF0000;
                if (v499 <= 255)
                  v417 = v499 << 24;
                else
                  v417 = -16777216;
                v418 = v415 | v416 | v417;
                LOBYTE(v418) = -1;
                *v606 = v418;
                v419 = ROQ_YY_tab[v560];
                v420 = v419 + v518;
                v421 = v494 + v419 + v528;
                v422 = v527 + v419;
                HIWORD(v423) = 0;
                v424 = v420 >> 6;
                if (v424 < 0)
                  v424 = 0;
                v425 = v421 >> 6;
                if (v425 < 0)
                  v425 = 0;
                v426 = v422 >> 6;
                if (v426 < 0)
                  v426 = 0;
                if (v424 <= 255)
                  v423 = v424 << 8;
                else
                  LOWORD(v423) = -256;
                if (v425 <= 255)
                  v427 = v425 << 16;
                else
                  v427 = (int)&unk_FF0000;
                if (v426 <= 255)
                  v428 = v426 << 24;
                else
                  v428 = -16777216;
                v429 = v423 | v427 | v428;
                LOBYTE(v429) = -1;
                v606[1] = v429;
                v430 = ROQ_YY_tab[(v561 + 3 * v559) >> 2];
                v431 = v430 + v518;
                v432 = v494 + v430 + v528;
                v433 = v527 + v430;
                HIWORD(v423) = 0;
                v434 = v431 >> 6;
                if (v434 < 0)
                  v434 = 0;
                v435 = v432 >> 6;
                if (v435 < 0)
                  v435 = 0;
                v436 = v433 >> 6;
                if (v436 < 0)
                  v436 = 0;
                if (v434 <= 255)
                  v423 = v434 << 8;
                else
                  LOWORD(v423) = -256;
                if (v435 <= 255)
                  v437 = v435 << 16;
                else
                  v437 = (int)&unk_FF0000;
                if (v436 <= 255)
                  v438 = v436 << 24;
                else
                  v438 = -16777216;
                v439 = v423 | v437 | v438;
                LOBYTE(v439) = -1;
                v606[2] = v439;
                v440 = ROQ_YY_tab[(v562 + 3 * v560) >> 2];
                v441 = v440 + v518;
                v442 = v494 + v440 + v528;
                v443 = v527 + v440;
                HIWORD(v423) = 0;
                v444 = v441 >> 6;
                if (v444 < 0)
                  v444 = 0;
                v445 = v442 >> 6;
                if (v445 < 0)
                  v445 = 0;
                v446 = v443 >> 6;
                if (v446 < 0)
                  v446 = 0;
                if (v444 <= 255)
                  v423 = v444 << 8;
                else
                  LOWORD(v423) = -256;
                if (v445 <= 255)
                  v447 = v445 << 16;
                else
                  v447 = (int)&unk_FF0000;
                if (v446 <= 255)
                  v448 = v446 << 24;
                else
                  v448 = -16777216;
                v449 = v423 | v447 | v448;
                LOBYTE(v449) = -1;
                v606[3] = v449;
                v450 = ROQ_YY_tab[(v559 + 3 * v561) >> 2];
                v451 = v450 + v518;
                v452 = v494 + v450 + v528;
                v453 = v527 + v450;
                HIWORD(v423) = 0;
                v454 = v451 >> 6;
                if (v454 < 0)
                  v454 = 0;
                v455 = v452 >> 6;
                if (v455 < 0)
                  v455 = 0;
                v456 = v453 >> 6;
                if (v456 < 0)
                  v456 = 0;
                if (v454 <= 255)
                  v423 = v454 << 8;
                else
                  LOWORD(v423) = -256;
                if (v455 <= 255)
                  v457 = v455 << 16;
                else
                  v457 = (int)&unk_FF0000;
                if (v456 <= 255)
                  v458 = v456 << 24;
                else
                  v458 = -16777216;
                v463 = v457 | v458 | v423;
                LOBYTE(v463) = -1;
                v606[4] = v463;
                v459 = ROQ_YY_tab[(v560 + 3 * v562) >> 2];
                v460 = v459 + v518;
                v461 = v494 + v459 + v528;
                v462 = v527 + v459;
                HIWORD(v463) = 0;
                v464 = v460 >> 6;
                if (v464 < 0)
                  v464 = 0;
                v465 = v461 >> 6;
                if (v465 < 0)
                  v465 = 0;
                v466 = v462 >> 6;
                if (v466 < 0)
                  v466 = 0;
                if (v464 <= 255)
                  v463 = v464 << 8;
                else
                  LOWORD(v463) = -256;
                if (v465 <= 255)
                  v467 = v465 << 16;
                else
                  v467 = (int)&unk_FF0000;
                if (v466 <= 255)
                  v468 = v466 << 24;
                else
                  v468 = -16777216;
                v473 = v467 | v468 | v463;
                LOBYTE(v473) = -1;
                v606[5] = v473;
                v469 = ROQ_YY_tab[v561];
                v470 = v469 + v518;
                v471 = v494 + v469 + v528;
                v472 = v527 + v469;
                HIWORD(v473) = 0;
                v474 = v470 >> 6;
                if (v474 < 0)
                  v474 = 0;
                v475 = v471 >> 6;
                if (v475 < 0)
                  v475 = 0;
                v476 = v472 >> 6;
                if (v476 < 0)
                  v476 = 0;
                if (v474 <= 255)
                  v473 = v474 << 8;
                else
                  LOWORD(v473) = -256;
                if (v475 <= 255)
                  v477 = v475 << 16;
                else
                  v477 = (int)&unk_FF0000;
                if (v476 <= 255)
                  v478 = v476 << 24;
                else
                  v478 = -16777216;
                v483 = v477 | v478 | v473;
                LOBYTE(v483) = -1;
                v606[6] = v483;
                v479 = ROQ_YY_tab[v562];
                v480 = v479 + v518;
                v481 = v494 + v479 + v528;
                v482 = v527 + v479;
                HIWORD(v483) = 0;
                v484 = v480 >> 6;
                if (v484 < 0)
                  v484 = 0;
                v485 = v481 >> 6;
                if (v485 < 0)
                  v485 = 0;
                v486 = v482 >> 6;
                if (v486 < 0)
                  v486 = 0;
                if (v484 <= 255)
                  v483 = v484 << 8;
                else
                  LOWORD(v483) = -256;
                v487 = v485 <= 255 ? v485 << 16 : (unsigned int)&unk_FF0000;
                v488 = v486 <= 255 ? v486 << 24 : -16777216;
                v489 = v487 | v488 | v483;
                LOBYTE(v489) = -1;
                v606[7] = v489;
                v606 += 8;
                if (v546 == ++v626)
                  break;
                v410 = v617;
                v411 = v617;
                v412 = v617;
                v413 = v617;
              }
            } else {
              v617 = v566;
            }
            if (v567 > 0) {
              v592 = &vq8;
              v593 = &vq4;
              for (ii = 0; ii != v567; ++ii) {
                v112 = v593;
                v113 = v592;
                v114 = 32 * *v617;
                v115 = 32 * v617[1];
                v617 += 2;
                v590 = v114 + 7630832;
                v591 = v115 + 7630832;
                v569 = 2;
                for (jj = v114 + 7630832;; jj = v590) {
                  v117 = *(_DWORD *)(jj - 16);
                  *v112 = v117;
                  *v113 = v117;
                  v113[1] = v117;
                  v118 = *(_DWORD *)(jj - 12);
                  v112[1] = v118;
                  v113[2] = v118;
                  v113[3] = v118;
                  v119 = *(_DWORD *)(v591 - 16);
                  v112[2] = v119;
                  v113[4] = v119;
                  v113[5] = v119;
                  v120 = *(_DWORD *)(v591 - 12);
                  v112[3] = v120;
                  v113[6] = v120;
                  v113[7] = v120;
                  v113[8] = v117;
                  v113[9] = v117;
                  v113[10] = v118;
                  v113[11] = v118;
                  v113[12] = v119;
                  v113[13] = v119;
                  v113[14] = v120;
                  v113[15] = v120;
                  v121 = *(_DWORD *)(v590 - 8);
                  v112[4] = v121;
                  v113[16] = v121;
                  v113[17] = v121;
                  v122 = *(_DWORD *)(v590 - 4);
                  v112[5] = v122;
                  v113[18] = v122;
                  v113[19] = v122;
                  v123 = *(_DWORD *)(v591 - 8);
                  v112[6] = v123;
                  v113[20] = v123;
                  v113[21] = v123;
                  v124 = *(_DWORD *)(v591 - 4);
                  v112[7] = v124;
                  v112 += 8;
                  v113[22] = v124;
                  v113[23] = v124;
                  v113[24] = v121;
                  v113[25] = v121;
                  v113[26] = v122;
                  v113[27] = v122;
                  v113[28] = v123;
                  v113[29] = v123;
                  v113[30] = v124;
                  v113[31] = v124;
                  v113 += 32;
                  v590 += 16;
                  v591 += 16;
                  if (!--v569)
                    break;
                }
                v592 += 64;
                v593 += 16;
              }
            }
            break;
          case 1:
            v608 = vq2;
            if (v546 > 0) {
              v628 = 0;
              v500 = dword_4F3A84[115 * v514];
              v501 = v566;
              for (kk = v566;; kk += 6) {
                v511 = *v501;
                v503 = kk[1];
                v504 = kk[2];
                v505 = kk[3];
                v615 = kk + 6;
                *(_BYTE *)v608 = *(_BYTE *)(v500 + v511);
                *((_BYTE *)v608 + 1) = *(_BYTE *)(v500 + v503);
                *((_BYTE *)v608 + 2) =
                    *(_BYTE *)(v500 + ((v504 + 3 * v511) >> 2));
                *((_BYTE *)v608 + 3) =
                    *(_BYTE *)(v500 + ((v505 + 3 * v503) >> 2));
                *((_BYTE *)v608 + 4) =
                    *(_BYTE *)(v500 + ((3 * v504 + v511) >> 2));
                *((_BYTE *)v608 + 5) =
                    *(_BYTE *)(v500 + ((3 * v505 + v503) >> 2));
                *((_BYTE *)v608 + 6) = *(_BYTE *)(v500 + v504);
                *((_BYTE *)v608 + 7) = *(_BYTE *)(v500 + v505);
                v608 += 2;
                if (v546 == ++v628)
                  break;
                v501 = kk + 6;
              }
            } else {
              v615 = v566;
            }
            if (v567 > 0) {
              v596 = &vq8;
              v597 = &vq4;
              for (mm = 0; mm != v567; ++mm) {
                v98 = v597;
                v99 = v596;
                v100 = *v615;
                v101 = v615[1];
                v615 += 2;
                v102 = &dword_746FE4[2 * v100];
                v594 = v102;
                v595 = &dword_746FE4[2 * v101];
                v568 = 2;
                while (1) {
                  v103 = *((_BYTE *)v102 - 4);
                  *(_BYTE *)v98 = v103;
                  *(_BYTE *)v99 = v103;
                  *((_BYTE *)v99 + 1) = v103;
                  v104 = *((_BYTE *)v102 - 3);
                  *((_BYTE *)v98 + 1) = v104;
                  *((_BYTE *)v99 + 2) = v104;
                  *((_BYTE *)v99 + 3) = v104;
                  v105 = *((_BYTE *)v595 - 4);
                  *((_BYTE *)v98 + 2) = v105;
                  *((_BYTE *)v99 + 4) = v105;
                  *((_BYTE *)v99 + 5) = v105;
                  v106 = *((_BYTE *)v595 - 3);
                  *((_BYTE *)v98 + 3) = v106;
                  *((_BYTE *)v99 + 6) = v106;
                  *((_BYTE *)v99 + 7) = v106;
                  *((_BYTE *)v99 + 8) = v103;
                  *((_BYTE *)v99 + 9) = v103;
                  *((_BYTE *)v99 + 10) = v104;
                  *((_BYTE *)v99 + 11) = v104;
                  *((_BYTE *)v99 + 12) = v105;
                  *((_BYTE *)v99 + 13) = v105;
                  *((_BYTE *)v99 + 14) = v106;
                  *((_BYTE *)v99 + 15) = v106;
                  v107 = *((_BYTE *)v594 - 2);
                  *((_BYTE *)v98 + 4) = v107;
                  *((_BYTE *)v99 + 16) = v107;
                  *((_BYTE *)v99 + 17) = v107;
                  v108 = *((_BYTE *)v594 - 1);
                  *((_BYTE *)v98 + 5) = v108;
                  *((_BYTE *)v99 + 18) = v108;
                  *((_BYTE *)v99 + 19) = v108;
                  v109 = *((_BYTE *)v595 - 2);
                  *((_BYTE *)v98 + 6) = v109;
                  *((_BYTE *)v99 + 20) = v109;
                  *((_BYTE *)v99 + 21) = v109;
                  v110 = *((_BYTE *)v595 - 1);
                  *((_BYTE *)v98 + 7) = v110;
                  v98 += 2;
                  *((_BYTE *)v99 + 22) = v110;
                  *((_BYTE *)v99 + 23) = v110;
                  *((_BYTE *)v99 + 24) = v107;
                  *((_BYTE *)v99 + 25) = v107;
                  *((_BYTE *)v99 + 26) = v108;
                  *((_BYTE *)v99 + 27) = v108;
                  *((_BYTE *)v99 + 28) = v109;
                  *((_BYTE *)v99 + 29) = v109;
                  *((_BYTE *)v99 + 30) = v110;
                  *((_BYTE *)v99 + 31) = v110;
                  v99 += 8;
                  ++v594;
                  ++v595;
                  if (!--v568)
                    break;
                  v102 = v594;
                }
                v596 += 16;
                v597 += 4;
              }
            }
            break;
          }
        } else {
          v35 = dword_4F3A80[115 * v514];
          switch (v35) {
          case 2:
            if (v546 > 0) {
              v547 = vq2;
              v544 = 0;
              for (nn = v566;; nn = v616) {
                v236 = *nn;
                v549 = nn[1];
                v550 = nn[2];
                v551 = nn[3];
                v237 = nn[4];
                v238 = nn;
                v239 = nn[5];
                v616 = v238 + 6;
                v240 = ROQ_YY_tab[v236];
                v515 = ROQ_VR_tab[v239];
                v241 = v240 + v515;
                v523 = ROQ_UG_tab[v237];
                v242 = ROQ_VG_tab[v239];
                v243 = v242 + v240 + v523;
                v521 = ROQ_UB_tab[v237];
                v244 = v521 + v240;
                v245 = v241 >> 9;
                if (v241 >> 9 < 0)
                  v245 = 0;
                v246 = v243 >> 8;
                if (v246 < 0)
                  v246 = 0;
                v247 = v244 >> 9;
                if (v247 < 0)
                  v247 = 0;
                if (v245 > 31)
                  v203 = -2048;
                else
                  v203 = (_WORD)v245 << 11;
                if (v246 <= 63)
                  v204 = 32 * v246;
                else
                  v204 = 2016;
                v205 = 31;
                if (v247 < 32)
                  v205 = v247;
                *(_WORD *)v547 = v203 + v204 + v205;
                v206 = ROQ_YY_tab[v549];
                v207 = v206 + v515;
                v208 = v242 + v206 + v523;
                v209 = v521 + v206;
                v210 = v207 >> 9;
                if (v210 < 0)
                  v210 = 0;
                v211 = v208 >> 8;
                if (v211 < 0)
                  v211 = 0;
                v212 = v209 >> 9;
                if (v212 < 0)
                  v212 = 0;
                if (v210 <= 31)
                  v213 = (_WORD)v210 << 11;
                else
                  v213 = -2048;
                if (v211 <= 63)
                  v214 = 32 * v211;
                else
                  v214 = 2016;
                v215 = 31;
                if (v212 < 32)
                  v215 = v212;
                *((_WORD *)v547 + 1) = v213 + v214 + v215;
                v216 = ROQ_YY_tab[v550];
                v217 = v216 + v515;
                v218 = v242 + v216 + v523;
                v219 = v521 + v216;
                v220 = v217 >> 9;
                if (v220 < 0)
                  v220 = 0;
                v221 = v218 >> 8;
                if (v221 < 0)
                  v221 = 0;
                v222 = v219 >> 9;
                if (v222 < 0)
                  v222 = 0;
                if (v220 <= 31)
                  v223 = (_WORD)v220 << 11;
                else
                  v223 = -2048;
                if (v221 <= 63)
                  v224 = 32 * v221;
                else
                  v224 = 2016;
                v225 = 31;
                if (v222 < 32)
                  v225 = v222;
                *((_WORD *)v547 + 2) = v223 + v224 + v225;
                v226 = ROQ_YY_tab[v551];
                v227 = v226 + v515;
                v228 = v242 + v226 + v523;
                v229 = v521 + v226;
                v230 = v227 >> 9;
                if (v230 < 0)
                  v230 = 0;
                v231 = v228 >> 8;
                if (v231 < 0)
                  v231 = 0;
                v232 = v229 >> 9;
                if (v232 < 0)
                  v232 = 0;
                if (v230 <= 31)
                  v233 = (_WORD)v230 << 11;
                else
                  v233 = -2048;
                if (v231 <= 63)
                  v234 = 32 * v231;
                else
                  v234 = 2016;
                v235 = 31;
                if (v232 < 32)
                  v235 = v232;
                *((_WORD *)v547 + 3) = v233 + v234 + v235;
                v547 += 2;
                if (v546 == ++v544)
                  break;
              }
            } else {
              v616 = v566;
            }
            if (v567 > 0) {
              v620 = 0;
              v576 = &vq8;
              v577 = &vq4;
              do {
                v177 = v577;
                v178 = v576;
                v179 = *v616;
                v180 = v616[1];
                v616 += 2;
                v181 = &dword_746FE4[2 * v179];
                v574 = v181;
                v575 = &dword_746FE4[2 * v180];
                v573 = 2;
                while (1) {
                  v182 = *((_WORD *)v181 - 2);
                  *(_WORD *)v177 = v182;
                  *(_WORD *)v178 = v182;
                  *((_WORD *)v178 + 1) = v182;
                  v183 = *((_WORD *)v181 - 1);
                  *((_WORD *)v177 + 1) = v183;
                  *((_WORD *)v178 + 2) = v183;
                  *((_WORD *)v178 + 3) = v183;
                  v184 = *((_WORD *)v575 - 2);
                  *((_WORD *)v177 + 2) = v184;
                  *((_WORD *)v178 + 4) = v184;
                  *((_WORD *)v178 + 5) = v184;
                  v185 = *((_WORD *)v575 - 1);
                  *((_WORD *)v177 + 3) = v185;
                  v177 += 2;
                  *((_WORD *)v178 + 6) = v185;
                  *((_WORD *)v178 + 7) = v185;
                  *((_WORD *)v178 + 8) = v182;
                  *((_WORD *)v178 + 9) = v182;
                  *((_WORD *)v178 + 10) = v183;
                  *((_WORD *)v178 + 11) = v183;
                  *((_WORD *)v178 + 12) = v184;
                  *((_WORD *)v178 + 13) = v184;
                  *((_WORD *)v178 + 14) = v185;
                  *((_WORD *)v178 + 15) = v185;
                  v178 += 8;
                  ++v574;
                  ++v575;
                  if (!--v573)
                    break;
                  v181 = v574;
                }
                ++v620;
                v576 += 16;
                v577 += 4;
              } while (v567 != v620);
            }
            break;
          case 4:
            v548 = vq2;
            if (v546 > 0) {
              v621 = 0;
              for (i1 = v566;; i1 = v619) {
                v552 = i1[1];
                v553 = i1[2];
                v554 = i1[3];
                v400 = i1[4];
                v401 = i1[5];
                v619 = i1 + 6;
                v402 = ROQ_YY_tab[*i1];
                v516 = ROQ_VR_tab[v401];
                v403 = v402 + v516;
                v524 = ROQ_UG_tab[v400];
                v404 = ROQ_VG_tab[v401];
                v405 = v404 + v402 + v524;
                v522 = ROQ_UB_tab[v400];
                v406 = v522 + v402;
                v407 = v403 >> 6;
                if (v403 >> 6 < 0)
                  v407 = 0;
                v408 = v405 >> 6;
                if (v408 < 0)
                  v408 = 0;
                v409 = v406 >> 6;
                if (v409 < 0)
                  v409 = 0;
                if (v407 > 255)
                  v365 = 65280;
                else
                  v365 = v407 << 8;
                if (v408 <= 255)
                  v366 = v408 << 16;
                else
                  v366 = (int)&unk_FF0000;
                if (v409 <= 255)
                  v367 = v409 << 24;
                else
                  v367 = -16777216;
                v368 = v366 | v367 | v365;
                LOBYTE(v368) = -1;
                *v548 = v368;
                v369 = ROQ_YY_tab[v552];
                v370 = v369 + v516;
                v371 = v404 + v369 + v524;
                v372 = v522 + v369;
                HIWORD(v373) = 0;
                v374 = v370 >> 6;
                if (v374 < 0)
                  v374 = 0;
                v375 = v371 >> 6;
                if (v375 < 0)
                  v375 = 0;
                v376 = v372 >> 6;
                if (v376 < 0)
                  v376 = 0;
                if (v374 <= 255)
                  v373 = v374 << 8;
                else
                  LOWORD(v373) = -256;
                if (v375 <= 255)
                  v377 = v375 << 16;
                else
                  v377 = (int)&unk_FF0000;
                if (v376 <= 255)
                  v378 = v376 << 24;
                else
                  v378 = -16777216;
                v383 = v377 | v378 | v373;
                LOBYTE(v383) = -1;
                v548[1] = v383;
                v379 = ROQ_YY_tab[v553];
                v380 = v379 + v516;
                v381 = v404 + v379 + v524;
                v382 = v522 + v379;
                HIWORD(v383) = 0;
                v384 = v380 >> 6;
                if (v384 < 0)
                  v384 = 0;
                v385 = v381 >> 6;
                if (v385 < 0)
                  v385 = 0;
                v386 = v382 >> 6;
                if (v386 < 0)
                  v386 = 0;
                if (v384 <= 255)
                  v383 = v384 << 8;
                else
                  LOWORD(v383) = -256;
                if (v385 <= 255)
                  v387 = v385 << 16;
                else
                  v387 = (int)&unk_FF0000;
                if (v386 <= 255)
                  v388 = v386 << 24;
                else
                  v388 = -16777216;
                v393 = v387 | v388 | v383;
                LOBYTE(v393) = -1;
                v548[2] = v393;
                v389 = ROQ_YY_tab[v554];
                v390 = v389 + v516;
                v391 = v404 + v389 + v524;
                v392 = v522 + v389;
                HIWORD(v393) = 0;
                v394 = v390 >> 6;
                if (v394 < 0)
                  v394 = 0;
                v395 = v391 >> 6;
                if (v395 < 0)
                  v395 = 0;
                v396 = v392 >> 6;
                if (v396 < 0)
                  v396 = 0;
                if (v394 <= 255)
                  v393 = v394 << 8;
                else
                  LOWORD(v393) = -256;
                v397 = v395 <= 255 ? v395 << 16 : (unsigned int)&unk_FF0000;
                v398 = v396 <= 255 ? v396 << 24 : -16777216;
                v399 = v397 | v398 | v393;
                LOBYTE(v399) = -1;
                v548[3] = v399;
                v548 += 4;
                if (v546 == ++v621)
                  break;
              }
            } else {
              v619 = v566;
            }
            if (v567 > 0) {
              v580 = &vq8;
              v581 = &vq4;
              for (i2 = 0; i2 != v567; ++i2) {
                v125 = v581;
                v126 = v580;
                v127 = 16 * *v619;
                v128 = 16 * v619[1];
                v619 += 2;
                v578 = v127 + 7630824;
                v579 = v128 + 7630824;
                v572 = 2;
                for (i3 = v127 + 7630824;; i3 = v578) {
                  v130 = *(_DWORD *)(i3 - 8);
                  *v125 = v130;
                  *v126 = v130;
                  v126[1] = v130;
                  v131 = *(_DWORD *)(i3 - 4);
                  v125[1] = v131;
                  v126[2] = v131;
                  v126[3] = v131;
                  v132 = *(_DWORD *)(v579 - 8);
                  v125[2] = v132;
                  v126[4] = v132;
                  v126[5] = v132;
                  v133 = *(_DWORD *)(v579 - 4);
                  v125[3] = v133;
                  v125 += 4;
                  v126[6] = v133;
                  v126[7] = v133;
                  v126[8] = v130;
                  v126[9] = v130;
                  v126[10] = v131;
                  v126[11] = v131;
                  v126[12] = v132;
                  v126[13] = v132;
                  v126[14] = v133;
                  v126[15] = v133;
                  v126 += 16;
                  v578 += 8;
                  v579 += 8;
                  if (!--v572)
                    break;
                }
                v580 += 32;
                v581 += 8;
              }
            }
            break;
          case 1:
            v36 = vq2;
            if (v546 > 0) {
              v506 = 0;
              v507 = dword_4F3A84[115 * v514];
              v508 = v566;
              do {
                *(_BYTE *)v36 = *(_BYTE *)(v507 + *v508);
                *((_BYTE *)v36 + 1) = *(_BYTE *)(v507 + v508[1]);
                *((_BYTE *)v36 + 2) = *(_BYTE *)(v507 + v508[2]);
                *((_BYTE *)v36++ + 3) = *(_BYTE *)(v507 + v508[3]);
                v508 += 6;
                v618 = v508;
                ++v506;
              } while (v546 != v506);
            } else {
              v618 = v566;
            }
            if (v567 > 0) {
              v584 = &vq8;
              v585 = &vq4;
              for (i4 = 0; i4 != v567; ++i4) {
                v37 = v585;
                v38 = v584;
                v39 = *v618;
                v40 = v618[1];
                v618 += 2;
                v41 = 4 * v39 + 7630818;
                v582 = v41;
                v583 = 4 * v40 + 7630818;
                v571 = 2;
                while (1) {
                  v42 = *(_BYTE *)(v41 - 2);
                  *(_BYTE *)v37 = v42;
                  *(_BYTE *)v38 = v42;
                  *((_BYTE *)v38 + 1) = v42;
                  v43 = *(_BYTE *)(v41 - 1);
                  *((_BYTE *)v37 + 1) = v43;
                  *((_BYTE *)v38 + 2) = v43;
                  *((_BYTE *)v38 + 3) = v43;
                  v44 = *(_BYTE *)(v583 - 2);
                  *((_BYTE *)v37 + 2) = v44;
                  *((_BYTE *)v38 + 4) = v44;
                  *((_BYTE *)v38 + 5) = v44;
                  v45 = *(_BYTE *)(v583 - 1);
                  *((_BYTE *)v37++ + 3) = v45;
                  *((_BYTE *)v38 + 6) = v45;
                  *((_BYTE *)v38 + 7) = v45;
                  *((_BYTE *)v38 + 8) = v42;
                  *((_BYTE *)v38 + 9) = v42;
                  *((_BYTE *)v38 + 10) = v43;
                  *((_BYTE *)v38 + 11) = v43;
                  *((_BYTE *)v38 + 12) = v44;
                  *((_BYTE *)v38 + 13) = v44;
                  *((_BYTE *)v38 + 14) = v45;
                  *((_BYTE *)v38 + 15) = v45;
                  v38 += 4;
                  v582 += 2;
                  v583 += 2;
                  if (!--v571)
                    break;
                  v41 = v582;
                }
                v584 += 8;
                v585 += 2;
              }
            }
            break;
          }
        }
        goto LABEL_48;
      }
      v75 = dword_4F3A80[115 * v514];
      if (v75 != 2) {
        if (v75 == 1) {
          v142 = vq2;
          if (v546 > 0) {
            v199 = 0;
            v200 = dword_4F3A84[115 * v514];
            v201 = v566;
            do {
              *(_BYTE *)v142 = *(_BYTE *)(v200 + *v201);
              *((_BYTE *)v142 + 1) = *(_BYTE *)(v200 + v201[2]);
              v142 = (int *)((char *)v142 + 2);
              v201 += 6;
              v612 = v201;
              ++v199;
            } while (v546 != v199);
          } else {
            v612 = v566;
          }
          if (v567 > 0) {
            v600 = &vq8;
            v601 = &vq4;
            for (i5 = 0; i5 != v567; ++i5) {
              v143 = v601;
              v144 = v600;
              v145 = *v612;
              v146 = v612[1];
              v612 += 2;
              v147 = 2 * v145 + 7630817;
              v148 = 2 * v146 + 7630817;
              for (i6 = 0; i6 != 2; ++i6) {
                v149 = *(_BYTE *)(v147 - 1);
                *(_BYTE *)v143 = v149;
                *(_BYTE *)v144 = v149;
                *((_BYTE *)v144 + 1) = v149;
                v150 = *(_BYTE *)(v148 - 1);
                *((_BYTE *)v143 + 1) = v150;
                v143 = (int *)((char *)v143 + 2);
                *((_BYTE *)v144 + 2) = v150;
                *((_BYTE *)v144 + 3) = v150;
                *((_BYTE *)v144 + 4) = v149;
                *((_BYTE *)v144 + 5) = v149;
                *((_BYTE *)v144 + 6) = v150;
                *((_BYTE *)v144 + 7) = v150;
                v144 += 2;
                ++v147;
                ++v148;
              }
              v600 += 4;
              ++v601;
            }
          }
        } else if (v75 == 4) {
          v607 = vq2;
          if (v546 > 0) {
            v633 = 0;
            for (i7 = v566;; i7 = v613) {
              v352 = *i7;
              v564 = i7[2];
              v353 = i7[4];
              v354 = i7;
              v355 = i7[5];
              v613 = v354 + 6;
              v356 = ROQ_YY_tab[v352];
              v520 = ROQ_VR_tab[v355];
              v357 = v356 + v520;
              v530 = ROQ_UG_tab[v353];
              v532 = ROQ_VG_tab[v355];
              v358 = v532 + v356 + v530;
              v359 = ROQ_UB_tab[v353];
              v360 = v359 + v356;
              v361 = v357 >> 6;
              if (v357 >> 6 < 0)
                v361 = 0;
              v362 = v358 >> 6;
              if (v362 < 0)
                v362 = 0;
              v363 = v360 >> 6;
              if (v363 < 0)
                v363 = 0;
              if (v361 > 255)
                v337 = 65280;
              else
                v337 = v361 << 8;
              if (v362 <= 255)
                v338 = v362 << 16;
              else
                v338 = (int)&unk_FF0000;
              if (v363 <= 255)
                v339 = v363 << 24;
              else
                v339 = -16777216;
              v340 = v337 | v338 | v339;
              LOBYTE(v340) = -1;
              *v607 = v340;
              v341 = ROQ_YY_tab[v564];
              v342 = v341 + v520;
              v343 = v532 + v341 + v530;
              v344 = v359 + v341;
              HIWORD(v345) = 0;
              v346 = v342 >> 6;
              if (v346 < 0)
                v346 = 0;
              v347 = v343 >> 6;
              if (v347 < 0)
                v347 = 0;
              v348 = v344 >> 6;
              if (v348 < 0)
                v348 = 0;
              if (v346 <= 255)
                v345 = v346 << 8;
              else
                LOWORD(v345) = -256;
              v349 = v347 <= 255 ? v347 << 16 : (unsigned int)&unk_FF0000;
              v350 = v348 <= 255 ? v348 << 24 : -16777216;
              v351 = v345 | v349 | v350;
              LOBYTE(v351) = -1;
              v607[1] = v351;
              v607 += 2;
              if (v546 == ++v633)
                break;
            }
          } else {
            v613 = v566;
          }
          if (v567 > 0) {
            v602 = &vq8;
            v603 = &vq4;
            for (i8 = 0; i8 != v567; ++i8) {
              v76 = v603;
              v77 = v602;
              v78 = *v613;
              v79 = v613[1];
              v613 += 2;
              v80 = &dword_746FE4[2 * v78];
              v81 = &dword_746FE4[2 * v79];
              for (i9 = 0; i9 != 2; ++i9) {
                v82 = *(v80 - 1);
                *v76 = v82;
                *v77 = v82;
                v77[1] = v82;
                v83 = *(v81 - 1);
                v76[1] = v83;
                v76 += 2;
                v77[2] = v83;
                v77[3] = v83;
                v77[4] = v82;
                v77[5] = v82;
                v77[6] = v83;
                v77[7] = v83;
                v77 += 8;
                ++v80;
                ++v81;
              }
              v602 += 16;
              v603 += 4;
            }
          }
        }
        goto LABEL_48;
      }
      if (v546 <= 0) {
        v614 = v566;
        goto LABEL_185;
      }
      v605 = vq2;
      v630 = 0;
      v151 = v566;
      while (2) {
        v165 = *v151;
        v563 = v151[2];
        v166 = v151[4];
        v167 = v151;
        v168 = v151[5];
        v614 = v167 + 6;
        v169 = ROQ_YY_tab[v165];
        v519 = ROQ_VR_tab[v168];
        v170 = v169 + v519;
        v529 = ROQ_UG_tab[v166];
        v531 = ROQ_VG_tab[v168];
        v171 = v531 + v169 + v529;
        v172 = ROQ_UB_tab[v166];
        v173 = v172 + v169;
        v174 = v170 >> 9;
        if (v170 >> 9 < 0)
          v174 = 0;
        v175 = v171 >> 8;
        if (v175 < 0)
          v175 = 0;
        v176 = v173 >> 9;
        if (v176 < 0)
          v176 = 0;
        if (v174 > 31) {
          v152 = -2048;
          if (v175 > 63)
            goto LABEL_203;
        } else {
          v152 = (_WORD)v174 << 11;
          if (v175 > 63) {
          LABEL_203:
            v153 = 2016;
            goto LABEL_204;
          }
        }
        v153 = 32 * v175;
      LABEL_204:
        v154 = 31;
        if (v176 < 32)
          v154 = v176;
        *(_WORD *)v605 = v152 + v153 + v154;
        v155 = ROQ_YY_tab[v563];
        v156 = v155 + v519;
        v157 = v531 + v155 + v529;
        v158 = v172 + v155;
        v159 = v156 >> 9;
        if (v159 < 0)
          v159 = 0;
        v160 = v157 >> 8;
        if (v160 < 0)
          v160 = 0;
        v161 = v158 >> 9;
        if (v158 >> 9 < 0)
          v161 = 0;
        if (v159 <= 31)
          v162 = (_WORD)v159 << 11;
        else
          v162 = -2048;
        if (v160 <= 63)
          v163 = 32 * v160;
        else
          v163 = 2016;
        v164 = 31;
        if (v161 < 32)
          v164 = v161;
        *((_WORD *)v605++ + 1) = v164 + v162 + v163;
        if (v546 != ++v630) {
          v151 = v614;
          continue;
        }
        break;
      }
    LABEL_185:
      if (v567 > 0) {
        v631 = 0;
        v598 = &vq8;
        v599 = &vq4;
        do {
          v134 = v599;
          v135 = v598;
          v136 = *v614;
          v137 = v614[1];
          v614 += 2;
          v138 = 4 * v136 + 7630818;
          v139 = 4 * v137 + 7630818;
          for (i10 = 0; i10 != 2; ++i10) {
            v140 = *(_WORD *)(v138 - 2);
            *(_WORD *)v134 = v140;
            *(_WORD *)v135 = v140;
            *((_WORD *)v135 + 1) = v140;
            v141 = *(_WORD *)(v139 - 2);
            *((_WORD *)v134++ + 1) = v141;
            *((_WORD *)v135 + 2) = v141;
            *((_WORD *)v135 + 3) = v141;
            *((_WORD *)v135 + 4) = v140;
            *((_WORD *)v135 + 5) = v140;
            *((_WORD *)v135 + 6) = v141;
            *((_WORD *)v135 + 7) = v141;
            v135 += 4;
            v138 += 2;
            v139 += 2;
          }
          ++v631;
          v598 += 8;
          v599 += 2;
        } while (v567 != v631);
      }
    LABEL_48:
      v21 = v514;
    LABEL_49:
      v22 = 115 * v21;
      if (dword_4F3A50[115 * v21] < dword_4F3A54[115 * v21]) {
      LABEL_50:
        v23 = &v566[dword_4F3A58[v22]];
        v533 = *v23 + (v23[1] << 8);
        dword_4F3A68[v22] = v533;
        v24 = v23[2] + ((v23[3] + (v23[4] << 8)) << 8);
        dword_4F3A50[v22 + 2] = v24;
        dword_4F3AA0[v22 + 2] = (v23[7] << 8) + v23[6];
        dword_4F3AA0[v22 + 3] = (char)v23[7];
        dword_4F3AB0[v22] = (char)v23[6];
        if ((unsigned int)dword_4F3A58[v22] > 0x10000 ||
            dword_4F3A68[v22] == 4228) {
          Com_DPrintf(
              "roq_size>65536||roq_id==0x1084 (roq_size=%i,roq_id=%i)\n", v24,
              v533);
          v514 = currentHandle;
          v59 = 115 * currentHandle;
          dword_4F3A3C[v59] = 2;
          if (!dword_4F3A18[v59]) {
          LABEL_39:
            v11 = v514;
            goto LABEL_31;
          }
        LABEL_96:
          RoQReset();
          v514 = currentHandle;
          v11 = currentHandle;
          goto LABEL_31;
        }
        v25 = dword_4F3AA0[v22];
        if (!v25 || dword_4F3A3C[v22] == 2) {
          dword_4F3A50[115 * v514] += dword_4F3A58[115 * v514] + 8;
          v11 = v514;
          goto LABEL_31;
        }
        dword_4F3AA0[v22] = v25 - 1;
        v566 = v23 + 8;
        continue;
      }
    LABEL_56:
      if (dword_4F3A1C[v22]) {
        dword_4F3A3C[v22] = 0;
        v11 = v514;
      } else if (dword_4F3A18[v22]) {
        RoQReset();
        v11 = currentHandle;
        v514 = currentHandle;
      } else {
        dword_4F3A3C[v22] = 2;
        v11 = v514;
      }
    LABEL_31:
      if (v538 == dword_4F3A40[115 * v11]) {
        v8 = v11;
        goto LABEL_24;
      }
      v12 = CL_ScaledMilliseconds();
      v514 = currentHandle;
      v13 = dword_4F3A40[115 * currentHandle];
      dword_4F3A4C[115 * currentHandle] =
          dword_4F3ABC[115 * currentHandle] * (v12 - v13) / 0x3E8u;
      v538 = v13;
      v9 = 115 * v514;
      if (dword_4F3A4C[115 * v514] != dword_4F3A60[115 * v514])
        goto LABEL_25;
    LABEL_33:
      dword_4F3A40[v9 + 2] = v539;
      if (dword_4F3A3C[v9] == 5)
        dword_4F3A3C[v9] = 1;
      if (dword_4F3A3C[v9] == 2) {
        if (dword_4F3A18[v9])
          RoQReset();
        else
          RoQShutdown();
        v14 = currentHandle;
        v15 = currentHandle;
      } else {
        v14 = v514;
        v15 = v514;
      }
      return *(int *)((char *)dword_4F3A3C + 459 * v14 + v15);
    case 4099:
    case 4100:
    case 4101:
    case 4102:
    case 4103:
    case 4104:
    case 4105:
    case 4106:
    case 4107:
    case 4108:
    case 4109:
    case 4110:
    case 4111:
    case 4112:
    case 4116:
    case 4117:
    case 4118:
    case 4119:
    case 4120:
    case 4121:
    case 4122:
    case 4123:
    case 4124:
    case 4125:
    case 4126:
    case 4127:
    case 4130:
    case 4131:
    case 4132:
    case 4133:
    case 4134:
    case 4135:
    case 4136:
    case 4137:
    case 4138:
    case 4139:
    case 4140:
    case 4141:
    case 4142:
    case 4143:
      v31 = v514;
      goto LABEL_65;
    case 4113:
      dword_121C7E8();
      v46 = currentHandle;
      v47 = 115 * currentHandle;
      if ((dword_4F3A60[115 * currentHandle] & 1) != 0) {
        dword_4F3AA4[115 * currentHandle] = dword_4F3AB8[115 * currentHandle];
        v48 = dword_4F3AB0[v47];
        v49 = dword_4F3AAC[v47];
        v540 = dword_4F3A64[v47];
        v50 = dword_4F3A80[v47];
        if (dword_4F3A88[v47] == 4 * dword_4F3A8C[v47] && !dword_4F3A98[v47]) {
          v50 *= 2;
          v540 *= 2;
        }
        v541 = 0;
        v537 = 115 * v46;
        v51 = dword_4F3AA4[115 * v46];
        v536 = v51;
        v52 = v540 * (v48 - 8);
        v509 = 2163200;
        v53 = v50 * (v49 - 8);
        v512 = v53;
        v54 = -v50;
        while (1) {
          v55 = (int *)(v509 + 5199296);
          v56 = 16;
          v57 = v51 - (v52 + v53);
          do {
            *v55 = v57;
            v57 += v54;
            v55 += 16;
            --v56;
          } while (v56);
          ++v541;
          v509 += 4;
          v52 += v540;
          if (v541 == 16)
            break;
          v53 = v512;
          v51 = v536;
        }
        ((void(__cdecl *)(int *, unsigned __int8 *))dword_4F3A74[v537])(
            dword_725BC0, v566);
        v70 = currentHandle;
        v514 = currentHandle;
        dword_4F3AC4[115 * currentHandle] =
            dword_4F3A6C[115 * currentHandle] + 5199296;
        v71 = v70;
      } else {
        dword_4F3AA4[115 * currentHandle] = dword_4F3AB4[115 * currentHandle];
        v60 = dword_4F3AB0[v47];
        v61 = dword_4F3AAC[v47];
        v542 = dword_4F3A64[v47];
        v62 = dword_4F3A80[v47];
        if (dword_4F3A88[v47] == 4 * dword_4F3A8C[v47] && !dword_4F3A98[v47]) {
          v62 *= 2;
          v542 *= 2;
        }
        v543 = 0;
        v535 = 115 * v46;
        v63 = dword_4F3AA4[115 * v46];
        v534 = v63;
        v64 = v542 * (v60 - 8);
        v510 = 2163200;
        v65 = v62 * (v61 - 8);
        v513 = v65;
        v66 = -v62;
        while (1) {
          v67 = (int *)(v510 + 5199296);
          v68 = 16;
          v69 = v63 - (v64 + v65);
          do {
            *v67 = v69;
            v69 += v66;
            v67 += 16;
            --v68;
          } while (v68);
          ++v543;
          v510 += 4;
          v64 += v542;
          if (v543 == 16)
            break;
          v65 = v513;
          v63 = v534;
        }
        ((void(__cdecl *)(int *, unsigned __int8 *))dword_4F3A70[v535])(
            dword_705BC0, v566);
        v74 = currentHandle;
        v514 = currentHandle;
        dword_4F3AC4[115 * currentHandle] = (int)&cin;
        v71 = v74;
      }
      if (dword_4F3A60[115 * v71]) {
        v72 = v71;
      } else {
        Com_Memcpy((void *)(dword_4F3A6C[115 * v71] + 5199296), &cin,
                   dword_4F3A8C[115 * v71] * dword_4F3A64[115 * v71]);
        v514 = currentHandle;
        v72 = currentHandle;
      }
      v73 = v514 + 459 * v72;
      ++*(int *)((char *)dword_4F3A60 + v73);
      *(int *)((char *)dword_4F3A20 + v73) = 1;
      v21 = v514;
      goto LABEL_49;
    case 4114:
      goto LABEL_48;
    case 4115:
      dword_4F3A58[115 * v514] = 0;
      v22 = 115 * v514;
      if (dword_4F3A50[115 * v514] >= dword_4F3A54[115 * v514])
        goto LABEL_56;
      goto LABEL_50;
    case 4128:
      if (dword_4F3A28[115 * v514])
        goto LABEL_48;
      v16 = dword_4F3A58[115 * v514];
      v17 = dword_4F3AA8[115 * v514];
      if (v16) {
        v18 = 0;
        v19 = __src;
        do {
          v17 += word_7055C0[v566[v18]];
          *((_WORD *)v19 + 1) = v17;
          *(_WORD *)v19 = v17;
          ++v18;
          v19 += 4;
        } while (v16 != v18);
      }
      SND_RawSamples(v16, 22050, 2, 1, __src);
      v20 = currentHandle;
      v514 = currentHandle;
      goto LABEL_47;
    case 4129:
      if (dword_4F3A28[115 * v514]) {
        v21 = v514;
        goto LABEL_49;
      }
      v565 = dword_4F3A58[115 * v514];
      v26 = dword_4F3AA8[115 * v514];
      LOBYTE(v26) = 0;
      v27 = LOWORD(dword_4F3AA8[115 * v514]) << 8;
      if (v565) {
        v28 = v566;
        v29 = 0;
        v30 = __src;
        do {
          v26 += word_7055C0[*v28];
          v27 += word_7055C0[v28[1]];
          v28 += 2;
          *(_WORD *)v30 = v26;
          *((_WORD *)v30 + 1) = v27;
          v29 += 2;
          v30 += 4;
        } while (v565 > v29);
      }
      SND_RawSamples(v565 >> 1, 22050, 2, 2, __src);
      v514 = currentHandle;
      v20 = currentHandle;
    LABEL_47:
      *(int *)((char *)dword_4F3A34 + 459 * v20 + v514) = 1;
      goto LABEL_48;
    case 4144:
      v58 = 115 * v514;
      dword_4F3AA0[v58] = dword_4F3AA8[115 * v514];
      dword_4F3A58[v58] = 0;
      goto LABEL_48;
    default:
      v31 = v514;
    LABEL_65:
      dword_4F3A3C[115 * v31] = 2;
      v21 = v31;
      goto LABEL_49;
    }
  }
}

int ROQ_RunCinematic(void) {
  int result; // eax

  result = CL_handle;
  if ((unsigned int)CL_handle <= 0xF)
    return ROQ_RunCinematicFromHandle(CL_handle);
  return result;
}

void Com_InitSoundAlias(void) {
  saLoadObjGlob = 0;
  dword_1150524 = 0;
}

void Com_RefreshVolumeModGroups_f(void) { byte_1150DA8 = 0; }

int __cdecl AliasNameCompare(snd_alias_build_s *a1, snd_alias_build_s *a2) {
  return I_stricmp(a1->szAliasName, a2->szAliasName);
}

snd_alias_list_t *__cdecl Com_MakeSoundAliasesPermanent(snd_alias_list_t *a1,
                                                        SoundFileInfo *a2) {
  snd_alias_list_t *result; // eax
  snd_alias_list_t *v3;     // ebx
  unsigned int v4;          // esi
  char v5;                  // di
  snd_alias_list_t *v6;     // esi
  unsigned int v7;          // ebx
  int v8;                   // esi
  const char *v9;           // ebx
  char *v10;                // edi
  char **v11;               // ebx
  int v12;                  // eax
  unsigned int v13;         // edx
  unsigned int v14;         // edx
  unsigned int v15;         // edx
  unsigned int v16;         // edx
  unsigned int v17;         // edx
  int32_t pHashNext;        // eax
  const char *v19;          // ecx
  int32_t v20;              // eax
  const char *v21;          // edx
  char *v22;                // eax
  char *v23;                // eax
  char *v24;                // [esp+3Ch] [ebp-4Ch]
  char *v25;                // [esp+40h] [ebp-48h]
  snd_alias_list_t *v26;    // [esp+44h] [ebp-44h]
  char *v27;                // [esp+48h] [ebp-40h]
  size_t v28;               // [esp+4Ch] [ebp-3Ch]
  char **v29;               // [esp+50h] [ebp-38h]
  void *v30;                // [esp+54h] [ebp-34h]
  int v31;                  // [esp+58h] [ebp-30h]
  char *aliasName;          // [esp+5Ch] [ebp-2Ch]
  int *p_count;             // [esp+64h] [ebp-24h]
  char *v34;                // [esp+68h] [ebp-20h]
  char *__dst;              // [esp+6Ch] [ebp-1Ch]

  a2->count = 0;
  a1->count = 0;
  result = (snd_alias_list_t *)dword_1150524;
  if (!dword_1150524)
    return result;
  result = (snd_alias_list_t *)Com_SortTempSoundAliases_r(
      saLoadObjGlob, &dword_1150524, (int(__cdecl *)(int, int))AliasNameCompare,
      (snd_alias_build_s *)1);
  saLoadObjGlob = (int)result;
  if (!result)
    return result;
  result = (snd_alias_list_t *)Com_SortTempSoundAliases_r(
      (int)result, &dword_1150524,
      (int(__cdecl *)(int, int))FileNameTypeCompare, 0);
  v3 = result;
  saLoadObjGlob = (int)result;
  if (!result)
    return result;
  v28 = 0;
  v26 = 0;
  v24 = 0;
  v31 = 0;
  do {
    p_count = (int *)&v3[12].count;
    v4 = strlen((const char *)&v3[12].count) + 1;
    if (v26 && v3[18].pHashNext == v26[18].pHashNext) {
      v5 = 1;
      if (!v24) {
      LABEL_50:
        v3[20].pHashNext = 0;
        v28 += v4;
        ++v31;
        v26 = v3;
        v24 = (char *)&v3[12].count;
        goto LABEL_12;
      }
    } else {
      v5 = 0;
      if (!v24)
        goto LABEL_50;
    }
    if (I_stricmp(v24, (char *)p_count))
      goto LABEL_50;
    if (v5) {
      v3[20].pHashNext = (int32_t)v26;
    } else {
      pHashNext = v3[18].pHashNext;
      if (pHashNext == 2) {
        v19 = "streamed";
      } else {
        v19 = "primed";
        if (pHashNext != 3)
          v19 = "loaded";
      }
      v20 = v26[18].pHashNext;
      if (v20 == 2) {
        v21 = "streamed";
      } else {
        v21 = "primed";
        if (v20 != 3)
          v21 = "loaded";
      }
      Com_Printf("WARNING: sound file '%s' used as %s in alias '%s' and %s in "
                 "alias '%s'\n",
                 (const char *)p_count, v19, v3[4].aliasName, v21,
                 v26[4].aliasName);
      v3[20].pHashNext = 0;
      v28 += v4;
      ++v31;
      v26 = v3;
      v24 = (char *)&v3[12].count;
    }
  LABEL_12:
    v3 = *(snd_alias_list_t **)v3[21].aliasName;
  } while (v3);
  result = (snd_alias_list_t *)Com_SortTempSoundAliases_r(
      saLoadObjGlob, &dword_1150524, (int(__cdecl *)(int, int))AliasNameCompare,
      (snd_alias_build_s *)1);
  v6 = result;
  saLoadObjGlob = (int)result;
  if (result) {
    aliasName = 0;
    do {
      v7 = strlen(v6[4].aliasName) + 1;
      if (!aliasName || I_stricmp(aliasName, v6[4].aliasName)) {
        v28 += v7;
        aliasName = v6[4].aliasName;
      }
      if (*(_DWORD *)v6[12].aliasName)
        v28 += strlen(*(const char **)v6[12].aliasName) + 1;
      v6 = *(snd_alias_list_t **)v6[21].aliasName;
    } while (v6);
    a1->head = (int32_t)Com_AllocSoundMemory(68 * dword_1150524);
    a2->files = (int32_t)Com_AllocSoundMemory(16 * v31);
    result = (snd_alias_list_t *)Com_AllocSoundMemory(v28);
    __dst = (char *)result;
    v8 = saLoadObjGlob;
    if (saLoadObjGlob) {
      v30 = 0;
      v9 = (const char *)(saLoadObjGlob + 64);
      v10 = (char *)result;
      while (1) {
        strcpy(v10, v9);
        v34 = &__dst[strlen(__dst) + 1];
        while (2) {
          if (*(_DWORD *)(v8 + 192)) {
            strcpy(v34, *(const char **)(v8 + 192));
            v27 = &v34[strlen(v34) + 1];
            v25 = v34;
          } else {
            v27 = v34;
            v25 = 0;
          }
          v11 = (char **)(a1->head + 68 * a1->count);
          if (!v30 || I_stricmp(**((char ***)v30 + 1), __dst)) {
            v30 = Com_AllocSoundMemory(0x10u);
            if (!(unsigned __int8)Com_AddAliasList(__dst,
                                                   (snd_alias_list_t *)v30)) {
              Com_Printf("^1ERROR: alias '%s' already added - ignoring\n",
                         __dst);
              result = (snd_alias_list_t *)v27;
              v34 = v27;
              v30 = 0;
              goto LABEL_45;
            }
            *(_DWORD *)v30 = __dst;
            *((_DWORD *)v30 + 1) = v11;
          }
          v12 = *(_DWORD *)(v8 + 332);
          if (v12) {
            v29 = *(char ***)(v12 + 264);
            v34 = v27;
          } else {
            strcpy(v27, (const char *)(v8 + 200));
            v34 = &v27[strlen(v27) + 1];
            v29 = (char **)(a2->files + 16 * a2->count);
            v23 = *(char **)(v8 + 300);
            *v29 = v27;
            v29[1] = 0;
            v29[3] = v23;
            ++a2->count;
          }
          *(_DWORD *)(v8 + 264) = v29;
          *v11 = __dst;
          if (*(_BYTE *)(v8 + 128)) {
            v22 = (char *)Com_AllocSoundMemory(
                strlen((const char *)(v8 + 128)) + 1);
            v11[2] = v22;
            strcpy(v22, (const char *)(v8 + 128));
          } else {
            v11[2] = 0;
          }
          v11[3] = (char *)v29;
          v11[1] = v25;
          v11[4] = 0;
          v11[5] = *(char **)(v8 + 268);
          v11[6] = *(char **)(v8 + 272);
          v11[7] = *(char **)(v8 + 280);
          v11[8] = *(char **)(v8 + 284);
          v11[9] = *(char **)(v8 + 288);
          v11[10] = *(char **)(v8 + 292);
          v13 =
              (*(_DWORD *)(v8 + 296) << 7) | (unsigned int)v11[11] & 0xFFFFF87F;
          v11[11] = (char *)v13;
          v14 = (32 * *(_DWORD *)(v8 + 300)) | v13 & 0xFFFFFF9F;
          v11[11] = (char *)v14;
          v11[16] = *(char **)(v8 + 304);
          if (*(_BYTE *)(v8 + 324))
            v11[11] = (char *)(v14 | 1);
          else
            v11[11] = (char *)(v14 & 0xFFFFFFFE);
          if (*(_BYTE *)(v8 + 325))
            v15 = (unsigned int)v11[11] | 2;
          else
            v15 = (unsigned int)v11[11] & 0xFFFFFFFD;
          v11[11] = (char *)v15;
          if (*(_BYTE *)(v8 + 326))
            v16 = v15 | 4;
          else
            v16 = v15 & 0xFFFFFFFB;
          v11[11] = (char *)v16;
          if (*(_BYTE *)(v8 + 327))
            v17 = v16 | 8;
          else
            v17 = v16 & 0xFFFFFFF7;
          v11[11] = (char *)v17;
          if (*(_BYTE *)(v8 + 328))
            v11[11] = (char *)(v17 | 0x10);
          else
            v11[11] = (char *)(v17 & 0xFFFFFFEF);
          v11[12] = *(char **)(v8 + 308);
          v11[13] = *(char **)(v8 + 312);
          v11[14] = *(char **)(v8 + 316);
          v11[15] = *(char **)(v8 + 320);
          result = a1;
          ++a1->count;
          ++*((_DWORD *)v30 + 2);
        LABEL_45:
          v8 = *(_DWORD *)(v8 + 336);
          if (!v8)
            return result;
          if (__dst) {
            v9 = (const char *)(v8 + 64);
            if (!I_stricmp(__dst, (char *)(v8 + 64)))
              continue;
            __dst = v34;
            v10 = v34;
          } else {
            v9 = (const char *)(v8 + 64);
            __dst = v34;
            v10 = v34;
          }
          break;
        }
      }
    }
  }
  return result;
}

int __cdecl Com_LoadVolumeFalloffCurve(const char *a1, SndCurve *a2) {
  int v2;             // eax
  int v3;             // ebx
  char *v4;           // eax
  signed int v5;      // eax
  SndCurve *v7;       // ebx
  int i;              // esi
  float v9;           // xmm0_4
  char *v10;          // eax
  float v11;          // xmm0_4
  char *v12;          // eax
  SndCurve *v13;      // edx
  uint32_t knotCount; // eax
  uint32_t v15;       // eax
  double v16;         // xmm0_8
  char __b[8192];     // [esp+28h] [ebp-2060h] BYREF
  char __str[64];     // [esp+2028h] [ebp-60h] BYREF
  char *v19;          // [esp+2068h] [ebp-20h] BYREF
  int v20[7];         // [esp+206Ch] [ebp-1Ch] BYREF

  Com_sprintf(__str, 0x40u, "soundaliases/%s.vfcurve", a1);
  v2 = FS_FOpenFileRead(__str, v20, 1);
  v3 = v2;
  if (v2 < 0) {
    Com_Printf("^1ERROR: Could not load sndcurve file '%s'\n", __str);
    return 0;
  }
  if (!v2) {
    FS_FCloseFile(v20[0]);
    Com_Printf("^1ERROR: sndcurve file '%s' is empty\n", __str);
    return 0;
  }
  FS_Read(__b, 8u, v20[0]);
  __b[8] = 0;
  if (memcmp(__b, "SNDCURVE", 8)) {
    FS_FCloseFile(v20[0]);
    Com_Printf("^1ERROR: \"%s\" does not appear to be a sndcurve file\n",
               __str);
    return 0;
  }
  if (v3 - 8 > 0x1FFF) {
    FS_FCloseFile(v20[0]);
    Com_Printf("^1ERROR: \"%s\" Is too long of a sndcurve file to parse\n",
               __str);
    return 0;
  }
  memset(__b, 0, sizeof(__b));
  FS_Read(__b, v3 - 8, v20[0]);
  __b[v3 - 8] = 0;
  FS_FCloseFile(v20[0]);
  v19 = __b;
  Com_BeginParseSession(__str);
  v4 = Com_Parse(&v19);
  v5 = atoi(v4);
  a2->knotCount = v5;
  if (v5 <= 1) {
    Com_EndParseSession();
    Com_Printf("^1ERROR: sndcurve parse failure on file \"%s\": knot count "
               "(%d) is less than 2\n",
               __str, a2->knotCount);
    return 0;
  }
  if (v5 > 8) {
    Com_EndParseSession();
    Com_Printf("^1ERROR: sndcurve parse failure on file \"%s\": knot count "
               "(%d) is greater than maxKnots (%d)\n",
               __str, a2->knotCount, 8);
    return 0;
  }
  v7 = a2;
  for (i = 0;; ++i) {
    v12 = Com_Parse(&v19);
    if (!*v12 || *v12 == 125) {
    LABEL_25:
      Com_EndParseSession();
      v13 = a2;
      knotCount = a2->knotCount;
      if (knotCount != i) {
        Com_Printf("^1ERROR: sndcurve parse failure on file \"%s\": knot count "
                   "(%d) does not match knots parsed (%d).\n",
                   __str, knotCount, i);
        return 0;
      }
      v15 = knotCount - 1;
      if (*(float *)a2->knots == 0.0) {
        if (*(float *)&a2->knots[4] == 1.0 &&
            *(float *)&a2->knots[8 * v15] == 1.0 &&
            *(float *)&a2->knots[8 * v15 + 4] == 0.0) {
          goto LABEL_31;
        }
        v13 = a2;
      }
      *(_DWORD *)v13->knots = 0;
      *(_DWORD *)&v13->knots[4] = 1065353216;
      *(_DWORD *)&v13->knots[8 * v15] = 1065353216;
      *(_DWORD *)&v13->knots[8 * v15 + 4] = 0;
      Com_Printf("^3WARNING^7: sndcurve parse on file \"%s\": the first point "
                 "must be '0.0000 1.0000' and the last point must be '"
                 "1.0000 0.0000'.\n"
                 "adjusting sndcurve endpoints.\n",
                 __str);
    LABEL_31:
      *(_DWORD *)a2->filename = a1;
      return 1;
    }
    if (i == 8) {
      Com_EndParseSession();
      Com_Printf("^1ERROR: sndcurve parse failure on file \"%s\": knots parsed "
                 "(%d) is greater than or equal to maxKnots (%d)\n",
                 __str, 8, 8);
      return 0;
    }
    v9 = atof(v12);
    *(float *)v7->knots = v9;
    if (v9 < 0.0 || v9 > 1.0) {
      Com_EndParseSession();
      v16 = *(float *)&a2->knots[8 * i];
      goto LABEL_33;
    }
    v10 = Com_Parse(&v19);
    if (!*v10 || *v10 == 125)
      goto LABEL_25;
    v11 = atof(v10);
    *(float *)&v7->knots[4] = v11;
    if (v11 < 0.0)
      break;
    v7 = (SndCurve *)((char *)v7 + 8);
    if (v11 > 1.0)
      break;
  }
  Com_EndParseSession();
  v16 = *(float *)&a2->knots[8 * i + 4];
LABEL_33:
  Com_Printf("^1ERROR: sndcurve parse failure on file \"%s\": knot x-coord "
             "'%f' is not in the range 0-1.\n",
             __str, v16);
  return 0;
}

SndCurve *__cdecl Com_InitDefaultSoundAliasVolumeFalloffCurve(SndCurve *a1) {
  SndCurve *result; // eax

  result = a1;
  *(_DWORD *)a1->filename = &inData;
  *(_DWORD *)a1->knots = 0;
  *(_DWORD *)&a1->knots[4] = 1065353216;
  *(_DWORD *)&a1->knots[8] = 1065353216;
  *(_DWORD *)&a1->knots[12] = 0;
  a1->knotCount = 2;
  return result;
}

int __cdecl FileNameTypeCompare(snd_alias_build_s *a1, snd_alias_build_s *a2) {
  int result; // eax

  result = I_stricmp(a1->szSoundFile, a2->szSoundFile);
  if (!result) {
    result = a1->eType - a2->eType;
    if (!result)
      return I_stricmp(a1->szAliasName, a2->szAliasName);
  }
  return result;
}

void __usercall Com_LoadSoundAliasField(
    const char *a1 @<eax>, const char *a2 @<edx>, const char *a3 @<ecx>,
    long double a4 @<st0>, __m128 a5 @<xmm0>, __m128 a6 @<xmm1>,
    __m128 a7 @<xmm2>, __m128 a8 @<xmm3>, __m128 a9 @<xmm4>, __m128 a10 @<xmm6>,
    char *__big, const char *a12, const char *a13, const char *a14) {
  char v15;                 // al
  _BOOL4 v16;               // eax
  const char *v17;          // edi
  __m128 v18;               // xmm2
  __m128 v19;               // xmm2
  __m128 v20;               // xmm3
  __m128 v21;               // xmm0
  char v22;                 // al
  _BOOL4 v23;               // eax
  const char *v24;          // eax
  unsigned int v25;         // kr0C_4
  bool v26;                 // al
  float v27;                // xmm0_4
  float v28;                // xmm0_4
  int v29;                  // esi
  char **v30;               // ebx
  int v31;                  // ebx
  const char **v32;         // edi
  float v33;                // xmm0_4
  float v34;                // xmm0_4
  float v35;                // xmm0_4
  size_t v36;               // eax
  size_t v37;               // ebx
  char v38;                 // dl
  int v39;                  // esi
  const char *v40;          // ebx
  int v41;                  // edi
  int v42;                  // eax
  float v43;                // xmm0_4
  float v44;                // xmm0_4
  char *i;                  // edx
  char *v46;                // eax
  size_t v47;               // edx
  size_t v48;               // esi
  void *TempMemoryInternal; // eax
  float v50;                // xmm0_4
  char v51;                 // al
  const char *v52;          // ebx
  _BOOL4 v53;               // eax
  char v54;                 // al
  const char *v55;          // ebx
  _BOOL4 v56;               // eax
  const char *__s1;         // [esp+2Ch] [ebp-408Ch]
  bool v60;                 // [esp+9Fh] [ebp-4019h]
  char __dst[16383];        // [esp+A0h] [ebp-4018h] BYREF
  char v62;                 // [esp+409Fh] [ebp-19h]

  if (a12) {
    if (a13[(_DWORD)a12]) {
      Com_Printf("^1ERROR: Sound alias file %s: Duplicate entries for the '%s' "
                 "column\n",
                 a3, (const char *)g_pszSndAliasKeyNames[(_DWORD)a12]);
      *((_BYTE *)a14 + 329) = 1;
      return;
    }
    a13[(_DWORD)a12] = 1;
    switch ((unsigned int)a12) {
    case 1u:
      if (strlen(__big) > 0x3E) {
        Com_Printf("^1ERROR: Sound alias file %s: Alias name '%s' is longer "
                   "than %i characters\n",
                   a3, __big, 63);
        *((_BYTE *)a14 + 329) = 1;
      } else {
        v15 = *__big;
        if (*__big <= 31) {
          v17 = __big;
          goto LABEL_11;
        }
        if ((v15 & 0xFFFFFF80) != 0)
          v16 = __maskrune(v15, 1280) != 0;
        else
          v16 = (_DefaultRuneLocale.__runetype[v15] & 0x500) != 0;
        if (!v16 && *__big != 95) {
          v17 = __big;
        LABEL_11:
          Com_Printf(
              "^1ERROR: Sound alias file %s: Alias name '%s' is invalid\n", a3,
              v17);
          *((_BYTE *)a14 + 329) = 1;
          return;
        }
        v54 = __big[1];
        if (v54) {
          if (v54 > 31) {
            v55 = __big + 1;
            do {
              if ((v54 & 0xFFFFFF80) != 0)
                v56 = __maskrune(v54, 1280) != 0;
              else
                v56 = (_DefaultRuneLocale.__runetype[v54] & 0x500) != 0;
              if (!v56 && *v55 != 95)
                break;
              v54 = v55[1];
              if (!v54)
                goto LABEL_126;
              ++v55;
            } while (v54 > 31);
          }
          v17 = __big;
          goto LABEL_11;
        }
      LABEL_126:
        strcpy((char *)a14 + 64, __big);
      }
      return;
    case 2u:
      *((_DWORD *)a14 + 49) = atoi(__big);
      return;
    case 3u:
      if (strlen(__big) > 0x3E) {
        Com_Printf("^1ERROR: Sound alias file %s: Sound file '%s' is longer "
                   "than %i characters\n",
                   a3, __big, 63);
        *((_BYTE *)a14 + 329) = 1;
      } else {
        strcpy((char *)a14 + 200, __big);
      }
      return;
    case 4u:
      if (!*__big) {
        v47 = 1;
        v48 = 0;
        v37 = 0;
      LABEL_92:
        TempMemoryInternal = Hunk_AllocateTempMemoryInternal(v47);
        *((_DWORD *)a14 + 48) = TempMemoryInternal;
        memcpy(TempMemoryInternal, __big, v48);
        *(_BYTE *)(*((_DWORD *)a14 + 48) + v37) = 0;
        return;
      }
      if (*__big >= 0) {
        v36 = 0;
        while (1) {
          v37 = ++v36;
          v38 = __big[v36];
          if (!v38)
            break;
          if (v38 < 0)
            goto LABEL_59;
        }
        v47 = v36 + 1;
        v48 = v36;
        goto LABEL_92;
      }
      v38 = *__big;
    LABEL_59:
      Com_Printf("^1ERROR: Sound alias file %s: Subtitle '%s' has invalid "
                 "character '%c' ascii %i\n",
                 a3, __big, v38, (unsigned __int8)v38);
      *((_BYTE *)a14 + 329) = 1;
      return;
    case 5u:
      v35 = atof(__big);
      *((float *)a14 + 67) = v35;
      if (v35 >= 0.0 && v35 <= 1.0) {
        if (!a13[6])
          *((float *)a14 + 68) = v35;
      } else {
        Com_Printf("^1ERROR: Sound alias file %s: MinVolume '%f' is not within "
                   "the range of '%f'-'%f'.\n",
                   a3, v35, 0.0, 1.0);
        *((_BYTE *)a14 + 329) = 1;
      }
      return;
    case 6u:
      v43 = atof(__big);
      *((float *)a14 + 68) = v43;
      if (v43 < 0.0 || v43 > 1.0) {
        Com_Printf("^1ERROR: Sound alias file %s: MaxVolume '%f' is not within "
                   "the range of '%f'-'%f'.\n",
                   a3, v43, 0.0, 1.0);
        *((_BYTE *)a14 + 329) = 1;
      }
      return;
    case 7u:
      v39 = 0;
      v40 = byte_1150528;
      v41 = 0;
      do {
        if (!stricmp(__big, v40)) {
          v42 = dword_1150568[v41];
          goto LABEL_67;
        }
        ++v39;
        v41 += 17;
        v40 += 68;
      } while (v39 != 32);
      Com_Error(a4, a5.f32[0], a6, a7, a8, a9, a10, 1,
                "\x15Sound alias file %s: Volume Mod Group '%s' not found.", a3,
                __big);
      v42 = 0;
    LABEL_67:
      *((_DWORD *)a14 + 69) = v42;
      return;
    case 8u:
      v44 = atof(__big);
      *((float *)a14 + 70) = v44;
      if (!a13[9])
        *((float *)a14 + 71) = v44;
      return;
    case 9u:
      v28 = atof(__big);
      *((float *)a14 + 71) = v28;
      return;
    case 0xAu:
      v34 = atof(__big);
      *((float *)a14 + 72) = v34;
      return;
    case 0xBu:
      v33 = atof(__big);
      *((float *)a14 + 73) = v33;
      return;
    case 0xCu:
      v29 = 0;
      v30 = (char **)&g_pszChannelNames;
      do {
        if (!I_stricmp(__big, *v30)) {
          *((_DWORD *)a14 + 74) = v29;
          return;
        }
        ++v29;
        ++v30;
      } while (v29 != 11);
      LOWORD(v29) = 0;
      v31 = 0;
      v32 = (const char **)&g_pszChannelNames;
      do {
        v31 += sprintf(&__dst[v31], "%s", *v32);
        if (v29 > 8) {
          if (v29 == 9) {
            strcpy(&__dst[v31], " or ");
            v31 += 4;
          }
        } else {
          strcpy(&__dst[v31], ", ");
          v31 += 2;
        }
        ++v29;
        ++v32;
      } while (v29 != 11);
      Com_Printf("^1ERROR: Sound alias file %s: Unknown sound channel '%s'; "
                 "should be %s\n",
                 a3, __big, __dst);
      *((_BYTE *)a14 + 329) = 1;
      return;
    case 0xDu:
      if (I_stricmp(__big, "streamed")) {
        if (I_stricmp(__big, "primed")) {
          if (I_stricmp(__big, "loaded")) {
            Com_Printf("^1ERROR: Sound alias file %s: Unknown sound type '%s'; "
                       "should be primed, streamed or loaded\n",
                       a3, __big);
            *((_BYTE *)a14 + 329) = 1;
          } else {
            *((_DWORD *)a14 + 75) = 1;
          }
        } else {
          *((_DWORD *)a14 + 75) = 2;
        }
      } else {
        *((_DWORD *)a14 + 75) = 2;
      }
      return;
    case 0xEu:
      if (I_stricmp(__big, "looping")) {
        if (I_stricmp(__big, "nonlooping")) {
          Com_Printf("^1ERROR: Sound alias file %s: Unknown sound looping type "
                     "'%s'; should be looping or nonlooping\n",
                     a3, __big);
          *((_BYTE *)a14 + 329) = 1;
        } else {
          *((_BYTE *)a14 + 324) = 0;
        }
      } else {
        *((_BYTE *)a14 + 324) = 1;
      }
      return;
    case 0xFu:
      v27 = atof(__big);
      *((float *)a14 + 78) = v27;
      return;
    case 0x10u:
      v25 = strlen(a1) + 1;
      v62 = 0;
      strncpy(__dst, __big, 0x4000u);
      if (v62) {
        Com_Printf(
            "^1ERROR: Sound alias file %s: loadspec is > %i characters\n", a3,
            0x3FFF);
        v26 = 0;
      } else {
        strlwr(__dst);
        v60 = __dst[0] != 33 || !strcmp(a1, "menu");
        __s1 = __dst;
        for (i = __dst;; i = v46 + 1) {
          v46 = strstr(i, a1);
          if (!v46)
            break;
          if ((__dst == v46 || *(v46 - 1) <= 33) && v46[v25 - 1] <= 32)
            goto LABEL_121;
          __s1 = v46 + 1;
        }
        if (!strcmp(a1, "menu") || strcmp(__s1, a2)) {
          v26 = !v60;
          goto LABEL_33;
        }
      LABEL_121:
        v26 = v60;
      }
    LABEL_33:
      *((_BYTE *)a14 + 330) = v26;
      return;
    case 0x11u:
      if (!stricmp(__big, "master")) {
        *((_BYTE *)a14 + 325) = 1;
        *((_BYTE *)a14 + 326) = 0;
      } else {
        *((_BYTE *)a14 + 325) = 0;
        *((_BYTE *)a14 + 326) = 1;
        v50 = atof(__big);
        *((float *)a14 + 77) = v50;
        if (v50 < 0.0 || v50 > 1.0) {
          Com_Printf("^1ERROR: Sound alias file %s: SlavePercentage'%f' is not "
                     "within the range of '%f'-'%f'.\n",
                     a3, v50, 0.0, 1.0);
          *((_BYTE *)a14 + 329) = 1;
        }
      }
      return;
    case 0x12u:
      if (strlen(__big) > 0x3E) {
        Com_Printf("^1ERROR: Sound alias file %s: Secondary Alias name '%s' is "
                   "longer than %i characters\n",
                   a3, __big, 63);
        *((_BYTE *)a14 + 329) = 1;
      } else {
        v22 = *__big;
        if (*__big <= 31) {
          v24 = __big;
          goto LABEL_28;
        }
        if ((v22 & 0xFFFFFF80) != 0)
          v23 = __maskrune(v22, 1280) != 0;
        else
          v23 = (_DefaultRuneLocale.__runetype[v22] & 0x500) != 0;
        if (!v23 && *__big != 95) {
          v24 = __big;
        LABEL_28:
          Com_Printf("^1ERROR: Sound alias file %s: Secondary Alias name '%s' "
                     "is invalid\n",
                     a3, v24);
          *((_BYTE *)a14 + 329) = 1;
          return;
        }
        v51 = __big[1];
        if (v51) {
          if (v51 > 31) {
            v52 = __big + 1;
            do {
              if ((v51 & 0xFFFFFF80) != 0)
                v53 = __maskrune(v51, 1280) != 0;
              else
                v53 = (_DefaultRuneLocale.__runetype[v51] & 0x500) != 0;
              if (!v53 && *v52 != 95)
                break;
              v51 = v52[1];
              if (!v51)
                goto LABEL_125;
              ++v52;
            } while (v51 > 31);
          }
          v24 = __big;
          goto LABEL_28;
        }
      LABEL_125:
        strcpy((char *)a14 + 128, __big);
      }
      break;
    case 0x13u:
      *((_DWORD *)a14 + 76) = Com_RegisterSoundAliasVolumeFalloffCurve(
          a4, a5.f32[0], a6, a7, a8, a9, a10, __big, a3);
      return;
    case 0x14u:
      *((_DWORD *)a14 + 80) = atoi(__big);
      return;
    case 0x16u:
      if (strstr(__big, "fulldrylevel"))
        *((_BYTE *)a14 + 327) = 1;
      if (strstr(__big, "nowetlevel"))
        *((_BYTE *)a14 + 328) = 1;
      return;
    case 0x17u:
      a5.f32[0] = atof(__big);
      v18 = a5;
      v18.f32[0] = a5.f32[0] - 1.0;
      v19 = _mm_cmpge_ss(v18, (__m128)0LL);
      v19.i32[0] = _mm_andnot_ps(v19, a5).u32[0] | v19.i32[0] & 0x3F800000;
      v20 = 0;
      v20.f32[0] = 0.0 - a5.f32[0];
      v21 = _mm_cmplt_ss(v20, (__m128)0LL);
      *((_DWORD *)a14 + 79) =
          _mm_andnot_ps(v21, (__m128)0LL).u32[0] | v19.i32[0] & v21.i32[0];
      return;
    default:
      return;
    }
  }
}

void __usercall Com_ProcessSoundAliasFileLocalization(
    long double a1 @<st0>, __m128 a2 @<xmm0>, __m128 a3 @<xmm1>,
    __m128 a4 @<xmm2>, __m128 a5 @<xmm3>, __m128 a6 @<xmm4>, __m128 a7 @<xmm6>,
    char *__src, const char *a9) {
  FILE *v9;                        // eax
  unsigned __int8 *v10;            // ecx
  unsigned __int8 *v11;            // eax
  unsigned __int8 *v12;            // edi
  char *v13;                       // eax
  int v14;                         // esi
  int *v15;                        // ebx
  int v16;                         // esi
  const char *i;                   // ecx
  const char *v18;                 // ebx
  unsigned int v19;                // kr04_4
  int v20;                         // ebx
  char v21;                        // dl
  int v22;                         // edi
  const char *v23;                 // ebx
  char *v24;                       // ebx
  int v25;                         // edx
  char *v26;                       // edx
  char *v27;                       // eax
  char *v28;                       // eax
  int v29;                         // ebx
  const char *v30;                 // ebx
  char *SubtitleStringEdReference; // eax
  char *v32;                       // ebx
  char *v33;                       // eax
  char *v34;                       // eax
  char *v35;                       // [esp+28h] [ebp-6FF0h]
  char *v36;                       // [esp+34h] [ebp-6FE4h]
  int v37;                         // [esp+4Ch] [ebp-6FCCh]
  int v38;                         // [esp+50h] [ebp-6FC8h]
  int v39;                         // [esp+54h] [ebp-6FC4h]
  int v40;                         // [esp+58h] [ebp-6FC0h]
  int v41;                         // [esp+5Ch] [ebp-6FBCh]
  char *v42;                       // [esp+60h] [ebp-6FB8h]
  int v43;                         // [esp+64h] [ebp-6FB4h]
  int v44;                         // [esp+68h] [ebp-6FB0h]
  int v45;                         // [esp+6Ch] [ebp-6FACh]
  char **v46;                      // [esp+70h] [ebp-6FA8h]
  int v47;                         // [esp+74h] [ebp-6FA4h]
  char *v48;                       // [esp+7Ch] [ebp-6F9Ch]
  char v49[1024];                  // [esp+84h] [ebp-6F94h] BYREF
  char v50[1024];                  // [esp+484h] [ebp-6B94h] BYREF
  char v51[2048];                  // [esp+884h] [ebp-6794h] BYREF
  char v52[9];                     // [esp+1084h] [ebp-5F94h] BYREF
  char v53[20471];                 // [esp+108Dh] [ebp-5F8Bh] BYREF
  char v54[9];                     // [esp+6084h] [ebp-F94h] BYREF
  char __s2[1015];                 // [esp+608Dh] [ebp-F8Bh] BYREF
  char *v56[256];                  // [esp+6484h] [ebp-B94h] BYREF
  char __dst[192];                 // [esp+6884h] [ebp-794h] BYREF
  int v58;                         // [esp+6944h] [ebp-6D4h]
  int v59;                         // [esp+6948h] [ebp-6D0h]
  char v60;                        // [esp+694Ch] [ebp-6CCh]
  int v61;                         // [esp+6990h] [ebp-688h]
  int v62;                         // [esp+6994h] [ebp-684h]
  int v63;                         // [esp+6998h] [ebp-680h]
  int v64;                         // [esp+699Ch] [ebp-67Ch]
  int v65;                         // [esp+69A0h] [ebp-678h]
  int v66;                         // [esp+69A4h] [ebp-674h]
  int v67;                         // [esp+69A8h] [ebp-670h]
  int v68;                         // [esp+69ACh] [ebp-66Ch]
  int v69;                         // [esp+69B0h] [ebp-668h]
  SndCurve *DefaultSoundAliasVolumeFalloffCurve; // [esp+69B4h] [ebp-664h]
  int v71;                                       // [esp+69B8h] [ebp-660h]
  int v72;                                       // [esp+69BCh] [ebp-65Ch]
  int v73;                                       // [esp+69C0h] [ebp-658h]
  int v74;                                       // [esp+69C4h] [ebp-654h]
  char v75;                                      // [esp+69C8h] [ebp-650h]
  char v76;                                      // [esp+69C9h] [ebp-64Fh]
  char v77;                                      // [esp+69CAh] [ebp-64Eh]
  char v78;                                      // [esp+69CBh] [ebp-64Dh]
  char v79;                                      // [esp+69CCh] [ebp-64Ch]
  char v80;                                      // [esp+69CDh] [ebp-64Bh]
  char v81;                                      // [esp+69CEh] [ebp-64Ah]
  int v82;                                       // [esp+69D4h] [ebp-644h]
  char v83[256];                                 // [esp+69D8h] [ebp-640h] BYREF
  char __str[256];                               // [esp+6AD8h] [ebp-540h] BYREF
  char __big[256];                               // [esp+6BD8h] [ebp-440h] BYREF
  char v86[256];                                 // [esp+6CD8h] [ebp-340h] BYREF
  char v87[256];                                 // [esp+6DD8h] [ebp-240h] BYREF
  char v88[256];                                 // [esp+6ED8h] [ebp-140h] BYREF
  char v89[24];                                  // [esp+6FD8h] [ebp-40h] BYREF
  char *v90;                                     // [esp+6FF0h] [ebp-28h] BYREF
  int v91;                                       // [esp+6FF4h] [ebp-24h] BYREF
  int v92;                                       // [esp+6FF8h] [ebp-20h] BYREF
  char *v93[7];                                  // [esp+6FFCh] [ebp-1Ch] BYREF

  Com_sprintf(__str, 0x100u, "soundaliases/%s", __src);
  FS_BuildOSPath((const char *)fs_basepath->current.integer, fs_gamedir, __str,
                 v87);
  Com_Printf("Processing sound alias file %s..\n", v87);
  v9 = FS_FileOpen(v87, "r+");
  if (v9) {
    FS_FileClose(v9);
    if ((FS_ReadFile(__str, (char **)&v92) & 0x80000000) != 0) {
      Com_Printf("WARNING: Could not read sound alias file %s\n", __str);
    } else {
      v39 = FS_FOpenFileWrite("soundaliases/temp.csv");
      if (!v39) {
        Com_Printf("WARNING: Could not open output file %s for writing\n",
                   "soundaliases/temp.csv");
        return;
      }
      Com_BeginParseSession(__str);
      Com_SetCSV(1);
      v90 = (char *)v92;
      v37 = 0;
      v38 = 0;
      v10 = (unsigned __int8 *)v92;
    LABEL_5:
      while (2) {
        v36 = (char *)v10;
        v11 = v10;
        if (v10) {
          if (*v10 == 13) {
            do
              v90 = (char *)++v11;
            while (*v11 == 13);
            v36 = (char *)v11;
            v12 = v11;
            if (*v11 != 10) {
            LABEL_8:
              v13 = Com_Parse(&v90);
              v35 = v13;
              if (!v90)
                break;
              goto LABEL_9;
            }
          } else {
            v12 = v10;
            if (*v10 != 10)
              goto LABEL_8;
          }
          v90 = (char *)(v12 + 1);
          FS_Write("\r\n", 2u, v39);
          v36 = v90;
          v13 = Com_Parse(&v90);
          v35 = v13;
          if (!v90)
            break;
        LABEL_9:
          I_stricmp(v13, "#Chateau");
          if (*v35 && *v35 != 35) {
            if (v37) {
              memset(v89, 0, sizeof(v89));
              strcpy(__dst, __src);
              __dst[64] = 0;
              __dst[128] = 0;
              v59 = 0;
              v60 = 0;
              v58 = 0;
              v61 = 1065353216;
              v62 = 1065353216;
              v63 = 1065353216;
              v64 = 1065353216;
              v65 = 1065353216;
              v66 = 1123024896;
              v67 = 0;
              v68 = 0;
              v69 = 1;
              v75 = 0;
              v72 = 1065353216;
              v73 = 0;
              v80 = 0;
              v81 = 0;
              v76 = 0;
              v77 = 0;
              v78 = 0;
              v79 = 0;
              v71 = 1065353216;
              v74 = 0;
              DefaultSoundAliasVolumeFalloffCurve =
                  Com_GetDefaultSoundAliasVolumeFalloffCurve();
              v82 = 0;
              v16 = 0;
              for (i = v35;; i = v35) {
                v18 = v56[v16];
                strcpy(&v49[1024 * (_DWORD)v18], i);
                if (*v35) {
                  Com_LoadSoundAliasField("menu", a9, __src, a1, a2, a3, a4, a5,
                                          a6, a7, v35, v18, v89, __dst);
                  if (v37 == ++v16) {
                  LABEL_42:
                    if (v89[1] && v89[3]) {
                      if (v89[4])
                        goto LABEL_45;
                    LABEL_67:
                      Com_SkipRestOfLine((unsigned __int8 **)&v90);
                      FS_Write(v36, v90 - v36, v39);
                      v10 = (unsigned __int8 *)v90;
                    } else {
                      Com_Error(a1, a2.f32[0], a3, a4, a5, a6, a7, 1,
                                "\x15Sound alias file %s: alias entry missing "
                                "name and/or file\n",
                                __src);
                      if (!v89[4])
                        goto LABEL_67;
                    LABEL_45:
                      v19 = strlen(v52) + 1;
                      if ((int)(v19 - 1) <= 0) {
                      LABEL_51:
                        if (!I_strncmp(v52, "SUBTITLE_", 9) &&
                            !I_strncmp(v52, "SUBTITLE_", 9)) {
                          if ((FS_ReadFile("soundaliases/subtitle.st",
                                           (char **)&v91) &
                               0x80000000) != 0) {
                            Com_Printf("WARNING: Could not read local copy of "
                                       "StringEd file %s\n",
                                       "soundaliases/subtitle.st");
                          } else {
                            Com_BeginParseSession("soundaliases/subtitle.st");
                            v93[0] = (char *)v91;
                            while (1) {
                              v28 = Com_Parse(v93);
                              if (!v93[0]) {
                                v29 = 0;
                                goto LABEL_77;
                              }
                              if (!strcmp(v28, "REFERENCE")) {
                                v27 = Com_ParseOnLine(v93);
                                if (!I_stricmp(v53, v27))
                                  break;
                              }
                              Com_SkipRestOfLine((unsigned __int8 **)v93);
                            }
                            v29 = 1;
                          LABEL_77:
                            Com_EndParseSession();
                            FS_FreeFile((void *)v91);
                            if (v29)
                              goto LABEL_67;
                          }
                        }
                      } else {
                        v20 = 0;
                        while (1) {
                          v21 = v52[v20];
                          if ((unsigned __int8)(v21 - 65) > 0x19u &&
                              (unsigned __int8)(v21 - 48) > 9u && v21 != 95)
                            break;
                          if (v19 - 1 == ++v20)
                            goto LABEL_51;
                        }
                      }
                      if (v37 > 0) {
                        v47 = 0;
                        v22 = 0;
                        while (2) {
                          v26 = v56[v22];
                          if (v26 && v89[(_DWORD)v26]) {
                            if (v26 == (char *)4) {
                              SubtitleStringEdReference =
                                  Com_GetSubtitleStringEdReference(
                                      a1, a2.f32[0], a3, a4, a5, a6, a7, v52);
                              if (SubtitleStringEdReference) {
                                Com_sprintf(v54, 0x400u, "%s%s", "SUBTITLE_",
                                            SubtitleStringEdReference);
                                v48 = I_strupr(v54);
                              } else {
                                if (v89[2])
                                  Com_sprintf(v54, 0x400u, "%s%s_%s",
                                              "SUBTITLE_", v50, v51);
                                else
                                  Com_sprintf(v54, 0x400u, "%s%s", "SUBTITLE_",
                                              v50);
                                v48 = I_strupr(v54);
                                v43 = FS_FOpenFileWrite("soundaliases/temp.st");
                                if (v43) {
                                  if ((FS_ReadFile("soundaliases/subtitle.st",
                                                   v93) &
                                       0x80000000) != 0) {
                                    Com_Printf("WARNING: Could not read local "
                                               "copy of StringEd file %s\n",
                                               "soundaliases/subtitle.st");
                                    FS_FCloseFile(v43);
                                  } else {
                                    Com_BeginParseSession(
                                        "soundaliases/subtitle.st");
                                    v91 = (int)v93[0];
                                    v32 = v93[0];
                                    v44 = 0;
                                    while (1) {
                                      v42 = Com_Parse((char **)&v91);
                                      if (!v91)
                                        break;
                                      if (!strcmp(v42, "ENDMARKER")) {
                                        if ((unsigned int)v32 < v91)
                                          FS_Write(v32, v91 - (_DWORD)v32 - 11,
                                                   v43);
                                        break;
                                      }
                                      if (!strcmp(v42, "REFERENCE")) {
                                        v33 = Com_ParseOnLine((char **)&v91);
                                        if (!strcmp(v33, __s2)) {
                                          if (v91 > (unsigned int)v32)
                                            FS_Write(v32, v91 - (_DWORD)v32,
                                                     v43);
                                          Com_WriteStringEdReferenceToFile(
                                              __s2, v52, v43);
                                          while (1) {
                                            v32 = (char *)v91;
                                            v34 = Com_Parse((char **)&v91);
                                            if (!v91)
                                              break;
                                            if (!strcmp(v34, "REFERENCE") ||
                                                !strcmp(v34, "ENDMARKER")) {
                                              Com_UngetToken();
                                              v44 = 1;
                                              goto LABEL_102;
                                            }
                                          }
                                          v44 = 1;
                                          v32 = 0;
                                        }
                                      }
                                    LABEL_102:
                                      Com_SkipRestOfLine(
                                          (unsigned __int8 **)&v91);
                                    }
                                    if (!v44)
                                      Com_WriteStringEdReferenceToFile(
                                          __s2, v52, v43);
                                    Com_EndParseSession();
                                    FS_FreeFile(v93[0]);
                                    FS_Write("\r\nENDMARKER\r\n\r\n\r\n", 0x11u,
                                             v43);
                                    FS_FCloseFile(v43);
                                    FS_BuildOSPath((const char *)fs_basepath
                                                       ->current.integer,
                                                   fs_gamedir,
                                                   "soundaliases/temp.st", v83);
                                    FS_BuildOSPath(
                                        (const char *)
                                            fs_basepath->current.integer,
                                        fs_gamedir, "soundaliases/subtitle.st",
                                        v88);
                                    FS_CopyFile(v83, v88);
                                    FS_Remove(v83);
                                  }
                                } else {
                                  Com_Printf("WARNING: Could not open output "
                                             "file %s for writing\n",
                                             "soundaliases/temp.st");
                                }
                                ++v38;
                              }
                              FS_Write(v48, strlen(v48), v39);
                            } else {
                              if (v47 == v37 - 1) {
                                v30 = &v49[1024 * (_DWORD)v26];
                                if (strchr(v30, 44) || strchr(v30, 32) ||
                                    strchr(v30, 10) || strchr(v30, 13))
                                  v24 = va("\"%s\"", v30);
                                else
                                  v24 = va("%s", v30);
                              } else {
                                v23 = &v49[1024 * (_DWORD)v26];
                                if (strchr(v23, 44) || strchr(v23, 32) ||
                                    strchr(v23, 10) || strchr(v23, 13))
                                  v24 = va("\"%s\",", v23);
                                else
                                  v24 = va("%s,", v23);
                              }
                              FS_Write(v24, strlen(v24), v39);
                            }
                            goto LABEL_60;
                          }
                          if (v47 == v37 - 1) {
                          LABEL_60:
                            v25 = ++v47;
                            if (v37 == v47)
                              break;
                          } else {
                            FS_Write(",", 1u, v39);
                            v25 = ++v47;
                            if (v37 == v47)
                              break;
                          }
                          v22 = v25;
                          continue;
                        }
                      }
                      FS_Write("\r\n", 2u, v39);
                      Com_SkipRestOfLine((unsigned __int8 **)&v90);
                      v10 = (unsigned __int8 *)v90;
                    }
                    goto LABEL_5;
                  }
                } else if (v37 == ++v16) {
                  goto LABEL_42;
                }
                v35 = Com_ParseOnLine(&v90);
              }
            }
            v40 = 0;
            v41 = 0;
            v45 = 1;
            while (1) {
              v46 = &v56[v45 - 1];
              *v46 = 0;
              v14 = 1;
              v15 = g_pszSndAliasKeyNames;
              while (I_stricmp((char *)v15[1], v35)) {
                ++v14;
                ++v15;
                if (v14 == 24)
                  goto LABEL_19;
              }
              *v46 = (char *)v14;
              if (v14 == 1) {
                v40 = 1;
              } else if (v14 == 3) {
                v41 = 1;
              }
            LABEL_19:
              v37 = v45;
              if (v45 == 256)
                break;
              if (!v90)
                break;
              ++v45;
              if (*v90 == 10)
                break;
              v35 = Com_ParseOnLine(&v90);
            }
            if (!v40 || !v41)
              Com_Error(a1, a2.f32[0], a3, a4, a5, a6, a7, 1,
                        "\x15Sound alias file %s: missing 'name' and/or 'file' "
                        "columns\n",
                        __src);
          }
          Com_SkipRestOfLine((unsigned __int8 **)&v90);
          if (*v36 == 10)
            FS_Write("\r", 1u, v39);
          FS_Write(v36, v90 - v36, v39);
          v10 = (unsigned __int8 *)v90;
          continue;
        }
        break;
      }
      Com_EndParseSession();
      FS_FCloseFile(v39);
      FS_BuildOSPath((const char *)fs_basepath->current.integer, fs_gamedir,
                     "soundaliases/temp.csv", v86);
      FS_BuildOSPath((const char *)fs_basepath->current.integer, fs_gamedir,
                     __str, __big);
      if (v38)
        FS_CopyFile(v86, __big);
      FS_Remove(v86);
      Com_Printf("Localized %i sound alias subtitles\n", v38);
    }
  } else {
    Com_Printf("WARNING: Can not write to sound alias file %s\n", v87);
  }
}

void __usercall Com_WriteLocalizedSoundAliasFiles(
    long double a1 @<st0>, __m128 a2 @<xmm0>, __m128 a3 @<xmm1>,
    __m128 a4 @<xmm2>, __m128 a5 @<xmm3>, __m128 a6 @<xmm4>,
    __m128 a7 @<xmm6>) {
  FILE *v7;        // eax
  void **v8;       // esi
  int v9;          // eax
  FILE *v10;       // eax
  FILE *v11;       // edi
  size_t v12;      // esi
  FILE *v13;       // eax
  FILE *v14;       // ebx
  int v15;         // edi
  void *v16;       // [esp+28h] [ebp-230h]
  int v17;         // [esp+2Ch] [ebp-22Ch]
  char __big[256]; // [esp+3Ch] [ebp-21Ch] BYREF
  char v19[256];   // [esp+13Ch] [ebp-11Ch] BYREF
  int v20[7];      // [esp+23Ch] [ebp-1Ch] BYREF

  FS_BuildOSPath(*(const char **)(fs_homepath + 8),
                 "../source_data/string_resources/subtitle.st",
                 (const char *)&inData, v19);
  __big[strlen(v19) + 255] = 0;
  v7 = FS_FileOpen(v19, "r+");
  if (v7) {
    FS_FileClose(v7);
    FS_BuildOSPath((const char *)fs_basepath->current.integer, fs_gamedir,
                   "soundaliases/subtitle.st", __big);
    FS_CopyFile(v19, __big);
    if (FS_FileExists("soundaliases/subtitle.st")) {
      Com_Printf("Localizing sound alias subtitle text...\n");
      Com_Printf("Writing to StringEd file %s\n", v19);
      v8 = (void **)FS_ListFiles("soundaliases", "csv", FS_LIST_PURE_ONLY, v20);
      if (v20[0]) {
        v9 = Hunk_HideTempMemory();
        v17 = v9;
        if (v20[0] > 0) {
          v15 = 0;
          do {
            Com_ProcessSoundAliasFileLocalization(a1, a2, a3, a4, a5, a6, a7,
                                                  (char *)v8[v15], "all_mp");
            Hunk_ClearTempMemory();
            ++v15;
          } while (v15 < v20[0]);
          v9 = v17;
        }
        Hunk_ShowTempMemory(v9);
        FS_FreeFileList(v8);
        v10 = FS_FileOpen(__big, "rb");
        v11 = v10;
        if (v10) {
          FS_FileSeek(v10, 0, 2);
          v12 = ftell(v11);
          FS_FileSeek(v11, 0, 0);
          v16 = malloc(v12);
          if (v12 != FS_FileRead(v16, 1u, v12, v11))
            Com_Error(a1, a2.f32[0], a3, a4, a5, a6, a7, 0,
                      "\x15Short read in COM_WriteFinalStringEdFile()\n");
          FS_FileClose(v11);
          v13 = FS_FileOpen(v19, "wb");
          v14 = v13;
          if (v13) {
            if (v12 != FS_FileWrite(v16, 1u, v12, v13))
              Com_Error(a1, a2.f32[0], a3, a4, a5, a6, a7, 0,
                        "\x15Short write in COM_WriteFinalStringEdFile()\n");
            FS_FileClose(v14);
          }
          free(v16);
        }
        FS_Remove(__big);
        Com_Printf("done\n");
      } else {
        Com_Printf(
            "WARNING: can't find any sound alias files (soundaliases/*.csv)\n");
      }
    } else {
      Com_Printf("WARNING: Could not make local copy of StringEd file %s\n",
                 "soundaliases/subtitle.st");
    }
  } else {
    Com_Printf("WARNING: Can not write to StringEd file %s\n", v19);
  }
}

int __cdecl SE_LoadFileData(char *a1) {
  int v2; // [esp+1Ch] [ebp-Ch] BYREF

  if ((int)FS_ReadFile(a1, (char **)&v2) <= 0)
    return 0;
  else
    return v2;
}

void __cdecl SE_FreeFileDataAfterLoad(void *a1) { FS_FreeFile(a1); }

void __usercall SE_R_ListFiles(char *a1 @<eax>, char *a2 @<edx>,
                               std::string *a3 @<ecx>) {
  int i;            // edi
  char v5;          // al
  void **v6;        // eax
  void **v7;        // ecx
  int v8;           // edx
  int v9;           // edx
  unsigned int v10; // edi
  int v11;          // edx
  const char *v12;  // [esp+0h] [ebp-A8h]
  const char *v13;  // [esp+4h] [ebp-A4h]
  std::string *v14; // [esp+8h] [ebp-A0h]
  void **v17;       // [esp+34h] [ebp-74h]
  void **v18;       // [esp+38h] [ebp-70h]
  int v19;          // [esp+3Ch] [ebp-6Ch]
  char v20[64];     // [esp+48h] [ebp-60h] BYREF
  int v21;          // [esp+88h] [ebp-20h] BYREF
  int v22[7];       // [esp+8Ch] [ebp-1Ch] BYREF

  v18 = (void **)FS_ListFiles(a2, "/", FS_LIST_PURE_ONLY, &v21);
  if (v21 > 0) {
    for (i = 0; i < v21; ++i) {
      v5 = *(_BYTE *)v18[i];
      if (v5 && v5 != 46) {
        sprintf(v20, "%s/%s", a2, (const char *)v18[i]);
        SE_R_ListFiles(v12, v13, v14);
      }
    }
  }
  v6 = (void **)FS_ListFiles(a2, a1, FS_LIST_PURE_ONLY, v22);
  v17 = v6;
  if (v22[0] > 0) {
    v19 = 0;
    v8 = 0;
    do {
      sprintf(v20, "%s/%s", a2, (const char *)v17[v8]);
      std::string::append(a3, v20, strlen(v20));
      v9 = *(_DWORD *)a3;
      v10 = *(_DWORD *)(*(_DWORD *)a3 - 12) + 1;
      if (v10 > *(_DWORD *)(*(_DWORD *)a3 - 8) || *(int *)(v9 - 4) > 0) {
        std::string::reserve(a3, *(_DWORD *)(*(_DWORD *)a3 - 12) + 1);
        v9 = *(_DWORD *)a3;
      }
      *(_BYTE *)(v9 + *(_DWORD *)(v9 - 12)) = 59;
      v11 = *(_DWORD *)a3;
      *(_DWORD *)(v11 - 4) = 0;
      *(_DWORD *)(v11 - 12) = v10;
      *(_BYTE *)(v11 + v10) = std::string::_Rep::_S_terminal;
      ++giFilesFound;
      v8 = ++v19;
    } while (v22[0] > v19);
    v7 = v17;
  } else {
    v7 = v6;
  }
  FS_FreeFileList(v7);
  FS_FreeFileList(v18);
}

int __cdecl SE_BuildFileList(char *a1, std::string *a2) {
  giFilesFound = 0;
  std::string::assign(a2, (const char *)&inData, 0);
  SE_R_ListFiles("str", a1, a2);
  return giFilesFound;
}

char **__cdecl SetConfigString(char **a1, char *__src) {
  char **result; // eax
  char *v3;      // ebx

  if (*__src) {
    v3 = (char *)Hunk_AllocLowAlignInternal(strlen(__src) + 1, 1);
    strcpy(v3, __src);
    result = a1;
    *a1 = v3;
  } else {
    result = a1;
    *a1 = (char *)&inData;
  }
  return result;
}

int __cdecl BG_ParseWeaponDefSpecificFieldType(unsigned __int8 *a1, char *a2,
                                               int a3) {
  int v4;           // esi
  const char **v5;  // ebx
  int v6;           // ebx
  int v7;           // esi
  int v8;           // esi
  const char **v9;  // ebx
  int v10;          // ebx
  int v11;          // esi
  const char **v12; // ebx
  int v13;          // ebx
  int v14;          // esi
  const char **v15; // ebx
  int v16;          // ebx
  int v17;          // esi
  const char **v18; // ebx
  int v19;          // ebx
  int v20;          // esi
  const char **v21; // ebx
  int v22;          // ebx
  int v23;          // esi
  const char **v24; // ebx
  int v25;          // ebx
  const char **v26; // ebx
  int v27;          // [esp+1Ch] [ebp-1Ch]

  switch (a3) {
  case 8:
    v4 = 0;
    v5 = (const char **)&szWeapTypeNames;
    while (stricmp(a2, *v5)) {
      ++v4;
      ++v5;
      if (v4 == 4) {
        v6 = -1;
      LABEL_7:
        Com_Error(1, "\x15Unknown weapon type \"%s\" in \"%s\"\n", (char)a2);
        goto LABEL_8;
      }
    }
    if (v4 < 0) {
      v6 = v4;
      goto LABEL_7;
    }
    v6 = v4;
  LABEL_8:
    *((_DWORD *)a1 + 30) = v6;
    return 1;
  case 9:
    v23 = 0;
    v24 = (const char **)&szWeapClassNames;
    while (stricmp(a2, *v24)) {
      ++v23;
      ++v24;
      if (v23 == 10) {
        v25 = -1;
      LABEL_47:
        Com_Error(1, "\x15Unknown weapon class \"%s\" in \"%s\"\n", (char)a2);
        goto LABEL_48;
      }
    }
    if (v23 < 0) {
      v25 = v23;
      goto LABEL_47;
    }
    v25 = v23;
  LABEL_48:
    *((_DWORD *)a1 + 31) = v25;
    return 1;
  case 10:
    v17 = 0;
    v18 = (const char **)&szWeapOverlayReticleNames;
    while (stricmp(a2, *v18)) {
      ++v17;
      ++v18;
      if (v17 == 5) {
        v19 = -1;
      LABEL_35:
        Com_Error(1, "\x15Unknown weapon overlay reticle \"%s\" in \"%s\"\n",
                  (char)a2);
        goto LABEL_36;
      }
    }
    if (v17 < 0) {
      v19 = v17;
      goto LABEL_35;
    }
    v19 = v17;
  LABEL_36:
    *((_DWORD *)a1 + 158) = v19;
    return 1;
  case 11:
    v20 = 0;
    v21 = (const char **)szWeapSlotNames;
    while (stricmp(a2, *v21)) {
      ++v20;
      ++v21;
      if (v20 == 3) {
        v22 = -1;
      LABEL_41:
        Com_Error(1, "\x15Unknown weapon slot \"%s\" in \"%s\"\n", (char)a2);
        goto LABEL_42;
      }
    }
    if (v20 < 0) {
      v22 = v20;
      goto LABEL_41;
    }
    v22 = v20;
  LABEL_42:
    *((_DWORD *)a1 + 32) = v22;
    return 1;
  case 12:
    v14 = 0;
    v15 = (const char **)&szWeapStanceNames;
    while (stricmp(a2, *v15)) {
      ++v14;
      ++v15;
      if (v14 == 3) {
        v16 = -1;
      LABEL_29:
        Com_Error(1, "\x15Unknown weapon stance \"%s\" in \"%s\"\n", (char)a2);
        goto LABEL_30;
      }
    }
    if (v14 < 0) {
      v16 = v14;
      goto LABEL_29;
    }
    v16 = v14;
  LABEL_30:
    *((_DWORD *)a1 + 35) = v16;
    return 1;
  case 13:
    v11 = 0;
    v12 = (const char **)&szProjectileExplosionNames;
    while (stricmp(a2, *v12)) {
      ++v11;
      ++v12;
      if (v11 == 3) {
        v13 = -1;
      LABEL_23:
        Com_Error(1, "\x15Unknown projectile explosion \"%s\" in \"%s\"\n",
                  (char)a2);
        goto LABEL_24;
      }
    }
    if (v11 < 0) {
      v13 = v11;
      goto LABEL_23;
    }
    v13 = v11;
  LABEL_24:
    *((_DWORD *)a1 + 228) = v13;
    return 1;
  case 14:
    v8 = 0;
    v9 = (const char **)&offhandClassNames;
    while (stricmp(a2, *v9)) {
      ++v8;
      ++v9;
      if (v8 == 3) {
        v10 = -1;
      LABEL_17:
        Com_Error(1, "\x15Unknown offhand class \"%s\" in \"%s\"\n", (char)a2);
        goto LABEL_18;
      }
    }
    if (v8 < 0) {
      v10 = v8;
      goto LABEL_17;
    }
    v10 = v8;
  LABEL_18:
    *((_DWORD *)a1 + 33) = v10;
    return 1;
  case 15:
    v27 = g_playerAnimTypeNamesCount;
    if (g_playerAnimTypeNamesCount <= 0)
      goto LABEL_10;
    v7 = 0;
    v26 = (const char **)&g_playerAnimTypeNames;
    break;
  default:
    Com_Error(1, "\x15Bad field type %i in %s\n", a3);
    return 0;
  }
  while (stricmp(a2, *v26)) {
    ++v7;
    ++v26;
    if (v27 == v7) {
    LABEL_10:
      v7 = -1;
    LABEL_11:
      Com_Error(1, "\x15Unknown playerAnimType \"%s\" in \"%s\"\n", (char)a2);
      goto LABEL_12;
    }
  }
  if (v7 < 0)
    goto LABEL_11;
LABEL_12:
  *((_DWORD *)a1 + 29) = v7;
  return 1;
}

unsigned __int8 *__cdecl SetConfigString2(unsigned __int8 *a1, char *__src) {
  unsigned __int8 *result; // eax
  char *v3;                // ebx

  if (*__src) {
    v3 = (char *)Hunk_AllocLowAlignInternal(strlen(__src) + 1, 1);
    strcpy(v3, __src);
    result = a1;
    *(_DWORD *)a1 = v3;
  } else {
    result = a1;
    *(_DWORD *)a1 = &inData;
  }
  return result;
}

WeaponDef *__cdecl BG_LoadWeaponDefInternal(const char *a1, char *__src) {
  int32_t *p_iFieldType;         // edx
  unsigned int v3;               // ebx
  char *v5;                      // ebx
  int iAdsTransInTime;           // eax
  int iAdsTransOutTime;          // eax
  float destabilizationAngleMax; // xmm0_4
  WeaponDef *v9;                 // [esp+2Ch] [ebp-207Ch]
  int v10;                       // [esp+3Ch] [ebp-206Ch]
  char __b[8192];                // [esp+4Ch] [ebp-205Ch] BYREF
  char __str[64];                // [esp+204Ch] [ebp-5Ch] BYREF
  int v13[7];                    // [esp+208Ch] [ebp-1Ch] BYREF

  v9 = (WeaponDef *)Hunk_AllocLowInternal(0x604u);
  *(_DWORD *)v9->szInternalName = &inData;
  p_iFieldType = &weaponDefFields.iFieldType;
  do {
    if (!*p_iFieldType)
      *(_DWORD *)&v9->szInternalName[*(p_iFieldType - 1)] = &inData;
    p_iFieldType += 3;
  } while (&unk_310C10 != (_UNKNOWN *)p_iFieldType);
  Com_sprintf(__str, 0x40u, "weapons/%s/%s", a1, __src);
  v10 = FS_FOpenFileByMode(__str, v13, FS_READ);
  if (v10 < 0) {
    Com_Printf("^3WARNING: Could not load weapon file '%s'\n", __str);
    return 0;
  }
  FS_Read(__b, 0xAu, v13[0]);
  __b[10] = 0;
  if (memcmp(__b, "WEAPONFILE", 10)) {
    Com_Printf("^3WARNING: \"%s\" does not appear to be a weapon file\n",
               __str);
    goto LABEL_17;
  }
  v3 = v10 - 10;
  if (v10 - 10 > 0x1FFF) {
    Com_Printf("^3WARNING: \"%s\" Is too long of a weapon file to parse\n",
               __str);
  LABEL_17:
    FS_FCloseFile(v13[0]);
    return 0;
  }
  memset(__b, 0, sizeof(__b));
  FS_Read(__b, v3, v13[0]);
  __b[v3] = 0;
  FS_FCloseFile(v13[0]);
  if (Info_Validate(__b)) {
    if (*__src) {
      v5 = (char *)Hunk_AllocLowAlignInternal(strlen(__src) + 1, 1);
      strcpy(v5, __src);
      *(_DWORD *)v9->szInternalName = v5;
    } else {
      *(_DWORD *)v9->szInternalName = &inData;
    }
    if (!ParseConfigStringToStruct(
            (unsigned __int8 *)v9, &weaponDefFields, 366, __b, 16,
            (int (*)(unsigned __int8 *, const char *,
                     int))BG_ParseWeaponDefSpecificFieldType,
            (void (*)(unsigned __int8 *, const char *))SetConfigString2))
      return 0;
    iAdsTransInTime = v9->iAdsTransInTime;
    if (iAdsTransInTime <= 0)
      LODWORD(v9->fOOPosAnimLength) = 995783694;
    else
      *(float *)&v9->fOOPosAnimLength = 1.0 / (float)iAdsTransInTime;
    iAdsTransOutTime = v9->iAdsTransOutTime;
    if (iAdsTransOutTime <= 0)
      HIDWORD(v9->fOOPosAnimLength) = 990057071;
    else
      *((float *)&v9->fOOPosAnimLength + 1) = 1.0 / (float)iAdsTransOutTime;
    if (*(float *)&v9->fMaxDamageRange <= 0.0)
      v9->fMaxDamageRange = 1232348144;
    if (*(float *)&v9->fMinDamageRange <= 0.0)
      v9->fMinDamageRange = 1232348146;
    if (*(float *)&v9->enemyCrosshairRange > 15000.0)
      Com_Error(1, "Enemy crosshair ranges should be less than %f ", 0);
    if (v9->weapType == 2) {
      if ((float)SLODWORD(v9->iProjectileSpeed) <= 0.0)
        Com_Error(1,
                  "Projectile speed for WeapType %s must be greater than 0.0",
                  *(_DWORD *)v9->szDisplayName);
      destabilizationAngleMax = v9->destabilizationAngleMax;
      if (destabilizationAngleMax >= 45.0 || destabilizationAngleMax < 0.0)
        Com_Error(1,
                  "Destabilization angle for for WeapType %s must be between 0 "
                  "and 45 degrees",
                  *(_DWORD *)v9->szDisplayName);
      if (*(float *)&v9->destabilizationBaseTime <= 0.0)
        Com_Error(
            1, "Destabilization base time for for WeapType %s must be positive",
            *(_DWORD *)v9->szDisplayName);
      if (*(float *)&v9->destabilizationTimeReductionRatio <= 0.0)
        Com_Error(1,
                  "Destabilization reduction ratio for for WeapType %s must be "
                  "positive",
                  *(_DWORD *)v9->szDisplayName);
    }
    if (!(unsigned __int8)G_ParseWeaponAccurayGraphs(v9))
      return 0;
    I_strlwr(*(char **)v9->szAmmoName);
    I_strlwr(*(char **)v9->szClipName);
    return v9;
  }
  Com_Printf("^3WARNING: \"%s\" is not a valid weapon file\n", __str);
  return 0;
}

void *__cdecl CM_Hunk_AllocXModel(size_t __len) {
  return Hunk_AllocInternal(__len);
}

void *__cdecl CM_Hunk_AllocXModelColl(size_t __len) {
  return Hunk_AllocInternal(__len);
}

void SourceError(source_s *a1, char *__format, ...) {
  char __str[1024]; // [esp+1Ch] [ebp-40Ch] BYREF
  va_list v3;       // [esp+41Ch] [ebp-Ch]
  va_list va;       // [esp+438h] [ebp+10h] BYREF

  va_start(va, __format);
  va_copy(v3, va);
  vsnprintf(__str, 0x400u, __format, va);
  Com_Printf("^1Error: file %s, line %d: %s\n", *(const char **)a1->scriptstack,
             *(_DWORD *)(*(_DWORD *)a1->scriptstack + 92), __str);
}

void SourceWarning(source_s *a1, char *__format, ...) {
  char __str[1024]; // [esp+1Ch] [ebp-40Ch] BYREF
  va_list v3;       // [esp+41Ch] [ebp-Ch]
  va_list va;       // [esp+438h] [ebp+10h] BYREF

  va_start(va, __format);
  va_copy(v3, va);
  vsnprintf(__str, 0x400u, __format, va);
  Com_Printf("^3Warning: file %s, line %d: %s\n",
             *(const char **)a1->scriptstack,
             *(_DWORD *)(*(_DWORD *)a1->scriptstack + 92), __str);
}

int __cdecl PC_StringizeTokens(token_s *__s2, token_s *__s1) {
  token_s *v2; // ebx

  __s1->type = 1;
  __s1->whitespace_p = 0;
  __s1->endwhitespace_p = 0;
  __s1->string[0] = 0;
  *(_WORD *)&__s1->string[strlen(__s1->string)] = 34;
  if (__s2) {
    v2 = __s2;
    do {
      strncat(__s1->string, v2->string, 1024 - strlen(__s1->string));
      v2 = (token_s *)v2->next;
    } while (v2);
  }
  strncat(__s1->string, "\"", 1025 - (strlen(__s1->string) + 1));
  return 1;
}

int __cdecl PC_OperatorPriority(int a1) {
  int result; // eax

  switch (a1) {
  case 5:
    result = 7;
    break;
  case 6:
    result = 6;
    break;
  case 7:
  case 8:
  case 37:
  case 38:
    result = 12;
    break;
  case 9:
  case 10:
    result = 11;
    break;
  case 21:
  case 22:
    result = 13;
    break;
  case 26:
  case 27:
  case 28:
    result = 15;
    break;
  case 29:
  case 30:
    result = 14;
    break;
  case 32:
    result = 10;
    break;
  case 33:
    result = 8;
    break;
  case 34:
    result = 9;
    break;
  case 35:
  case 36:
    result = 16;
    break;
  case 42:
  case 43:
    result = 5;
    break;
  default:
    result = 0;
    break;
  }
  return result;
}

int __cdecl PC_Directive_line(source_s *a1) {
  SourceError(a1, "#line directive not supported");
  return 0;
}

int __cdecl PC_SourceFileAndLine(int a1, char *__dst, int *a3) {
  int v3; // eax
  int v4; // ebx

  if ((unsigned int)(a1 - 1) > 0x3E)
    return 0;
  v3 = (int)*(&sourceFiles + a1);
  if (!v3)
    return 0;
  v4 = *(_DWORD *)(v3 + 132);
  if (v4) {
    strcpy(__dst, *(const char **)(v3 + 132));
    *a3 = *(_DWORD *)(v4 + 92);
  } else {
    strcpy(__dst, (*(&sourceFiles + a1))->filename);
    *a3 = 0;
  }
  return 1;
}

int __cdecl PC_ReadSourceToken(source_s *a1, token_s *__dst) {
  const void *tokens;  // eax
  _DWORD *v3;          // edx
  int result;          // eax
  int v5;              // edx
  _DWORD *indentstack; // edx

  tokens = (const void *)a1->tokens;
  if (tokens) {
  LABEL_2:
    memcpy(__dst, tokens, 0x440u);
    v3 = (_DWORD *)a1->tokens;
    a1->tokens = v3[268];
    FreeMemory(v3);
    --numtokens;
  } else {
    while (!PS_ReadToken(*(script_s **)a1->scriptstack, __dst)) {
      if (EndOfScript(*(script_s **)a1->scriptstack)) {
        indentstack = (_DWORD *)a1->indentstack;
        while (indentstack) {
          if (indentstack[2] != *(_DWORD *)a1->scriptstack)
            break;
          SourceWarning(a1, "missing #endif");
          indentstack = (_DWORD *)a1->indentstack;
          if (!indentstack)
            break;
          if (indentstack[2] == *(_DWORD *)a1->scriptstack) {
            a1->indentstack = indentstack[3];
            a1->skip -= indentstack[1];
            FreeMemory(indentstack);
            indentstack = (_DWORD *)a1->indentstack;
          }
        }
      }
      v5 = *(_DWORD *)a1->scriptstack;
      result = *(_DWORD *)(v5 + 1216);
      if (!result)
        return result;
      *(_DWORD *)a1->scriptstack = result;
      FreeScript((script_s *)v5);
      tokens = (const void *)a1->tokens;
      if (tokens)
        goto LABEL_2;
    }
  }
  return 1;
}

int __cdecl PC_Directive_error(source_s *a1) {
  token_s __dst; // [esp+10h] [ebp-448h] BYREF

  __dst.string[0] = 0;
  PC_ReadSourceToken(a1, &__dst);
  SourceError(a1, "#error directive: %s", __dst.string);
  return 0;
}

int __cdecl PC_Directive_else(source_s *a1) {
  int *indentstack; // edx
  int v3;           // esi
  int v4;           // edi
  _DWORD *Memory;   // eax
  int v6;           // edx

  indentstack = (int *)a1->indentstack;
  if (indentstack && indentstack[2] == *(_DWORD *)a1->scriptstack &&
      (v3 = *indentstack, v4 = indentstack[1], a1->indentstack = indentstack[3],
       a1->skip -= indentstack[1], FreeMemory(indentstack), v3)) {
    if (v3 == 2) {
      SourceError(a1, "#else after #else");
      return 0;
    } else {
      Memory = GetMemory(0x10u);
      *Memory = 2;
      Memory[2] = *(_DWORD *)a1->scriptstack;
      v6 = v4 == 0;
      Memory[1] = v6;
      a1->skip += v6;
      Memory[3] = a1->indentstack;
      a1->indentstack = (int32_t)Memory;
      return 1;
    }
  } else {
    SourceError(a1, "misplaced #else");
    return 0;
  }
}

int __cdecl PC_Directive_endif(source_s *a1) {
  int *indentstack; // edx
  int v3;           // ebx

  indentstack = (int *)a1->indentstack;
  if (indentstack) {
    if (indentstack[2] == *(_DWORD *)a1->scriptstack) {
      v3 = *indentstack;
      a1->indentstack = indentstack[3];
      a1->skip -= indentstack[1];
      FreeMemory(indentstack);
      if (v3)
        return 1;
    }
  }
  SourceError(a1, "misplaced #endif");
  return 0;
}

int __cdecl PC_EvaluateTokens(source_s *a1, token_s *a2, int *a3, double *a4,
                              int a5) {
  token_s *v5;     // ebx
  int v6;          // ecx
  int v7;          // edx
  int32_t type;    // eax
  int v9;          // edx
  int32_t *v10;    // eax
  _QWORD *v11;     // eax
  char v13;        // al
  int v14;         // ecx
  int v15;         // edx
  int v16;         // eax
  int v17;         // esi
  double v18;      // xmm2_8
  _QWORD *v19;     // ebx
  int32_t *i;      // esi
  int32_t v21;     // edx
  int32_t v22;     // eax
  int v23;         // edi
  int32_t v24;     // edx
  int32_t subtype; // eax
  _QWORD *v26;     // edx
  int v27;         // edx
  int32_t *v28;    // edx
  _BOOL4 v29;      // eax
  double v30;      // xmm0_8
  int v31;         // eax
  int32_t v32;     // edx
  int32_t v33;     // eax
  int v34;         // eax
  _BOOL4 v35;      // eax
  bool v36;        // zf
  _DWORD *v37;     // [esp+14h] [ebp-B64h]
  int32_t *v38;    // [esp+30h] [ebp-B48h]
  int32_t *v39;    // [esp+34h] [ebp-B44h]
  _QWORD *v40;     // [esp+38h] [ebp-B40h]
  _QWORD *v41;     // [esp+3Ch] [ebp-B3Ch]
  int v42;         // [esp+40h] [ebp-B38h]
  int32_t v43;     // [esp+44h] [ebp-B34h]
  int v44;         // [esp+48h] [ebp-B30h]
  int v45;         // [esp+4Ch] [ebp-B2Ch]
  int v46;         // [esp+50h] [ebp-B28h]
  int v47;         // [esp+54h] [ebp-B24h]
  _QWORD v48[355]; // [esp+60h] [ebp-B18h] BYREF

  if (a3)
    *a3 = 0;
  if (a4)
    *a4 = 0.0;
  if (!a2) {
    v38 = 0;
    v40 = 0;
    goto LABEL_92;
  }
  v5 = a2;
  v6 = 0;
  v46 = 0;
  v47 = 0;
  v39 = 0;
  v41 = 0;
  v43 = 0;
  v7 = 0;
  v38 = 0;
  v40 = 0;
  do {
    type = v5->type;
    switch (type) {
    case 4:
      if (v7 || v6)
        goto LABEL_195;
      if (strcmp(v5->string, "defined")) {
        SourceError(a1, "undefined name %s in #if/#elif", v5->string);
        goto LABEL_11;
      }
      v5 = (token_s *)v5->next;
      if (!strcmp(v5->string, "(")) {
        v5 = (token_s *)v5->next;
        v42 = 1;
      } else {
        v42 = 0;
      }
      if (!v5 || v5->type != 4) {
        SourceError(a1, "defined without name in #if/#elif");
        goto LABEL_11;
      }
      if (v47 > 63)
        goto LABEL_191;
      v37 = &v48[3 * v47++];
      v13 = v5->string[0];
      if (v5->string[0]) {
        v14 = 0;
        v27 = 119;
        do {
          v14 += v27 * v13;
          v13 = v5->string[v27++ - 118];
        } while (v13);
        v15 = v14 >> 10;
        v16 = v14 >> 20;
      } else {
        LOWORD(v14) = 0;
        LOWORD(v15) = 0;
        LOWORD(v16) = 0;
      }
      v17 = *(_DWORD *)(a1->definehash + 4 * (((unsigned __int16)v16 ^
                                               (unsigned __int16)(v15 ^ v14)) &
                                              0x3FF));
      if (v17) {
        while (strcmp(*(const char **)v17, v5->string)) {
          v17 = *(_DWORD *)(v17 + 28);
          if (!v17)
            goto LABEL_42;
        }
        *v37 = 1;
        v37[1] = 0;
        v37[2] = 1072693248;
      } else {
      LABEL_42:
        *v37 = 0;
        v37[1] = 0;
        v37[2] = 0;
      }
      v37[3] = v43;
      v37[5] = 0;
      v37[4] = v41;
      if (v41)
        *((_DWORD *)v41 + 5) = v37;
      else
        v40 = v37;
      if (v42) {
        v5 = (token_s *)v5->next;
        if (!v5 || strcmp(v5->string, ")")) {
          SourceError(a1, "defined without ) in #if/#elif");
          goto LABEL_11;
        }
      }
      v41 = v37;
      v7 = 1;
      v6 = 0;
      break;
    case 5:
      if (v6) {
        SourceError(a1, "misplaced minus sign in #if/#elif");
        goto LABEL_11;
      }
      subtype = v5->subtype;
      if (subtype == 44) {
        ++v43;
      } else if (subtype == 45) {
        if (--v43 < 0) {
          SourceError(a1, "too many ) in #if/#elsif");
          goto LABEL_11;
        }
      } else {
        if (!a5 &&
            (subtype == 35 || subtype == 28 || subtype == 21 || subtype == 22 ||
             subtype == 32 || subtype == 33 || subtype == 34)) {
          SourceError(a1, "illigal operator %s on floating point operands\n",
                      v5->string);
          goto LABEL_11;
        }
        switch (subtype) {
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 21:
        case 22:
        case 26:
        case 27:
        case 28:
        case 29:
        case 32:
        case 33:
        case 34:
        case 37:
        case 38:
        case 42:
        case 43:
          if (v7)
            goto LABEL_97;
          SourceError(a1, "operator %s after operator in #if/#elif",
                      v5->string);
          goto LABEL_11;
        case 16:
        case 17:
          SourceError(a1, "++ or -- used in #if/#elif");
          goto LABEL_97;
        case 30:
          if (v7)
            goto LABEL_97;
          v6 = 1;
          goto LABEL_49;
        case 35:
        case 36:
          if (v7) {
            SourceError(a1, "! or ~ after value in #if/#elif");
            goto LABEL_11;
          }
        LABEL_97:
          if (v46 > 63) {
            SourceError(a1, "out of operator space\n");
            goto LABEL_11;
          }
          v28 = (int32_t *)&v48[192] + 5 * v46++;
          *v28 = v5->subtype;
          switch (v5->subtype) {
          case 5:
            v34 = 7;
            break;
          case 6:
            v34 = 6;
            break;
          case 7:
          case 8:
          case 0x25:
          case 0x26:
            v34 = 12;
            break;
          case 9:
          case 0xA:
            v34 = 11;
            break;
          case 0x15:
          case 0x16:
            v34 = 13;
            break;
          case 0x1A:
          case 0x1B:
          case 0x1C:
            v34 = 15;
            break;
          case 0x1D:
          case 0x1E:
            v34 = 14;
            break;
          case 0x20:
            v34 = 10;
            break;
          case 0x21:
            v34 = 8;
            break;
          case 0x22:
            v34 = 9;
            break;
          case 0x23:
          case 0x24:
            v34 = 16;
            break;
          case 0x2A:
          case 0x2B:
            v34 = 5;
            break;
          default:
            v34 = 0;
            break;
          }
          v28[1] = v34;
          v28[2] = v43;
          v28[4] = 0;
          v28[3] = (int32_t)v39;
          if (v39) {
            v39[4] = (int32_t)v28;
            v39 = v28;
          } else {
            v39 = v28;
            v38 = v28;
          }
          v7 = 0;
          v6 = 0;
          break;
        default:
          SourceError(a1, "invalid operator %s in #if/#elif", v5->string);
          goto LABEL_11;
        }
      }
      break;
    case 3:
      if (v7) {
      LABEL_195:
        SourceError(a1, "syntax error in #if/#elif");
        goto LABEL_11;
      }
      if (v47 > 63) {
      LABEL_191:
        SourceError(a1, "out of value space\n");
        goto LABEL_11;
      }
      v26 = &v48[3 * v47++];
      if (v6) {
        *(_DWORD *)v26 = -v5->intvalue;
        *(double *)((char *)v26 + 4) = -(double)*(long double *)v5->floatvalue;
      } else {
        *(_DWORD *)v26 = v5->intvalue;
        *(double *)((char *)v26 + 4) = *(long double *)v5->floatvalue;
      }
      *((_DWORD *)v26 + 3) = v43;
      *((_DWORD *)v26 + 5) = 0;
      v6 = (int)v41;
      *((_DWORD *)v26 + 4) = v41;
      if (v41) {
        *((_DWORD *)v41 + 5) = v26;
        v41 = v26;
        v7 = 1;
        v6 = 0;
      } else {
        v40 = v26;
        v41 = v26;
        v7 = 1;
      }
      break;
    default:
      SourceError(a1, "unknown %s in #if/#elif", v5->string);
      goto LABEL_11;
    }
  LABEL_49:
    v5 = (token_s *)v5->next;
  } while (v5);
  if (!v7) {
  LABEL_92:
    SourceError(a1, "trailing operator in #if/#elif");
    goto LABEL_11;
  }
  if (v43) {
    SourceError(a1, "too many ( in #if/#elif");
  LABEL_11:
    v9 = 1;
    goto LABEL_12;
  }
  if (!v38) {
  LABEL_124:
    v9 = 0;
    goto LABEL_12;
  }
  v44 = 0;
  v18 = 0.0;
  v45 = 0;
  while (2) {
    v19 = v40;
    for (i = v38;; i = (int32_t *)i[4]) {
      v21 = i[4];
      if (!v21)
        break;
      v22 = *(_DWORD *)(v21 + 8);
      if (i[2] > v22 || i[2] == v22 && i[1] >= *(_DWORD *)(v21 + 4))
        break;
      if ((unsigned int)(*i - 35) > 1)
        v19 = (_QWORD *)*((_DWORD *)v19 + 5);
      if (!v19) {
        SourceError(a1, "mising values in #if/#elif");
        goto LABEL_11;
      }
    }
    v23 = *((_DWORD *)v19 + 5);
    v24 = *i;
    switch (*i) {
    case 5:
      v35 = *(_DWORD *)v19 && *(_DWORD *)v23;
      *(_DWORD *)v19 = v35;
      if (*(double *)((char *)v19 + 4) == 0.0)
        goto LABEL_110;
      v36 = *(double *)(v23 + 4) == 0.0;
      goto LABEL_161;
    case 6:
      v29 = *(_DWORD *)v19 || *(_DWORD *)v23;
      *(_DWORD *)v19 = v29;
      if (*(double *)((char *)v19 + 4) == 0.0 && *(double *)(v23 + 4) == 0.0)
        goto LABEL_110;
      goto LABEL_144;
    case 7:
      *(_DWORD *)v19 = *(_DWORD *)v19 >= *(_DWORD *)v23;
      if (*(double *)((char *)v19 + 4) >= *(double *)(v23 + 4))
        goto LABEL_144;
      goto LABEL_110;
    case 8:
      *(_DWORD *)v19 = *(_DWORD *)v19 <= *(_DWORD *)v23;
      if (*(double *)(v23 + 4) < *(double *)((char *)v19 + 4))
        goto LABEL_110;
      goto LABEL_144;
    case 9:
      *(_DWORD *)v19 = *(_DWORD *)v19 == *(_DWORD *)v23;
      if (*(double *)((char *)v19 + 4) == *(double *)(v23 + 4))
        goto LABEL_144;
      goto LABEL_110;
    case 10:
      *(_DWORD *)v19 = *(_DWORD *)v19 != *(_DWORD *)v23;
      v36 = *(double *)((char *)v19 + 4) == *(double *)(v23 + 4);
    LABEL_161:
      if (v36)
        goto LABEL_110;
      goto LABEL_144;
    case 21:
      *(int *)v19 >>= *(_DWORD *)v23;
      v24 = *i;
      goto LABEL_112;
    case 22:
      *(_DWORD *)v19 <<= *(_DWORD *)v23;
      v24 = *i;
      goto LABEL_112;
    case 26:
      *(_DWORD *)v19 *= *(_DWORD *)v23;
      v30 = *(double *)((char *)v19 + 4) * *(double *)(v23 + 4);
      goto LABEL_111;
    case 27:
      if (!*(_DWORD *)v23 || *(double *)(v23 + 4) == 0.0)
        goto LABEL_201;
      *(int *)v19 /= *(int *)v23;
      v30 = *(double *)((char *)v19 + 4) / *(double *)(v23 + 4);
      goto LABEL_111;
    case 28:
      if (!*(_DWORD *)v23) {
      LABEL_201:
        SourceError(a1, "divide by zero in #if/#elif\n");
        v9 = 1;
        goto LABEL_12;
      }
      *(int *)v19 %= *(_DWORD *)v23;
      v24 = *i;
      goto LABEL_112;
    case 29:
      *(_DWORD *)v19 += *(_DWORD *)v23;
      *(double *)((char *)v19 + 4) =
          *(double *)((char *)v19 + 4) + *(double *)(v23 + 4);
      v24 = *i;
      goto LABEL_112;
    case 30:
      *(_DWORD *)v19 -= *(_DWORD *)v23;
      *(double *)((char *)v19 + 4) =
          *(double *)((char *)v19 + 4) - *(double *)(v23 + 4);
      v24 = *i;
      goto LABEL_112;
    case 32:
      *(_DWORD *)v19 &= *(_DWORD *)v23;
      v24 = *i;
      goto LABEL_112;
    case 33:
      *(_DWORD *)v19 |= *(_DWORD *)v23;
      v24 = *i;
      goto LABEL_112;
    case 34:
      *(_DWORD *)v19 ^= *(_DWORD *)v23;
      v24 = *i;
      goto LABEL_112;
    case 35:
      *(_DWORD *)v19 = ~*(_DWORD *)v19;
      v24 = *i;
      goto LABEL_112;
    case 36:
      *(_DWORD *)v19 = *(_DWORD *)v19 == 0;
      if (*(double *)((char *)v19 + 4) == 0.0)
        goto LABEL_144;
      goto LABEL_110;
    case 37:
      *(_DWORD *)v19 = *(_DWORD *)v19 > *(_DWORD *)v23;
      if (*(double *)((char *)v19 + 4) <= *(double *)(v23 + 4))
        goto LABEL_110;
      goto LABEL_144;
    case 38:
      *(_DWORD *)v19 = *(_DWORD *)v19 < *(_DWORD *)v23;
      if (*(double *)(v23 + 4) <= *(double *)((char *)v19 + 4))
      LABEL_110:
        v30 = 0.0;
      else
      LABEL_144:
        v30 = 1.0;
    LABEL_111:
      *(double *)((char *)v19 + 4) = v30;
      v24 = *i;
      goto LABEL_112;
    case 42:
      if (v45) {
        if (!a5) {
          if (v18 == 0.0) {
            *(_QWORD *)((char *)v19 + 4) = *(_QWORD *)(v23 + 4);
            v45 = 0;
            v24 = *i;
            goto LABEL_112;
          }
        LABEL_202:
          v45 = 0;
          goto LABEL_112;
        }
        if (v44)
          goto LABEL_202;
        *(_DWORD *)v19 = *(_DWORD *)v23;
        v45 = 0;
        v24 = *i;
      LABEL_112:
        if ((unsigned int)(v24 - 35) > 1) {
          if (v24 != 43) {
            v19 = (_QWORD *)v23;
            v23 = *(_DWORD *)(v23 + 20);
          }
          v31 = *((_DWORD *)v19 + 4);
          if (v31) {
            *(_DWORD *)(v31 + 20) = v23;
            v23 = *((_DWORD *)v19 + 5);
          } else {
            v40 = (_QWORD *)v23;
          }
          if (v23)
            *(_DWORD *)(v23 + 16) = v31;
        }
        v32 = i[3];
        if (v32)
          *(_DWORD *)(v32 + 16) = i[4];
        else
          v38 = (int32_t *)i[4];
        v33 = i[4];
        if (v33)
          *(_DWORD *)(v33 + 12) = v32;
        if (!v38)
          goto LABEL_124;
        continue;
      }
      SourceError(a1, ": without ? in #if/#elif");
      v9 = 1;
    LABEL_12:
      if (v40) {
        if (a3)
          *a3 = *(_DWORD *)v40;
        if (a4)
          *a4 = *(double *)((char *)v40 + 4);
      }
      if (v38) {
        v10 = v38;
        do
          v10 = (int32_t *)v10[4];
        while (v10);
      }
      if (v40) {
        v11 = v40;
        do
          v11 = (_QWORD *)*((_DWORD *)v11 + 5);
        while (v11);
      }
      if (!v9)
        return 1;
      if (a3)
        *a3 = 0;
      if (a4)
        *a4 = 0.0;
      return 0;
    case 43:
      if (v45) {
        SourceError(a1, "? after ? in #if/#elif");
        goto LABEL_11;
      }
      v44 = *(_DWORD *)v19;
      v18 = *(double *)((char *)v19 + 4);
      v45 = 1;
      goto LABEL_112;
    default:
      goto LABEL_112;
    }
  }
}

void __cdecl FreeSource(source_s *a1) {
  int i;               // edx
  _DWORD *j;           // edx
  int v3;              // edi
  _DWORD *definehash;  // eax
  _DWORD *v5;          // edx
  _DWORD *k;           // esi
  _DWORD *v7;          // eax
  _DWORD *v8;          // ebx
  _DWORD *v9;          // eax
  _DWORD *v10;         // ebx
  _DWORD *indentstack; // edx

  for (i = *(_DWORD *)a1->scriptstack; i; i = *(_DWORD *)a1->scriptstack) {
    *(_DWORD *)a1->scriptstack = *(_DWORD *)(i + 1216);
    FreeScript((script_s *)i);
  }
  for (j = (_DWORD *)a1->tokens; j; j = (_DWORD *)a1->tokens) {
    a1->tokens = j[268];
    FreeMemory(j);
    --numtokens;
  }
  v3 = 0;
  definehash = (_DWORD *)a1->definehash;
  do {
    v5 = &definehash[v3];
    for (k = (_DWORD *)definehash[v3]; k; k = (_DWORD *)definehash[v3]) {
      *v5 = k[7];
      v7 = (_DWORD *)k[4];
      if (v7) {
        while (1) {
          v8 = (_DWORD *)v7[268];
          FreeMemory(v7);
          --numtokens;
          if (!v8)
            break;
          v7 = v8;
        }
      }
      v9 = (_DWORD *)k[5];
      if (v9) {
        while (1) {
          v10 = (_DWORD *)v9[268];
          FreeMemory(v9);
          --numtokens;
          if (!v10)
            break;
          v9 = v10;
        }
      }
      FreeMemory(k);
      definehash = (_DWORD *)a1->definehash;
      v5 = &definehash[v3];
    }
    ++v3;
  } while (v3 != 1024);
  indentstack = (_DWORD *)a1->indentstack;
  if (indentstack) {
    do {
      a1->indentstack = indentstack[3];
      FreeMemory(indentstack);
      indentstack = (_DWORD *)a1->indentstack;
    } while (indentstack);
    definehash = (_DWORD *)a1->definehash;
  }
  if (definehash)
    FreeMemory(definehash);
  FreeMemory(a1);
}

int __cdecl PC_FreeSourceHandle(int a1) {
  if ((unsigned int)(a1 - 1) > 0x3E || !*(&sourceFiles + a1))
    return 0;
  FreeSource(*(&sourceFiles + a1));
  *(&sourceFiles + a1) = 0;
  return 1;
}

void *__cdecl PS_CreatePunctuationTable(script_s *a1, punctuation_s *a2) {
  void *result;      // eax
  const char *p;     // esi
  int32_t v4;        // edx
  unsigned int v5;   // kr04_4
  int32_t v6;        // esi
  punctuation_s *v7; // [esp+28h] [ebp-20h]
  const char **v8;   // [esp+2Ch] [ebp-1Ch]

  if (!a1->punctuationtable)
    a1->punctuationtable = (int32_t)GetMemory(0x400u);
  result = memset((void *)a1->punctuationtable, 0, 0x400u);
  p = (const char *)a2->p;
  if (a2->p) {
    v7 = a2 + 1;
    v8 = (const char **)&a2[1];
    do {
      v4 = *(_DWORD *)(a1->punctuationtable + 4 * *p);
      if (v4) {
        v5 = strlen(p) + 1;
        v6 = 0;
        while (1) {
          if (strlen(*(const char **)v4) < v5 - 1) {
            a2->next = v4;
            if (v6)
              *(_DWORD *)(v6 + 8) = a2;
            else
              *(_DWORD *)(a1->punctuationtable + 4 * *(char *)a2->p) = a2;
            goto LABEL_12;
          }
          if (!*(_DWORD *)(v4 + 8))
            break;
          v6 = v4;
          v4 = *(_DWORD *)(v4 + 8);
        }
        a2->next = 0;
        if (!v4)
          goto LABEL_15;
        *(_DWORD *)(v4 + 8) = a2;
      } else {
        a2->next = 0;
      LABEL_15:
        *(_DWORD *)(a1->punctuationtable + 4 * *(char *)a2->p) = a2;
      }
    LABEL_12:
      a2 = v7;
      p = *v8;
      ++v7;
      result = v8 + 3;
      v8 += 3;
    } while (p);
  }
  return result;
}

void ScriptError(script_s *a1, char *__format, ...) {
  char __str[1024]; // [esp+1Ch] [ebp-40Ch] BYREF
  va_list v3;       // [esp+41Ch] [ebp-Ch]
  va_list va;       // [esp+438h] [ebp+10h] BYREF

  va_start(va, __format);
  if ((a1->flags & 1) == 0) {
    va_copy(v3, va);
    vsnprintf(__str, 0x400u, __format, va);
    Com_Printf("^1Error: file %s, line %d: %s\n", a1->filename, a1->line,
               __str);
  }
}

void ScriptWarning(script_s *a1, char *__format, ...) {
  char __str[1024]; // [esp+1Ch] [ebp-40Ch] BYREF
  va_list v3;       // [esp+41Ch] [ebp-Ch]
  va_list va;       // [esp+438h] [ebp+10h] BYREF

  va_start(va, __format);
  if ((a1->flags & 2) == 0) {
    va_copy(v3, va);
    vsnprintf(__str, 0x400u, __format, va);
    Com_Printf("^3Warning: file %s, line %d: %s\n", a1->filename, a1->line,
               __str);
  }
}

int __cdecl PS_ReadEscapeCharacter(script_s *a1, char *a2) {
  int v2;          // ebx
  char *v3;        // edx
  char v4;         // cl
  char *v5;        // ecx
  unsigned int v6; // edx
  int v7;          // ebx
  char v8;         // cl
  int v10;         // edi
  char *v11;       // ebx
  int v12;         // edx
  int v13;         // ecx

  v2 = *(_DWORD *)a1->script_p;
  v3 = (char *)(v2 + 1);
  *(_DWORD *)a1->script_p = v2 + 1;
  v4 = *(_BYTE *)(v2 + 1);
  switch (v4) {
  case '"':
    v8 = 34;
    goto LABEL_8;
  case '\'':
    v8 = 39;
    goto LABEL_8;
  case '?':
    v8 = 63;
    goto LABEL_8;
  case '\\':
    v8 = 92;
    goto LABEL_8;
  case 'a':
    v8 = 7;
    goto LABEL_8;
  case 'b':
    v8 = 8;
    goto LABEL_8;
  case 'f':
    v8 = 12;
    goto LABEL_8;
  case 'n':
    v8 = 10;
    goto LABEL_8;
  case 'r':
    v8 = 13;
    goto LABEL_8;
  case 't':
    v8 = 9;
    goto LABEL_8;
  case 'v':
    v8 = 11;
    goto LABEL_8;
  case 'x':
    *(_DWORD *)a1->script_p = v2 + 2;
    v10 = 0;
    v11 = (char *)(v2 + 2);
    while (2) {
      v13 = *v11;
      v12 = v13 - 48;
      if ((unsigned int)(v13 - 48) <= 9)
        goto LABEL_15;
      if ((unsigned int)(v13 - 65) <= 0x19) {
        v12 = v13 - 55;
      LABEL_15:
        v10 = v12 + 16 * v10;
        *(_DWORD *)a1->script_p = ++v11;
        continue;
      }
      break;
    }
    if ((unsigned int)(v13 - 97) <= 0x19) {
      v12 = v13 - 87;
      goto LABEL_15;
    }
    v3 = v11 - 1;
    *(_DWORD *)a1->script_p = v11 - 1;
    if (v10 > 255)
      goto LABEL_10;
    v8 = v10;
  LABEL_8:
    *(_DWORD *)a1->script_p = v3 + 1;
    *a2 = v8;
    return 1;
  default:
    if ((unsigned __int8)(v4 - 48) > 9u) {
      ScriptError(a1, "unknown escape char");
      v5 = *(char **)a1->script_p;
      v6 = *v5 - 48;
      if (v6 <= 9)
        goto LABEL_4;
    LABEL_9:
      LOBYTE(v7) = 0;
      v3 = v5 - 1;
      *(_DWORD *)a1->script_p = v5 - 1;
    LABEL_7:
      v8 = v7;
      goto LABEL_8;
    }
    v5 = (char *)(v2 + 1);
    v6 = *v3 - 48;
    if (v6 > 9)
      goto LABEL_9;
  LABEL_4:
    v7 = 0;
    do {
      v7 = v6 + 10 * v7;
      *(_DWORD *)a1->script_p = ++v5;
      v6 = *v5 - 48;
    } while (v6 <= 9);
    v3 = v5 - 1;
    *(_DWORD *)a1->script_p = v5 - 1;
    if (v7 <= 255)
      goto LABEL_7;
  LABEL_10:
    ScriptWarning(a1, "too large value in escape character");
    ++*(_DWORD *)a1->script_p;
    *a2 = -1;
    return 1;
  }
}

unsigned int __cdecl NumberValue(char *a1, unsigned int a2, unsigned int *a3,
                                 long double *a4) {
  char *v4;            // ecx
  unsigned int result; // eax
  int v6;              // ebx
  long double v7;      // fst7
  long double v8;      // fst7
  signed __int8 v9;    // dl
  int v10;             // eax
  char *i;             // ebx
  int v12;             // eax
  unsigned int v13;    // ecx
  char v14;            // dl
  char v15;            // dl
  char *v16;           // ecx
  int v17;             // eax
  char v18;            // dl
  char *v19;           // ecx
  int v20;             // eax

  v4 = a1;
  result = a2;
  *a3 = 0;
  *(_QWORD *)a4 = 0;
  *((_DWORD *)a4 + 2) = 0;
  if ((a2 & 0x800) == 0) {
    if ((a2 & 8) != 0) {
      v9 = *a1;
      if (*a1) {
        v10 = *a3;
        do {
          v10 = v9 + 10 * v10 - 48;
          *a3 = v10;
          v9 = *++v4;
        } while (v9);
      }
    } else if ((a2 & 0x100) != 0) {
      for (i = a1 + 2; *i; ++i) {
        v13 = 16 * *a3;
        *a3 = v13;
        v14 = *i;
        if ((unsigned __int8)(*i - 97) > 5u) {
          if ((unsigned __int8)(v14 - 65) > 5u)
            v12 = v13 + v14 - 48;
          else
            v12 = v13 + v14 - 55;
          *a3 = v12;
        } else {
          *a3 = v13 + v14 - 87;
        }
      }
    } else if ((a2 & 0x200) != 0) {
      v15 = a1[1];
      if (v15) {
        v16 = a1 + 1;
        v17 = *a3;
        do {
          v17 = v15 + 8 * v17 - 48;
          *a3 = v17;
          v15 = *++v16;
        } while (v15);
      }
    } else {
      if ((a2 & 0x400) == 0)
        return result;
      v18 = a1[2];
      if (v18) {
        v19 = a1 + 2;
        v20 = *a3;
        do {
          v20 = v18 + 2 * v20 - 48;
          *a3 = v20;
          v18 = *++v19;
        } while (v18);
      }
    }
    result = *a3;
    *a4 = (long double)*a3;
    return result;
  }
  result = (unsigned __int8)*a1;
  if ((_BYTE)result) {
    v6 = 0;
    while ((_BYTE)result != 46) {
      if (v6) {
        v8 = (long double)(unsigned int)v6;
        v6 *= 10;
      LABEL_9:
        v7 = (long double)(*v4 - 48) / v8 + *a4;
        *a4 = v7;
        goto LABEL_5;
      }
      v7 = *a4 * 10.0 + (long double)(*v4 - 48);
      *a4 = v7;
    LABEL_5:
      result = (unsigned __int8)*++v4;
      if (!(_BYTE)result)
        goto LABEL_25;
    }
    if (v6)
      return result;
    ++v4;
    v8 = 10.0;
    v6 = 100;
    goto LABEL_9;
  }
  v7 = *a4;
LABEL_25:
  result = (__int64)v7;
  *a3 = result;
  return result;
}

int __cdecl PS_ReadNumber(script_s *a1, token_s *a2) {
  _BYTE *v2;       // ecx
  _BYTE *v3;       // edx
  token_s *v4;     // ebx
  int v5;          // esi
  char v6;         // dl
  int32_t subtype; // edx
  int v8;          // ebx
  char *v9;        // ecx
  char v10;        // al
  int32_t v11;     // eax
  _BYTE *v13;      // esi
  char v14;        // al
  char v15;        // cl
  char v16;        // dl
  token_s *v17;    // ebx
  char *v18;       // edx
  _BYTE *v19;      // eax
  token_s *v20;    // ecx
  char *v21;       // edx
  _BOOL4 v22;      // [esp+18h] [ebp-20h]
  int v23;         // [esp+1Ch] [ebp-1Ch]

  a2->type = 3;
  v2 = *(_BYTE **)a1->script_p;
  v3 = v2;
  if (*v2 == 48) {
    v13 = v2 + 1;
    v14 = v2[1];
    if (v14 == 120 || v14 == 88) {
      a2->string[0] = 48;
      *(_DWORD *)a1->script_p = v13;
      a2->string[1] = v2[1];
      *(_DWORD *)a1->script_p = v2 + 2;
      v16 = v2[2];
      v17 = a2;
      v5 = 2;
      while (1) {
        if ((unsigned __int8)(v16 - 48) > 9u &&
            (unsigned __int8)(v16 - 97) > 5u && v16 != 65) {
          subtype = a2->subtype;
          BYTE1(subtype) |= 1u;
          a2->subtype = subtype;
          goto LABEL_13;
        }
        v18 = *(char **)a1->script_p;
        v17->string[2] = *v18;
        ++v5;
        *(_DWORD *)a1->script_p = v18 + 1;
        v17 = (token_s *)((char *)v17 + 1);
        if (v5 == 1024)
          break;
        v16 = v18[1];
      }
      ScriptError(a1, "hexadecimal number longer than MAX_TOKEN = %d", 1024);
      return 0;
    }
    if (v14 == 98 || v14 == 66) {
      a2->string[0] = 48;
      *(_DWORD *)a1->script_p = v13;
      a2->string[1] = v2[1];
      *(_DWORD *)a1->script_p = v2 + 2;
      v15 = v2[2];
      if ((unsigned __int8)(v15 - 48) <= 1u) {
        a2->string[2] = v15;
        v19 = v3 + 3;
        *(_DWORD *)a1->script_p = v3 + 3;
        v20 = a2;
        v5 = 3;
        while ((unsigned __int8)(*v19 - 48) <= 1u) {
          v21 = *(char **)a1->script_p;
          v20->string[3] = *v21;
          ++v5;
          v19 = v21 + 1;
          *(_DWORD *)a1->script_p = v21 + 1;
          v20 = (token_s *)((char *)v20 + 1);
          if (v5 == 1024) {
            ScriptError(a1, "binary number longer than MAX_TOKEN = %d", 1024);
            return 0;
          }
        }
      } else {
        v5 = 2;
      }
      subtype = a2->subtype;
      BYTE1(subtype) |= 4u;
      a2->subtype = subtype;
      goto LABEL_13;
    }
  }
  v22 = *v2 == 48;
  v4 = a2;
  v5 = 0;
  v23 = 0;
  while (1) {
    v6 = *v2;
    if (*v2 == 46) {
      v23 = 1;
      goto LABEL_5;
    }
    if ((unsigned __int8)(v6 - 56) <= 1u) {
      v22 = 0;
      goto LABEL_5;
    }
    if ((unsigned __int8)(v6 - 48) > 9u)
      break;
  LABEL_5:
    v4->string[0] = v6;
    ++v5;
    *(_DWORD *)a1->script_p = ++v2;
    v4 = (token_s *)((char *)v4 + 1);
    if (v5 == 1023) {
      ScriptError(a1, "number longer than MAX_TOKEN = %d", 1024);
      return 0;
    }
  }
  if (v22) {
    subtype = a2->subtype;
    BYTE1(subtype) |= 2u;
  } else {
    subtype = a2->subtype | 8;
  }
  a2->subtype = subtype;
  if (v23) {
    BYTE1(subtype) |= 8u;
    a2->subtype = subtype;
  }
LABEL_13:
  v8 = 2;
  do {
    v9 = *(char **)a1->script_p;
    v10 = *v9;
    if ((*v9 == 108 || v10 == 76) && (subtype & 0x2000) == 0) {
      *(_DWORD *)a1->script_p = v9 + 1;
      subtype = a2->subtype;
      BYTE1(subtype) |= 0x20u;
      a2->subtype = subtype;
    } else if ((v10 == 117 || v10 == 85) && (subtype & 0x4800) == 0) {
      *(_DWORD *)a1->script_p = v9 + 1;
      subtype = a2->subtype;
      BYTE1(subtype) |= 0x40u;
      a2->subtype = subtype;
    }
    --v8;
  } while (v8);
  a2->string[v5] = 0;
  NumberValue(a2->string, subtype, (unsigned int *)&a2->intvalue,
              (long double *)a2->floatvalue);
  v11 = a2->subtype;
  if ((v11 & 0x800) == 0) {
    BYTE1(v11) |= 0x10u;
    a2->subtype = v11;
  }
  return 1;
}

char *__cdecl StripDoubleQuotes(char *__dst) {
  unsigned int v1; // ecx
  char *result;    // eax

  if (*__dst == 34)
    strcpy(__dst, __dst + 1);
  v1 = strlen(__dst) + 1;
  result = &__dst[v1 - 1];
  if (__dst[v1 - 2] == 34)
    __dst[v1 - 2] = 0;
  return result;
}

_BOOL4 __cdecl EndOfScript(script_s *a1) {
  return *(_DWORD *)a1->script_p >= a1->end_p;
}

void __cdecl FreeScript(script_s *a1) {
  if (a1->punctuationtable)
    FreeMemory((_DWORD *)a1->punctuationtable);
  FreeMemory(a1);
}

script_s *__cdecl LoadScriptFile(char *__src) {
  unsigned int v1;         // esi
  script_s *ClearedMemory; // ebx
  void *buffer;            // eax
  char __str[64];          // [esp+1Ch] [ebp-5Ch] BYREF
  int v6[7];               // [esp+5Ch] [ebp-1Ch] BYREF

  Com_sprintf(__str, 0x40u, "%s", __src);
  v1 = FS_FOpenFileRead(__str, v6, 1);
  if (!v6[0])
    return 0;
  ClearedMemory = (script_s *)GetClearedMemory(v1 + 1233);
  strcpy(ClearedMemory->filename, __src);
  ClearedMemory->buffer = &ClearedMemory[8].filename[48];
  ClearedMemory[8].filename[v1 + 48] = 0;
  ClearedMemory->length = v1;
  buffer = ClearedMemory->buffer;
  *(_DWORD *)ClearedMemory->script_p = buffer;
  *(_DWORD *)ClearedMemory->lastscript_p = buffer;
  ClearedMemory->end_p = (int32_t)buffer + v1;
  ClearedMemory->tokenavailable = 0;
  ClearedMemory->line = 1;
  ClearedMemory->lastline = 1;
  PS_CreatePunctuationTable(ClearedMemory, &default_punctuations);
  ClearedMemory->punctuations = (int32_t)&default_punctuations;
  FS_Read((char *)ClearedMemory->buffer, v1, v6[0]);
  FS_FCloseFile(v6[0]);
  ClearedMemory->length = Com_Compress((char *)ClearedMemory->buffer);
  return ClearedMemory;
}

int __cdecl PS_ReadString(script_s *a1, token_s *a2, int a3) {
  char *v3;     // edx
  char *v4;     // edx
  char v5;      // cl
  int32_t v7;   // esi
  char v8;      // al
  char *v9;     // ecx
  char v10;     // al
  char *v11;    // ecx
  char *v12;    // edx
  char *v13;    // ebx
  char v14;     // al
  char *v15;    // edx
  char *v16;    // ecx
  char v17;     // al
  int v18;      // [esp+14h] [ebp-24h]
  int32_t line; // [esp+18h] [ebp-20h]
  char *v20;    // [esp+1Ch] [ebp-1Ch]

  if (a3 == 34)
    a2->type = 1;
  else
    a2->type = 2;
  v3 = *(char **)a1->script_p;
  a2->string[0] = *v3;
  *(_DWORD *)a1->script_p = v3 + 1;
  v18 = 1;
  while (1) {
    v4 = *(char **)a1->script_p;
    v5 = *v4;
    if (*v4 != 92 || (a1->flags & 8) != 0)
      break;
    if (!PS_ReadEscapeCharacter(a1, &a2->string[v18])) {
      a2->string[v18] = 0;
      return 0;
    }
    ++v18;
  LABEL_10:
    if (v18 > 1021) {
      ScriptError(a1, "string longer than MAX_TOKEN = %d", 1024);
      return 0;
    }
  }
  if (a3 != v5) {
    if (!v5) {
      a2->string[v18] = 0;
      ScriptError(a1, "missing trailing quote");
      return 0;
    }
    if (v5 == 10) {
      a2->string[v18] = 0;
      ScriptError(a1, "newline inside string %s", a2->string);
      return 0;
    }
    a2->string[v18++] = v5;
    goto LABEL_9;
  }
  v20 = ++v4;
  *(_DWORD *)a1->script_p = v4;
  if ((a1->flags & 4) != 0)
    goto LABEL_30;
  line = a1->line;
  v7 = line;
LABEL_17:
  while (1) {
    v8 = *v4;
    if (*v4 > 32)
      break;
    if (!v8)
      goto LABEL_29;
    if (v8 == 10)
      a1->line = ++v7;
    *(_DWORD *)a1->script_p = ++v4;
  }
  if (v8 == 47) {
    v9 = v4 + 1;
    v10 = v4[1];
    if (v10 == 47) {
      v15 = v4 + 1;
      *(_DWORD *)a1->script_p = v9;
      while (1) {
        v16 = v15++;
        *(_DWORD *)a1->script_p = v15;
        v17 = v16[1];
        if (!v17)
          goto LABEL_29;
        if (v17 == 10) {
          a1->line = ++v7;
          v4 = v16 + 2;
          *(_DWORD *)a1->script_p = v16 + 2;
          if (v16[2])
            goto LABEL_17;
          goto LABEL_29;
        }
      }
    }
    if (v10 == 42) {
      *(_DWORD *)a1->script_p = v9;
      v11 = v4 + 2;
      while (1) {
        v12 = v11;
        v13 = v11++;
        *(_DWORD *)a1->script_p = v12;
        v14 = *(v11 - 1);
        if (!v14)
          break;
        if (v14 == 10)
          a1->line = ++v7;
        if (*(v11 - 1) == 42 && v12[1] == 47) {
          *(_DWORD *)a1->script_p = v11;
          if (v13[1]) {
            v4 = v13 + 2;
            *(_DWORD *)a1->script_p = v13 + 2;
            if (v13[2])
              goto LABEL_17;
          }
          break;
        }
      }
    LABEL_29:
      *(_DWORD *)a1->script_p = v20;
      a1->line = line;
      goto LABEL_30;
    }
  }
  if (a3 == *v4) {
  LABEL_9:
    *(_DWORD *)a1->script_p = v4 + 1;
    goto LABEL_10;
  }
  *(_DWORD *)a1->script_p = v20;
  a1->line = line;
LABEL_30:
  a2->string[v18] = a3;
  a2->string[v18 + 1] = 0;
  a2->subtype = v18 + 1;
  return 1;
}

int __cdecl PS_ReadToken(script_s *a1, token_s *__dst) {
  int32_t v3;         // eax
  char *v4;           // ecx
  char v5;            // al
  _BYTE *v6;          // edx
  char v7;            // al
  _BYTE *v8;          // edx
  _BYTE *v9;          // ecx
  _BYTE *v10;         // edi
  char v11;           // al
  _BYTE *v12;         // ecx
  _BYTE *v13;         // edx
  char v14;           // al
  char v15;           // dl
  token_s *v16;       // ecx
  int v17;            // eax
  unsigned int v18;   // ecx
  unsigned int v19;   // edi
  token_s *v20;       // edi
  char *v21;          // edx
  char v22;           // dl
  int String;         // eax
  char *__s1;         // [esp+1Ch] [ebp-2Ch]
  int32_t v25;        // [esp+20h] [ebp-28h]
  unsigned int end_p; // [esp+24h] [ebp-24h]
  char *__s2;         // [esp+28h] [ebp-20h]
  int v28;            // [esp+2Ch] [ebp-1Ch]

  if (a1->tokenavailable) {
    a1->tokenavailable = 0;
    memcpy(__dst, &a1->token, 0x440u);
    return 1;
  }
  *(_DWORD *)a1->lastscript_p = *(_DWORD *)a1->script_p;
  a1->lastline = a1->line;
  memset(__dst, 0, 0x440u);
  v3 = *(_DWORD *)a1->script_p;
  a1->whitespace_p = v3;
  __dst->whitespace_p = v3;
  v4 = *(char **)a1->script_p;
LABEL_4:
  while (1) {
    v5 = *v4;
    if (*v4 > 32)
      break;
    if (!v5)
      return 0;
    if (v5 == 10)
      ++a1->line;
    *(_DWORD *)a1->script_p = ++v4;
  }
  if (v5 == 47) {
    v6 = v4 + 1;
    v7 = v4[1];
    if (v7 == 47) {
      v12 = v4 + 1;
      *(_DWORD *)a1->script_p = v6;
      while (1) {
        v13 = v12++;
        *(_DWORD *)a1->script_p = v12;
        v14 = v13[1];
        if (!v14)
          return 0;
        if (v14 == 10) {
          ++a1->line;
          v4 = v13 + 2;
          *(_DWORD *)a1->script_p = v13 + 2;
          if (v13[2])
            goto LABEL_4;
          return 0;
        }
      }
    }
    if (v7 == 42) {
      *(_DWORD *)a1->script_p = v6;
      v8 = v4 + 2;
      while (1) {
        v9 = v8;
        v10 = v8++;
        *(_DWORD *)a1->script_p = v9;
        v11 = *(v8 - 1);
        if (!v11)
          return 0;
        if (v11 == 10)
          ++a1->line;
        if (*(v8 - 1) == 42 && v9[1] == 47) {
          *(_DWORD *)a1->script_p = v8;
          if (v10[1]) {
            v4 = v10 + 2;
            *(_DWORD *)a1->script_p = v10 + 2;
            if (v10[2])
              goto LABEL_4;
          }
          return 0;
        }
      }
    }
  }
  a1->endwhitespace_p = (int32_t)v4;
  __dst->endwhitespace_p = (int32_t)v4;
  __dst->line = a1->line;
  __dst->linescrossed = a1->line - a1->lastline;
  __s1 = *(char **)a1->script_p;
  v15 = *__s1;
  if (*__s1 == 34) {
    String = PS_ReadString(a1, __dst, 34);
  LABEL_60:
    if (String)
      goto LABEL_38;
    return 0;
  }
  if (v15 == 39) {
    String = PS_ReadString(a1, __dst, 39);
    goto LABEL_60;
  }
  if ((unsigned __int8)(v15 - 48) <= 9u ||
      v15 == 46 && (unsigned __int8)(__s1[1] - 48) <= 9u) {
    if (!PS_ReadNumber(a1, __dst))
      return 0;
  LABEL_38:
    memcpy(&a1->token, __dst, 0x440u);
    return 1;
  }
  if ((a1->flags & 0x10) != 0) {
    if (v15 <= 32 || v15 == 59) {
      v17 = 0;
    } else {
      v16 = __dst;
      v17 = 0;
      while (1) {
        v16->string[0] = v15;
        ++v17;
        *(_DWORD *)a1->script_p = ++__s1;
        v15 = *__s1;
        if (*__s1 <= 32 || v15 == 59)
          break;
        v16 = (token_s *)((char *)v16 + 1);
        if (v17 == 1024) {
          ScriptError(a1, "primitive token longer than MAX_TOKEN = %d", 1024);
          return 0;
        }
      }
    }
    __dst->string[v17] = 0;
    goto LABEL_38;
  }
  if ((unsigned __int8)(v15 - 97) <= 0x19u ||
      (unsigned __int8)(v15 - 65) <= 0x19u || v15 == 95) {
    __dst->type = 4;
    v20 = __dst;
    v25 = 0;
    while (1) {
      v21 = *(char **)a1->script_p;
      v20->string[0] = *v21;
      ++v25;
      *(_DWORD *)a1->script_p = v21 + 1;
      if (v25 == 1024) {
        ScriptError(a1, "name longer than MAX_TOKEN = %d", 1024);
        return 0;
      }
      v22 = v21[1];
      if ((unsigned __int8)(v22 - 97) > 0x19u &&
          (unsigned __int8)(v22 - 65) > 0x19u &&
          (unsigned __int8)(v22 - 48) > 9u && v22 != 95) {
        break;
      }
      v20 = (token_s *)((char *)v20 + 1);
    }
    __dst->string[v25] = 0;
    __dst->subtype = v25;
    goto LABEL_38;
  }
  v28 = *(_DWORD *)(a1->punctuationtable + 4 * v15);
  if (v28) {
    end_p = a1->end_p;
    while (1) {
      __s2 = *(char **)v28;
      v18 = strlen(*(const char **)v28) + 1;
      v19 = v18 - 1;
      if ((unsigned int)&__s1[v18 - 1] <= end_p &&
          !strncmp(__s1, __s2, v18 - 1))
        break;
      v28 = *(_DWORD *)(v28 + 8);
      if (!v28)
        goto LABEL_64;
    }
    strncpy(__dst->string, __s2, 0x400u);
    *(_DWORD *)a1->script_p += v19;
    __dst->type = 5;
    __dst->subtype = *(_DWORD *)(v28 + 4);
    goto LABEL_38;
  }
LABEL_64:
  ScriptError(a1, "can't read token");
  return 0;
}

_DWORD *__cdecl GetMemory(unsigned int a1) {
  _DWORD *result; // eax

  result = Z_MallocInternal(a1 + 4);
  if (result)
    *result++ = 305419896;
  return result;
}

void __cdecl FreeMemory(_DWORD *a1) {
  if (*(a1 - 1) == 305419896)
    Z_FreeInternal(a1 - 1);
}

_DWORD *__cdecl GetClearedMemory(size_t __len) {
  _DWORD *v1; // eax
  _DWORD *v2; // ebx

  v1 = Z_MallocInternal(__len + 4);
  if (v1) {
    *v1 = 305419896;
    v2 = v1 + 1;
    memset(v1 + 1, 0, __len);
    return v2;
  } else {
    memset(0, 0, __len);
    return 0;
  }
}

void *__cdecl Sys_GetInfo(SysInfo *__dst) {
  return memcpy(__dst, &sys_info, 0x210u);
}

void __cdecl Sys_ArchiveInfo(int a1) {
  float v1; // xmm0_4

  sys_cpuGHz =
      Dvar_RegisterFloat("sys_cpuGHz", 0, -3.4028235e38, 3.4028235e38, 0x1011u);
  sys_sysMB = Dvar_RegisterInt("sys_sysMB", 0, 0x80000000, 0x7FFFFFFF, 0x1011u);
  sys_gpu = Dvar_RegisterString("sys_gpu", (DvarValue)&inData, 0x1011u);
  sys_configSum =
      Dvar_RegisterInt("sys_configSum", 0, 0x80000000, 0x7FFFFFFF, 0x1011u);
  v1 = *(double *)&sys_info;
  Dvar_SetFloat(sys_cpuGHz, v1);
  Dvar_SetInt(sys_sysMB, dword_7EFC88);
  Dvar_SetString(sys_gpu, byte_7EFC8D);
  Dvar_SetInt(sys_configSum, a1);
}

void __noreturn Sys_DirectXFatalError(void) {
  char *v0; // ebx
  char *v1; // eax

  v0 = Win_LocalizeRef("WIN_DIRECTX_INIT_TITLE");
  v1 = Win_LocalizeRef("WIN_DIRECTX_INIT_BODY");
  MessageBoxA(0, (MacStrings *)v1, (MacStrings *)v0, 16);
  j__exit(-1);
}

void __cdecl __noreturn Sys_OutOfMemErrorInternal(const char *a1, int a2) {
  char *v2; // ebx
  char *v3; // eax

  Com_Printf("Out of memory: filename '%s', line %d\n", a1, a2);
  v2 = Win_LocalizeRef("WIN_OUT_OF_MEM_TITLE");
  v3 = Win_LocalizeRef("WIN_OUT_OF_MEM_BODY");
  MessageBoxA(0, (MacStrings *)v3, (MacStrings *)v2, 16);
  j__exit(-1);
}

void __cdecl Sys_StartProcess(char *__big, int a2) {
  OSStatus ApplicationFolderItemRef; // eax
  char v3;                           // [esp+8h] [ebp-60h]
  FSRef inRef;                       // [esp+10h] [ebp-58h] BYREF

  if (strstr(__big, "cod2sp")) {
    ApplicationFolderItemRef = MacFolders::GetApplicationFolderItemRef(
        (MacFolders *)"Call of Duty 2.app", &inRef);
  } else {
    if (!strstr(__big, "cod2mp")) {
      dprintf();
      return;
    }
    ApplicationFolderItemRef = MacFolders::GetApplicationFolderItemRef(
        (MacFolders *)"Call of Duty 2 Multiplayer.app", &inRef);
  }
  if (!ApplicationFolderItemRef && !LSOpenFSRef(&inRef, 0)) {
    if (a2)
      Cbuf_ExecuteText(2, "quit\n", v3);
  }
}

void __usercall __noreturn Sys_Error(long double a1 @<st0>, float a2 @<xmm0>,
                                     __m128 a3 @<xmm1>, __m128 a4 @<xmm2>,
                                     __m128 a5 @<xmm3>, __m128 a6 @<xmm4>,
                                     __m128 a7 @<xmm6>, char *__format, ...) {
  CMacGameEngine *v8; // [esp+0h] [ebp-1028h]
  char __str[4096];   // [esp+1Ch] [ebp-100Ch] BYREF
  va_list v10;        // [esp+101Ch] [ebp-Ch]
  va_list va;         // [esp+1034h] [ebp+Ch] BYREF

  va_start(va, __format);
  com_errorEntered = 1;
  va_copy(v10, va);
  vsnprintf(__str, 0x1000u, __format, va);
  Sys_DestroySplashWindow();
  timeEndPeriod();
  IN_Shutdown();
  CL_ShutdownHunkUsers(a1, a2, a3, a4, a5, a6, a7);
  CL_ShutdownRef();
  Conbuf_AppendText(__str);
  Conbuf_AppendText("\n");
  Sys_SetErrorText((MacStrings *)__str);
  Sys_ShowConsole(1);
  while (!(unsigned __int8)CMacGameEngine::ProcessAllEvents(v8) &&
         gConsoleRunning)
    ;
  Com_Quit_f();
}

void Sys_NormalExit(void) { ; }

void __cdecl Sys_Print(const char *iDataPtr) { Conbuf_AppendText(iDataPtr); }

void *__cdecl Sys_QueEvent(int a1, sysEventType_t a2, int a3, int a4, int a5,
                           void *a6) {
  int v6;       // esi
  int v7;       // edx
  int *v8;      // ebx
  void *result; // eax

  v6 = a1;
  v7 = eventHead;
  v8 = &eventQue[6 * (unsigned __int8)eventHead];
  if (eventHead - eventTail > 255) {
    Com_Printf("Sys_QueEvent: overflow\n");
    if (v8[5])
      Z_FreeInternal((void *)v8[5]);
    ++eventTail;
    v7 = eventHead;
  }
  eventHead = v7 + 1;
  if (!a1)
    v6 = Sys_Milliseconds();
  *v8 = v6;
  v8[1] = a2;
  v8[2] = a3;
  v8[3] = a4;
  v8[4] = a5;
  result = a6;
  v8[5] = (int)a6;
  return result;
}

void Sys_Net_Restart_f(void) { NET_Restart(); }

OSErr Sys_LoadingKeepAlive(void) { return UpdateSystemActivity(0); }

void __usercall __noreturn WinMain(__m128 a1 @<xmm0>, __m128 a2 @<xmm1>,
                                   __m128 a3 @<xmm2>, __m128 a4 @<xmm3>,
                                   __m128 a5 @<xmm4>, __m128 a6 @<xmm6>, int a7,
                                   int a8, char *a9) {
  long double v9; // fst7
  dvar_s *v10;    // eax
  int v11;        // eax
  char v12[264];  // [esp+10h] [ebp-108h] BYREF

  Sys_InitMainThread();
  Win_InitLocalization();
  Dvar_Init();
  v9 = Sys_CpuGHz();
  *(double *)&sys_info = v9;
  dword_7EFC88 = Sys_SystemMemoryMB();
  Sys_DetectVideoCard(0x200u, byte_7EFC8D);
  byte_7EFC8C = Sys_SupportsSSE();
  v10 = Dvar_RegisterBool("sys_SSE", 0, 0x1000u);
  Dvar_SetBool(v10, byte_7EFC8C);
  dword_1150F8C = a7;
  Sys_CreateConsole();
  Sys_CreateSplashWindow();
  Sys_ShowSplashWindow();
  Sys_Milliseconds();
  Sys_InitStreamThread();
  Com_Init(v9, a1.f32[0], a2, a3, a4, a5, a6, a9);
  getcwd(v12, 0x100u);
  Com_Printf("Working directory: %s\n", v12);
  v11 = com_dedicated;
  if (!*(_DWORD *)(com_dedicated + 8)) {
    if (!com_viewlog->current.integer)
      Sys_ShowConsole(0);
    v11 = com_dedicated;
  }
  while (1) {
    if (v11) {
      if (*(_DWORD *)(v11 + 8))
        WinSleep(5);
    }
    Com_Frame(v9, a1, a2, a3, a4, a5, a6);
    v11 = com_dedicated;
  }
}

void __noreturn Sys_Quit(void) {
  int v0; // edx

  timeEndPeriod();
  IN_Shutdown();
  Key_Shutdown();
  Sys_DestroyConsole();
  Win_ShutdownLocalization();
  RefreshQuitOnErrorCondition();
  Dvar_Shutdown();
  Cmd_Shutdown();
  Con_Shutdown();
  Com_ShutdownEvents();
  while (1) {
    v0 = eventTail;
    if (eventHead <= eventTail)
      break;
    while (1) {
      eventTail = v0 + 1;
      if (!*(&dword_7EFEB4 + 6 * (unsigned __int8)v0))
        break;
      Z_FreeInternal(*(&dword_7EFEB4 + 6 * (unsigned __int8)v0));
      v0 = eventTail;
      if (eventHead <= eventTail)
        goto LABEL_5;
    }
  }
LABEL_5:
  MacPreferences::Synchronize();
  j__exit(0);
}

_DWORD *__stdcall Sys_GetEvent(_DWORD *a1) {
  int v1;              // edx
  int v2;              // eax
  char *v4;            // eax
  char *v5;            // edi
  int v6;              // edx
  int *v7;             // ebx
  _DWORD *v8;          // edi
  int v9;              // edx
  int *v10;            // ebx
  CMacGameEngine *v11; // [esp+0h] [ebp-78h]
  unsigned int __size; // [esp+14h] [ebp-64h]
  char *__src;         // [esp+18h] [ebp-60h]
  size_t v14;          // [esp+1Ch] [ebp-5Ch]
  msg_t v15;           // [esp+24h] [ebp-54h] BYREF
  _DWORD v16[6];       // [esp+3Ch] [ebp-3Ch] BYREF
  _DWORD v17[9];       // [esp+54h] [ebp-24h] BYREF

  v1 = eventTail;
  if (eventHead > eventTail)
    goto LABEL_2;
  if ((unsigned __int8)CMacGameEngine::ProcessAllEvents(v11))
    Com_Quit_f();
  v4 = Sys_ConsoleInput();
  __src = v4;
  if (v4) {
    __size = strlen(v4) + 1;
    v5 = (char *)Z_MallocInternal(__size);
    I_strncpyz(v5, __src, __size - 1);
    v6 = eventHead;
    v7 = &eventQue[6 * (unsigned __int8)eventHead];
    if (eventHead - eventTail > 255) {
      Com_Printf("Sys_QueEvent: overflow\n");
      if (v7[5])
        Z_FreeInternal((void *)v7[5]);
      ++eventTail;
      v6 = eventHead;
    }
    eventHead = v6 + 1;
    *v7 = Sys_Milliseconds();
    v7[1] = 4;
    v7[2] = 0;
    v7[3] = 0;
    v7[4] = __size;
    v7[5] = (int)v5;
  }
  MSG_Init(&v15, &sys_packetReceived, 0x4000u);
  if (NET_GetPacket((netadr_t *)v17, &v15)) {
    v14 = v15.cursize - v15.readcount + 12;
    v8 = Z_MallocInternal(v14);
    *v8 = v17[0];
    v8[1] = v17[1];
    v8[2] = v17[2];
    memcpy(v8 + 3, (const void *)(v15.data + v15.readcount),
           v15.cursize - v15.readcount);
    v9 = eventHead;
    v10 = &eventQue[6 * (unsigned __int8)eventHead];
    if (eventHead - eventTail > 255) {
      Com_Printf("Sys_QueEvent: overflow\n");
      if (v10[5])
        Z_FreeInternal((void *)v10[5]);
      ++eventTail;
      v9 = eventHead;
    }
    eventHead = v9 + 1;
    *v10 = Sys_Milliseconds();
    v10[1] = 5;
    v10[2] = 0;
    v10[3] = 0;
    v10[4] = v14;
    v10[5] = (int)v8;
  }
  v1 = eventTail;
  if (eventHead > eventTail) {
  LABEL_2:
    eventTail = v1 + 1;
    v2 = 6 * (unsigned __int8)v1;
    *a1 = eventQue[v2];
    a1[1] = dword_7EFEA4[v2];
    a1[2] = dword_7EFEA8[v2];
    a1[3] = dword_7EFEAC[v2];
    a1[4] = dword_7EFEB0[v2];
    a1[5] = *(MacPreferences **)((char *)&dword_7EFEB4 + v2 * 4);
  } else {
    memset(v16, 0, sizeof(v16));
    v16[0] = Sys_Milliseconds();
    *a1 = v16[0];
    a1[1] = v16[1];
    a1[2] = v16[2];
    a1[3] = v16[3];
    a1[4] = v16[4];
    a1[5] = v16[5];
  }
  return a1;
}

_BOOL4 Sys_ShouldUpdateForInfoChange(void) {
  float v0; // xmm0_4
  char *v1; // ebx
  char *v2; // eax

  sys_cpuGHz =
      Dvar_RegisterFloat("sys_cpuGHz", 0, -3.4028235e38, 3.4028235e38, 0x1011u);
  sys_sysMB = Dvar_RegisterInt("sys_sysMB", 0, 0x80000000, 0x7FFFFFFF, 0x1011u);
  sys_gpu = Dvar_RegisterString("sys_gpu", (DvarValue)&inData, 0x1011u);
  sys_configSum =
      Dvar_RegisterInt("sys_configSum", 0, 0x80000000, 0x7FFFFFFF, 0x1011u);
  v0 = *(double *)&sys_info;
  Dvar_SetFloat(sys_cpuGHz, v0);
  Dvar_SetInt(sys_sysMB, dword_7EFC88);
  Dvar_SetString(sys_gpu, byte_7EFC8D);
  Dvar_SetInt(sys_configSum, 0);
  v1 = Win_LocalizeRef("WIN_COMPUTER_CHANGE_TITLE");
  v2 = Win_LocalizeRef("WIN_COMPUTER_CHANGE_BODY");
  return MessageBoxA(0, (MacStrings *)v2, (MacStrings *)v1, 68) == 6;
}

_BOOL4 __cdecl Sys_HasConfigureChecksumChanged(int a1) {
  DvarValue current; // eax
  char *v2;          // ebx
  char *v3;          // eax
  _BOOL4 v4;         // ebx
  DvarValue v5;      // eax

  sys_cpuGHz =
      Dvar_RegisterFloat("sys_cpuGHz", 0, -3.4028235e38, 3.4028235e38, 0x1011u);
  sys_sysMB = Dvar_RegisterInt("sys_sysMB", 0, 0x80000000, 0x7FFFFFFF, 0x1011u);
  sys_gpu = Dvar_RegisterString("sys_gpu", (DvarValue)&inData, 0x1011u);
  sys_configSum =
      Dvar_RegisterInt("sys_configSum", 0, 0x80000000, 0x7FFFFFFF, 0x1011u);
  current = sys_configSum->current;
  if (!current.integer || current.integer == a1) {
    v4 = 0;
  } else {
    v2 = Win_LocalizeRef("WIN_CONFIGURE_UPDATED_TITLE");
    v3 = Win_LocalizeRef("WIN_CONFIGURE_UPDATED_BODY");
    v4 = MessageBoxA(0, (MacStrings *)v3, (MacStrings *)v2, 68) == 6;
  }
  v5 = sys_configSum->current;
  if (!v5.integer || v5.integer != a1)
    Dvar_SetInt(sys_configSum, a1);
  return v4;
}

int Sys_HasInfoChanged(void) {
  double v0;         // xmm2_8
  DvarValue current; // ecx
  int result;        // eax

  sys_cpuGHz =
      Dvar_RegisterFloat("sys_cpuGHz", 0, -3.4028235e38, 3.4028235e38, 0x1011u);
  sys_sysMB = Dvar_RegisterInt("sys_sysMB", 0, 0x80000000, 0x7FFFFFFF, 0x1011u);
  sys_gpu = Dvar_RegisterString("sys_gpu", (DvarValue)&inData, 0x1011u);
  sys_configSum =
      Dvar_RegisterInt("sys_configSum", 0, 0x80000000, 0x7FFFFFFF, 0x1011u);
  v0 = *(float *)&sys_cpuGHz->current.integer;
  if (v0 > *(double *)&sys_info * 1.100000023841858)
    return Sys_ShouldUpdateForInfoChange();
  if (*(double *)&sys_info * 0.8999999761581421 > v0)
    return Sys_ShouldUpdateForInfoChange();
  current = sys_sysMB->current;
  if (current.integer > dword_7EFC88 + 32)
    return Sys_ShouldUpdateForInfoChange();
  if (current.integer < dword_7EFC88 - 32)
    return Sys_ShouldUpdateForInfoChange();
  result = strcmp((const char *)sys_gpu->current.integer, byte_7EFC8D);
  if (result)
    return Sys_ShouldUpdateForInfoChange();
  return result;
}

int __cdecl EditTextHook(OpaqueControlRef *a1, __int16 a2) {
  char *v3; // eax

  if (a2 != 13 && a2 != 10)
    return 0;
  MacBuilder::GetControlText(sConsoleWindow, (OpaqueWindowPtr *)2, 512,
                             sConsoleText);
  if (sConsoleText[0]) {
    v3 = va("]%s\n", sConsoleText);
    Sys_Print(v3);
    *(_WORD *)((char *)&unk_7F191F + strlen(sConsoleText) + 1) = 10;
    MacBuilder::SetControlText(sConsoleWindow, (OpaqueWindowPtr *)2,
                               (const char *)&inData);
  }
  return 1;
}

void __cdecl TimerCallback() { UpdateSystemActivity(0); }

void Sys_CreateConsole() {
  if (!sConsoleData)
    sConsoleData = NewHandle(0);
  sConsoleText = 0;
  sReturnedText = 0;
}

EventLoopTimerRef Sys_DestroyConsole(void) {
  EventLoopTimerRef result; // eax

  if (sConsoleWindow) {
    MacBuilder::ReleaseWindow(sConsoleWindow);
    sConsoleWindow = 0;
  }
  if (sConsoleData) {
    DisposeHandle(sConsoleData);
    sConsoleData = 0;
  }
  result = sTimerRef;
  if (sTimerRef) {
    result = (EventLoopTimerRef)RemoveEventLoopTimer(sTimerRef);
    sTimerRef = 0;
  }
  return result;
}

void __cdecl Sys_ShowConsole(int a1) {
  OpaqueWindowPtr *v1; // edx
  OpaqueWindowPtr *v2; // eax

  gConsoleRunning = 0;
  if (a1 == 1) {
    v1 = sConsoleWindow;
    if (sConsoleWindow || (CreateConsoleWindow(), (v1 = sConsoleWindow) != 0)) {
      SetKeyboardFocus(v1, sConsoleEditText, -2);
      ShowWindow(sConsoleWindow);
      MacTools::ShowCursor(0, 0);
      gConsoleRunning = 1;
    }
  } else if (a1 == 2) {
    v2 = sConsoleWindow;
    if (sConsoleWindow || (CreateConsoleWindow(), (v2 = sConsoleWindow) != 0)) {
      if (!IsWindowVisible(v2)) {
        ShowWindow(sConsoleWindow);
        MacTools::ShowCursor(0, 0);
      }
      CollapseWindow(sConsoleWindow, 1u);
    }
  } else {
    if (a1)
      Sys_Error("Invalid visLevel %d sent to Sys_ShowConsole\n", a1);
    if (sConsoleWindow)
      HideWindow(sConsoleWindow);
  }
}

void __cdecl Conbuf_AppendText(const char *iDataPtr) {
  if (iDataPtr) {
    if (sConsoleWindow) {
      if (sConsoleTextView) {
        if (!TXNSetData(sConsoleTextView, 0x54455854u, iDataPtr,
                        strlen(iDataPtr), 0x7FFFFFFFu, 0x7FFFFFFFu)) {
          TXNSetSelection(sConsoleTextView, 0x7FFFFFFFu, 0x7FFFFFFFu);
          TXNShowSelection(sConsoleTextView, 1u);
        }
      }
    } else if (sConsoleData) {
      PtrAndHand(iDataPtr, sConsoleData, strlen(iDataPtr));
    }
  }
}

int __cdecl Sys_SetErrorText(MacStrings *a1) {
  if (sConsoleEditText)
    HideControl(sConsoleEditText);
  return MessageBoxA(0, a1, 0, 16);
}

void Sys_CreateSplashWindow(void) { ; }

void Sys_DestroySplashWindow(void) { ; }

void Sys_ShowSplashWindow(void) {
  CMacGameEngine::DrawSplashScreen((CMacGameEngine *)&stru_222D8C);
}

void Sys_HideSplashWindow(void) { ; }

long double Sys_CpuGHz(void) { return (float)MacFeatures::GetCPUSpeedInGHz(); }

int Sys_SystemMemoryMB(void) {
  int result; // eax

  result = MacFeatures::GetMemorySizeInMB();
  if (result >= 134217729)
    return 0x8000000;
  return result;
}

char *__cdecl Sys_DetectVideoCard(size_t __n, char *__dst) {
  const char *GLRenderer; // eax

  GLRenderer = (const char *)MacDisplay::GetGLRenderer();
  return strncpy(__dst, GLRenderer, __n);
}

_BOOL4 Sys_SupportsSSE(void) {
  return MacFeatures::HasGestaltAttribute(0x78383666u, 25);
}

int __cdecl Sys_Mkdir(char *a1) {
  int result; // eax

  result = access(a1, 7);
  if (result)
    return mkdir(a1, 0x1FFu);
  return result;
}

_BOOL4 __cdecl Sys_RemoveDirTree(UInt8 *path) {
  return MacFiles::RemoveDirectoryA(path) == 0;
}

int Sys_DefaultHomePath(void) { return 0; }

DIR *__cdecl Sys_ListFilteredFiles(const char *a1, const char *a2, char *a3,
                                   char **a4, DIR *a5) {
  DIR *result;     // eax
  DIR *v6;         // edi
  dirent *v7;      // eax
  char *d_name;    // ebx
  char **v9;       // ebx
  char __src[256]; // [esp+20h] [ebp-378h] BYREF
  char v11[256];   // [esp+120h] [ebp-278h] BYREF
  char __str[256]; // [esp+220h] [ebp-178h] BYREF
  stat v13;        // [esp+320h] [ebp-78h] BYREF

  result = a5;
  if (a5->__dd_fd <= 4094) {
    if (*a2)
      Com_sprintf(__str, 0x100u, "%s/%s", a1, a2);
    else
      Com_sprintf(__str, 0x100u, "%s", a1);
    result = opendir(__str);
    v6 = result;
    if (result) {
    LABEL_5:
      while (1) {
        v7 = readdir(v6);
        if (!v7)
          return (DIR *)closedir(v6);
        while (1) {
          d_name = v7->d_name;
          Com_sprintf(__src, 0x100u, "%s/%s", __str, v7->d_name);
          if (stat(__src, &v13) == -1)
            break;
          if ((v13.st_mode & 0x4000) != 0 && I_stricmp(d_name, ".") &&
              I_stricmp(d_name, "..")) {
            if (*a2)
              Com_sprintf(v11, 0x100u, "%s/%s", a2, d_name);
            else
              Com_sprintf(v11, 0x100u, "%s", d_name);
            Sys_ListFilteredFiles(a1, v11, a3, a4, &a5->__dd_fd);
          }
          if (a5->__dd_fd <= 4094) {
            Com_sprintf(__src, 0x100u, "%s/%s", a2, d_name);
            if (!(unsigned __int8)Com_FilterPath(a3, __src, 0))
              goto LABEL_5;
            v9 = &a4[a5->__dd_fd];
            *v9 = CopyStringInternal(__src);
            ++a5->__dd_fd;
            v7 = readdir(v6);
            if (v7)
              continue;
          }
          return (DIR *)closedir(v6);
        }
      }
    }
  }
  return result;
}

_DWORD *__cdecl Sys_ListFiles(char *a1, const char *a2, char *a3, int *a4,
                              int a5) {
  const gentity_s *v5; // eax
  DIR *v6;             // eax
  DIR *i;              // edx
  dirent *v8;          // eax
  char *d_name;        // esi
  int v10;             // ebx
  int v11;             // eax
  _DWORD *v13;         // ecx
  int v14;             // edx
  int v15;             // eax
  unsigned int v16;    // kr04_4
  unsigned int v17;    // kr08_4
  int v18;             // eax
  int v19;             // edx
  DIR *v20;            // [esp+28h] [ebp-4190h]
  char *v22[4096];     // [esp+3Ch] [ebp-417Ch] BYREF
  char __str[256];     // [esp+403Ch] [ebp-17Ch] BYREF
  stat v24;            // [esp+413Ch] [ebp-7Ch] BYREF
  int v25;             // [esp+419Ch] [ebp-1Ch] BYREF
  char *v26;           // [esp+41C4h] [ebp+Ch]

  if (a3) {
    v25 = 0;
    Sys_ListFilteredFiles(a1, (const char *)&inData, a3, v22, (DIR *)&v25);
    v18 = v25;
    v22[v25] = 0;
    *a4 = v18;
    if (!v18)
      return 0;
    v13 = Z_MallocInternal(4 * v18 + 4);
    if (v25 > 0) {
      v19 = 1;
      do {
        v13[v19 - 1] = v22[v19 - 1];
        v15 = v19++;
      } while (v25 > v15);
      goto LABEL_33;
    }
  } else {
    v5 = &inData;
    if (a2)
      v5 = (const gentity_s *)a2;
    v26 = (char *)v5;
    if (LOBYTE(v5->s.number) == 47 && !BYTE1(v5->s.number)) {
      a5 = 1;
      v26 = (char *)&inData;
    }
    v25 = 0;
    v6 = opendir(a1);
    v20 = v6;
    if (!v6) {
      *a4 = 0;
      return 0;
    }
    for (i = v6;; i = v20) {
      v8 = readdir(i);
      if (!v8)
        break;
      while (v8->d_name[0] != 46) {
        d_name = v8->d_name;
        Com_sprintf(__str, 0x100u, "%s/%s", a1, v8->d_name);
        if (stat(__str, &v24) == -1)
          break;
        if (a5) {
          if ((v24.st_mode & 0x4000) == 0)
            break;
        } else if ((v24.st_mode & 0x4000) != 0) {
          break;
        }
        if (*v26) {
          v16 = strlen(d_name) + 1;
          v17 = strlen(v26) + 1;
          if (v16 - 1 < v17 - 1 || I_stricmp(&d_name[v16 - v17], v26))
            break;
        }
        v10 = v25;
        if (v25 == 4095)
          goto LABEL_18;
        v22[v10] = CopyStringInternal(d_name);
        ++v25;
        v8 = readdir(v20);
        if (!v8)
          goto LABEL_17;
      }
    }
  LABEL_17:
    v10 = v25;
  LABEL_18:
    v22[v10] = 0;
    closedir(v20);
    v11 = v25;
    *a4 = v25;
    if (!v11)
      return 0;
    v13 = Z_MallocInternal(4 * v11 + 4);
    if (v25 > 0) {
      v14 = 1;
      do {
        v13[v14 - 1] = v22[v14 - 1];
        v15 = v14++;
      } while (v15 < v25);
      goto LABEL_33;
    }
  }
  v15 = 0;
LABEL_33:
  v13[v15] = 0;
  return v13;
}

void __cdecl Sys_FreeFileList(char **a1) {
  char *v1;  // eax
  char **v2; // ebx

  if (a1) {
    v1 = *a1;
    if (*a1) {
      v2 = a1;
      do {
        Z_FreeInternal(v1);
        v1 = v2[1];
        ++v2;
      } while (v1);
    }
    Z_FreeInternal(a1);
  }
}

int __cdecl Sys_DirectoryHasContents(char *a1) {
  DIR *v1;    // ebx
  dirent *v2; // eax
  int v3;     // esi

  v1 = opendir(a1);
  if (!v1)
    return 0;
  while (1) {
    v2 = readdir(v1);
    if (!v2)
      break;
    if (v2->d_name[0] != 46 && v2->d_type == 8) {
      v3 = 1;
      goto LABEL_7;
    }
  }
  v3 = 0;
LABEL_7:
  closedir(v1);
  return v3;
}

void Sys_InitStreamThread(void) { ; }

void Sys_BeginStreamedFile() { ; }

void Sys_EndStreamedFile() { ; }

int __cdecl Sys_StreamedRead(char *a1, int a2, int a3, int a4) {
  return FS_Read(a1, a3 * a2, a4);
}

int __cdecl Sys_StreamSeek(int a1, int a2, int a3) {
  return FS_Seek(a1, a2, a3);
}

int R_AddCmdTouchAllImages(void) {
  int v0;     // ecx
  int v1;     // ebx
  int result; // eax
  _WORD *v3;  // edx

  v0 = s_cmdList;
  v1 = *(_DWORD *)(s_cmdList + 196608);
  result = *(_DWORD *)(s_cmdList + 196612) + 196608 - v1 - 0x2000;
  if (result > 3) {
    v3 = (_WORD *)(s_cmdList + v1);
    result = v1 + 4;
    *(_DWORD *)(s_cmdList + 196608) = v1 + 4;
    *(_DWORD *)(v0 + 196616) = v0 + v1;
    *v3 = 33;
    v3[1] = 4;
  } else {
    *(_DWORD *)(s_cmdList + 196616) = 0;
  }
  return result;
}

_BOOL4 __cdecl R_DisplayModeLess(_DWORD *a1, _DWORD *a2) {
  unsigned int v2; // eax

  if (*a1 <= *a2) {
    if (*a1 < *a2)
      return 1;
    v2 = a2[1];
    if (a1[1] <= v2) {
      if (a1[1] >= v2)
        return a1[2] < a2[2];
      return 1;
    }
  }
  return 0;
}

int R_UpdateGpuSyncType(void) {
  int result; // eax

  if (*(_BYTE *)(r_multiGpu + 8)) {
    result = 0;
    dword_11804C0 = 0;
  } else {
    result = *(_DWORD *)(r_gpuSync + 8);
    dword_11804C0 = result;
  }
  return result;
}

int *__cdecl GetRefAPI(int a1, void *__src) {
  memcpy(&ri, __src, 0x21Cu);
  memset(&GetRefAPI::re, 0, 0x160u);
  if (a1 == 59) {
    GetRefAPI::re = (int)R_Shutdown;
    dword_C85984 = (int)R_BeginRegistration;
    dword_C85988 = (int)R_RegisterModel;
    dword_C8598C = (int)R_RegisterInlineModel;
    dword_C859B0 = (int)R_GetMinSpecImageMemory;
    dword_C85990 = (int)Material_RegisterHandle;
    dword_C85994 = (int)R_RegisterRawImage;
    dword_C85998 = (int)Material_IsDefault;
    dword_C8599C = (int)R_LoadWorld;
    dword_C859A0 = (int)R_GetWorldBounds;
    dword_C859A4 = (int)R_FinishLoadingModels;
    dword_C859A8 = (int)R_SetIgnorePrecacheErrors;
    dword_C859AC = (int)R_GetIgnorePrecacheErrors;
    dword_C859C4 = (int)R_EndRegistration;
    dword_C859B4 = (int)R_GetMaterialName;
    dword_C859B8 = (int)R_GetMaterialSubimageCount;
    dword_C859BC = (int)R_IsMaterialRefractive;
    dword_C859C0 = (int)R_GetFarPlaneDist;
    dword_C85A28 = (int)R_BeginFrame;
    dword_C85A2C = (int)R_EndFrame;
    dword_C85A30 = (int)R_BeginDebugFrame;
    dword_C85A34 = (int)R_EndDebugFrame;
    dword_C85A38 = (int)R_EndView;
    dword_C85A3C = (int)R_DoneRenderingViews;
    dword_C85A40 = (int)R_AddCmdSaveScreen;
    dword_C85A44 = (int)R_AddCmdBlendSavedScreen;
    dword_C85A48 = (int)R_AddCmdClearScreen;
    dword_C85A4C = (int)R_AddCmdSetViewport;
    dword_C85A50 = (int)R_MarkFragments;
    dword_C85A54 = (int)R_ModelBounds;
    dword_C859C8 = (int)R_ClearScene;
    dword_C859CC = (int)R_DefaultVertexFrames;
    dword_C859D0 = (int)R_AddPolyToScene;
    dword_C859D4 = (int)R_AddLightToScene;
    dword_C859D8 = (int)R_InterpretSunLightParseParams;
    dword_C859DC = (int)R_ResetSunLightParseParams;
    dword_C859E0 = (int)R_SetCullDist;
    dword_C859E4 = (int)R_SetFog;
    dword_C859E8 = (int)R_SwitchFog;
    dword_C859EC = (int)R_ArchiveFogState;
    dword_C859F0 = (int)R_ClearFogs;
    dword_C859F4 = (int)R_SetSunLightOverride;
    dword_C859F8 = (int)R_ResetSunLightOverride;
    dword_C859FC = (int)R_RenderScene;
    dword_C85A00 = (int)R_BeginDelayedDrawing;
    dword_C85A04 = (int)R_EndDelayedDrawing;
    dword_C85A08 = (int)R_IssueDelayedDrawing;
    dword_C85A0C = (int)R_ClearFlares;
    dword_C85A14 = (int)R_AddCmdDrawStretchPic;
    dword_C85A18 = (int)R_AddCmdDrawStretchPicRotate;
    dword_C85A1C = (int)R_AddCmdDrawStretchRaw;
    dword_C85A20 = (int)R_AddCmdDrawQuadPic;
    dword_C85A24 = (int)R_AddCmdDrawSprite;
    dword_C85A10 = (int)R_AddCmdSetMaterialColor;
    dword_C85A60 = (int)R_RegisterFont;
    dword_C85A64 = (int)R_ResetImageAllocations;
    dword_C85A68 = (int)R_FreeImageAllocations;
    dword_C85A6C = (int)R_BeginCubemapShot;
    dword_C85A70 = (int)R_EndCubemapShot;
    dword_C85A74 = (int)R_SaveCubemapShot;
    dword_C85A78 = (int)R_LightingFromCubemapShots;
    dword_C85A7C = (int)R_LocateDebugStrings;
    dword_C85A80 = (int)R_LocateDebugLines;
    dword_C85A84 = (int)R_AddPlume;
    dword_C85A88 = (int)R_ShutdownDebug;
    dword_C85A58 = (int)R_TrackStatistics;
    dword_C85A5C = (int)R_PickMaterial;
    dword_C85A8C = (int)RB_UpdateColor;
    dword_C85A90 = (int)R_NormalizedTextScale;
    dword_C85A94 = (int)R_TextWidth;
    dword_C85A98 = (int)R_TextHeight;
    dword_C85A9C = (int)R_DrawText;
    dword_C85AA0 = (int)R_AddCmdDrawTextInSpace;
    dword_C85AA4 = (int)R_ConsoleTextWidth;
    dword_C85AA8 = (int)R_DrawConsoleText;
    dword_C85AAC = (int)R_AddCmdDrawTextWithCursor;
    dword_C85AB0 = (int)R_DObjGetSurfMaterials;
    dword_C85AB4 = (int)R_DObjReplaceMaterial;
    dword_C85AB8 = (int)R_ParseSunLight;
    dword_C85ABC = (int)Material_Duplicate;
    dword_C85AC0 = (int)R_DuplicateFont;
    byte_C85AC4 = 1;
    dword_C85AC8 = (int)R_SyncRenderThread;
    dword_C85ACC = (int)R_AbortRenderCommands;
    dword_C85AD0 = (int)RB_IsGpuFenceFinished;
    dword_C85AD4 = (int)RB_AdaptiveGpuSyncWait;
    dword_C85AD8 = (int)RB_GpuWaited;
    dword_C85ADC = (int)R_SetLodOrigin;
    return &GetRefAPI::re;
  } else {
    ri(0, "Mismatched REF_API_VERSION: expected %i, got %i\n", 59, a1);
    return 0;
  }
}

int __cdecl RB_SetAlphaAntiAliasingState(__int16 a1) {
  int v1;     // ebx
  int result; // eax

  if ((a1 & 0xF00) != 0) {
    v1 = 0;
  } else {
    v1 = 1094800211;
    if (*(_DWORD *)(r_aaAlpha + 8) != 2)
      v1 = 1129272385;
  }
  do {
    (*(void(__cdecl **)(int, int, int))(*(_DWORD *)dword_117D8A8 + 228))(
        dword_117D8A8, 181, v1);
    result = alwaysfails;
  } while (alwaysfails);
  return result;
}

int __cdecl RB_ChangeAlphaStageState(int a1, int a2) {
  return RB_ChangeTextureStageState(a1, texStageEnums_126457, a2,
                                    (int)&unk_1186C74);
}

int __cdecl RB_ChangeColorStageState(int a1, int a2) {
  return RB_ChangeTextureStageState(a1, texStageEnums_126452, a2,
                                    (int)&unk_1186C54);
}

int __cdecl RB_SetSamplerConstantDx7(unsigned int a1) {
  int result; // eax

  if (dword_1186D4C != a1) {
    dword_1186D4C = a1;
    do {
      (*(void(__cdecl **)(int, int, unsigned int))(*(_DWORD *)dword_117D8A8 +
                                                   228))(dword_117D8A8, 60, a1);
      result = alwaysfails;
    } while (alwaysfails);
  }
  return result;
}

int __cdecl RB_ChangeGenTexCoords(int a1, unsigned __int8 a2) {
  int result;   // eax
  float v3[22]; // [esp+20h] [ebp-58h] BYREF

  if (a2 == 1) {
    MatrixInverse44(
        (float *)&dword_11E19C8->viewMatrix.unnamed_field.unnamed_field._11,
        v3);
    memset(&v3[12], 0, 12);
    do
      (*(void(__cdecl **)(int, int, int, void *))(
          *(_DWORD *)dword_117D8A8 + 268))(dword_117D8A8, a1, 11, &loc_20000);
    while (alwaysfails);
    do
      (*(void(__cdecl **)(int, int, int, int))(*(_DWORD *)dword_117D8A8 + 268))(
          dword_117D8A8, a1, 24, 3);
    while (alwaysfails);
    do
      (*(void(__cdecl **)(int, int, float *))(*(_DWORD *)dword_117D8A8 + 176))(
          dword_117D8A8, a1 + 16, v3);
    while (alwaysfails);
    result = 1;
    *((_BYTE *)&word_1186C95 + a1) = 1;
  } else if (a2) {
    if (a2 == 2) {
      MatrixIdentity44(v3);
      LODWORD(v3[9]) = dword_11E1ADC ^ 0x80000000;
      do
        (*(void(__cdecl **)(int, int, int, int))(
            *(_DWORD *)dword_117D8A8 + 268))(dword_117D8A8, a1, 11, a1);
      while (alwaysfails);
      do
        (*(void(__cdecl **)(int, int, int, int))(
            *(_DWORD *)dword_117D8A8 + 268))(dword_117D8A8, a1, 24, 3);
      while (alwaysfails);
      do
        (*(void(__cdecl **)(int, int, float *))(
            *(_DWORD *)dword_117D8A8 + 176))(dword_117D8A8, a1 + 16, v3);
      while (alwaysfails);
      result = a2;
      *((_BYTE *)&word_1186C95 + a1) = a2;
    } else {
      result = a2;
      *((_BYTE *)&word_1186C95 + a1) = a2;
    }
  } else {
    do
      (*(void(__cdecl **)(int, int, int, int))(*(_DWORD *)dword_117D8A8 + 268))(
          dword_117D8A8, a1, 11, a1);
    while (alwaysfails);
    do
      (*(void(__cdecl **)(int, int, int, _DWORD))(
          *(_DWORD *)dword_117D8A8 + 268))(dword_117D8A8, a1, 24, 0);
    while (alwaysfails);
    result = a2;
    *((_BYTE *)&word_1186C95 + a1) = a2;
  }
  return result;
}

int __cdecl RB_SetViewMatrixForWDx7(float a1) {
  int result;    // eax
  _DWORD v2[22]; // [esp+10h] [ebp-58h] BYREF

  v2[0] = dword_11E19C8->viewMatrix.unnamed_field.unnamed_field._11;
  v2[1] = dword_11E19C8->viewMatrix.unnamed_field.unnamed_field._12;
  v2[2] = dword_11E19C8->viewMatrix.unnamed_field.unnamed_field._13;
  v2[3] = dword_11E19C8->viewMatrix.unnamed_field.unnamed_field._14;
  v2[4] = dword_11E19C8->viewMatrix.unnamed_field.unnamed_field._21;
  v2[5] = dword_11E19C8->viewMatrix.unnamed_field.unnamed_field._22;
  v2[6] = dword_11E19C8->viewMatrix.unnamed_field.unnamed_field._23;
  v2[7] = dword_11E19C8->viewMatrix.unnamed_field.unnamed_field._24;
  v2[8] = dword_11E19C8->viewMatrix.unnamed_field.unnamed_field._31;
  v2[9] = dword_11E19C8->viewMatrix.unnamed_field.unnamed_field._32;
  v2[10] = dword_11E19C8->viewMatrix.unnamed_field.unnamed_field._33;
  v2[11] = dword_11E19C8->viewMatrix.unnamed_field.unnamed_field._34;
  v2[12] = dword_11E19C8->viewMatrix.unnamed_field.unnamed_field._41;
  v2[13] = dword_11E19C8->viewMatrix.unnamed_field.unnamed_field._42;
  v2[14] = dword_11E19C8->viewMatrix.unnamed_field.unnamed_field._43;
  *(float *)&v2[15] = a1;
  do
    result = (*(int(__cdecl **)(int, int, _DWORD *))(
        *(_DWORD *)dword_117D8A8 + 176))(dword_117D8A8, 2, v2);
  while (alwaysfails);
  return result;
}

int __cdecl R_ReleaseModel(XAssetHeader a1) {
  int result; // eax

  result = XModelBad((const XModel *)a1.parts);
  if (!result)
    return XModelUnoptimize((XModel *)a1.parts);
  return result;
}

int R_OptimizeAllModels(void) {
  int result; // eax

  result = *(_DWORD *)(r_optimizeXModels + 8);
  if (result)
    return DB_EnumXAssets(1, (void (*)(XAssetHeader, void *))R_OptimizeModel,
                          0);
  return result;
}

int R_ReleaseAllModels(void) {
  return DB_EnumXAssets(1, (void (*)(XAssetHeader, void *))R_ReleaseModel, 0);
}

void *__cdecl Model_Alloc(size_t __len) { return Hunk_AllocInternal(__len); }

int __cdecl R_OptimizeModel(XAssetHeader a1) {
  int result; // eax

  result = XModelBad((const XModel *)a1.parts);
  if (!result)
    return XModelOptimize((XModel *)a1.parts);
  return result;
}

int __cdecl R_LockSkinnedCache(GfxLockType a1) {
  int v1;     // ebx
  int v2;     // ecx
  int result; // eax

  v1 = *(_DWORD *)(*((_DWORD *)frontEndDataOut + 548638) + 8);
  if (dword_11804C0 || a1)
    v2 = 4096;
  else
    v2 = 0x2000;
  result = (*(int(__cdecl **)(int, _DWORD, _DWORD, _DWORD *, int))(
      *(_DWORD *)v1 + 44))(v1, 0, 0, &dword_1180660, v2);
  if (result < 0)
    result = R_FatalLockError();
  if ((dword_1180660 & 0xF) != 0) {
    result = (*(int(__cdecl **)(int))(*(_DWORD *)v1 + 48))(v1);
    dword_1180660 = 0;
  }
  return result;
}

int R_ShutdownModels(void) {
  return DB_EnumXAssets(1, (void (*)(XAssetHeader, void *))R_ReleaseModel, 0);
}

int R_FinishLoadingModels(void) {
  int result; // eax

  result = *(_DWORD *)(r_optimizeXModels + 8);
  if (result)
    return DB_EnumXAssets(1, (void (*)(XAssetHeader, void *))R_OptimizeModel,
                          0);
  return result;
}

int __cdecl Material_RegisterLiteral(float *a1) {
  int v1;    // ebx
  float v2;  // xmm1_4
  float *v3; // edx
  int v5;    // eax
  int v6;    // esi
  float *v7; // ecx

  v1 = dword_C87E8C;
  if (dword_C87E8C > 0) {
    v2 = *a1;
    v5 = 0;
    v6 = 2244;
    do {
      v7 = (float *)&materialGlobals[v6];
      if (v2 == *(float *)&materialGlobals[v6] && a1[1] == v7[1] &&
          a1[2] == v7[2] && a1[3] == v7[3])
        return 16 * v5 + 13139600;
      ++v5;
      v6 += 4;
    } while (v5 != dword_C87E8C);
    if (dword_C87E8C == 16) {
      R_Error(ERR_DROP, "more than %i shader literals used", 16);
      v2 = *a1;
    }
  } else {
    v1 = 0;
    v2 = *a1;
  }
  v3 = (float *)&materialGlobals[4 * v1 + 2244];
  *v3 = v2;
  v3[1] = a1[1];
  v3[2] = a1[2];
  v3[3] = a1[3];
  return (int)v3;
}

void *__cdecl Material_SetTechnique(char *a1, MaterialTechnique *a2) {
  int v2;         // ebx
  const char **i; // eax
  void *result;   // eax

  if (dword_C86E88 == 1023)
    R_Error(ERR_DROP, "More than %i techniques in use", 1023);
  v2 = R_HashAssetName(a1) & 0x3FF;
  for (i = (const char **)dword_C86E8C[v2]; i;
       i = (const char **)dword_C86E8C[v2]) {
    if (!stricmp(*i, a1))
      break;
    v2 = ((_WORD)v2 + 1) & 0x3FF;
  }
  ++dword_C86E88;
  result = &unk_C86E80;
  *((_DWORD *)&unk_C86E80 + v2 + 3) = a2;
  return result;
}

void *__cdecl Material_SetTechniqueSet(char *a1, MaterialTechniqueSet *a2) {
  int v2;         // ebx
  const char **i; // eax
  void *result;   // eax

  v2 = R_HashAssetName(a1) & 0x3FF;
  for (i = (const char **)dword_C85E88[v2]; i;
       i = (const char **)dword_C85E88[v2]) {
    if (!stricmp(*i, a1))
      break;
    v2 = ((_WORD)v2 + 1) & 0x3FF;
  }
  result = &unk_C85E80;
  *((_DWORD *)&unk_C85E80 + v2 + 2) = a2;
  return result;
}

void *__cdecl Material_SetStateMap(char *__s2, MaterialStateMap *a2) {
  int v2;         // ebx
  const char **i; // eax
  void *result;   // eax

  v2 = R_HashAssetName(__s2) & 0x1F;
  for (i = (const char **)dword_C87F94[v2]; i;
       i = (const char **)dword_C87F94[v2]) {
    if (!strcmp(*i, __s2))
      break;
    v2 = ((_BYTE)v2 + 1) & 0x1F;
  }
  result = &unk_C87F90;
  *((_DWORD *)&unk_C87F90 + v2 + 1) = a2;
  return result;
}

void *__cdecl Material_SetShader(char *__s2, MaterialShaderType a2, int a3,
                                 MaterialShader *a4) {
  int v4;       // ebx
  int i;        // edx
  void *result; // eax

  if (++dword_C88118 == 256)
    R_Error(ERR_DROP, "More than %i unique pixel and vertex shaders", 255);
  v4 = (unsigned __int8)(a3 + 97 * a2 + R_HashAssetName(__s2));
  for (i = dword_C8811C[v4]; i; i = dword_C8811C[v4]) {
    if (a2 == *(unsigned __int8 *)(i + 10) &&
        a3 == *(unsigned __int8 *)(i + 11) && !strcmp(*(const char **)i, __s2))
      break;
    v4 = (unsigned __int8)(v4 + 1);
  }
  result = &unk_C88110;
  *((_DWORD *)&unk_C88110 + v4 + 3) = a4;
  return result;
}

int __cdecl Material_LoadFile(const char *a1, int *a2) {
  char __str[72]; // [esp+10h] [ebp-48h] BYREF

  Com_sprintf(__str, 0x40u, "materials/%s", a1);
  return unk_11807F0(__str, a2, 1);
}

const char *__cdecl Material_RegisterString(char *__s2) {
  int v1;         // esi
  const char *v2; // ebx
  size_t v3;      // ebx
  void *v4;       // edi

  v1 = R_HashString(__s2) & 0x3F;
  v2 = (&_s1)[v1];
  if (v2) {
    while (strcmp(v2, __s2)) {
      v1 = ((_BYTE)v1 + 1) & 0x3F;
      v2 = (&_s1)[v1];
      if (!v2)
        goto LABEL_4;
    }
    return v2;
  } else {
  LABEL_4:
    if (++dword_C88014 == 64)
      R_Error(ERR_DROP, "More than %i string identifiers used by shaders", 63);
    v3 = strlen(__s2) + 1;
    v4 = (void *)(*(int(__cdecl **)(size_t)) & algn_11806C8[4])(v3);
    memcpy(v4, __s2, v3);
    *((_DWORD *)&unk_C88010 + v1 + 2) = v4;
    return (const char *)v4;
  }
}

int *__cdecl Material_AllocVertexDecl(MaterialStreamRouting *__src, int a2,
                                      unsigned __int8 *a3) {
  int v3;   // ebx
  void *v4; // ebx
  int v6;   // ecx
  char v7;  // bl
  int *v8;  // [esp+18h] [ebp-20h]
  int __n;  // [esp+1Ch] [ebp-1Ch]

  __n = 2 * a2;
  if (2 * a2 > 0) {
    v6 = 0;
    v7 = 0;
    do {
      v7 += *(&__src->source + v6) * (v6 + 119);
      ++v6;
    } while (__n != v6);
    v3 = v7 & 0x1F;
  } else {
    v3 = 0;
  }
  while (1) {
    v8 = &materialGlobals[6 * v3 + 1];
    if (!*v8)
      break;
    if (a2 == materialGlobals[6 * v3 + 2] &&
        !memcmp((const char *)*v8, &__src->source, 2 * a2)) {
      *a3 = 1;
      return v8;
    }
    v3 = ((_BYTE)v3 + 1) & 0x1F;
  }
  if (materialGlobals[0] == 31)
    R_Error(ERR_DROP, "More than %i vertex declarations in use", 31);
  ++materialGlobals[0];
  v4 = (void *)(*(int(__cdecl **)(int)) & algn_11806C8[4])(__n);
  memcpy(v4, __src, __n);
  memset(v8, 0, 0x18u);
  *v8 = (int)v4;
  v8[1] = a2;
  *a3 = 0;
  return v8;
}

const char **__cdecl Material_FindStateMap(char *__s2) {
  int v1;          // ebx
  const char **v2; // esi

  v1 = R_HashAssetName(__s2) & 0x1F;
  v2 = (const char **)dword_C87F94[v1];
  if (!v2)
    return 0;
  while (strcmp(*v2, __s2)) {
    v1 = ((_BYTE)v1 + 1) & 0x1F;
    v2 = (const char **)dword_C87F94[v1];
    if (!v2)
      return 0;
  }
  return v2;
}

int __cdecl Material_FindTechniqueSet(char *a1) {
  int v1;          // ebx
  const char **v2; // eax

  v1 = R_HashAssetName(a1) & 0x3FF;
  v2 = (const char **)dword_C85E88[v1];
  if (!v2)
    return 0;
  while (stricmp(*v2, a1)) {
    v1 = ((_WORD)v1 + 1) & 0x3FF;
    v2 = (const char **)dword_C85E88[v1];
    if (!v2)
      return 0;
  }
  return dword_C85E88[v1];
}

int __cdecl Material_FindTechnique(char *a1) {
  int v1;          // ebx
  const char **v2; // eax

  v1 = R_HashAssetName(a1) & 0x3FF;
  v2 = (const char **)dword_C86E8C[v1];
  if (!v2)
    return 0;
  while (stricmp(*v2, a1)) {
    v1 = ((_WORD)v1 + 1) & 0x3FF;
    v2 = (const char **)dword_C86E8C[v1];
    if (!v2)
      return 0;
  }
  return dword_C86E8C[v1];
}

int __cdecl Material_FindShader(char *__s2, MaterialShaderType a2, int a3) {
  int v3; // esi
  int v4; // ebx

  v3 = (unsigned __int8)(a3 + 97 * a2 + R_HashAssetName(__s2));
  v4 = dword_C8811C[v3];
  if (!v4)
    return 0;
  while (a2 != *(unsigned __int8 *)(v4 + 10) ||
         a3 != *(unsigned __int8 *)(v4 + 11) ||
         strcmp(*(const char **)v4, __s2)) {
    v3 = (unsigned __int8)(v3 + 1);
    v4 = dword_C8811C[v3];
    if (!v4)
      return 0;
  }
  return v4;
}

void R_Cmd_ReloadMaterialTextures(void) {
  char *v0;                                     // edi
  __int16 i;                                    // bx
  unsigned __int16 v2;                          // bx
  const char **v3;                              // eax
  long double (*v4)(_DWORD, const char *, ...); // ebx
  char *v5;                                     // eax
  unsigned __int16 v6;                          // ax
  int v7;                                       // edi
  GfxImage *j;                                  // esi
  int v9;                                       // edx
  int v10;                                      // ecx
  GfxImage *v11;                                // ebx
  unsigned int v12;                             // eax
  int v13;                                      // edx
  int v14;                                      // ecx
  int v15;                                      // [esp+1Ch] [ebp-1Ch]

  if (unk_11807C0() == 2) {
    v0 = (char *)unk_11807C4(1);
    for (i = R_HashAssetName(v0);; i = v2 + 1) {
      v2 = i & 0x3FF;
      v3 = *(const char ***)&rg[4 * v2 + 40];
      if (!v3)
        goto LABEL_8;
      if (!strcmp(*v3, v0))
        break;
    }
    v15 = *(_DWORD *)&rg[4 * v2 + 40];
    if (!v15) {
    LABEL_8:
      v4 = ri;
      v5 =
          va("ReloadMaterialTextures: Material '%s' is not currently loaded.\n",
             v0);
      v4(0, v5);
      return;
    }
    RB_BindDefaultImages();
    v6 = *(_WORD *)(v15 + 52);
    v7 = v6;
    if (v6) {
      for (j = 0;; j = v11) {
        if (j) {
          v9 = *(_DWORD *)(v15 + 60);
          v10 = 0;
          v11 = 0;
          do {
            if (*(_BYTE *)(v9 + 5) != 5) {
              v12 = *(_DWORD *)(v9 + 8);
              if ((unsigned int)v11 < v12 && (unsigned int)j > v12)
                v11 = *(GfxImage **)(v9 + 8);
            }
            ++v10;
            v9 += 12;
          } while (v7 != v10);
        } else {
          v13 = *(_DWORD *)(v15 + 60);
          v14 = 0;
          v11 = 0;
          do {
            if (*(_BYTE *)(v13 + 5) != 5 &&
                (unsigned int)v11 < *(_DWORD *)(v13 + 8))
              v11 = *(GfxImage **)(v13 + 8);
            ++v14;
            v13 += 12;
          } while (v7 != v14);
        }
        if (!v11)
          break;
        Image_Reload(v11);
      }
    }
  } else {
    ri(0, "Usage: reloadmaterialtextures <materialname>\n");
  }
}

int *__cdecl Material_Duplicate(Material *__src, char *__s2) {
  int v2;          // eax
  unsigned int v3; // edi
  int v4;          // esi
  const char **v5; // eax
  size_t v6;       // ebx
  _WORD *v7;       // edi
  int v8;          // eax
  int *v10;        // edi
  int v11;         // ebx

  v2 = R_HashAssetName(__s2);
  v3 = v2 & 0xFFFF03FF;
  v4 = v2 & 0x3FF;
  v5 = *(const char ***)&rg[4 * v4 + 40];
  if (v5) {
    while (strcmp(*v5, __s2)) {
      ++v3;
      LOWORD(v3) = v3 & 0x3FF;
      v4 = (unsigned __int16)v3;
      v5 = *(const char ***)&rg[4 * (unsigned __int16)v3 + 40];
      if (!v5)
        goto LABEL_4;
    }
    v10 = *(int **)&rg[4 * v4 + 40];
    v11 = *v10;
    memcpy(v10, __src, 0x44u);
    *v10 = v11;
    rgp[0] = 1;
    return v10;
  } else {
  LABEL_4:
    v6 = strlen(__s2) + 1;
    v7 = (_WORD *)(*(int(__cdecl **)(size_t)) & algn_11806C8[4])(v6 + 68);
    memcpy(v7, __src, 0x44u);
    *(_DWORD *)v7 = v7 + 34;
    memcpy(v7 + 34, __s2, v6);
    rgp[0] = 1;
    v7[4] = v4;
    v7[5] = rgp[1];
    v8 = rgp[1];
    rgp[v8 + 2] = v7;
    *(_DWORD *)&rg[4 * v4 + 40] = v7;
    rgp[1] = ++v8;
    if (v8 == 1024)
      R_Error(ERR_FATAL, "Too many unique materials (%i or more)\n", 1024);
    return (int *)v7;
  }
}

_DWORD *__cdecl R_LoadXSkins(XModel *a1) {
  int v1;                  // eax
  _DWORD *result;          // eax
  _DWORD *v3;              // edi
  int i;                   // edx
  int v5;                  // eax
  int Surfaces;            // esi
  int v7;                  // ebx
  const char *SurfaceName; // eax
  int v9;                  // ebx
  int v10;                 // esi
  _DWORD *v11;             // [esp+10h] [ebp-78h]
  int NumLods;             // [esp+14h] [ebp-74h]
  char *v13;               // [esp+18h] [ebp-70h]
  int v14;                 // [esp+1Ch] [ebp-6Ch]
  char __dst[64];          // [esp+28h] [ebp-60h] BYREF
  int *v16;                // [esp+68h] [ebp-20h] BYREF
  XSurface_s **v17[7];     // [esp+6Ch] [ebp-1Ch] BYREF

  NumLods = XModelGetNumLods(a1);
  if (NumLods > 0) {
    v9 = 0;
    v10 = 0;
    do
      v10 += XModelGetSurfaces(a1, v17, v9++, &v16);
    while (NumLods != v9);
    v1 = v10;
  } else {
    v1 = 0;
  }
  result = Model_Alloc(4 * (NumLods + v1));
  v11 = result;
  v13 = (char *)&result[NumLods];
  if (NumLods > 0) {
    v3 = result;
    v14 = 0;
    for (i = 0;; i = v5) {
      Surfaces = XModelGetSurfaces(a1, v17, i, &v16);
      *v3 = v13;
      v13 += 4 * Surfaces;
      if (Surfaces <= 0) {
        ++v14;
        ++v3;
        v5 = v14;
        if (NumLods == v14)
          return v11;
      } else {
        v7 = 0;
        do {
          SurfaceName = XModelGetSurfaceName(a1, v7, v14);
          strcpy(__dst, SurfaceName);
          strlwr(__dst);
          *(_DWORD *)(*v3 + 4 * v7++) = Material_RegisterHandle(__dst, 0, 8);
        } while (Surfaces != v7);
        ++v14;
        ++v3;
        v5 = v14;
        if (NumLods == v14)
          return v11;
      }
    }
  }
  return result;
}

int RB_IsGpuFenceFinished(void) {
  GLboolean v1; // al
  bool v2;      // bl

  if (!byte_1180608)
    return 1;
  v1 = glTestFenceAPPLE(g_FenceID);
  v2 = v1 != 0;
  if (v1)
    glDeleteFencesAPPLE(1, &g_FenceID);
  if (v2) {
    byte_1180608 = 0;
    return 1;
  }
  return 0;
}

int *__cdecl RB_GpuWaited(int a1) {
  int *result; // eax

  result = &dx;
  unk_1180604 = a1;
  return result;
}

void RB_AdaptiveGpuSyncWait(void) {
  unsigned __int64 v0; // rax
  __int64 v1;          // kr00_8
  GLboolean v2;        // al
  unsigned __int64 v3; // rax
  __int64 v4;          // [esp+10h] [ebp-28h]
  bool v5;             // [esp+1Fh] [ebp-19h]

  if (dword_11804C0 == 3) {
    v0 = __rdtsc();
    v1 = (unsigned int)v0 - (__int64)dword_1180604;
    dword_1180604 = 0;
    LODWORD(v4) = 0;
    while (byte_1180608) {
      v2 = glTestFenceAPPLE(g_FenceID);
      v5 = v2 != 0;
      if (v2)
        glDeleteFencesAPPLE(1, &g_FenceID);
      if (v5) {
        byte_1180608 = 0;
        break;
      }
      v3 = __rdtsc();
      v4 = (unsigned int)v3 - v1;
      if (v4 > 0x7FFFFFFF)
        return;
    }
    unk_1180600 -= (unk_1180600 - (int)v4) / 2;
  } else {
    while (byte_1180608) {
      if (glTestFenceAPPLE(g_FenceID)) {
        glDeleteFencesAPPLE(1, &g_FenceID);
        byte_1180608 = 0;
        return;
      }
    }
  }
}

int RB_AdaptiveGpuSyncTarget(void) {
  int result; // eax
  int v1;     // eax
  int v2;     // esi

  if (!byte_1180608)
    goto LABEL_2;
  LOBYTE(v1) = glTestFenceAPPLE(g_FenceID) != 0;
  v2 = v1;
  if ((_BYTE)v1)
    glDeleteFencesAPPLE(1, &g_FenceID);
  result = v2;
  if ((_BYTE)v2) {
    byte_1180608 = 0;
  LABEL_2:
    result = ~((unk_1180600 - 20000) >> 31);
    unk_1180600 = result & (unk_1180600 - 20000);
  }
  return result;
}

int R_ReleaseWorld(void) {
  int result; // eax

  result = *(_DWORD *)(dword_1184B9C + 48);
  if (result) {
    R_FreeStaticVertexBuffer(*(IDirect3DVertexBuffer9 **)(dword_1184B9C + 48));
    result = dword_1184B9C;
    *(_DWORD *)(dword_1184B9C + 48) = 0;
  }
  return result;
}

IDirect3DVertexBuffer9 *__cdecl R_CreateWorldVertexBuffer(GfxWorldVertex *__src,
                                                          int a2) {
  int v2;                     // esi
  int v3;                     // esi
  _DWORD *v4;                 // edx
  int v5;                     // ebx
  GfxWorldVertex *v6;         // ecx
  IDirect3DVertexBuffer9 *v8; // [esp+1Ch] [ebp-1Ch] BYREF

  v2 = 32;
  if (*(_DWORD *)(r_rendererInUse + 8) != 2)
    v2 = 68;
  v3 = a2 * v2;
  v4 = (_DWORD *)R_AllocStaticVertexBuffer(&v8, v3);
  if (*(_DWORD *)(r_rendererInUse + 8) == 2) {
    if (a2 > 0) {
      v5 = 0;
      v6 = __src;
      do {
        *v4 = LODWORD(v6->xyz[0]);
        v4[1] = LODWORD(v6->xyz[1]);
        v4[2] = LODWORD(v6->xyz[2]);
        v4[3] = v6->color.packed;
        v4[4] = LODWORD(v6->texCoord[0]);
        v4[5] = LODWORD(v6->texCoord[1]);
        v4[6] = LODWORD(v6->lmapCoord[0]);
        v4[7] = LODWORD(v6->lmapCoord[1]);
        ++v5;
        v4 += 8;
        ++v6;
      } while (a2 != v5);
    }
  } else {
    Com_Memcpy(v4, __src, v3);
  }
  R_FinishStaticVertexBuffer(v8);
  return v8;
}

int __cdecl R_FreeStaticVertexBuffer(IDirect3DVertexBuffer9 *a1) {
  int result; // eax

  while (1) {
    result =
        (*(int(__cdecl **)(IDirect3DVertexBuffer9 *))(*(_DWORD *)a1 + 8))(a1);
    if (!alwaysfails)
      break;
    a1 = 0;
  }
  return result;
}

int __cdecl R_FreeStaticIndexBuffer(IDirect3DIndexBuffer9 *a1) {
  int result; // eax

  while (1) {
    (*(void(__cdecl **)(IDirect3DIndexBuffer9 *))(*(_DWORD *)a1 + 8))(a1);
    result = alwaysfails;
    if (!alwaysfails)
      break;
    a1 = 0;
  }
  return result;
}

const char *__cdecl R_ParseSunLight(SunLightParseParams *a1, const char *a2) {
  char *v2;         // eax
  char v3;          // dl
  char *v5;         // eax
  int32_t v6;       // xmm0_4
  float v7;         // xmm0_4
  int32_t v8;       // xmm0_4
  char __src[2048]; // [esp+40h] [ebp-1018h] BYREF
  char __dst[2072]; // [esp+840h] [ebp-818h] BYREF

LABEL_1:
  v2 = Com_Parse((char **)&a2);
  v3 = *v2;
  if (*v2) {
    while (v3 != 125) {
      if (v3 != 123) {
        I_strncpyz(__dst, v2, 2048);
        v5 = Com_Parse((char **)&a2);
        if (!*v5 || *v5 == 125)
          return a2;
        I_strncpyz(__src, v5, 2048);
        if (I_stricmp(__dst, "ambient")) {
          if (I_stricmp(__dst, "_color")) {
            if (I_stricmp(__dst, "diffuseFraction")) {
              if (I_stricmp(__dst, "suncolor")) {
                if (I_stricmp(__dst, "sundiffusecolor")) {
                  if (I_stricmp(__dst, "sunlight")) {
                    if (I_stricmp(__dst, "sundirection")) {
                      if (!I_stricmp(__dst, "name"))
                        I_strncpyz(a1->name, __src, 64);
                    } else {
                      a1->angles[0] = 0.0;
                      a1->angles[1] = 0.0;
                      a1->angles[2] = 0.0;
                      sscanf(__src, "%f %f %f", a1->angles, &a1->angles[1],
                             &a1->angles[2]);
                    }
                  } else {
                    *(float *)&v8 = atof(__src);
                    a1->sunLight = v8;
                  }
                } else {
                  a1->diffuseColor[0] = 0.0;
                  a1->diffuseColor[1] = 0.0;
                  a1->diffuseColor[2] = 0.0;
                  sscanf(__src, "%f %f %f", a1->diffuseColor,
                         &a1->diffuseColor[1], &a1->diffuseColor[2]);
                  ColorNormalize(a1->diffuseColor, a1->diffuseColor);
                  a1->diffuseColorHasBeenSet = 1;
                }
              } else {
                a1->sunColor[0] = 0.0;
                a1->sunColor[1] = 0.0;
                a1->sunColor[2] = 0.0;
                sscanf(__src, "%f %f %f", a1->sunColor, &a1->sunColor[1],
                       &a1->sunColor[2]);
                ColorNormalize(a1->sunColor, a1->sunColor);
              }
            } else {
              v7 = atof(__src);
              a1->diffuseFraction = v7;
            }
          } else {
            a1->ambientColor[0] = 0.0;
            a1->ambientColor[1] = 0.0;
            a1->ambientColor[2] = 0.0;
            sscanf(__src, "%f %f %f", a1->ambientColor, &a1->ambientColor[1],
                   &a1->ambientColor[2]);
          }
        } else {
          *(float *)&v6 = atof(__src);
          a1->ambientScale = v6;
          if (*(float *)&v6 > 2.0) {
            Com_Printf(
                "^3WARNING: ambient too big, assuming it uses the old 0-255 "
                "scale instead of the proper 0-1 scale (value = '%s')\n",
                __src);
            *(float *)&a1->ambientScale =
                0.015686275 * *(float *)&a1->ambientScale;
          }
        }
        goto LABEL_1;
      }
      a1->ambientScale = 0;
      a1->sunLight = 0;
      a1->diffuseFraction = 0.5;
      a1->diffuseColorHasBeenSet = 0;
      a1->ambientColor[0] = 0.0;
      a1->ambientColor[1] = 0.0;
      a1->ambientColor[2] = 0.0;
      a1->sunColor[0] = 0.0;
      a1->sunColor[1] = 0.0;
      a1->sunColor[2] = 0.0;
      a1->diffuseColor[0] = 0.0;
      a1->diffuseColor[1] = 0.0;
      a1->diffuseColor[2] = 0.0;
      v2 = Com_Parse((char **)&a2);
      v3 = *v2;
      if (!*v2)
        return a2;
    }
  }
  return a2;
}

int R_GetMinSpecImageMemory(void) { return dword_C96BD0; }

int __cdecl Image_Create2DTexture(int a1, unsigned __int16 a2,
                                  unsigned __int16 a3, int a4, int a5, int a6,
                                  int a7) {
  int result;     // eax
  int v8;         // ebx
  const char *v9; // eax

  *(_WORD *)(a1 + 24) = a2;
  *(_WORD *)(a1 + 26) = a3;
  *(_WORD *)(a1 + 28) = 1;
  *(_DWORD *)a1 = 3;
  result = (*(int(__cdecl **)(int, _DWORD, _DWORD, int, int, int, int, int,
                              _DWORD))(*(_DWORD *)dword_117D8A8 + 92))(
      dword_117D8A8, a2, a3, a4, a5, a6, a7, a1 + 4, 0);
  v8 = result;
  if (result < 0) {
    v9 = (const char *)R_ErrorDescription();
    return R_Error(ERR_DROP,
                   "Create2DTexture( %s, %i, %i, %i, %i ) failed: %08x = %s",
                   *(const char **)(a1 + 32), *(unsigned __int16 *)(a1 + 24),
                   *(unsigned __int16 *)(a1 + 26), 0, a6, v8, v9);
  }
  return result;
}

int __cdecl Image_Create3DTexture(int a1, unsigned __int16 a2,
                                  unsigned __int16 a3, unsigned __int16 a4,
                                  int a5, int a6, int a7, int a8) {
  int result;      // eax
  int v9;          // ebx
  const char *v10; // eax

  *(_WORD *)(a1 + 24) = a2;
  *(_WORD *)(a1 + 26) = a3;
  *(_WORD *)(a1 + 28) = a4;
  *(_DWORD *)a1 = 4;
  result = (*(int(__cdecl **)(int, _DWORD, _DWORD, _DWORD, int, int, int, int,
                              int, _DWORD))(*(_DWORD *)dword_117D8A8 + 96))(
      dword_117D8A8, a2, a3, a4, a5, a6, a7, a8, a1 + 4, 0);
  v9 = result;
  if (result < 0) {
    v10 = (const char *)R_ErrorDescription();
    return R_Error(
        ERR_DROP, "Create3DTexture( %s, %i, %i, %i, %i, %i ) failed: %08x = %s",
        *(const char **)(a1 + 32), *(unsigned __int16 *)(a1 + 24),
        *(unsigned __int16 *)(a1 + 26), *(unsigned __int16 *)(a1 + 28), 0, a7,
        v9, v10);
  }
  return result;
}

int __cdecl Image_CreateCubeTexture(int a1, unsigned __int16 a2, int a3, int a4,
                                    int a5, int a6) {
  int v6;         // edi
  int result;     // eax
  int v8;         // ebx
  const char *v9; // eax

  v6 = a3;
  *(_WORD *)(a1 + 24) = a2;
  *(_WORD *)(a1 + 26) = a2;
  *(_WORD *)(a1 + 28) = 1;
  *(_DWORD *)a1 = 5;
  if (byte_118061B) {
    result = (*(int(__cdecl **)(int, _DWORD, int, _DWORD, int, int, int,
                                _DWORD))(*(_DWORD *)dword_117D8A8 + 100))(
        dword_117D8A8, a2, a3, 0, a5, a6, a1 + 4, 0);
  } else {
    v6 = 1;
    result = (*(int(__cdecl **)(int, _DWORD, int, _DWORD, int, int, int,
                                _DWORD))(*(_DWORD *)dword_117D8A8 + 100))(
        dword_117D8A8, a2, 1, 0, a5, a6, a1 + 4, 0);
  }
  v8 = result;
  if (result < 0) {
    v9 = (const char *)R_ErrorDescription();
    return R_Error(ERR_DROP,
                   "CreateCubeTexture ( %s, %i, %i, %i ) failed: %08x = %s",
                   *(const char **)(a1 + 32), *(unsigned __int16 *)(a1 + 24),
                   v6, a5, v8, v9);
  }
  return result;
}

int __cdecl Image_PicmipForSemantic(unsigned __int8 a1, Picmip *a2) {
  int result; // eax
  char v3;    // dl

  result = a1;
  if (a1 == 3) {
    result = dword_C96BC4;
    goto LABEL_10;
  }
  if (a1 <= 3u) {
    if (a1 != 2)
      goto LABEL_5;
    goto LABEL_7;
  }
  if (a1 == 4) {
    result = dword_C96BC8;
  LABEL_10:
    HIBYTE(a2->platform) = 2;
    if (result < 0)
      goto LABEL_8;
    goto LABEL_11;
  }
  if (a1 != 5) {
  LABEL_5:
    a2->platform = 0;
    return result;
  }
LABEL_7:
  result = dword_C96BC0;
  HIBYTE(a2->platform) = 2;
  if (result < 0) {
  LABEL_8:
    LOBYTE(a2->platform) = 0;
    return result;
  }
LABEL_11:
  v3 = 3;
  if (result < 4)
    v3 = result;
  LOBYTE(a2->platform) = v3;
  return result;
}

void R_SetPicmip(void) {
  unsigned int v0; // edi
  unsigned int v1; // esi
  int v2;          // eax
  char v3;         // dl

  v0 = R_AvailableTextureMemory();
  v1 = unk_11807A0("sys_sysMB");
  if (*(_BYTE *)(r_picmip_manual + 8)) {
    ri(0, "Picmip is set manually.\n");
    dword_C96BC0 = *(_DWORD *)(r_picmip + 8);
    dword_C96BC4 = *(_DWORD *)(r_picmip_bump + 8);
    dword_C96BC8 = *(_DWORD *)(r_picmip_spec + 8);
    goto LABEL_11;
  }
  if (*(_DWORD *)(r_rendererInUse + 8) == 2) {
    ri(0, "Texture detail is set automatically for DirectX 7.\n");
    if (v0 <= 0x80) {
      dword_C96BC0 = 2;
      dword_C96BC4 = 2;
      dword_C96BC8 = 2;
    } else {
      dword_C96BC0 = 1;
      dword_C96BC4 = 1;
      dword_C96BC8 = 1;
    }
    if (v1 > 0x17F)
      goto LABEL_11;
    v2 = 1;
  LABEL_16:
    if (dword_C96BC0 >= 1)
      goto LABEL_5;
  LABEL_17:
    dword_C96BC0 = v2;
    v3 = 1;
    goto LABEL_6;
  }
  ri(0, "Texture detail is set automatically.\n");
  dword_C96BC0 = 2;
  dword_C96BC4 = 2;
  dword_C96BC8 = 2;
  if (v1 > 0x17F) {
    if (v1 > 0x1DF)
      goto LABEL_11;
    v2 = 1;
    goto LABEL_16;
  }
  v2 = 2;
  if (dword_C96BC0 < 2)
    goto LABEL_17;
LABEL_5:
  v3 = 0;
LABEL_6:
  if (dword_C96BC4 < v2) {
    dword_C96BC4 = v2;
    v3 = 1;
  }
  if (dword_C96BC8 >= v2) {
    if (!v3)
      goto LABEL_11;
  } else {
    dword_C96BC8 = v2;
  }
  ri(0,
     "Reducing texture detail based on total system memory of %i MB to improve "
     "load times.\n",
     v1);
LABEL_11:
  dword_1180758(r_picmip, dword_C96BC0);
  dword_1180758(r_picmip_bump, dword_C96BC4);
  dword_1180758(r_picmip_spec, dword_C96BC8);
  ri(0,
     "Using picmip %i on most textures, %i on normal maps, and %i on specular "
     "maps\n",
     dword_C96BC0, dword_C96BC4, dword_C96BC8);
}

water_t *__cdecl R_LoadWaterSetup(const water_t *__src) {
  int v1;      // ebx
  water_t *v2; // esi

  if (dword_1181928 > 0) {
    v1 = 0;
    while (1) {
      v2 = (water_t *)&rg[68 * v1 + 4140];
      if (R_WatersEquivalent(v2, __src))
        break;
      if (++v1 >= dword_1181928) {
        if (v1 != 16)
          goto LABEL_3;
        Com_Printf("^1ERROR: map uses more than %i waterMap textures\n", 16);
        return 0;
      }
    }
  } else {
    v1 = 0;
  LABEL_3:
    v2 = (water_t *)&rg[68 * v1 + 4140];
    R_CreateWaterSetup(__src, v1, v2);
    ++dword_1181928;
  }
  return v2;
}

unsigned int R_ReloadLostImages(void) {
  int *v0;             // ebx
  unsigned int result; // eax
  unsigned __int8 v2;  // dl
  _BOOL4 v3;           // ecx

  v0 = imageGlobals;
  do {
    while (1) {
      result = *v0;
      if (*v0) {
        v2 = *(_BYTE *)(result + 30);
        if (v2 > 4u && !*(_DWORD *)(result + 4)) {
          v3 = result >= (unsigned int)&g_imageProgs &&
               result < (unsigned int)&unk_C94BB0;
          if (!v3 && v2 == 5)
            break;
        }
      }
      if (&dword_C96BC0 == ++v0)
        return result;
    }
    result = Image_BuildWaterMap((GfxImage *)*v0++);
  } while (&dword_C96BC0 != v0);
  return result;
}

int __cdecl Image_Alloc(char *__src, char a2, char a3, char a4) {
  size_t v4; // ebx
  int v5;    // edi
  int i;     // eax

  v4 = strlen(__src) + 1;
  v5 = (*(int(__cdecl **)(size_t)) & algn_11806C8[4])(v4 + 36);
  *(_DWORD *)(v5 + 32) = v5 + 36;
  memcpy((void *)(v5 + 36), __src, v4);
  *(_BYTE *)(v5 + 30) = a2;
  *(_BYTE *)(v5 + 10) = a3;
  *(_BYTE *)(v5 + 12) = a4;
  for (i = R_HashAssetName(__src) & 0x7FF; imageGlobals[i];
       i = ((_WORD)i + 1) & 0x7FF)
    ;
  imageGlobals[i] = v5;
  return v5;
}

int R_ReleaseLostImages(void) {
  int *v0;    // esi
  int v1;     // ebx
  int result; // eax
  int v3;     // edx
  int *v4;    // ecx
  int v5;     // edx

  v0 = &imageGlobals;
  do {
    v1 = *v0;
    if (*v0 && *(_BYTE *)(v1 + 30) > 4u) {
      if (*(_BYTE *)(v1 + 12) > 4u ||
          (result = 1 << *(_BYTE *)(v1 + 12), (result & 0x13) == 0)) {
        v3 = *v0;
        v4 = &imageGlobals;
        do {
          result = v4[2051] - *(_DWORD *)(v3 + 16);
          v4[2051] = result;
          ++v4;
          v3 += 4;
        } while (v4 != (int *)&unk_C94BC8);
      }
      v5 = *(_DWORD *)(v1 + 4);
      if (v5) {
        result = (*(int(__cdecl **)(_DWORD))(*(_DWORD *)v5 + 8))(
            *(_DWORD *)(v1 + 4));
        *(_DWORD *)(v1 + 4) = 0;
        *(_DWORD *)(v1 + 16) = 0;
        *(_DWORD *)(v1 + 20) = 0;
      }
      *(_DWORD *)v1 = 0;
    }
    ++v0;
  } while (v0 != &dword_C96BC0);
  return result;
}

int __cdecl Image_UpdatePicmip(GfxImage *a1) {
  int result;    // eax
  GfxImage *v2;  // edx
  int *v3;       // ecx
  GfxTexture v4; // edx
  Picmip v5;     // [esp+1Eh] [ebp-Ah] BYREF

  Image_GetPicmip(a1, &v5);
  result = LOBYTE(a1->picmip.platform);
  if ((_BYTE)result != LOBYTE(v5.platform)) {
    if (a1->track > 4u || ((1 << a1->track) & 0x13) == 0) {
      v2 = a1;
      v3 = imageGlobals;
      do {
        v3[2051] -= LODWORD(v2->cardMemory.platform);
        ++v3;
        v2 = (GfxImage *)((char *)v2 + 4);
      } while (v3 != (int *)&unk_C94BC8);
    }
    v4.basemap = (int32_t)a1->texture;
    if (v4.basemap) {
      (*(void(__cdecl **)(GfxTexture))(*(_DWORD *)v4.basemap + 8))(a1->texture);
      a1->texture.basemap = 0;
      a1->cardMemory.platform = 0;
    }
    a1->mapType = 0;
    a1->picmip = v5;
    result = Image_LoadFromFile(a1);
    if (!(_BYTE)result)
      return R_Error(ERR_DROP, "failed to load image '%s'",
                     *(const char **)a1->name);
  }
  return result;
}

int __cdecl Image_Reload(GfxImage *a1) {
  GfxTexture v1; // edx
  int result;    // eax
  GfxImage *v3;  // edx
  int *v4;       // ecx

  if (a1->track > 4u || ((1 << a1->track) & 0x13) == 0) {
    v3 = a1;
    v4 = imageGlobals;
    do {
      v4[2051] -= LODWORD(v3->cardMemory.platform);
      ++v4;
      v3 = (GfxImage *)((char *)v3 + 4);
    } while (v4 != (int *)&unk_C94BC8);
  }
  v1.basemap = (int32_t)a1->texture;
  if (v1.basemap) {
    (*(void(__cdecl **)(GfxTexture))(*(_DWORD *)v1.basemap + 8))(a1->texture);
    a1->texture.basemap = 0;
    a1->cardMemory.platform = 0;
  }
  a1->mapType = 0;
  result = Image_LoadFromFile(a1);
  if (!(_BYTE)result)
    return R_Error(ERR_DROP, "failed to load image '%s'",
                   *(const char **)a1->name);
  return result;
}

int __cdecl R_GetFrontBufferData(GLsizei height, int a2, int a3) {
  GLsizei v3;      // ecx
  GLsizei v4;      // edi
  GLint v5;        // ebx
  int k;           // esi
  char *v7;        // ecx
  _BYTE *v8;       // edx
  int m;           // ebx
  int i;           // esi
  char *v12;       // ecx
  _BYTE *v13;      // edx
  int j;           // ebx
  char *pixels;    // [esp+20h] [ebp-38h]
  int v16;         // [esp+24h] [ebp-34h]
  int v17;         // [esp+28h] [ebp-30h]
  int v18;         // [esp+2Ch] [ebp-2Ch]
  int v19;         // [esp+34h] [ebp-24h] BYREF
  char v20[4];     // [esp+38h] [ebp-20h] BYREF
  GLint params[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  v4 = v3;
  v16 = 4 * v3;
  pixels = (char *)calloc(1u, height * 4 * v3);
  glPushAttrib(0xFFFFFu);
  glPushClientAttrib(0xFFFFFFFF);
  glDisable((GLenum)&loc_861E + 2);
  if (MacDisplay::GetCardType() == 2) {
    glDisable(0x86DEu);
    glDisable(0x8522u);
  } else if (MacDisplay::GetCardType() == 1) {
    glDisable(0x8200u);
  }
  if ((unsigned int)MacOpenGLUtils::GetPCPixelShaderVersion() > 0xFFFF01FF)
    glDisable(0x8804u);
  glDisable(0xB50u);
  glDisable(0xBE2u);
  glDisable(0xBC0u);
  glDisable(0xB71u);
  glDisable(0xBD0u);
  glColorMask(1u, 1u, 1u, 1u);
  glDepthMask(1u);
  glDisable(0xB44u);
  glDisable(0xB60u);
  glActiveTextureARB(0x84C0u);
  glDisable(0xB90u);
  glGetIntegerv(0x84E2u, params);
  if (params[0] > 0) {
    v5 = 0;
    do {
      glActiveTextureARB(v5 + 33984);
      glDisable(0xDE1u);
      glDisable(0x84F5u);
      glDisable(0x806Fu);
      glDisable(0x8513u);
      ++v5;
    } while (v5 < params[0]);
  }
  MacDisplay::GetCurrentDimensions((MacDisplay *)v20, &v19);
  glReadBuffer(0x404u);
  glReadPixels(0, v19 - height, v4, height, 0x80E1u, 0x8035u, pixels);
  glPopClientAttrib();
  glPopAttrib();
  if (!glGetError()) {
    if (a2 == 3) {
      if (height > 0) {
        v17 = 3 * height - 3;
        for (i = 0; i != height; ++i) {
          v12 = &pixels[i * v16];
          v13 = (_BYTE *)(v4 * v17 + a3);
          if (v4 > 0) {
            for (j = 0; j != v4; ++j) {
              *v13 = v12[3];
              v13[1] = v12[2];
              v13[2] = v12[1];
              v13 += 3;
              v12 += 4;
            }
          }
          v17 -= 3;
        }
      }
      goto LABEL_18;
    }
    if (a2 == 4) {
      if (height > 0) {
        v18 = 4 * height - 4;
        for (k = 0; k != height; ++k) {
          v7 = &pixels[k * v16];
          v8 = (_BYTE *)(v4 * v18 + a3);
          if (v4 > 0) {
            for (m = 0; m != v4; ++m) {
              *v8 = v7[3];
              v8[1] = v7[2];
              v8[2] = v7[1];
              v8 += 4;
              v7 += 4;
            }
          }
          v18 -= 4;
        }
      }
    LABEL_18:
      free(pixels);
      return 1;
    }
  }
  free(pixels);
  return 0;
}

char *__cdecl R_DescribeFormat(int a1) {
  char *result; // eax

  switch (a1) {
  case 21:
  case 32:
    result = "24-bit color with 8-bit alpha";
    break;
  case 23:
    result = "16-bit color";
    break;
  case 25:
    result = "15-bit color with 1-bit alpha";
    break;
  case 70:
  case 80:
    result = "16-bit depth without stencil";
    break;
  case 73:
    result = "15-bit depth with 1-bit stencil";
    break;
  case 75:
    result = "24-bit depth with 8-bit stencil";
    break;
  case 77:
    result = "24-bit depth without stencil";
    break;
  default:
    result = va("unknown format 0x%08x", a1);
    break;
  }
  return result;
}

int __cdecl RB_DeriveEntityLights(float *a1, int a2, int a3, char *__b,
                                  int a5) {
  int v5;     // eax
  float *v6;  // ecx
  float *v7;  // eax
  float *v8;  // edx
  float v9;   // xmm4_4
  float v10;  // xmm3_4
  float v11;  // xmm1_4
  float v12;  // xmm0_4
  float v13;  // xmm1_4
  float v14;  // xmm3_4
  float *v16; // ecx
  float *v17; // ebx
  float *v18; // edx
  float *v19; // edi
  int i;      // ecx
  float v21;  // xmm7_4
  int v22;    // ecx
  float *v23; // edx
  int v24;    // eax
  float v25;  // xmm2_4
  float v26;  // xmm1_4
  char v27;   // al
  int v28;    // ecx
  float v29;  // xmm2_4
  float *v30; // edx
  int v31;    // eax
  float v32;  // xmm1_4
  float *v33; // ecx
  float *v34; // esi
  int v35;    // ebx
  float v36;  // xmm6_4
  float v37;  // xmm3_4
  float v38;  // xmm2_4
  float *v39; // eax
  int v40;    // edx
  float v41;  // xmm1_4
  float v42;  // xmm4_4
  float v43;  // xmm5_4
  float v44;  // xmm3_4
  float v45;  // xmm2_4
  float *v46; // eax
  float *v47; // edx
  float v48;  // xmm1_4
  float v49;  // xmm3_4
  float v50;  // xmm4_4
  float *v51; // edx
  int v52;    // [esp+28h] [ebp-A0h]
  float v53;  // [esp+2Ch] [ebp-9Ch]
  float v54;  // [esp+30h] [ebp-98h]
  float v55;  // [esp+34h] [ebp-94h]
  float *v56; // [esp+38h] [ebp-90h]
  int v57;    // [esp+3Ch] [ebp-8Ch]
  char v58;   // [esp+44h] [ebp-84h] BYREF
  char v59;   // [esp+48h] [ebp-80h] BYREF
  char v60;   // [esp+4Ch] [ebp-7Ch] BYREF
  float v61;  // [esp+A4h] [ebp-24h] BYREF
  float v62;  // [esp+A8h] [ebp-20h]
  float v63;  // [esp+ACh] [ebp-1Ch]

  v5 = *(_DWORD *)(*(_DWORD *)(a3 + 56) + 64);
  if (!v5 || !*(_BYTE *)(v5 + 14)) {
    memset(__b, 0, 104 * a5);
    v16 = a1;
    v17 = a1 + 8;
    v18 = a1 + 16;
    v19 = (float *)&v58;
    do {
      *v19 = *v16;
      v19[1] = *v17;
      v19[2] = *v18;
      ++v16;
      v19 += 3;
      ++v17;
      ++v18;
    } while (v19 != &v61);
    v56 = (float *)__b;
    v57 = 0;
    for (i = 0;; i = v52) {
      v52 = i + 1;
      if (a5 <= i + 1) {
      LABEL_31:
        v51 = (float *)&__b[104 * v57];
        *(_DWORD *)v51 = 3;
        v51[9] = *(float *)(dword_1184B9C + 212) * 0.5;
        v51[10] = *(float *)(dword_1184B9C + 216) * 0.5;
        v51[11] = *(float *)(dword_1184B9C + 220) * 0.5;
        v51[1] = (float)(*(float *)&a2 * *(float *)(dword_1184B9C + 200)) * 0.5;
        v51[2] = (float)(*(float *)&a2 * *(float *)(dword_1184B9C + 204)) * 0.5;
        v51[3] = 0.5 * (float)(*(float *)&a2 * *(float *)(dword_1184B9C + 208));
        v51[16] = -*(float *)(dword_1184B9C + 184);
        v51[17] = -*(float *)(dword_1184B9C + 188);
        v51[18] = -*(float *)(dword_1184B9C + 192);
        return v52;
      }
      v61 = 0.0;
      v62 = 0.0;
      v63 = 0.0;
      v21 = 0.0;
      v22 = 0;
      v23 = (float *)&v58;
      v24 = 0;
      do {
        v25 =
            (float)((float)(0.29899999 * *v23) + (float)(0.58700001 * v23[1])) +
            (float)(0.114 * v23[2]);
        v26 = fabs(v25);
        v61 = (float)(v26 * *(float *)&gridBasisDirs[v24]) + v61;
        v62 = (float)(v26 * *(float *)&dword_2F2A04[v24]) + v62;
        v63 = (float)(v26 * *(float *)&dword_2F2A08[v24]) + v63;
        v21 = v21 + (float)(v25 * v25);
        ++v22;
        v24 += 3;
        v23 += 3;
      } while (v22 != 8);
      if (v21 < 0.00079999998)
        goto LABEL_13;
      Vec3Normalize(&v61);
      v28 = 0;
      v53 = 0.0;
      v29 = 0.0;
      v54 = 0.0;
      v55 = 0.0;
      v30 = (float *)&v58;
      v31 = 0;
      do {
        v32 = (float)((float)(v61 * *(float *)&gridBasisDirs[v31]) +
                      (float)(v62 * *(float *)&dword_2F2A04[v31])) +
              (float)(v63 * *(float *)&dword_2F2A08[v31]);
        if (v32 > 0.0099999998) {
          v55 = (float)(v32 * *v30) + v55;
          v54 = (float)(v32 * v30[1]) + v54;
          v53 = (float)(v32 * v30[2]) + v53;
          v29 = v29 + v32;
        }
        ++v28;
        v31 += 3;
        v30 += 3;
      } while (v28 != 8);
      if (v29 != 0.0) {
        v55 = v55 * (float)(1.0 / v29);
        v54 = v54 * (float)(1.0 / v29);
        v53 = (float)(1.0 / v29) * v53;
      }
      v33 = (float *)&v60;
      v34 = (float *)&v59;
      v35 = 0;
      v36 = 0.0;
      v37 = 0.0;
      v38 = 0.0;
      v39 = (float *)&v58;
      v40 = 0;
      do {
        v41 = (float)((float)(*(float *)&gridBasisDirs[v40] * v61) +
                      (float)(*(float *)&dword_2F2A04[v40] * v62)) +
              (float)(*(float *)&dword_2F2A08[v40] * v63);
        if (v41 > 0.0) {
          *(v33 - 2) = (float)(v55 * (float)-v41) + *(v33 - 2);
          v39[1] = (float)(v54 * (float)-v41) + v39[1];
          v39[2] = (float)((float)-v41 * v53) + v39[2];
        }
        v38 = v38 + *v39;
        v37 = v37 + *v34;
        v36 = v36 + *v33;
        ++v35;
        v40 += 3;
        v33 += 3;
        v34 += 3;
        v39 += 3;
      } while (v35 != 8);
      v42 = v38 * 0.125;
      v43 = v37 * 0.125;
      v44 = 0.125 * v36;
      v45 = 0.0;
      v46 = (float *)&v58;
      v47 = (float *)&v58;
      do {
        *v46 = *v46 - v42;
        v46[1] = v46[1] - v43;
        v46[2] = v46[2] - v44;
        v48 =
            (float)((float)(0.29899999 * *v47) + (float)(v47[1] * 0.58700001)) +
            (float)(v47[2] * 0.114);
        v45 = v45 + (float)(v48 * v48);
        v46 += 3;
        v47 += 3;
      } while (v46 != v19);
      if ((float)(v21 - v45) < 0.020000001) {
      LABEL_13:
        v27 = 0;
      } else {
        *(_DWORD *)v56 = 3;
        v56[9] = v42 * 0.5;
        v56[10] = v43 * 0.5;
        v56[11] = v44 * 0.5;
        v56[1] = 0.5 * v55;
        v56[2] = 0.5 * v54;
        v56[3] = 0.5 * v53;
        v49 = v62;
        v50 = v63;
        if ((float)((float)((float)(v61 * v61) + (float)(v49 * v49)) +
                    (float)(v50 * v50)) < 0.0000010000001) {
          v56[16] = 0.0;
          v56[17] = 0.0;
          v56[18] = 1.0;
          v56 += 26;
          goto LABEL_15;
        }
        v56[16] = -v61;
        v56[17] = -v49;
        v56[18] = -v50;
        v27 = 1;
      }
      v56 += 26;
      if (!v27)
        goto LABEL_31;
    LABEL_15:
      v57 = v52;
    }
  }
  memset(__b, 0, 104 * a5);
  v6 = a1;
  v7 = a1 + 8;
  v8 = a1 + 16;
  v9 = 0.0;
  v10 = 0.0;
  v11 = 0.0;
  do {
    v11 = v11 + *v6;
    v10 = v10 + *v7;
    v9 = v9 + *v8;
    ++v6;
    ++v7;
    ++v8;
  } while (a1 + 16 != v7);
  *(_DWORD *)__b = 3;
  *((float *)__b + 9) = (float)(v11 * 0.125) * 0.5;
  *((float *)__b + 10) = (float)(v10 * 0.125) * 0.5;
  *((float *)__b + 11) = (float)(v9 * 0.125) * 0.5;
  *((_DWORD *)__b + 18) = 1065353216;
  v12 = (float)(*(float *)&a2 * *(float *)(dword_1184B9C + 200)) +
        *(float *)(dword_1184B9C + 212);
  v13 = (float)(*(float *)&a2 * *(float *)(dword_1184B9C + 204)) +
        *(float *)(dword_1184B9C + 216);
  v14 = (float)(*(float *)&a2 * *(float *)(dword_1184B9C + 208)) +
        *(float *)(dword_1184B9C + 220);
  *((_DWORD *)__b + 26) = 3;
  *((float *)__b + 35) = v12 * 0.5;
  *((float *)__b + 36) = v13 * 0.5;
  *((float *)__b + 37) = 0.5 * v14;
  *((_DWORD *)__b + 44) = 1065353216;
  return 2;
}

int32_t __cdecl R_DuplicateFont(Font_s *a1, char *a2) {
  int v2;         // eax
  Font_s *v3;     // ebx
  char *v4;       // esi
  int32_t result; // eax
  char ***v6;     // esi
  char **v7;      // ebx
  char *v8;       // edx
  int v9;         // [esp+1Ch] [ebp-1Ch]

  v2 = registeredFontCount;
  if (registeredFontCount > 0) {
    v9 = 0;
    v6 = (char ***)registeredFont;
    while (1) {
      v7 = *v6;
      if (!I_stricmp(a2, **v6))
        break;
      ++v9;
      v2 = registeredFontCount;
      ++v6;
      if (v9 >= registeredFontCount)
        goto LABEL_3;
    }
    v8 = *v7;
    *v7 = *(char **)a1->name;
    v7[1] = (char *)a1->pixelHeight;
    v7[2] = (char *)a1->glyphCount;
    v7[3] = (char *)a1->material;
    result = a1->glyphs;
    v7[4] = (char *)result;
    *v7 = v8;
  } else {
    v9 = 0;
  LABEL_3:
    if (v2 > 15) {
      return R_Error(ERR_DROP,
                     "R_DuplicateFont: Too many fonts registered already.\n");
    } else {
      v3 = (Font_s *)(*(int(__cdecl **)(int)) & algn_11806C8[4])(20);
      *v3 = *a1;
      v4 = (char *)(*(int(__cdecl **)(unsigned int)) &
                    algn_11806C8[4])(strlen(a2) + 1);
      strcpy(v4, a2);
      *(_DWORD *)v3->name = v4;
      result = v9;
      registeredFont[v9] = (int)v3;
      ++registeredFontCount;
    }
  }
  return result;
}

void R_InitFonts(void) { ; }

void R_ShutdownFonts(void) { registeredFontCount = 0; }

void __usercall R_GetSidePlaneNormals(float *a1 @<eax>, int a2 @<edx>,
                                      float *a3 @<ecx>) {
  int v3;     // edx
  float v4;   // xmm3_4
  float v5;   // xmm2_4
  float v6;   // xmm1_4
  float *v7;  // ecx
  int v8;     // edx
  float *v9;  // eax
  float *v10; // edx
  float *v11; // ebx
  float *v12; // edi
  float *v13; // esi
  float *v14; // eax
  float *v15; // esi
  int i;      // edi
  float *v17; // ebx
  int v21;    // [esp+1Ch] [ebp-62Ch]
  float v22;  // [esp+24h] [ebp-624h] BYREF
  float v23;  // [esp+28h] [ebp-620h]
  float v24;  // [esp+2Ch] [ebp-61Ch]

  if (*(float *)&stru_C96E68.coeffs[12] == 0.0) {
    v3 = a2 - 1;
    if (a2 > 0) {
      v15 = a1;
      for (i = 0;; ++i) {
        v22 = *v15 - a1[3 * v3];
        v23 = v15[1] - a1[3 * v3 + 1];
        v24 = v15[2] - a1[3 * v3 + 2];
        v17 = &a3[3 * v3];
        Vec3Cross((float *)stru_C96E68.coeffs, &v22, v17);
        Vec3Normalize(v17);
        v15 += 3;
        v3 = i;
        if (a2 == i + 1)
          break;
      }
    }
  } else {
    if (a2 > 0) {
      v4 = *(float *)stru_C96E68.coeffs;
      v5 = *(float *)&stru_C96E68.coeffs[4];
      v6 = *(float *)&stru_C96E68.coeffs[8];
      v7 = a1;
      v8 = 0;
      do {
        v9 = &v22 + 3 * v8;
        *v9 = *v7 - v4;
        v9[1] = v7[1] - v5;
        v9[2] = v7[2] - v6;
        ++v8;
        v7 += 3;
      } while (a2 != v8);
    }
    v10 = &v22 + 3 * a2;
    *v10 = v22;
    v10[1] = v23;
    v10[2] = v24;
    if (a2 > 0) {
      v11 = a3;
      v21 = 0;
      v12 = &v22;
      v13 = &v22;
      do {
        v14 = v13;
        ++v21;
        v13 += 3;
        v12 += 3;
        Vec3Cross(v12, v14, v11);
        Vec3Normalize(v11);
        v11 += 3;
      } while (a2 != v21);
    }
  }
}

void __cdecl R_FrustumClipPlanes(float *a1, float *a2, int a3, int a4) {
  int i;     // edi
  float *v7; // edx
  int v8;    // ebx
  float *v9; // eax
  float v10; // xmm1_4
  char v11;  // al
  char v12;  // al
  char v13;  // al

  if (a3 > 0) {
    for (i = 0; i != a3; ++i) {
      v7 = (float *)a4;
      v8 = 0;
      v9 = a1;
      do {
        *v7 = (float)((float)((float)(*a2 * *v9) + (float)(a2[1] * v9[1])) +
                      (float)(a2[2] * v9[2])) +
              (float)(a2[3] * v9[3]);
        ++v8;
        v9 += 4;
        ++v7;
      } while (v8 != 4);
      v10 = 1.0 /
            fsqrt((float)((float)(*(float *)a4 * *(float *)a4) +
                          (float)(*(float *)(a4 + 4) * *(float *)(a4 + 4))) +
                  (float)(*(float *)(a4 + 8) * *(float *)(a4 + 8)));
      *(float *)a4 = v10 * *(float *)a4;
      *(float *)(a4 + 4) = v10 * *(float *)(a4 + 4);
      *(float *)(a4 + 8) = v10 * *(float *)(a4 + 8);
      *(float *)(a4 + 12) = v10 * *(float *)(a4 + 12);
      v11 = 12;
      if (*(int *)a4 <= 0)
        v11 = 0;
      *(_BYTE *)(a4 + 16) = v11;
      v12 = 16;
      if (*(int *)(a4 + 4) <= 0)
        v12 = 4;
      *(_BYTE *)(a4 + 17) = v12;
      v13 = 20;
      if (*(int *)(a4 + 8) <= 0)
        v13 = 8;
      *(_BYTE *)(a4 + 18) = v13;
      *(_BYTE *)(a4 + 19) = -1;
      a4 += 20;
      a2 += 4;
    }
  }
}

int __cdecl R_CheckDxCaps(int a1) {
  char *v1;        // esi
  int v2;          // edi
  int v3;          // ecx
  int v4;          // edx
  int v5;          // eax
  int v6;          // ebx
  char *v7;        // esi
  int v8;          // edi
  unsigned int v9; // eax
  int v10;         // ebx
  int v12;         // [esp+14h] [ebp-34h]
  const char *v13; // [esp+18h] [ebp-30h]
  const char *v14; // [esp+1Ch] [ebp-2Ch]
  int v15;         // [esp+28h] [ebp-20h] BYREF
  int v16[7];      // [esp+2Ch] [ebp-1Ch] BYREF

  MacDisplay::GetVideoMemoryInfo((MacDisplay *)v16, &v15);
  v12 = 2 * (v16[0] >= 67108865) + 4;
  v1 = (char *)&s_capsCheckBits;
  do {
    while (1) {
      v3 = *(_DWORD *)(*(_DWORD *)v1 + a1);
      v4 = *((_DWORD *)v1 + 2);
      if (!v4 || (~v3 & v4) != 0) {
        v5 = *((_DWORD *)v1 + 1);
        if (!v5 || (v5 & v3) != 0)
          break;
      }
    LABEL_7:
      v1 += 20;
      if (v1 == (char *)&unk_330770)
        goto LABEL_15;
    }
    v13 = (const char *)*((_DWORD *)v1 + 4);
    v6 = *((_DWORD *)v1 + 3);
    if (v6 != 1 && v6 != 3) {
      v2 = 0;
      ri(0, "Video card or driver %s.\n", v13);
    LABEL_4:
      if (v6 == 4) {
        v12 &= ~2u;
        ri(v2, "  DirectX 9 rendering path will not be available.\n");
      } else if (!v6) {
        R_Error(ERR_FATAL, "Video card or driver %s.\n", v13);
      }
      goto LABEL_7;
    }
    v2 = 2;
    ri(2, "Video card or driver %s.\n", v13);
    if (v6 != 3)
      goto LABEL_4;
    v12 &= ~4u;
    ri(2, "  DirectX 7 rendering path will not be available.\n");
    v1 += 20;
  } while (v1 != (char *)&unk_330770);
LABEL_15:
  v7 = (char *)&s_capsCheckInt;
  while (2) {
    while (1) {
      v9 = *(_DWORD *)(*(_DWORD *)v7 + a1);
      if (v9 < *((_DWORD *)v7 + 1) || v9 > *((_DWORD *)v7 + 2))
        break;
    LABEL_21:
      v7 += 20;
      if (v7 == (char *)&s_capsCheckBits)
        return v12;
    }
    v14 = (const char *)*((_DWORD *)v7 + 4);
    v10 = *((_DWORD *)v7 + 3);
    if (v10 != 1 && v10 != 3) {
      v8 = 0;
      ri(0, "Video card or driver %s.\n", v14);
      goto LABEL_18;
    }
    v8 = 2;
    ri(2, "Video card or driver %s.\n", v14);
    if (v10 != 3) {
    LABEL_18:
      if (v10 == 4) {
        v12 &= ~2u;
        ri(v8, "  DirectX 9 rendering path will not be available.\n");
      } else if (!v10) {
        R_Error(ERR_FATAL, "Video card or driver %s.\n", v14);
      }
      goto LABEL_21;
    }
    v12 &= ~4u;
    ri(2, "  DirectX 7 rendering path will not be available.\n");
    v7 += 20;
    if (v7 != (char *)&s_capsCheckBits)
      continue;
    return v12;
  }
}

void R_Cmd_LoadSun(void) {
  int v0;         // ebx
  const char *v1; // eax

  if (unk_11807C0() == 2) {
    if (*(_BYTE *)(sv_cheats + 8)) {
      v0 = dword_1184B9C;
      if (dword_1184B9C) {
        v1 = (const char *)unk_11807C4(1);
        R_LoadSunThroughDvars(v1, (sunflare_t *)(v0 + 352));
      } else {
        ri(0, "You can't r_loadsun while a map isn't loaded\n");
      }
    } else {
      ri(0, "You must have cheats enabled to use r_loadsun\n");
    }
  } else {
    ri(0, "USAGE: r_loadsun <sunname>\n  sunname must not have an extension\n");
  }
}

int __cdecl RB_SetVertexData(unsigned int a1, int *__src, int a3,
                             unsigned int a4) {
  unsigned int v4;             // ebx
  int v5;                      // ecx
  _DWORD *v6;                  // eax
  int v7;                      // edx
  IDirect3DVertexBuffer9 *v8;  // ebx
  int result;                  // eax
  int v10;                     // ecx
  int v11;                     // ebx
  int v12;                     // esi
  int v13;                     // edi
  int v14;                     // ecx
  int v15;                     // ebx
  int v16;                     // esi
  int v17;                     // edi
  int v18;                     // ebx
  int v19;                     // esi
  int v20;                     // edi
  int v21;                     // ebx
  int v22;                     // esi
  int v23;                     // edi
  int v24;                     // ebx
  int v25;                     // esi
  int v26;                     // edi
  int v27;                     // [esp+2Ch] [ebp-FCh]
  int v28;                     // [esp+2Ch] [ebp-FCh]
  unsigned int v29;            // [esp+48h] [ebp-E0h]
  IDirect3DVertexBuffer9 *v30; // [esp+4Ch] [ebp-DCh]
  int __n;                     // [esp+50h] [ebp-D8h]
  int *v32;                    // [esp+54h] [ebp-D4h]
  _DWORD *v33;                 // [esp+58h] [ebp-D0h]
  int *ColorConverter;         // [esp+5Ch] [ebp-CCh]
  unsigned int k;              // [esp+60h] [ebp-C8h]
  int v36;                     // [esp+64h] [ebp-C4h]
  int v37;                     // [esp+68h] [ebp-C0h]
  int v38;                     // [esp+6Ch] [ebp-BCh]
  int v39;                     // [esp+70h] [ebp-B8h]
  int v40;                     // [esp+74h] [ebp-B4h]
  unsigned int j;              // [esp+78h] [ebp-B0h]
  int v42;                     // [esp+7Ch] [ebp-ACh]
  int v43;                     // [esp+80h] [ebp-A8h]
  int v44;                     // [esp+84h] [ebp-A4h]
  int v45;                     // [esp+88h] [ebp-A0h]
  unsigned int i;              // [esp+8Ch] [ebp-9Ch]
  int v47;                     // [esp+90h] [ebp-98h]
  int v48;                     // [esp+94h] [ebp-94h]
  unsigned int m;              // [esp+98h] [ebp-90h]
  int v50;                     // [esp+9Ch] [ebp-8Ch]
  int v51;                     // [esp+A0h] [ebp-88h]
  int v52;                     // [esp+A4h] [ebp-84h]
  int v53;                     // [esp+A8h] [ebp-80h]
  int v54;                     // [esp+ACh] [ebp-7Ch]
  int v55;                     // [esp+B0h] [ebp-78h]
  int v56;                     // [esp+B4h] [ebp-74h]
  int v57;                     // [esp+B8h] [ebp-70h]
  int v58;                     // [esp+BCh] [ebp-6Ch]
  unsigned int n;              // [esp+C0h] [ebp-68h]
  int v60;                     // [esp+C4h] [ebp-64h]
  int v61;                     // [esp+C8h] [ebp-60h]
  int v62;                     // [esp+CCh] [ebp-5Ch]
  int v63;                     // [esp+D0h] [ebp-58h]
  int v64;                     // [esp+D4h] [ebp-54h]
  int v65;                     // [esp+D8h] [ebp-50h]
  int v66;                     // [esp+DCh] [ebp-4Ch]
  int v67;                     // [esp+E0h] [ebp-48h]
  int v68;                     // [esp+E4h] [ebp-44h]
  int v69;                     // [esp+E8h] [ebp-40h]
  int v70;                     // [esp+ECh] [ebp-3Ch]
  int v71;                     // [esp+F0h] [ebp-38h]
  int v72;                     // [esp+F4h] [ebp-34h]
  int v73;                     // [esp+F8h] [ebp-30h]
  int v74;                     // [esp+FCh] [ebp-2Ch]
  int v75;                     // [esp+108h] [ebp-20h] BYREF
  void *__dst;                 // [esp+10Ch] [ebp-1Ch] BYREF

  __n = a3 * a4;
  v30 = *(IDirect3DVertexBuffer9 **)(dword_1180654 + 8);
  if ((*(int(__cdecl **)(IDirect3DVertexBuffer9 *, _DWORD, unsigned int,
                         void **, int))(*(_DWORD *)v30 + 44))(
          v30, *(_DWORD *)dword_1180654, a3 * a4, &__dst,
          *(_DWORD *)dword_1180654 == 0 ? 0x2000 : 4096) < 0)
    R_FatalLockError();
  v29 = __n / (int)a4;
  v4 = a4 >> 2;
  v32 = __src;
  v33 = __dst;
  ColorConverter = CColorConverter::GetColorConverter(0);
  switch (a4) {
  case 0x14u:
    Com_Memcpy(__dst, __src, __n);
    break;
  case 0x18u:
    if (v29) {
      v70 = 4 * v4;
      for (i = 0; i < v29; ++i) {
        v24 = *v32;
        v25 = v32[1];
        v26 = v32[2];
        v47 = v32[4];
        v48 = v32[5];
        (*(void(__cdecl **)(int *, int *, int *)) *
         ColorConverter)(ColorConverter, &v75, v32 + 3);
        *v33 = v24;
        v33[1] = v25;
        v33[2] = v26;
        v33[3] = v75;
        v33[4] = v47;
        v33[5] = v48;
        v32 = (int *)((char *)v32 + v70);
        v33 = (_DWORD *)((char *)v33 + v70);
      }
    }
    break;
  case 0x20u:
    if (v29) {
      v71 = 4 * v4;
      for (j = 0; j < v29; ++j) {
        v21 = *v32;
        v22 = v32[1];
        v23 = v32[2];
        v42 = v32[4];
        v43 = v32[5];
        v44 = v32[6];
        v45 = v32[7];
        (*(void(__cdecl **)(int *, int *, int *)) *
         ColorConverter)(ColorConverter, &v75, v32 + 3);
        *v33 = v21;
        v33[1] = v22;
        v33[2] = v23;
        v33[3] = v75;
        v33[4] = v42;
        v33[5] = v43;
        v33[6] = v44;
        v33[7] = v45;
        v32 = (int *)((char *)v32 + v71);
        v33 = (_DWORD *)((char *)v33 + v71);
      }
    }
    break;
  case 0x24u:
    if (v29) {
      v72 = 4 * v4;
      for (k = 0; k < v29; ++k) {
        v18 = *v32;
        v19 = v32[1];
        v20 = v32[2];
        v36 = v32[3];
        v37 = v32[4];
        v38 = v32[5];
        v39 = v32[7];
        v40 = v32[8];
        (*(void(__cdecl **)(int *, int *, int *)) *
         ColorConverter)(ColorConverter, &v75, v32 + 6);
        *v33 = v18;
        v33[1] = v19;
        v33[2] = v20;
        v33[3] = v36;
        v33[4] = v37;
        v33[5] = v38;
        v33[6] = v75;
        v33[7] = v39;
        v33[8] = v40;
        v32 = (int *)((char *)v32 + v72);
        v33 = (_DWORD *)((char *)v33 + v72);
      }
    }
    break;
  case 0x40u:
    if (v29) {
      v73 = 4 * v4;
      for (m = 0; m < v29; ++m) {
        v28 = v32[1];
        v14 = v32[2];
        v15 = v32[3];
        v16 = v32[4];
        v17 = v32[5];
        v50 = v32[6];
        v51 = v32[8];
        v52 = v32[9];
        v53 = v32[10];
        v54 = v32[11];
        v55 = v32[12];
        v56 = v32[13];
        v57 = v32[14];
        v58 = v32[15];
        *v33 = *v32;
        v33[1] = v28;
        v33[2] = v14;
        v33[3] = v15;
        v33[4] = v16;
        v33[5] = v17;
        v33[6] = v50;
        (*(void(__cdecl **)(int *, int *, int *)) *
         ColorConverter)(ColorConverter, &v75, v32 + 7);
        v33[7] = v75;
        v33[8] = v51;
        v33[9] = v52;
        v33[10] = v53;
        v33[11] = v54;
        v33[12] = v55;
        v33[13] = v56;
        v33[14] = v57;
        v33[15] = v58;
        v32 = (int *)((char *)v32 + v73);
        v33 = (_DWORD *)((char *)v33 + v73);
      }
    }
    break;
  case 0x44u:
    if (v29) {
      v74 = 4 * v4;
      for (n = 0; n < v29; ++n) {
        v27 = v32[1];
        v10 = v32[2];
        v11 = v32[3];
        v12 = v32[4];
        v13 = v32[5];
        v60 = v32[7];
        v61 = v32[8];
        v62 = v32[9];
        v63 = v32[10];
        v64 = v32[11];
        v65 = v32[12];
        v66 = v32[13];
        v67 = v32[14];
        v68 = v32[15];
        v69 = v32[16];
        *v33 = *v32;
        v33[1] = v27;
        v33[2] = v10;
        v33[3] = v11;
        v33[4] = v12;
        v33[5] = v13;
        (*(void(__cdecl **)(int *, int *, int *)) *
         ColorConverter)(ColorConverter, &v75, v32 + 6);
        v33[6] = v75;
        v33[7] = v60;
        v33[8] = v61;
        v33[9] = v62;
        v33[10] = v63;
        v33[11] = v64;
        v33[12] = v65;
        v33[13] = v66;
        v33[14] = v67;
        v33[15] = v68;
        v33[16] = v69;
        v32 = (int *)((char *)v32 + v74);
        v33 = (_DWORD *)((char *)v33 + v74);
      }
    }
    break;
  default:
    goto LABEL_5;
  }
  do
  LABEL_5:
    (*(void(__cdecl **)(IDirect3DVertexBuffer9 *))(*(_DWORD *)v30 + 48))(v30);
  while (alwaysfails);
  v5 = *(_DWORD *)dword_1180654;
  v6 = (_DWORD *)((char *)&dxState + 12 * a1);
  if (v30 == (IDirect3DVertexBuffer9 *)v6[2100]) {
    if (v5 == v6[2101]) {
      if (a4 == v6[2102])
        goto LABEL_9;
      v7 = a4;
      v8 = v30;
    } else {
      v7 = a4;
      v8 = v30;
    }
  } else {
    v7 = a4;
    v8 = v30;
  }
  RB_ChangeStreamSource(a1, v8, v5, v7);
LABEL_9:
  result = dword_1180654;
  *(_DWORD *)dword_1180654 += __n;
  return result;
}

int32_t __cdecl XSurfaceTransferDx7(const XVertexBuffer *a1, GfxVertexDx7 *a2,
                                    int a3) {
  int i;          // esi
  int32_t result; // eax

  if (a3 > 0) {
    for (i = 0; i != a3; ++i) {
      a2->xyz[0] = a1->v.offset[0];
      a2->xyz[1] = a1->v.offset[1];
      a2->xyz[2] = a1->v.offset[2];
      a2->normal[0] = a1->v.normal[0];
      a2->normal[1] = a1->v.normal[1];
      a2->normal[2] = a1->v.normal[2];
      a2->color.packed = a1->v.color;
      LODWORD(a2->texCoord[0]) = a1->v.texCoordX;
      result = a1->v.texCoordY;
      LODWORD(a2->texCoord[1]) = result;
      a1 = (const XVertexBuffer *)((char *)a1 + 64);
      ++a2;
    }
  }
  return result;
}

void __cdecl FFT_Init(_DWORD *a1, float *a2) {
  int i;    // esi
  int j;    // edx
  float v6; // xmm0_4

  for (i = 0; i != 256; ++i) {
    *a1 = 0;
    for (j = 0; j != 8; ++j) {
      if (((i >> j) & 1) != 0)
        *a1 |= 1 << (7 - j);
    }
    v6 = (double)i * 0.02454369260617026;
    a2[1] = sinf(v6);
    *a2 = cosf(v6);
    ++a1;
    a2 += 2;
  }
}

int *__cdecl RB_UpdateFogColor(FogColorSrcEnum a1) {
  int *result;     // eax
  int v2;          // ebx
  unsigned int v3; // ebx

  result = (int *)rg;
  if (!unk_1181E0C)
    return result;
  if (a1) {
    if (a1 != FOG_COLOR_SRC_BLACK)
      goto LABEL_4;
  } else {
    result = (int *)(dword_1186C00 & 0xF0);
    if (result != (int *)32) {
    LABEL_4:
      result = backEnd;
      v2 = unk_11E1AC8;
      goto LABEL_5;
    }
  }
  v2 = 0;
LABEL_5:
  v3 = v2 | 0xFF000000;
  if (unk_1186D58 != v3) {
    do
      (*(void(__cdecl **)(int, int, unsigned int))(*(_DWORD *)dword_117D8A8 +
                                                   228))(dword_117D8A8, 34, v3);
    while (alwaysfails);
    result = (int *)&dxState;
    unk_1186D58 = v3;
  }
  return result;
}

void __cdecl R_LoadSunThroughDvars(const char *a1, sunflare_t *a2) {
  char *v2;         // esi
  int32_t min;      // ebx
  int SundvarsSize; // eax
  dvar_s _8;        // [esp+8h] [ebp-20h] OVERLAPPED BYREF

  v2 = va("sun/%s.sun", a1);
  if ((FS_ReadFile(v2, (char **)&_8.domain) & 0x80000000) != 0) {
    Com_Printf("^3WARNING: couldn't load sun file '%s'\n", v2);
  } else {
    min = _8.domain.integer.min;
    SundvarsSize = R_GetSundvarsSize();
    *(_DWORD *)&_8.flags = v2;
    *(_DWORD *)_8.name = min;
    if (Com_LoadDvarsFromBuffer((const char **)&s_sundvars, SundvarsSize, _8))
      R_SetSunFromDvars(a2);
    FS_FreeFile((void *)_8.domain.integer.min);
  }
}

void __cdecl R_LoadSun(char *__src, sunflare_t *__b) {
  char v2;        // al
  const char *v3; // edx
  char *v4;       // ecx
  char *v5;       // eax
  char __s[72];   // [esp+10h] [ebp-48h] BYREF

  Com_Memset(__b, 0, 0x60u);
  v2 = *__src;
  if (*__src) {
    v3 = __src;
    v4 = __src;
    do {
      while (v2 != 47 && v2 != 92) {
        v2 = *++v3;
        if (!*v3)
          goto LABEL_7;
      }
      v4 = (char *)++v3;
      v2 = *v3;
    } while (*v3);
  } else {
    v4 = __src;
  }
LABEL_7:
  I_strncpyz(__s, v4, 64);
  v5 = strchr(__s, 46);
  if (v5)
    *v5 = 0;
  if (__s[0])
    R_LoadSunThroughDvars(__s, __b);
}

int __cdecl R_LoadLightDef(char *__src) {
  char *v1;        // eax
  int File;        // eax
  int v3;          // edx
  int v4;          // esi
  unsigned int v5; // ecx
  unsigned int v6; // ebx
  const char *v7;  // edx
  int v9;          // [esp+1Ch] [ebp-2Ch]
  int v10[7];      // [esp+2Ch] [ebp-1Ch] BYREF

  v1 = (char *)va("lights/%s", (char)__src);
  File = FS_ReadFile(v1, (int)v10);
  if (File >= 0) {
    if (File) {
      v9 = Hunk_AllocInternal(0x18u);
      *(_DWORD *)(v9 + 20) = Hunk_AllocInternal(strlen(__src) + 1);
      v3 = v10[0];
      *(_DWORD *)v9 = *(unsigned __int8 *)v10[0];
      *(_BYTE *)(v9 + 8) = *(_BYTE *)(v3 + 1);
      v4 = v3 + 2;
      v5 = strlen((const char *)(v3 + 2)) + 1;
      v6 = v5 - 1;
      if (v5 == 1) {
        *(_DWORD *)(v9 + 4) = 0;
        *(_BYTE *)(v9 + 16) = *(_BYTE *)(v3 + 3);
        v7 = (const char *)(v4 + v6 + 2);
        if (~(strlen(v7) + 1) == -2) {
        LABEL_5:
          *(_DWORD *)(v9 + 12) = 0;
        LABEL_6:
          strcpy(*(char **)(v9 + 20), __src);
          I_strlwr(*(char **)(v9 + 20));
          FS_FreeFile(v10[0]);
          return v9;
        }
      } else {
        *(_DWORD *)(v9 + 4) = Image_Register((const char *)(v3 + 2), 1, 5);
        *(_BYTE *)(v9 + 16) = *(_BYTE *)(v4 + v6 + 1);
        v7 = (const char *)(v4 + v6 + 2);
        if (~(strlen(v7) + 1) == -2)
          goto LABEL_5;
      }
      *(_DWORD *)(v9 + 12) = Image_Register(v7, 1, 5);
      goto LABEL_6;
    }
    FS_FreeFile(v10[0]);
  }
  return 0;
}

char *__cdecl R_LoadFont(char *a1, char a2) {
  int v2;    // eax
  int v3;    // esi
  char *v4;  // edi
  int v6[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  v2 = FS_FOpenFileRead(a1, v6, 1);
  v3 = v2;
  if (v2 >= 0) {
    if ((unsigned int)v2 <= 0xF) {
      FS_FCloseFile(v6[0]);
      Com_Printf("^1ERROR: Font file '%s' too small\n", a1);
      return 0;
    } else {
      v4 = (char *)Hunk_AllocInternal(v2 + 4);
      FS_Read(v4, 0x10u, v6[0]);
      FS_Read(v4 + 20, v3 - 16, v6[0]);
      FS_FCloseFile(v6[0]);
      *((_DWORD *)v4 + 4) = v4 + 20;
      *(_DWORD *)v4 += v4 + 4;
      *((_DWORD *)v4 + 3) =
          Material_RegisterHandle(&v4[*((_DWORD *)v4 + 3) + 4], 0, a2);
    }
    return v4;
  }
  if (v2 == -2) {
    Com_Printf("^1ERROR: Couldn't find font in iwd files or localized "
               "directories '%s'\n",
               a1);
    return 0;
  }
  Com_Printf("^1ERROR: Couldn't find font '%s'\n", a1);
  return 0;
}

int32_t __cdecl XSurfaceOptimizeRigid(XModel *a1, XSurface_s *a2,
                                      XVertexBuffer *a3) {
  int32_t result;   // eax
  int v4;           // edx
  GfxVertexDx7 *v5; // [esp+2Ch] [ebp-1Ch] BYREF

  result = a2->surfRigid.vb;
  if (result)
    return result;
  v4 = 36;
  if (*(_DWORD *)(r_rendererInUse + 8) != 2)
    v4 = 64;
  result = (*(int(__cdecl **)(int, int, int, _DWORD, _DWORD, XRigidSurface *,
                              _DWORD))(*(_DWORD *)dword_117D8A8 + 104))(
      dword_117D8A8, (__int16)a2->vertCount * v4, 8, 0, 0, &a2->surfRigid, 0);
  if (result < 0) {
  LABEL_10:
    a2->surfRigid.vb = 0;
    return result;
  }
  if ((*(int(__cdecl **)(int32_t, _DWORD, _DWORD, GfxVertexDx7 **, _DWORD))(
          *(_DWORD *)a2->surfRigid.vb + 44))(a2->surfRigid.vb, 0, 0, &v5, 0) <
      0) {
    result = (*(int(__cdecl **)(int32_t))(*(_DWORD *)a2->surfRigid.vb + 8))(
        a2->surfRigid.vb);
    goto LABEL_10;
  }
  if (*(_DWORD *)(r_rendererInUse + 8) == 2)
    XSurfaceTransferDx7(a3, v5, (__int16)a2->vertCount);
  else
    XSurfaceTransfer(a3, (GfxVertex *)v5, (__int16)a2->vertCount);
  return R_FinishStaticVertexBuffer((IDirect3DVertexBuffer9 *)a2->surfRigid.vb);
}

int __cdecl XModelOptimize(XModel *a1) {
  int result;    // eax
  int v2;        // edx
  int v3;        // ebx
  char *v4;      // esi
  int __n;       // [esp+18h] [ebp-40h]
  int v6;        // [esp+20h] [ebp-38h]
  int v7;        // [esp+24h] [ebp-34h]
  int v8;        // [esp+28h] [ebp-30h]
  int v9;        // [esp+2Ch] [ebp-2Ch]
  _BYTE v10[4];  // [esp+38h] [ebp-20h] BYREF
  _DWORD v11[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  result = unk_1180834(a1);
  v7 = result;
  if (result > 0) {
    v6 = 0;
    result = 0;
    while (1) {
      v9 = unk_1180828(a1, v11, result, v10);
      if (v9 > 0)
        break;
    LABEL_11:
      result = ++v6;
      if (v7 == v6)
        return result;
    }
    v8 = 0;
    v2 = 0;
    while (1) {
      v3 = *(_DWORD *)(v11[0] + 4 * v2);
      if (*(_DWORD *)(v3 + 20))
        goto LABEL_5;
      __n = 6 * *(__int16 *)(v3 + 4);
      v4 = (char *)R_AllocStaticIndexBuffer((IDirect3DIndexBuffer9 **)(v3 + 20),
                                            (__n + 31) & 0xFFFFFFE0);
      if (v4)
        break;
    LABEL_7:
      v2 = ++v8;
      if (v9 == v8)
        goto LABEL_11;
    }
    Com_Memcpy(v4, *(void **)(v3 + 8), __n);
    memset(&v4[__n], 0, ((__n + 31) & 0xFFFFFFE0) - __n);
    R_FinishStaticIndexBuffer(*(IDirect3DIndexBuffer9 **)(v3 + 20));
  LABEL_5:
    if (XSurfaceGetBoneOffset((const XSurface_s *)v3) != -1)
      XSurfaceOptimizeRigid(a1, (XSurface_s *)v3, *(XVertexBuffer **)(v3 + 12));
    goto LABEL_7;
  }
  return result;
}

int __cdecl XModelUnoptimize(XModel *a1) {
  int result;   // eax
  int i;        // esi
  int v3;       // ebx
  int v4;       // [esp+14h] [ebp-34h]
  int v5;       // [esp+18h] [ebp-30h]
  int v6;       // [esp+1Ch] [ebp-2Ch]
  _BYTE v7[4];  // [esp+28h] [ebp-20h] BYREF
  _DWORD v8[7]; // [esp+2Ch] [ebp-1Ch] BYREF

  result = unk_1180834(a1);
  v5 = result;
  if (result > 0) {
    v4 = 0;
    result = 0;
    do {
      v6 = unk_1180828(a1, v8, result, v7);
      if (v6 > 0) {
        for (i = 0; i != v6; ++i) {
          v3 = *(_DWORD *)(v8[0] + 4 * i);
          if (*(_DWORD *)(v3 + 20)) {
            R_FreeStaticIndexBuffer(*(IDirect3DIndexBuffer9 **)(v3 + 20));
            *(_DWORD *)(v3 + 20) = 0;
          }
          if (*(_DWORD *)(v3 + 16)) {
            do {
              (*(void(__cdecl **)(_DWORD))(**(_DWORD **)(v3 + 16) + 8))(
                  *(_DWORD *)(v3 + 16));
              *(_DWORD *)(v3 + 16) = 0;
            } while (alwaysfails);
          }
        }
      }
      result = ++v4;
    } while (v5 != v4);
  }
  return result;
}

int *__cdecl Image_Generate2D(int *a1, char *a2, int a3, int a4, int a5) {
  int v5; // eax

  Image_Setup((int)a1, a3, a4, 1, 3u, 0, a5);
  v5 = Image_CubemapFace(0);
  return Image_UploadData(a1, a5, v5, 0, a2);
}

int *__cdecl Image_Generate3D(int *a1, char *a2, int a3, int a4, int a5,
                              int a6) {
  int v6; // eax

  Image_Setup((int)a1, a3, a4, a5, 0xBu, 0, a6);
  v6 = Image_CubemapFace(0);
  return Image_UploadData(a1, a6, v6, 0, a2);
}

int __cdecl Image_BuildWaterMap(GfxImage *a1) {
  if (*(_DWORD *)(r_rendererInUse + 8) == 2)
    return Image_Create2DTexture((int)a1, a1->width, a1->height, 1, 512, 22, 0);
  else
    return Image_Create2DTexture((int)a1, a1->width, a1->height, 0, 512, 50, 0);
}

void __usercall Image_LoadBitmap(int a1 @<eax>, int a2 @<edx>, char *a3 @<ecx>,
                                 int a4, int a5) {
  int v6;      // ebx
  int v7;      // edi
  int v8;      // edx
  int v9;      // esi
  char *v10;   // ecx
  char *v11;   // edx
  int v12;     // ebx
  int v13;     // ebx
  int v14;     // eax
  int v15;     // ebx
  int v16;     // eax
  int v17;     // edx
  int i;       // eax
  int v22;     // [esp+40h] [ebp-28h]
  int v23;     // [esp+44h] [ebp-24h]
  int v24;     // [esp+48h] [ebp-20h]
  char *__src; // [esp+4Ch] [ebp-1Ch]

  Image_Setup(a1, *(__int16 *)(a2 + 6), *(__int16 *)(a2 + 8),
              *(__int16 *)(a2 + 10), *(unsigned __int8 *)(a2 + 5), 0, a4);
  v24 = 5 * (*(_DWORD *)a1 == 5) + 1;
  if (a4 == 22)
    __src = (char *)Hunk_AllocateTempMemoryInternal(
        4 * *(unsigned __int16 *)(a1 + 26) * *(unsigned __int16 *)(a1 + 24));
  else
    __src = 0;
  if ((*(_BYTE *)(a2 + 5) & 2) != 0) {
    v23 = 0;
  } else {
    v17 = 1;
    for (i = 1; i < *(__int16 *)(a2 + 6) || i < *(__int16 *)(a2 + 8) ||
                i < *(__int16 *)(a2 + 10);
         i *= 2)
      ++v17;
    v23 = v17 - 1;
  }
  for (; *(unsigned __int8 *)(a1 + 8) <= v23; --v23) {
    v6 = *(__int16 *)(a2 + 6) >> v23;
    HIWORD(v7) = 0;
    if (1 - v6 >= 0)
      v6 = 1;
    v8 = *(__int16 *)(a2 + 8) >> v23;
    if (1 - v8 >= 0)
      v8 = 1;
    if (v24 > 0) {
      v9 = v8 * v6;
      v22 = v8 * v6 * a5;
      LOWORD(v7) = 0;
      do {
        if (a4 == 22) {
          v10 = a3;
          v11 = __src;
          v12 = 0;
          do {
            *v11 = -1;
            v11[1] = v10[2];
            v11[2] = v10[1];
            v11[3] = *v10;
            v11 += 4;
            v10 += 3;
            ++v12;
          } while (v12 != v9);
          v13 = v23 - *(unsigned __int8 *)(a1 + 8);
          v14 = Image_CubemapFace(v7);
          Image_UploadData((int *)a1, 22, v14, v13, __src);
        } else {
          v15 = v23 - *(unsigned __int8 *)(a1 + 8);
          v16 = Image_CubemapFace(v7);
          Image_UploadData((int *)a1, a4, v16, v15, a3);
        }
        a3 += v22;
        ++v7;
      } while (v24 != v7);
    }
  }
  if (__src)
    Hunk_FreeTempMemory(__src);
}

void __usercall Image_LoadWavelet(int a1 @<eax>, int a2 @<edx>,
                                  int32_t a3 @<ecx>, int a4, int32_t a5) {
  signed int v6;            // ebx
  int32_t v7;               // edi
  int32_t v8;               // eax
  int32_t v9;               // eax
  int v10;                  // esi
  int32_t v11;              // ecx
  int32_t mipLevel;         // ebx
  int v13;                  // eax
  int32_t v14;              // eax
  unsigned int v15;         // eax
  int v16;                  // eax
  int v17;                  // eax
  unsigned __int8 *v18;     // ecx
  unsigned __int8 *v19;     // ebx
  int v20;                  // edi
  int *v21;                 // esi
  int v22;                  // ebx
  int v23;                  // eax
  void **v24;               // ebx
  int v25;                  // esi
  int v26;                  // ecx
  int i;                    // eax
  int j;                    // ebx
  void *TempMemoryInternal; // eax
  int v30;                  // edx
  int __size;               // [esp+34h] [ebp-84h]
  size_t __n;               // [esp+38h] [ebp-80h]
  size_t __na;              // [esp+38h] [ebp-80h]
  int v36;                  // [esp+3Ch] [ebp-7Ch]
  void *__src;              // [esp+40h] [ebp-78h]
  unsigned int v38;         // [esp+44h] [ebp-74h]
  int v39;                  // [esp+48h] [ebp-70h]
  int v40;                  // [esp+4Ch] [ebp-6Ch]
  WaveletDecode v41;        // [esp+50h] [ebp-68h] BYREF
  _DWORD v42[18];           // [esp+70h] [ebp-48h] BYREF

  Image_Setup(a1, *(__int16 *)(a2 + 6), *(__int16 *)(a2 + 8),
              *(__int16 *)(a2 + 10), *(unsigned __int8 *)(a2 + 5), 0, a4);
  v41.value = 0;
  v41.bit = 0;
  v6 = *(__int16 *)(a2 + 6);
  v41.width = v6;
  v7 = *(__int16 *)(a2 + 8);
  v41.height = v7;
  if ((*(_BYTE *)(a2 + 5) & 2) != 0) {
    v8 = 0;
  } else {
    v26 = 1;
    for (i = 1; i < v6 || i < v7 || i < *(__int16 *)(a2 + 10); i *= 2)
      ++v26;
    v8 = v26 - 1;
  }
  v41.mipLevel = v8;
  v41.channels = a5;
  v41.dataInitialized = 0;
  v9 = 4;
  if (a5 != 3)
    v9 = a5;
  v41.bpp = v9;
  v10 = a1;
  v36 = 5 * (*(_DWORD *)a1 == 5) + 1;
  __size = v9 * v7 * v6;
  if (v36 > 0) {
    for (j = 0; j != v36; ++j) {
      TempMemoryInternal = Hunk_AllocateTempMemoryInternal(__size);
      v30 = j;
      v42[v30 + 6] = TempMemoryInternal;
      v42[v30] = 0;
    }
    v10 = a1;
  }
  v41.data = a3;
  LOBYTE(v11) = v41.mipLevel;
  mipLevel = v41.mipLevel;
  if (*(unsigned __int8 *)(v10 + 8) <= v41.mipLevel) {
    do {
      while (1) {
        v13 = (int)v41.width >> v11;
        if (1 - ((int)v41.width >> v11) >= 0)
          v13 = 1;
        __n = v13;
        v14 = v41.height >> v11;
        if (1 - (v41.height >> v11) >= 0)
          v14 = 1;
        v15 = v41.bpp * __n * v14;
        __na = v15;
        if (v36 > 0)
          break;
        v11 = mipLevel - 1;
        mipLevel = v11;
        v41.mipLevel = v11;
        if (*(unsigned __int8 *)(a1 + 8) > v11)
          goto LABEL_22;
      }
      v38 = v15 >> 2;
      v39 = 4 * (v15 >> 2);
      v40 = 0;
      v16 = 0;
      do {
        v17 = v16;
        v18 = (unsigned __int8 *)v42[v17];
        v19 = (unsigned __int8 *)(v42[v17 + 6] + __size - __na);
        v42[v17] = v19;
        Wavelet_DecompressLevel(v18, v19, &v41);
        __src = (void *)operator new[](v39);
        memcpy(__src, v19, __na);
        if (v38) {
          v20 = 0;
          v21 = (int *)__src;
          do {
            *v21 = ((unsigned int)*v21 >> 8) & 0xFF00 |
                   ((unsigned __int8)BYTE1(*v21) << 16) | (*v21 << 24) |
                   HIBYTE(*v21);
            ++v20;
            ++v21;
          } while (v20 != v38);
        }
        v22 = v41.mipLevel - *(unsigned __int8 *)(a1 + 8);
        v23 = Image_CubemapFace(v40);
        Image_UploadData((int *)a1, a4, v23, v22, (char *)__src);
        if (__src)
          operator delete[](__src);
        v16 = ++v40;
      } while (v36 != v40);
      v11 = v41.mipLevel - 1;
      mipLevel = v11;
      --v41.mipLevel;
    } while (*(unsigned __int8 *)(a1 + 8) <= v11);
  }
LABEL_22:
  if (v36 - 1 >= 0) {
    v24 = (void **)&v42[v36 + 5];
    v25 = 0;
    do {
      Hunk_FreeTempMemory(*v24);
      ++v25;
      --v24;
    } while (v36 != v25);
  }
}

void __cdecl Image_LoadFromData(GfxImage *a1, GfxImageFileHeader *a2,
                                char *a3) {
  a1->texture.basemap = 0;
  switch (a2->format) {
  case 1:
    Image_LoadBitmap((int)a1, (int)a2, a3, 21, 4);
    break;
  case 2:
    Image_LoadBitmap((int)a1, (int)a2, a3, 22, 3);
    break;
  case 3:
    Image_LoadBitmap((int)a1, (int)a2, a3, 51, 2);
    break;
  case 4:
    Image_LoadBitmap((int)a1, (int)a2, a3, 50, 1);
    break;
  case 5:
    Image_LoadBitmap((int)a1, (int)a2, a3, 28, 1);
    break;
  case 6:
    Image_LoadWavelet((int)a1, (int)a2, (int32_t)a3, 21, 4);
    break;
  case 7:
    Image_LoadWavelet((int)a1, (int)a2, (int32_t)a3, 22, 3);
    break;
  case 8:
    Image_LoadWavelet((int)a1, (int)a2, (int32_t)a3, 51, 2);
    break;
  case 9:
    Image_LoadWavelet((int)a1, (int)a2, (int32_t)a3, 50, 1);
    break;
  case 0xA:
    Image_LoadWavelet((int)a1, (int)a2, (int32_t)a3, 28, 1);
    break;
  case 0xB:
    Image_LoadDxtc((int)a1, (int)a2, a3, 827611204, 8);
    break;
  case 0xC:
    Image_LoadDxtc((int)a1, (int)a2, a3, 861165636, 16);
    break;
  case 0xD:
    Image_LoadDxtc((int)a1, (int)a2, a3, 894720068, 16);
    break;
  default:
    return;
  }
}

int __cdecl Image_GetSunHalfAngleForVector(float *a1, int a2,
                                           unsigned __int8 *a3) {
  int result;   // eax
  float v4;     // [esp+24h] [ebp-34h]
  float v5;     // [esp+28h] [ebp-30h]
  float v6;     // [esp+2Ch] [ebp-2Ch]
  float v7;     // [esp+38h] [ebp-20h] BYREF
  float v8;     // [esp+3Ch] [ebp-1Ch]
  float v9;     // [esp+40h] [ebp-18h]
  float v10[5]; // [esp+44h] [ebp-14h] BYREF

  Vec3NormalizeTo(a1, v10);
  v7 = *(float *)(dword_1184B9C + 184) - v10[0];
  v8 = *(float *)(dword_1184B9C + 188) - v10[1];
  v9 = *(float *)(dword_1184B9C + 192) - v10[2];
  Vec3Normalize(&v7);
  v6 = floorf((float)((float)((float)(v9 * 0.5) + 0.5) * 255.0) + 0.5);
  a3[3] = (int)v6;
  v5 = floorf((float)((float)((float)(v8 * 0.5) + 0.5) * 255.0) + 0.5);
  a3[2] = (int)v5;
  v4 = floorf((float)((float)((float)(v7 * 0.5) + 0.5) * 255.0) + 0.5);
  result = (int)v4;
  a3[1] = (int)v4;
  *a3 = 0x80;
  return result;
}

unsigned __int8 *__cdecl Image_GetWaterColorForVector(float *a1, int a2,
                                                      unsigned __int8 *a3) {
  unsigned __int8 *result; // eax
  float v4;                // [esp+1Ch] [ebp-2Ch]
  float v5;                // [esp+2Ch] [ebp-1Ch]
  float v6[3];             // [esp+30h] [ebp-18h] BYREF
  int v7;                  // [esp+3Ch] [ebp-Ch]

  Vec3NormalizeTo(a1, v6);
  v4 = FresnelTerm(1.0, 1.3329999, v6[2]);
  v7 = a2;
  v5 = floorf((float)(v4 * 255.0) + 0.5);
  LOBYTE(v7) = (int)v5;
  result = a3;
  *(_DWORD *)a3 = v7;
  return result;
}

int __cdecl Image_GetLightGridWeightsForVector(float *a1, int a2,
                                               unsigned __int8 *a3) {
  float v3;            // xmm2_4
  float v4;            // xmm2_4
  float v5;            // xmm5_4
  float v6;            // xmm4_4
  float v7;            // xmm0_4
  float v8;            // xmm2_4
  float v9;            // xmm0_4
  float v10;           // xmm2_4
  int v11;             // edx
  int v12;             // edx
  unsigned __int8 v13; // di
  int v14;             // edx
  unsigned __int8 v15; // bl
  int v16;             // edx
  int result;          // eax
  float v18;           // [esp+34h] [ebp-44h]
  float v19;           // [esp+38h] [ebp-40h]
  float v20;           // [esp+3Ch] [ebp-3Ch]
  float v21;           // [esp+40h] [ebp-38h]
  unsigned __int8 v22; // [esp+4Fh] [ebp-29h]
  float v23;           // [esp+54h] [ebp-24h] BYREF
  float v24;           // [esp+58h] [ebp-20h]
  float v25;           // [esp+5Ch] [ebp-1Ch]

  AxisTransformVector(lightGridLookupMatrix_125709, *a1, a1[1], a1[2], &v23);
  v3 = 1.0 / fabs(*(&v23 + Vec3MajorAxis(&v23)));
  v23 = v3 * v23;
  v24 = v3 * v24;
  v4 = v3 * v25;
  v25 = v4;
  v5 = (float)((float)((float)(v23 * 0.5) + 0.5) *
               (float)((float)(v23 * 0.5) + 0.5)) *
       (float)((float)((float)((float)(v23 * 0.5) + 0.5) * -2.0) + 3.0);
  v6 = (float)((float)((float)(v24 * 0.5) + 0.5) *
               (float)((float)(v24 * 0.5) + 0.5)) *
       (float)((float)((float)((float)(v24 * 0.5) + 0.5) * -2.0) + 3.0);
  if (a2)
    v7 = v4 * 0.5;
  else
    v7 = v4 * -0.5;
  v8 = (float)((float)(v7 + 0.5) * (float)(v7 + 0.5)) *
       (float)((float)((float)(v7 + 0.5) * -2.0) + 3.0);
  v9 = (float)(1.0 - v6) * v8;
  v10 = v8 * v6;
  v21 = floorf((float)((float)(v9 * (float)(1.0 - v5)) * 255.0) + 0.5);
  v11 = (int)v21;
  if ((int)v21 - 255 >= 0) {
    LOBYTE(v11) = -1;
  LABEL_5:
    v22 = v11;
    goto LABEL_6;
  }
  if (v11 > 0)
    goto LABEL_5;
  v22 = 0;
LABEL_6:
  v20 = floorf((float)((float)(v5 * v9) * 255.0) + 0.5);
  v12 = (int)v20;
  if ((int)v20 - 255 >= 0) {
    LOBYTE(v12) = -1;
  LABEL_8:
    v13 = v12;
    goto LABEL_9;
  }
  if (v12 > 0)
    goto LABEL_8;
  v13 = 0;
LABEL_9:
  v19 = floorf((float)(255.0 * (float)((float)(1.0 - v5) * v10)) + 0.5);
  v14 = (int)v19;
  if ((int)v19 - 255 >= 0) {
    LOBYTE(v14) = -1;
  LABEL_11:
    v15 = v14;
    goto LABEL_12;
  }
  if (v14 > 0)
    goto LABEL_11;
  v15 = 0;
LABEL_12:
  v18 = floorf((float)(255.0 * (float)(v5 * v10)) + 0.5);
  v16 = (int)v18;
  if ((int)v18 - 255 >= 0) {
    v16 = 255;
  LABEL_14:
    result = v16;
    *a3 = v15;
    a3[1] = v13;
    a3[2] = v22;
    a3[3] = v16;
    return result;
  }
  if (v16 > 0)
    goto LABEL_14;
  result = 0;
  *a3 = v15;
  a3[1] = v13;
  a3[2] = v22;
  a3[3] = 0;
  return result;
}

int __cdecl Image_LoadFromFile(GfxImage *a1) {
  signed int File;         // eax
  GfxImageFileHeader *v2;  // edx
  GfxImageFileHeader *v3;  // ecx
  GfxImageFileHeader *v4;  // edx
  unsigned __int8 version; // al
  char __str[64];          // [esp+2Ch] [ebp-4Ch] BYREF
  GfxImageFileHeader *v8;  // [esp+6Ch] [ebp-Ch] BYREF

  if (Com_sprintf(__str, 0x40u, "%s%s%s", "images/", *(const char **)a1->name,
                  ".iwi") < 0) {
    Com_Printf("^1ERROR: filename '%s' too long\n", __str);
    return 0;
  } else {
    File = FS_ReadFile(__str, (char **)&v8);
    if (File < 0) {
      Com_Printf("^1ERROR: image '%s' is missing\n", __str);
      return 0;
    } else if (File) {
      v2 = v8;
      v3 = v8 + 1;
      if ((v8->flags & 3) != 0)
        a1->noPicmip = 1;
      if ((_UNKNOWN *)(*(_DWORD *)v2->tag & 0xFFFFFF) != &unk_695749) {
        Com_Printf("^1ERROR: image '%s' is not an IW image\n", __str);
        v4 = v8;
      LABEL_8:
        FS_FreeFile(v4);
        return 0;
      }
      version = v2->version;
      if (version != 5) {
        Com_Printf(
            "^1ERROR: image '%s' is version %i but should be version %i\n",
            __str, version, 5);
        v4 = v8;
        goto LABEL_8;
      }
      Image_LoadFromData(a1, v2, (char *)v3);
      FS_FreeFile(v8);
      return 1;
    } else {
      Com_Printf("^1ERROR: image '%s' has 0 length\n", __str);
      FS_FreeFile(v8);
      return 0;
    }
  }
}

int __cdecl R_CreateWaterMap(char *__src, unsigned __int16 a2,
                             unsigned __int16 a3) {
  int v3; // edi

  v3 = Image_Alloc(__src, 5, 5, 9);
  *(_WORD *)(v3 + 24) = a2;
  *(_WORD *)(v3 + 26) = a3;
  if (*(_DWORD *)(r_rendererInUse + 8) == 2)
    Image_Create2DTexture(v3, *(_WORD *)(v3 + 24), a3, 1, 512, 22, 0);
  else
    Image_Create2DTexture(v3, *(_WORD *)(v3 + 24), a3, 0, 512, 50, 0);
  return v3;
}

int __cdecl Image_LoadRaw(GfxImage *a1, const char *a2) {
  char *v2;    // esi
  int v3;      // ebx
  int v4;      // eax
  int v6;      // [esp+2Ch] [ebp-2Ch] BYREF
  int v7;      // [esp+30h] [ebp-28h] BYREF
  int v8;      // [esp+34h] [ebp-24h] BYREF
  void *__src; // [esp+38h] [ebp-20h] BYREF
  void *v10;   // [esp+3Ch] [ebp-1Ch] BYREF

  __src = 0;
  R_LoadJpg(a2, &v10, (int *)&__src, (unsigned int *)&v8, (unsigned int *)&v7,
            &v6);
  v2 = (char *)__src;
  if (!__src)
    return 0;
  v3 = v6;
  Image_Setup((int)a1, v8, v7, 1, 3u, 0, v6);
  v4 = Image_CubemapFace(0);
  Image_UploadData(&a1->mapType, v3, v4, 0, v2);
  Hunk_FreeTempMemory(__src);
  FS_FreeFile(v10);
  return 1;
}

int *__cdecl Image_LoadLightmapWeights(GfxImage *a1) {
  char *v1;         // edi
  int j;            // esi
  float v3;         // xmm1_4
  float v4;         // xmm2_4
  float v5;         // xmm0_4
  float v6;         // xmm0_4
  char *v7;         // ebx
  float v8;         // xmm0_4
  int v9;           // eax
  long double v11;  // [esp+0h] [ebp-1098h]
  long double v12;  // [esp+10h] [ebp-1088h]
  float v13;        // [esp+24h] [ebp-1074h]
  float v14;        // [esp+54h] [ebp-1044h]
  float v15;        // [esp+58h] [ebp-1040h]
  float v16;        // [esp+5Ch] [ebp-103Ch]
  float v17;        // [esp+60h] [ebp-1038h]
  int i;            // [esp+64h] [ebp-1034h]
  float v19;        // [esp+68h] [ebp-1030h]
  float v20;        // [esp+6Ch] [ebp-102Ch]
  char __src[4096]; // [esp+74h] [ebp-1024h] BYREF
  float v22;        // [esp+1074h] [ebp-24h] BYREF
  float v23;        // [esp+1078h] [ebp-20h]
  float v24;        // [esp+107Ch] [ebp-1Ch]

  v1 = __src;
  for (i = 0; i != 32; ++i) {
    v23 = (float)((float)((float)((float)i + 0.5) * 0.03125) +
                  (float)((float)((float)i + 0.5) * 0.03125)) -
          1.0;
    for (j = 0; j != 32; ++j) {
      v22 = (float)((float)((float)((float)j + 0.5) * 0.03125) +
                    (float)((float)((float)j + 0.5) * 0.03125)) -
            1.0;
      v8 = 1.0 - (float)((float)(v22 * v22) + (float)(v23 * v23));
      if (v8 < 0.0) {
        Vec2Normalize(&v22);
        v8 = 0.0;
      }
      v24 = fsqrt(v8);
      *((double *)&v11 + 1) = v22;
      *(double *)&v11 = v23;
      v3 = (double)atan2(v11, v12) * 0.477464829275686 - 0.75;
      if (v3 < 0.0) {
        v3 = v3 + 3.0;
      } else if (v3 > 3.0) {
        v3 = v3 - 3.0;
      }
      if (v3 < 1.0) {
        v4 = 1.0 - v3;
        v20 = 0.0;
      } else if (v3 < 2.0) {
        v20 = v3 - 1.0;
        v3 = 1.0 - (float)(v3 - 1.0);
        v4 = 0.0;
      } else {
        v4 = v3 - 2.0;
        v20 = 1.0 - (float)(v3 - 2.0);
        v3 = 0.0;
      }
      v13 = acosf(v24);
      v5 = (float)(v13 / -0.9553166) + 1.0;
      if (v5 < 0.0) {
        v19 = 1.0;
        v6 = 0.0;
      } else if (v5 <= 1.0) {
        v19 = 1.0 - v5;
        v6 = v5 * 255.0;
      } else {
        v19 = 0.0;
        v6 = 255.0;
      }
      v7 = &v1[4 * j];
      v17 = floorf(v6 + 0.5);
      *v7 = (int)v17;
      v16 = floorf((float)((float)(v4 * v19) * 255.0) + 0.5);
      v7[1] = (int)v16;
      v15 = floorf((float)((float)(v3 * v19) * 255.0) + 0.5);
      v7[2] = (int)v15;
      v14 = floorf((float)(255.0 * (float)(v19 * v20)) + 0.5);
      v7[3] = (int)v14;
    }
    v1 += 128;
  }
  Image_Setup((int)a1, 32, 32, 1, 3u, 0, 21);
  v9 = Image_CubemapFace(0);
  return Image_UploadData(&a1->mapType, 21, v9, 0, __src);
}

GfxImage *__cdecl Image_Load(char *a1, char a2, char a3) {
  GfxImage *v3;                        // esi
  int *v5;                             // esi
  int v6;                              // eax
  int v7;                              // eax
  unsigned __int8 *TempMemoryInternal; // ebx
  unsigned __int8 __src;               // [esp+30h] [ebp-6018h] BYREF
  char v10;                            // [esp+31h] [ebp-6017h]
  char v11;                            // [esp+32h] [ebp-6016h]
  char v12;                            // [esp+33h] [ebp-6015h]

  if (*a1 != 36) {
    v3 = (GfxImage *)Image_Alloc(a1, 3, a2, a3);
    if (!(unsigned __int8)Image_LoadFromFile(v3))
      return 0;
    return v3;
  }
  if (!strcmp(a1, "$white")) {
    v5 = (int *)Image_Alloc(a1, 1, a2, a3);
    v12 = -1;
    v11 = -1;
    v10 = -1;
  LABEL_7:
    __src = -1;
    goto LABEL_8;
  }
  if (!strcmp(a1, "$black")) {
    v5 = (int *)Image_Alloc(a1, 1, a2, a3);
    v12 = 0;
    v11 = 0;
    v10 = 0;
    goto LABEL_7;
  }
  if (strcmp(a1, "$identitynormalmap")) {
    if (!strcmp(a1, "$specularity")) {
      v3 = (GfxImage *)Image_Alloc(a1, 1, a2, a3);
      Image_BuildSpecularityMap(0.0, &__src);
      Image_Setup((int)v3, 32, 256, 1, 3u, 0, 50);
      v7 = Image_CubemapFace(0);
      Image_UploadData(&v3->mapType, 50, v7, 0, (char *)&__src);
    } else if (!strcmp(a1, "$outdoor")) {
      v3 = (GfxImage *)Image_Alloc(a1, 1, a2, a3);
      R_GenerateOutdoorImage(v3);
    } else if (!strcmp(a1, "$lightmapweights")) {
      v3 = (GfxImage *)Image_Alloc(a1, 1, a2, a3);
      Image_LoadLightmapWeights(v3);
    } else if (!strcmp(a1, "$lightgridweights0")) {
      v3 = (GfxImage *)Image_Alloc(a1, 1, a2, a3);
      Image_GenerateCubemapFunction(
          v3, &__src, 32, 0,
          (void (*)(const float *, int,
                    unsigned __int8 *))Image_GetLightGridWeightsForVector);
    } else if (!strcmp(a1, "$lightgridweights1")) {
      v3 = (GfxImage *)Image_Alloc(a1, 1, a2, a3);
      Image_GenerateCubemapFunction(
          v3, &__src, 32, 1,
          (void (*)(const float *, int,
                    unsigned __int8 *))Image_GetLightGridWeightsForVector);
    } else if (!strcmp(a1, "$watercolor")) {
      v3 = (GfxImage *)Image_Alloc(a1, 1, a2, a3);
      Image_GenerateCubemapFunction(
          v3, &__src, 16, 1296053247,
          (void (*)(const float *, int,
                    unsigned __int8 *))Image_GetWaterColorForVector);
    } else if (!strcmp(a1, "$sunhalfangle")) {
      v3 = (GfxImage *)Image_Alloc(a1, 1, a2, a3);
      TempMemoryInternal = (unsigned __int8 *)Hunk_AllocateTempMemoryInternal(
          (size_t)&loc_18000);
      Image_GenerateCubemapFunction(
          v3, TempMemoryInternal, 64, 0,
          (void (*)(const float *, int,
                    unsigned __int8 *))Image_GetSunHalfAngleForVector);
      Hunk_FreeTempMemory(TempMemoryInternal);
    } else {
      Com_Printf("ERROR: Unknown built-in image '%s'", a1);
      return 0;
    }
    return v3;
  }
  v5 = (int *)Image_Alloc(a1, 1, a2, a3);
  v12 = -1;
  v11 = 0x80;
  v10 = 0x80;
  __src = 0x80;
LABEL_8:
  Image_Setup((int)v5, 1, 1, 1, 3u, 0, 21);
  v6 = Image_CubemapFace(0);
  Image_UploadData(v5, 21, v6, 0, (char *)&__src);
  return (GfxImage *)v5;
}

unsigned int __cdecl Material_CachedShaderTextLess(
    const GfxCachedShaderText *a1, const GfxCachedShaderText *a2) {
  return (unsigned int)strcmp(*(const char **)a1->name,
                              *(const char **)a2->name) >>
         31;
}

void Material_PreLoadAllShaderText(void) {
  char **v0;                      // eax
  int v1;                         // edi
  int v2;                         // ebx
  char **v3;                      // eax
  int v4;                         // edi
  int v5;                         // edx
  int v6;                         // ebx
  int v7;                         // eax
  int v8;                         // edx
  GfxCachedShaderText *v9;        // edi
  int v10;                        // esi
  int v11;                        // ebx
  int v12;                        // esi
  GfxCachedShaderText *v13;       // ecx
  GfxCachedShaderText *v14;       // edx
  int j;                          // ebx
  char *name;                     // edx
  GfxCachedShaderText *v17;       // eax
  int v18;                        // eax
  int v19;                        // ecx
  const GfxCachedShaderText *v20; // ebx
  GfxCachedShaderText *v21;       // esi
  GfxCachedShaderText *v22;       // edi
  int v23;                        // esi
  int v24;                        // ebx
  int v25;                        // esi
  GfxCachedShaderText *v26;       // ecx
  GfxCachedShaderText *v27;       // edx
  int i;                          // ebx
  GfxCachedShaderText *v29;       // ebx
  const GfxCachedShaderText *v30; // ebx
  GfxCachedShaderText *v31;       // esi
  const GfxCachedShaderText *v32; // ebx
  GfxCachedShaderText *v33;       // esi
  char **v34;                     // ebx
  int v35;                        // esi
  char **v36;                     // ebx
  int v37;                        // esi
  GfxCachedShaderText *v38;       // [esp+2Ch] [ebp-5Ch]
  int v39;                        // [esp+30h] [ebp-58h]
  int v40;                        // [esp+34h] [ebp-54h]
  void **v41;                     // [esp+38h] [ebp-50h]
  void **v42;                     // [esp+3Ch] [ebp-4Ch]
  char *v43;                      // [esp+40h] [ebp-48h]
  GfxCachedShaderText *v44;       // [esp+4Ch] [ebp-3Ch]
  GfxCachedShaderText v45;        // [esp+50h] [ebp-38h] BYREF
  GfxCachedShaderText v46;        // [esp+5Ch] [ebp-2Ch] BYREF
  int v47;                        // [esp+68h] [ebp-20h] BYREF
  int v48[7];                     // [esp+6Ch] [ebp-1Ch] BYREF

  v41 = (void **)FS_ListFiles("materials/shaders/", "hlsl", FS_LIST_PURE_ONLY,
                              v48);
  v42 = (void **)FS_ListFiles("materials/shaders/lib/", "hlsl",
                              FS_LIST_PURE_ONLY, &v47);
  mtlLoadGlob = v47 + v48[0];
  v0 = (char **)Hunk_AllocInternal(12 * (v47 + v48[0]));
  dword_CE7084 = (int)v0;
  v1 = v48[0];
  if (v48[0] > 0) {
    v36 = v0;
    v37 = 0;
    do {
      Material_PreLoadSingleShaderText((const char *)v41[v37++],
                                       (const char *)&inData, v36);
      v36 += 3;
    } while (v1 != v37);
    v1 = v48[0];
    v2 = dword_CE7084;
  } else {
    v2 = (int)v0;
  }
  v38 = (GfxCachedShaderText *)v2;
  v3 = (char **)(v2 + 12 * v1);
  v4 = v47;
  if (v47 > 0) {
    v34 = v3;
    v35 = 0;
    do {
      Material_PreLoadSingleShaderText((const char *)v42[v35++], "lib/", v34);
      v34 += 3;
    } while (v4 != v35);
    v38 = (GfxCachedShaderText *)dword_CE7084;
    v5 = dword_CE7084;
  } else {
    v5 = v2;
  }
  v43 = (char *)(v5 + 12 * mtlLoadGlob);
  if ((char *)v5 != v43) {
    v6 = 12 * mtlLoadGlob;
    v7 = -1431655765 * ((12 * mtlLoadGlob) >> 2);
    if (v7 == 1) {
      LOBYTE(v7) = 0;
    } else {
      v8 = 0;
      do {
        ++v8;
        v7 >>= 1;
      } while (v7 != 1);
      v7 = 2 * v8;
    }
    std::__introsort_loop<GfxCachedShaderText *, int,
                          unsigned char (*)(GfxCachedShaderText const &,
                                            GfxCachedShaderText const &)>(
        v38->name, v43, v7,
        (unsigned __int8(__cdecl *)(char *,
                                    int *))Material_CachedShaderTextLess);
    if (v6 > 203) {
      v44 = v38 + 16;
      v22 = v38 + 1;
      if (&v38[16] == &v38[1]) {
        v17 = v38 + 16;
      } else {
        while (1) {
          v40 = *(_DWORD *)v22->name;
          *(_DWORD *)v45.name = *(_DWORD *)v22->name;
          v23 = *(_DWORD *)v22->text;
          *(_DWORD *)v45.text = v23;
          v24 = *(_DWORD *)v22->textSize;
          *(_DWORD *)v45.textSize = v24;
          if ((unsigned __int8)Material_CachedShaderTextLess(&v45, v38)) {
            v25 = -1431655765 * (((char *)v22 - (char *)v38) >> 2);
            if (v25 > 0) {
              v26 = v22;
              v27 = v22 + 1;
              for (i = 0; i != v25; ++i) {
                *(_DWORD *)v27[-1].name = *(_DWORD *)v26[-1].name;
                *(_DWORD *)v27[-1].text = *(_DWORD *)v26[-1].text;
                *(_DWORD *)v27[-1].textSize = *(_DWORD *)v26[-1].textSize;
                --v26;
                --v27;
              }
            }
            *v38 = v45;
            v29 = v22 + 1;
          } else {
            *(_DWORD *)v46.textSize = v24;
            *(_DWORD *)v46.text = v23;
            *(_DWORD *)v46.name = v40;
            v30 = v22 - 1;
            v31 = v22;
            while ((unsigned __int8)Material_CachedShaderTextLess(&v46, v30)) {
              *(_DWORD *)v31->name = *(_DWORD *)v30->name;
              *(_DWORD *)v31->text = *(_DWORD *)v30->text;
              *(_DWORD *)v31->textSize = *(_DWORD *)v30->textSize;
              v31 = (GfxCachedShaderText *)v30--;
            }
            *v31 = v46;
            v29 = v22 + 1;
          }
          if (v44 == v29)
            break;
          v22 = v29;
        }
        v17 = v38 + 16;
      }
      if (v43 != (char *)v17) {
        do {
          v18 = *(_DWORD *)v44->text;
          v19 = *(_DWORD *)v44->name;
          *(_DWORD *)v45.textSize = *(_DWORD *)v44->textSize;
          *(_DWORD *)v45.text = v18;
          *(_DWORD *)v45.name = v19;
          v20 = v44 - 1;
          v21 = v44;
          while ((unsigned __int8)Material_CachedShaderTextLess(&v45, v20)) {
            *(_DWORD *)v21->name = *(_DWORD *)v20->name;
            *(_DWORD *)v21->text = *(_DWORD *)v20->text;
            *(_DWORD *)v21->textSize = *(_DWORD *)v20->textSize;
            v21 = (GfxCachedShaderText *)v20--;
          }
          *v21 = v45;
          ++v44;
        } while (v43 != (char *)v44);
      }
    } else {
      v9 = v38 + 1;
      if (v43 != (char *)&v38[1]) {
        while (1) {
          v39 = *(_DWORD *)v9->name;
          *(_DWORD *)v45.name = *(_DWORD *)v9->name;
          v10 = *(_DWORD *)v9->text;
          *(_DWORD *)v45.text = v10;
          v11 = *(_DWORD *)v9->textSize;
          *(_DWORD *)v45.textSize = v11;
          if ((unsigned __int8)Material_CachedShaderTextLess(&v45, v38)) {
            v12 = -1431655765 * (((char *)v9 - (char *)v38) >> 2);
            if (v12 > 0) {
              v13 = v9;
              v14 = v9 + 1;
              for (j = 0; j != v12; ++j) {
                *(_DWORD *)v14[-1].name = *(_DWORD *)v13[-1].name;
                *(_DWORD *)v14[-1].text = *(_DWORD *)v13[-1].text;
                *(_DWORD *)v14[-1].textSize = *(_DWORD *)v13[-1].textSize;
                --v13;
                --v14;
              }
            }
            *v38 = v45;
            name = v9[1].name;
          } else {
            *(_DWORD *)v46.textSize = v11;
            *(_DWORD *)v46.text = v10;
            *(_DWORD *)v46.name = v39;
            v32 = v9 - 1;
            v33 = v9;
            while ((unsigned __int8)Material_CachedShaderTextLess(&v46, v32)) {
              *(_DWORD *)v33->name = *(_DWORD *)v32->name;
              *(_DWORD *)v33->text = *(_DWORD *)v32->text;
              *(_DWORD *)v33->textSize = *(_DWORD *)v32->textSize;
              v33 = (GfxCachedShaderText *)v32--;
            }
            *v33 = v46;
            name = v9[1].name;
          }
          if (v43 == name)
            break;
          v9 = (GfxCachedShaderText *)name;
        }
      }
    }
  }
  FS_FreeFileList(v42);
  FS_FreeFileList(v41);
}

char *__cdecl Material_Load(char *a1, char a2) {
  int File;        // eax
  unsigned int v3; // ebx
  char *v4;        // esi
  MaterialObj *v6; // [esp+1Ch] [ebp-Ch] BYREF

  File = Material_LoadFile(a1, (int *)&v6);
  v3 = File;
  if (File >= 0) {
    if (!File) {
      FS_FCloseFile((int)v6);
      Com_Printf("^1ERROR: material '%s' has zero length\n", a1);
      return 0;
    }
    v4 = (char *)Material_Alloc();
    FS_Read(v4, v3, (int)v6);
    FS_FCloseFile((int)v6);
    if ((unsigned __int8)Material_FinishLoadingInstance((int)v4, a2))
      return v4;
    return 0;
  }
  if (*a1 == 36)
    return 0;
  Com_Printf("^1ERROR: Couldn't find material '%s'\n", a1);
  return 0;
}

int __cdecl CompareStaticModels(_DWORD *a1, _DWORD *a2) { return *a1 - *a2; }

void *__cdecl R_PrepareStaticModelLightingCache(GfxWorld *a1, int a2) {
  int v2;       // ecx
  size_t v3;    // ebx
  void *result; // eax

  if (*(_DWORD *)(r_rendererInUse + 8) == 2) {
    *(_DWORD *)a1->smodelLightingColorTable =
        (*(int(__cdecl **)(int)) & algn_11806C8[4])(96 * a2);
    result = (void *)(*(int(__cdecl **)(int)) & algn_11806C8[4])(4 * a2);
    *(_DWORD *)a1->smodelLightingSunVisTable = result;
  } else {
    smodelLoadGlob = 1;
    if (a2 > 1) {
      v2 = 1;
      do
        v2 *= 2;
      while (v2 * v2 < a2);
      smodelLoadGlob = v2;
    } else {
      v2 = 1;
    }
    dword_CE7104 = v2;
    if (smodelLoadGlob * v2 >= 2 * a2)
      dword_CE7104 = (v2 + 1) >> 1;
    *(float *)&dword_CE7108 = 1.0 / (float)(2 * smodelLoadGlob);
    *(float *)&dword_CE710C = 1.0 / (float)(2 * dword_CE7104);
    v3 = 32 * dword_CE7104 * smodelLoadGlob;
    dword_CE7110 = (int)Hunk_AllocateTempMemoryInternal(v3);
    return memset((void *)dword_CE7110, 128, v3);
  }
  return result;
}

int __cdecl R_ValidateStaticModel(XModel *a1) {
  int v2;           // edi
  int Surfaces;     // esi
  int v4;           // ebx
  const char *Name; // eax
  int NumLods;      // [esp+1Ch] [ebp-2Ch]
  int *v7;          // [esp+28h] [ebp-20h] BYREF
  XSurface_s **v8;  // [esp+2Ch] [ebp-1Ch] BYREF

  NumLods = XModelGetNumLods(a1);
  if (NumLods <= 0)
    return 1;
  v2 = 0;
  while (1) {
    Surfaces = XModelGetSurfaces(a1, &v8, v2, &v7);
    if (Surfaces > 0)
      break;
  LABEL_4:
    if (NumLods == ++v2)
      return 1;
  }
  v4 = 0;
  while (XSurfaceGetBoneOffset(v8[v4]) != -1) {
    if (Surfaces == ++v4)
      goto LABEL_4;
  }
  Name = (const char *)XModelGetName(a1);
  Com_Printf("^1ERROR: model '%s' is not a valid static model, since lod %i "
             "surf %i has more than one bone.  Static models should "
             "be set to 'rigid' in asset manager.\n",
             Name, v2, v4);
  return 0;
}

char *__cdecl R_FinishStaticModelLightingCache(GfxWorld *a1) {
  char *result; // eax
  int *v2;      // eax
  float v3;     // xmm1_4

  result = (char *)r_rendererInUse;
  if (*(_DWORD *)(r_rendererInUse + 8) != 2) {
    v2 = (int *)Image_Alloc("*smodel_lighting", 2, 1, 4);
    *(_DWORD *)a1->smodelLightingImage = v2;
    Image_Generate3D(v2, (char *)dword_CE7110, 2 * smodelLoadGlob,
                     2 * dword_CE7104, 2, 21);
    v3 = *(float *)&dword_CE710C * 0.5;
    result = a1->smodelLightingLookupScale;
    *(float *)a1->smodelLightingLookupScale = 0.5 * *(float *)&dword_CE7108;
    *(float *)&a1->smodelLightingLookupScale[4] = v3;
    *(_DWORD *)&a1->smodelLightingLookupScale[8] = 1048576000;
    smodelLoadGlob = 0;
    dword_CE7104 = 0;
    dword_CE7108 = 0;
    dword_CE710C = 0;
    dword_CE7110 = 0;
  }
  return result;
}

_DWORD *__cdecl R_CreateStaticModel(GfxWorld *a1, XModel *a2, const float *a3,
                                    float *a4, int32_t a5,
                                    GfxStaticModelInstance *a6) {
  int v6;                            // edi
  int BasePose;                      // eax
  DObjSkelMat_s *v8;                 // ecx
  int v9;                            // esi
  int v10;                           // ebx
  float v11;                         // xmm3_4
  float v12;                         // xmm6_4
  float v13;                         // xmm1_4
  float v14;                         // xmm5_4
  float v15;                         // xmm4_4
  float v16;                         // xmm2_4
  float v17;                         // xmm7_4
  float v18;                         // xmm0_4
  float v19;                         // xmm3_4
  float v20;                         // xmm5_4
  float v21;                         // xmm6_4
  float v22;                         // xmm2_4
  int i;                             // ecx
  const XSurface_s *v25;             // ebx
  float *v26;                        // esi
  float *v27;                        // ebx
  float *v28;                        // ecx
  int k;                             // edi
  float v30;                         // xmm1_4
  float *v31;                        // edx
  float *v32;                        // eax
  float LodOutDist;                  // [esp+3Ch] [ebp-6Ch]
  float *v34;                        // [esp+40h] [ebp-68h]
  float *v35;                        // [esp+44h] [ebp-64h]
  int Surfaces;                      // [esp+48h] [ebp-60h]
  float *v37;                        // [esp+4Ch] [ebp-5Ch]
  int v38;                           // [esp+50h] [ebp-58h]
  int j;                             // [esp+54h] [ebp-54h]
  int NumVerts;                      // [esp+58h] [ebp-50h]
  DObjSkelMat_s *TempMemoryInternal; // [esp+5Ch] [ebp-4Ch]
  GfxWorld *mins;                    // [esp+60h] [ebp-48h]
  mnode_t *maxs;                     // [esp+6Ch] [ebp-3Ch]
  float v44;                         // [esp+78h] [ebp-30h]
  float v45;                         // [esp+7Ch] [ebp-2Ch]
  int *v46;                          // [esp+88h] [ebp-20h] BYREF
  XSurface_s **v47;                  // [esp+8Ch] [ebp-1Ch] BYREF

  *(_DWORD *)a6->model = a2;
  a6->origin[0] = *a3;
  v34 = (float *)(a3 + 1);
  a6->origin[1] = a3[1];
  v35 = (float *)(a3 + 2);
  a6->origin[2] = a3[2];
  AnglesToAxis(a4, a6->axis[0]);
  a6->scale = a5;
  maxs = (mnode_t *)a6->maxs;
  mins = (GfxWorld *)a6->mins;
  a6->mins[0] = 3.4028235e38;
  a6->mins[1] = 3.4028235e38;
  a6->mins[2] = 3.4028235e38;
  a6->maxs[0] = -3.4028235e38;
  a6->maxs[1] = -3.4028235e38;
  a6->maxs[2] = -3.4028235e38;
  Surfaces = XModelGetSurfaces(a2, &v47, 0, &v46);
  TempMemoryInternal =
      (DObjSkelMat_s *)Hunk_AllocateTempMemoryInternal(0x2000u);
  v37 = (float *)Hunk_AllocateTempMemoryInternal(0xFF78u);
  v6 = XModelNumBones(a2);
  BasePose = XModelGetBasePose(a2);
  if (v6 > 0) {
    v8 = TempMemoryInternal;
    v9 = 0;
    v10 = BasePose + 16;
    do {
      v11 = *(float *)(v10 + 12) * *(float *)(v10 - 16);
      v12 = *(float *)(v10 + 12) * *(float *)(v10 - 12);
      v13 = *(float *)(v10 + 12) * *(float *)(v10 - 8);
      v44 = v11 * *(float *)(v10 - 16);
      v14 = *(float *)(v10 - 12);
      v15 = v11 * v14;
      v16 = *(float *)(v10 - 8);
      v17 = v11 * v16;
      v18 = *(float *)(v10 - 4);
      v19 = v11 * v18;
      v45 = v14 * v12;
      v20 = v12 * v16;
      v21 = v12 * v18;
      v22 = v16 * v13;
      v8->axis[0][0] = 1.0 - (float)(v45 + v22);
      v8->axis[0][1] = (float)(v13 * v18) + v15;
      v8->axis[0][2] = v17 - v21;
      v8->axis[1][0] = 0.0;
      v8->axis[1][1] = v15 - (float)(v13 * v18);
      v8->axis[1][2] = 1.0 - (float)(v22 + v44);
      v8->axis[2][0] = v19 + v20;
      v8->axis[2][1] = 0.0;
      v8->axis[2][2] = v17 + v21;
      v8->axis[3][0] = v20 - v19;
      v8->axis[3][1] = 1.0 - (float)(v44 + v45);
      v8->axis[3][2] = 0.0;
      *(_DWORD *)v8->origin = *(_DWORD *)v10;
      *(_DWORD *)&v8->origin[4] = *(_DWORD *)(v10 + 4);
      *(_DWORD *)&v8->origin[8] = *(_DWORD *)(v10 + 8);
      *(_DWORD *)&v8->origin[12] = 1065353216;
      ++v9;
      v10 += 32;
      ++v8;
    } while (v6 != v9);
  }
  if (Surfaces > 0) {
    v38 = 0;
    for (i = 0;; i = v38) {
      v25 = v47[i];
      NumVerts = XSurfaceGetNumVerts(v25);
      XSurfaceGetVerts(v25, TempMemoryInternal, v37, 0, 0);
      if (NumVerts > 0) {
        v26 = v37;
        for (j = 0; j != NumVerts; ++j) {
          v27 = a6->axis[0];
          v28 = a6->axis[1];
          for (k = 1; k != 4; ++k) {
            v30 = (float)((float)(*v26 * *v27) + (float)(v26[1] * *v28)) +
                  (float)(v26[2] * a6->axis[1][k + 2]);
            v31 = (float *)&mins->name[4 * k];
            if (*(v31 - 1) > v30)
              *(v31 - 1) = v30;
            v32 = (float *)(&maxs->contents + k);
            if (v30 > *(v32 - 1))
              *(v32 - 1) = v30;
            ++v27;
            ++v28;
          }
          v26 += 3;
        }
      }
      if (Surfaces == ++v38)
        break;
    }
  }
  Hunk_FreeTempMemory(v37);
  Hunk_FreeTempMemory(TempMemoryInternal);
  *(float *)mins->name = (float)(*(float *)&a5 * *(float *)mins->name) + *a3;
  a6->mins[1] = (float)(*(float *)&a5 * a6->mins[1]) + *v34;
  a6->mins[2] = (float)(*(float *)&a5 * a6->mins[2]) + *v35;
  *(float *)&maxs->contents =
      (float)(*(float *)&a5 * *(float *)&maxs->contents) + *a3;
  a6->maxs[1] = (float)(*(float *)&a5 * a6->maxs[1]) + *v34;
  a6->maxs[2] = (float)(*(float *)&a5 * a6->maxs[2]) + *v35;
  LodOutDist = XModelGetLodOutDist(a2);
  *(float *)&a6->cullDist = *(float *)&a5 * LodOutDist;
  return R_FilterStaticModelIntoCells_r(a1, a1->nodes, (int)a6, mins, maxs);
}

int32_t __cdecl R_SortGfxAabbTree(GfxWorld *a1, GfxAabbTree *a2) {
  int32_t result;      // eax
  int i;               // esi
  int v5;              // edx
  int j;               // ebx
  int v7;              // ecx
  float *v8;           // eax
  float v9;            // xmm1_4
  float v10;           // xmm0_4
  float v11;           // xmm1_4
  float v12;           // xmm6_4
  float v13;           // xmm3_4
  float v14;           // xmm7_4
  float v15;           // xmm4_4
  float v16;           // xmm2_4
  float v17;           // xmm5_4
  int v18;             // ebx
  int *v19;            // ecx
  float *v20;          // eax
  int v21;             // eax
  int v22;             // eax
  int v23;             // edx
  int v24;             // ebx
  int *v25;            // ecx
  float *v26;          // eax
  int v27;             // eax
  int v28;             // eax
  int v29;             // edx
  int v30;             // ebx
  int *v31;            // ecx
  float *v32;          // eax
  int v33;             // eax
  int v34;             // eax
  int v35;             // edx
  int *v36;            // eax
  int v37;             // ebx
  int *v38;            // ecx
  float *v39;          // eax
  int v40;             // eax
  int v41;             // ecx
  int k;               // edx
  int32_t v43;         // ecx
  uint32_t childCount; // eax
  uint32_t v45;        // edx
  int m;               // esi
  int v47;             // ebx
  uint32_t v48;        // edx
  GfxAabbTree *v49;    // eax
  uint32_t v50;        // edx
  GfxAabbTree *v51;    // eax
  signed int v52;      // esi
  int v53;             // ebx
  int v54;             // [esp+1Ch] [ebp-9Ch]
  int v55;             // [esp+1Ch] [ebp-9Ch]
  int v56;             // [esp+1Ch] [ebp-9Ch]
  int v57;             // [esp+1Ch] [ebp-9Ch]
  int *v58;            // [esp+2Ch] [ebp-8Ch]
  int *v59;            // [esp+30h] [ebp-88h]
  int *v60;            // [esp+34h] [ebp-84h]
  int *v61;            // [esp+38h] [ebp-80h]
  int v62;             // [esp+3Ch] [ebp-7Ch]
  int *v63;            // [esp+40h] [ebp-78h]
  float v64;           // [esp+44h] [ebp-74h]
  int v65;             // [esp+48h] [ebp-70h]
  int v66;             // [esp+4Ch] [ebp-6Ch]
  int v67;             // [esp+50h] [ebp-68h]
  int v68;             // [esp+54h] [ebp-64h]
  int v69;             // [esp+58h] [ebp-60h]
  int v70;             // [esp+5Ch] [ebp-5Ch]
  int v71;             // [esp+60h] [ebp-58h]
  int *v72;            // [esp+64h] [ebp-54h]
  int v73;             // [esp+68h] [ebp-50h]
  int *v74;            // [esp+6Ch] [ebp-4Ch]
  _DWORD v76[4];       // [esp+78h] [ebp-40h]
  float v77;           // [esp+88h] [ebp-30h] BYREF
  float v78;           // [esp+8Ch] [ebp-2Ch]
  float v79;           // [esp+90h] [ebp-28h]
  float v80;           // [esp+94h] [ebp-24h] BYREF
  float v81;           // [esp+98h] [ebp-20h]
  float v82;           // [esp+9Ch] [ebp-1Ch]

  while (1) {
    qsort(*(void **)a2->staticModels, *(_DWORD *)a2->staticModelCount, 4u,
          (int(__cdecl *)(const void *, const void *))CompareStaticModels);
    result = a2->childCount;
    if (result)
      break;
    v80 = 3.4028235e38;
    v81 = 3.4028235e38;
    v82 = 3.4028235e38;
    v77 = -3.4028235e38;
    v78 = -3.4028235e38;
    v79 = -3.4028235e38;
    v69 = *(_DWORD *)a2->staticModelCount;
    if (v69 > 0) {
      v70 = *(_DWORD *)a2->staticModels;
      v62 = *(_DWORD *)a1->smodelInsts;
      for (i = 0; i != v69; ++i) {
        v5 = 96 * *(_DWORD *)(v70 + 4 * i) + v62;
        for (j = 1; j != 4; ++j) {
          v7 = 4 * j;
          v8 = &v80 + j;
          v9 = *(float *)(v5 + 20);
          if (*(v8 - 1) > v9)
            *(v8 - 1) = v9;
          v10 = *(float *)(v5 + 32);
          if (v10 > *(float *)((char *)&v77 + v7 - 4))
            *(float *)((char *)&v77 + v7 - 4) = v10;
          v5 += 4;
        }
      }
    }
    result = a2->surfaceCount;
    if (!result) {
      a2->mins[0] = v80;
      a2->mins[1] = v81;
      a2->mins[2] = v82;
      a2->maxs[0] = v77;
      a2->maxs[1] = v78;
      result = LODWORD(v79);
      a2->maxs[2] = v79;
    }
    v54 = *(_DWORD *)a2->staticModelCount;
    if (v54 <= 7)
      return result;
    v11 = v80;
    v12 = v77;
    v13 = v81;
    v14 = v78;
    v15 = v82;
    v64 = v79;
    v16 = (float)(v80 + v77) * 0.5;
    v17 = (float)(v81 + v78) * 0.5;
    v63 = *(int **)a2->staticModels;
    v18 = 0;
    v65 = 0;
    v19 = v63;
    v58 = v63;
    do {
      v20 = (float *)(*(_DWORD *)a1->smodelInsts + 96 * *v19);
      if (v11 <= v20[5] && v13 <= v20[6] && v15 <= v20[7] && v20[8] <= v16 &&
          v20[9] <= v14 && v20[10] <= v64) {
        v21 = *v58;
        *v58 = *v19;
        *v19 = v21;
        ++v65;
        ++v58;
      }
      ++v18;
      ++v19;
    } while (v54 != v18);
    if (v65 <= 1) {
      v22 = 0;
      v23 = 0;
    } else {
      v22 = v65;
      v23 = v65;
    }
    v76[0] = v23;
    v72 = &v63[v22];
    v55 = v54 - v23;
    if (v55 <= 0)
      goto LABEL_73;
    v24 = 0;
    v66 = 0;
    v25 = &v63[v22];
    v59 = v25;
    do {
      v26 = (float *)(*(_DWORD *)a1->smodelInsts + 96 * *v25);
      if (v16 <= v26[5] && v13 <= v26[6] && v15 <= v26[7] && v26[8] <= v12 &&
          v26[9] <= v14 && v26[10] <= v64) {
        v27 = *v59;
        *v59 = *v25;
        *v25 = v27;
        ++v66;
        ++v59;
      }
      ++v24;
      ++v25;
    } while (v55 != v24);
    if (v66 <= 1) {
    LABEL_73:
      v28 = 0;
      v29 = 0;
    } else {
      v28 = v66;
      v29 = v66;
    }
    v76[1] = v29;
    v74 = &v72[v28];
    v56 = v55 - v29;
    if (v56 <= 0)
      goto LABEL_72;
    v30 = 0;
    v67 = 0;
    v31 = &v72[v28];
    v60 = v31;
    do {
      v32 = (float *)(*(_DWORD *)a1->smodelInsts + 96 * *v31);
      if (v11 <= v32[5] && v13 <= v32[6] && v15 <= v32[7] && v32[8] <= v12 &&
          v32[9] <= v17 && v32[10] <= v64) {
        v33 = *v60;
        *v60 = *v31;
        *v31 = v33;
        ++v67;
        ++v60;
      }
      ++v30;
      ++v31;
    } while (v56 != v30);
    if (v67 <= 1) {
    LABEL_72:
      v34 = 0;
      v35 = 0;
    } else {
      v34 = v67;
      v35 = v67;
    }
    v76[2] = v35;
    v36 = &v74[v34];
    v57 = v56 - v35;
    if (v57 <= 0)
      goto LABEL_71;
    v37 = 0;
    v68 = 0;
    v38 = v36;
    v61 = v36;
    do {
      v39 = (float *)(*(_DWORD *)a1->smodelInsts + 96 * *v38);
      if (v11 <= v39[5] && v17 <= v39[6] && v15 <= v39[7] && v39[8] <= v12 &&
          v39[9] <= v14 && v39[10] <= v64) {
        v40 = *v61;
        *v61 = *v38;
        *v38 = v40;
        ++v68;
        ++v61;
      }
      ++v37;
      ++v38;
    } while (v57 != v37);
    if (v68 <= 1)
    LABEL_71:
      v68 = 0;
    v76[3] = v68;
    v41 = 0;
    for (k = 0; k != 4; ++k) {
      result = v76[k] != 0;
      v41 += result;
    }
    if (!v41)
      return result;
    result = (int32_t)Hunk_AllocAlignInternal(
        48 * (v41 - ((a2->surfaceCount == 0) - 1) - ((v57 == v68) - 1)), 4);
    v43 = result;
    a2->children = result;
    if (a2->surfaceCount) {
      childCount = a2->childCount;
      v45 = v43 + 48 * childCount;
      a2->childCount = childCount + 1;
      *(float *)v45 = a2->mins[0];
      *(float *)(v45 + 4) = a2->mins[1];
      *(float *)(v45 + 8) = a2->mins[2];
      *(float *)(v45 + 12) = a2->maxs[0];
      *(float *)(v45 + 16) = a2->maxs[1];
      *(float *)(v45 + 20) = a2->maxs[2];
      *(_DWORD *)(v45 + 28) = a2->startSurfIndex;
      result = a2->surfaceCount;
      *(_DWORD *)(v45 + 24) = result;
    }
    v73 = *(_DWORD *)a2->staticModels;
    v71 = *(_DWORD *)a2->staticModelCount;
    for (m = 1; m != 5; ++m) {
      v47 = v76[m - 1];
      if (v47) {
        v50 = a2->childCount;
        v51 = (GfxAabbTree *)(a2->children + 48 * v50);
        a2->childCount = v50 + 1;
        *(_DWORD *)v51->staticModelCount = v47;
        *(_DWORD *)v51->staticModels = v73;
        result = R_SortGfxAabbTree(a1, v51);
        v73 += 4 * v47;
        v71 -= v47;
      }
    }
    if (!v71)
      return result;
    v48 = a2->childCount;
    v49 = (GfxAabbTree *)(a2->children + 48 * v48);
    a2->childCount = v48 + 1;
    *(_DWORD *)v49->staticModelCount = v71;
    *(_DWORD *)v49->staticModels = v73;
    a2 = v49;
  }
  if ((int)a2->childCount > 0) {
    v52 = 0;
    v53 = 0;
    do {
      result = R_SortGfxAabbTree(a1, (GfxAabbTree *)(a2->children + v53));
      ++v52;
      v53 += 48;
    } while ((signed int)a2->childCount > v52);
  }
  return result;
}

signed int __cdecl R_AllocStaticModels(GfxAabbTree *a1) {
  signed int result; // eax
  void *v2;          // ebx
  int v3;            // eax
  void *v4;          // ebx
  int v5;            // eax
  void *v6;          // ebx
  int v7;            // eax
  void *v8;          // ebx
  int v9;            // eax
  void *v10;         // ebx
  int v11;           // eax
  int v12;           // eax
  int v13;           // ecx
  int v14;           // eax
  int v15;           // ecx
  int v16;           // eax
  int v17;           // esi
  int v18;           // eax
  void *v19;         // ebx
  int v20;           // edi
  int v21;           // ebx
  void *v22;         // ebx
  void *v23;         // ebx
  void *v24;         // ebx
  signed int v25;    // [esp+14h] [ebp-74h]
  int v26;           // [esp+18h] [ebp-70h]
  int v27;           // [esp+1Ch] [ebp-6Ch]
  int v28;           // [esp+20h] [ebp-68h]
  int v29;           // [esp+24h] [ebp-64h]
  int v30;           // [esp+28h] [ebp-60h]
  int v31;           // [esp+2Ch] [ebp-5Ch]
  int v32;           // [esp+30h] [ebp-58h]
  int v33;           // [esp+34h] [ebp-54h]
  int v34;           // [esp+38h] [ebp-50h]
  int v35;           // [esp+3Ch] [ebp-4Ch]
  int v36;           // [esp+40h] [ebp-48h]
  int v37;           // [esp+44h] [ebp-44h]
  int v38;           // [esp+48h] [ebp-40h]
  int v39;           // [esp+4Ch] [ebp-3Ch]
  int v40;           // [esp+50h] [ebp-38h]
  int v41;           // [esp+54h] [ebp-34h]
  int v42;           // [esp+58h] [ebp-30h]
  int v43;           // [esp+5Ch] [ebp-2Ch]
  int v44;           // [esp+60h] [ebp-28h]
  int v45;           // [esp+64h] [ebp-24h]
  int v46;           // [esp+68h] [ebp-20h]
  int i;             // [esp+6Ch] [ebp-1Ch]

  result = *(_DWORD *)a1->staticModelCount;
  if (result) {
    v2 = Hunk_AllocAlignInternal(4 * result, 4);
    memcpy(v2, *(const void **)a1->staticModels,
           4 * *(_DWORD *)a1->staticModelCount);
    result = (signed int)a1;
    *(_DWORD *)a1->staticModels = v2;
  }
  if ((int)a1->childCount > 0) {
    v25 = 0;
    for (i = 0;; i += 48) {
      v26 = a1->children + i;
      v3 = *(_DWORD *)(v26 + 32);
      if (v3) {
        v4 = Hunk_AllocAlignInternal(4 * v3, 4);
        memcpy(v4, *(const void **)(v26 + 36), 4 * *(_DWORD *)(v26 + 32));
        *(_DWORD *)(v26 + 36) = v4;
      }
      if (*(int *)(v26 + 40) > 0)
        break;
    LABEL_47:
      result = ++v25;
      if (v25 >= (signed int)a1->childCount)
        return result;
    }
    v27 = 0;
    v46 = 0;
    while (1) {
      v28 = *(_DWORD *)(v26 + 44) + v46;
      v5 = *(_DWORD *)(v28 + 32);
      if (v5) {
        v6 = Hunk_AllocAlignInternal(4 * v5, 4);
        memcpy(v6, *(const void **)(v28 + 36), 4 * *(_DWORD *)(v28 + 32));
        *(_DWORD *)(v28 + 36) = v6;
      }
      if (*(int *)(v28 + 40) > 0)
        break;
    LABEL_46:
      ++v27;
      v46 += 48;
      if (v27 >= *(_DWORD *)(v26 + 40))
        goto LABEL_47;
    }
    v29 = 0;
    v45 = 0;
    while (1) {
      v30 = *(_DWORD *)(v28 + 44) + v45;
      v7 = *(_DWORD *)(v30 + 32);
      if (v7) {
        v8 = Hunk_AllocAlignInternal(4 * v7, 4);
        memcpy(v8, *(const void **)(v30 + 36), 4 * *(_DWORD *)(v30 + 32));
        *(_DWORD *)(v30 + 36) = v8;
      }
      if (*(int *)(v30 + 40) > 0)
        break;
    LABEL_45:
      ++v29;
      v45 += 48;
      if (*(_DWORD *)(v28 + 40) <= v29)
        goto LABEL_46;
    }
    v31 = 0;
    v44 = 0;
    while (1) {
      v32 = *(_DWORD *)(v30 + 44) + v44;
      v9 = *(_DWORD *)(v32 + 32);
      if (v9) {
        v10 = Hunk_AllocAlignInternal(4 * v9, 4);
        memcpy(v10, *(const void **)(v32 + 36), 4 * *(_DWORD *)(v32 + 32));
        *(_DWORD *)(v32 + 36) = v10;
      }
      if (*(int *)(v32 + 40) > 0) {
        v33 = 0;
        v43 = 0;
        v34 = *(_DWORD *)(v32 + 44);
        v11 = *(_DWORD *)(v34 + 32);
        if (v11)
          goto LABEL_43;
        while (1) {
          if (*(int *)(v34 + 40) > 0) {
            v35 = 0;
            v42 = 0;
            v36 = *(_DWORD *)(v34 + 44);
            v12 = *(_DWORD *)(v36 + 32);
            if (v12)
              goto LABEL_40;
            while (1) {
              if (*(int *)(v36 + 40) > 0) {
                v37 = 0;
                v41 = 0;
                v13 = v36;
                while (1) {
                  v38 = *(_DWORD *)(v13 + 44) + v41;
                  v14 = *(_DWORD *)(v38 + 32);
                  if (v14) {
                    v23 = Hunk_AllocAlignInternal(4 * v14, 4);
                    memcpy(v23, *(const void **)(v38 + 36),
                           4 * *(_DWORD *)(v38 + 32));
                    *(_DWORD *)(v38 + 36) = v23;
                  }
                  if (*(int *)(v38 + 40) > 0)
                    break;
                LABEL_37:
                  ++v37;
                  v41 += 48;
                  v13 = v36;
                  if (v37 >= *(_DWORD *)(v36 + 40))
                    goto LABEL_38;
                }
                v39 = 0;
                v40 = 0;
                v15 = v38;
                while (2) {
                  v17 = *(_DWORD *)(v15 + 44) + v40;
                  v18 = *(_DWORD *)(v17 + 32);
                  if (v18) {
                    v19 = Hunk_AllocAlignInternal(4 * v18, 4);
                    memcpy(v19, *(const void **)(v17 + 36),
                           4 * *(_DWORD *)(v17 + 32));
                    *(_DWORD *)(v17 + 36) = v19;
                    if (*(int *)(v17 + 40) > 0) {
                    LABEL_34:
                      v20 = 0;
                      v21 = 0;
                      do {
                        R_AllocStaticModels(
                            (GfxAabbTree *)(*(_DWORD *)(v17 + 44) + v21));
                        ++v20;
                        v21 += 48;
                      } while (v20 < *(_DWORD *)(v17 + 40));
                      ++v39;
                      v40 += 48;
                      v16 = v38;
                      if (v39 >= *(_DWORD *)(v38 + 40))
                        goto LABEL_37;
                      goto LABEL_31;
                    }
                  } else if (*(int *)(v17 + 40) > 0) {
                    goto LABEL_34;
                  }
                  ++v39;
                  v40 += 48;
                  v16 = v38;
                  if (v39 >= *(_DWORD *)(v38 + 40))
                    goto LABEL_37;
                LABEL_31:
                  v15 = v16;
                  continue;
                }
              }
            LABEL_38:
              ++v35;
              v42 += 48;
              if (v35 >= *(_DWORD *)(v34 + 40))
                break;
              v36 = *(_DWORD *)(v34 + 44) + v42;
              v12 = *(_DWORD *)(v36 + 32);
              if (v12) {
              LABEL_40:
                v22 = Hunk_AllocAlignInternal(4 * v12, 4);
                memcpy(v22, *(const void **)(v36 + 36),
                       4 * *(_DWORD *)(v36 + 32));
                *(_DWORD *)(v36 + 36) = v22;
              }
            }
          }
          ++v33;
          v43 += 48;
          if (v33 >= *(_DWORD *)(v32 + 40))
            break;
          v34 = *(_DWORD *)(v32 + 44) + v43;
          v11 = *(_DWORD *)(v34 + 32);
          if (v11) {
          LABEL_43:
            v24 = Hunk_AllocAlignInternal(4 * v11, 4);
            memcpy(v24, *(const void **)(v34 + 36), 4 * *(_DWORD *)(v34 + 32));
            *(_DWORD *)(v34 + 36) = v24;
          }
        }
      }
      ++v31;
      v44 += 48;
      if (v31 >= *(_DWORD *)(v30 + 40))
        goto LABEL_45;
    }
  }
  return result;
}

GfxImage *__cdecl R_RegisterOutdoorImage(GfxWorld *a1) {
  GfxImage *result; // eax
  int v2;           // esi
  int v3;           // ebx
  _DWORD *v4;       // edx
  float *v5;        // eax
  float v6;         // xmm1_4
  _DWORD *v7;       // ecx
  float *v8;        // edx
  float v9;         // xmm1_4
  int v10;          // ecx
  float *v11;       // edx
  float v12;        // xmm1_4
  float v13;        // xmm0_4
  int v14;          // eax
  __int64 v15;      // [esp+8h] [ebp-40h]
  _BYTE v16[4];     // [esp+14h] [ebp-34h]
  float v17;        // [esp+18h] [ebp-30h]
  float v18;        // [esp+1Ch] [ebp-2Ch]
  _DWORD v19[10];   // [esp+20h] [ebp-28h]

  result = (GfxImage *)r_rendererInUse;
  if (*(_DWORD *)(r_rendererInUse + 8) == 2) {
    a1->outdoorImage = 0;
  } else {
    ClearBounds(outdoorGlob, dword_CE718C);
    if (a1->surfaceCount) {
      v2 = 0;
      v3 = 0;
      do {
        while (1) {
          v4 = (_DWORD *)(a1->surfaces + v3);
          if ((*(_BYTE *)(*v4 + 12) & 8) == 0)
            break;
          ++v2;
          v3 += 12;
          if (v2 == a1->surfaceCount)
            goto LABEL_7;
        }
        HIDWORD(v15) = dword_CE718C;
        LODWORD(v15) = outdoorGlob;
        ExpandBounds(v4[2] + 4, v4[2] + 16, v15);
        ++v2;
        v3 += 12;
      } while (v2 != a1->surfaceCount);
    }
  LABEL_7:
    v5 = (float *)outdoorGlob;
    do {
      v6 = *v5;
      if (*v5 == 131072.0) {
        *v5 = 0.0;
        v5[3] = 0.0;
        v6 = *v5;
      }
      if ((float)(v5[3] - v6) < 1.0) {
        *v5 = v6 - 0.5;
        v5[3] = v5[3] + 0.5;
      }
      ++v5;
    } while (v5 != (float *)dword_CE718C);
    v7 = &outdoorMapSize;
    v8 = (float *)dword_CE718C;
    do {
      v9 = (float)(*v7 - 1) / (float)(*v8 - *(v8 - 3));
      v8[3] = v9;
      v8[6] = 1.0 / v9;
      v8[9] = (float)-*(v8 - 3) * v9;
      ++v7;
      ++v8;
    } while (v7 != (_DWORD *)&unk_2F30AC);
    v10 = 1;
    v11 = (float *)dword_CE718C;
    do {
      v12 = *(v11 - 3);
      v13 = *v11 - v12;
      v14 = v10;
      *(float *)&v19[v14] = 1.0 / v13;
      *(float *)&v16[v14 * 4] = (float)-v12 * (float)(1.0 / v13);
      ++v10;
      ++v11;
    } while (v10 != 4);
    MatrixIdentity44(a1->outdoorLookupMatrix);
    LODWORD(a1->outdoorLookupMatrix[0]) = v19[1];
    LODWORD(a1->outdoorLookupMatrix[5]) = v19[2];
    LODWORD(a1->outdoorLookupMatrix[10]) = v19[3];
    a1->outdoorLookupMatrix[12] = v17;
    a1->outdoorLookupMatrix[13] = v18;
    LODWORD(a1->outdoorLookupMatrix[14]) = v19[0];
    result = Image_Register("$outdoor", 1, 0);
    a1->outdoorImage = (int32_t)result;
  }
  return result;
}

void __cdecl R_GenerateOutdoorImage(GfxImage *a1) {
  float v1;                  // xmm3_4
  int j;                     // ebx
  int v3;                    // edx
  _BYTE *v4;                 // eax
  float v5;                  // xmm2_4
  float v6;                  // xmm1_4
  float v7;                  // [esp+54h] [ebp-64h]
  int i;                     // [esp+58h] [ebp-60h]
  _BYTE *TempMemoryInternal; // [esp+5Ch] [ebp-5Ch]
  trace_t v10;               // [esp+64h] [ebp-54h] BYREF
  float v11[3];              // [esp+88h] [ebp-30h] BYREF
  float v12[9];              // [esp+94h] [ebp-24h] BYREF

  TempMemoryInternal = Hunk_AllocateTempMemoryInternal(0x40000u);
  dword_CE71BC = (int)TempMemoryInternal;
  for (i = 0; i != 512; ++i) {
    v1 = (float)((float)((float)i + 0.5) - *(float *)&dword_CE71B4) *
         *(float *)&dword_CE71A8;
    for (j = 0; j != 512; ++j) {
      while (1) {
        v5 = *(float *)&dword_CE7194 + 1.0;
        v6 = *(float *)&dword_CE7188 - 1.0;
        v12[0] = (float)((float)((float)j + 0.5) - *(float *)&dword_CE71B0) *
                 *(float *)&dword_CE71A4;
        v12[1] = v1;
        v12[2] = *(float *)&dword_CE7194 + 1.0;
        v11[0] = v12[0];
        v11[1] = v1;
        v11[2] = *(float *)&dword_CE7188 - 1.0;
        memset(&v10, 0, sizeof(v10));
        v10.fraction = 1.0;
        CM_BoxTrace(&v10, v12, v11, (trace_t *)vec3_origin, vec3_origin, 0,
                    flt_2001);
        v7 = floorf(
            (float)((float)(v5 + (float)((float)(v6 - v5) * v10.fraction)) *
                    *(float *)&dword_CE71A0) +
            *(float *)&dword_CE71B8);
        if ((int)v7 >= 0)
          break;
        v4 = TempMemoryInternal;
        TempMemoryInternal[j++] = 0;
        if (j == 512)
          goto LABEL_8;
      }
      LOBYTE(v3) = -1;
      if ((int)v7 <= 255)
        v3 = (int)v7;
      v4 = TempMemoryInternal;
      TempMemoryInternal[j] = v3;
    }
  LABEL_8:
    TempMemoryInternal = v4 + 512;
  }
  Image_Generate2D(&a1->mapType, (char *)dword_CE71BC, 512, 512, 50);
  Hunk_FreeTempMemory((void *)dword_CE71BC);
}

_BOOL4 __cdecl R_WatersEquivalent(const water_t *a1, const water_t *a2) {
  _BOOL4 result; // eax
  float v3;      // xmm1_4
  float v4;      // xmm5_4
  float v5;      // xmm0_4

  result = 0;
  if (a1->M == a2->M && a1->N == a2->N &&
      *(float *)&a1->Lx == *(float *)&a2->Lx &&
      *(float *)&a1->Lz == *(float *)&a2->Lz &&
      fabs(*(float *)&a1->amplitude - *(float *)&a2->amplitude) <= 0.001 &&
      fabs(*(float *)&a1->gravity - *(float *)&a2->gravity) <= 0.1 &&
      fabs(*(float *)&a1->windvel - *(float *)&a2->windvel) <= 0.1) {
    v3 = *(float *)&a2->winddir;
    v4 = *((float *)&a2->winddir + 1);
    v5 =
        fsqrt((float)((float)(*(float *)&a1->winddir * *(float *)&a1->winddir) +
                      (float)(*((float *)&a1->winddir + 1) *
                              *((float *)&a1->winddir + 1))) *
              (float)((float)(v3 * v3) + (float)(v4 * v4))) +
        1.0e-10;
    if (fabs((float)((float)((float)(*(float *)&a1->winddir * v3) +
                             (float)(*((float *)&a1->winddir + 1) * v4)) /
                     v5) -
             1.0) <= 0.001)
      return 1;
  }
  return result;
}

int32_t __cdecl R_CreateWaterSetup(const water_t *__src, int a2,
                                   water_t *__dst) {
  float v4;             // xmm5_4
  int32_t N;            // esi
  float v6;             // xmm0_4
  float v7;             // xmm1_4
  int32_t M;            // ecx
  int v9;               // ebx
  int v10;              // esi
  float v11;            // xmm0_4
  float v12;            // xmm0_4
  float v13;            // xmm3_4
  float v14;            // xmm4_4
  unsigned __int16 v15; // bx
  unsigned __int16 v16; // si
  char *v17;            // eax
  int32_t result;       // eax
  long double v19;      // [esp+0h] [ebp-B8h]
  double v20;           // [esp+40h] [ebp-78h]
  float v21;            // [esp+50h] [ebp-68h]
  int v22;              // [esp+70h] [ebp-48h]
  float v23;            // [esp+74h] [ebp-44h]
  int v24;              // [esp+80h] [ebp-38h]
  float v25;            // [esp+84h] [ebp-34h]
  int v26;              // [esp+8Ch] [ebp-2Ch]
  float v27;            // [esp+98h] [ebp-20h] BYREF
  float v28[7];         // [esp+9Ch] [ebp-1Ch] BYREF

  memcpy(__dst, __src, sizeof(water_t));
  __dst->H0 = Material_Alloc();
  __dst->wTerm = Material_Alloc();
  v4 = (float)((float)(*(float *)&__dst->windvel * *(float *)&__dst->windvel) *
               (float)(*(float *)&__dst->windvel * *(float *)&__dst->windvel)) /
       *(float *)&__dst->gravity;
  N = __dst->N;
  v6 = 6.283185307179586 / (float)((float)N * *(float *)&__dst->Lx);
  v23 = v6;
  v7 = 6.283185307179586 / (float)((float)__dst->M * *(float *)&__dst->Lz);
  v22 = ((N > 0) - N) >> 1;
  if (v22 < N / 2) {
    v24 = 0;
    M = __dst->M;
    do {
      while (1) {
        v9 = ((M > 0) - M) >> 1;
        if (M / 2 > v9)
          break;
        if (++v22 >= N / 2)
          goto LABEL_10;
      }
      v10 = 8 * v24;
      v26 = 4 * v24;
      do {
        while (1) {
          v21 = (float)v9 * v7;
          GaussianRandom(&v27, v28);
          v13 = (float)(v21 * v21) +
                (float)((float)(v23 * (float)v22) * (float)(v23 * (float)v22));
          v25 = fsqrt(v13) * *(float *)&__dst->gravity;
          v14 = (float)((float)(v23 * (float)v22) * *(float *)&__dst->winddir) +
                (float)(v21 * *((float *)&__dst->winddir + 1));
          if (v14 <= 0.0)
            break;
          *(double *)&v19 = (float)(-1.0 / (float)(v4 * v13));
          v20 = *(float *)&__dst->amplitude;
          v11 = v20 * (double)exp(v19) / (float)(v13 * (float)(v13 * v13)) *
                (float)(v14 * v14);
          v12 = fsqrt(v11 * 0.5) * *(float *)&__dst->amplitude;
          *(float *)(__dst->H0 + v10) = v12 * v27;
          *(float *)(__dst->H0 + v10 + 4) = v12 * v28[0];
          *(float *)(__dst->wTerm + v26) = fsqrt(v25);
          ++v24;
          ++v9;
          v10 += 8;
          v26 += 4;
          M = __dst->M;
          if (M / 2 <= v9)
            goto LABEL_9;
        }
        *(_DWORD *)(__dst->H0 + v10) = 0;
        *(_DWORD *)(__dst->H0 + v10 + 4) = 0;
        *(_DWORD *)(__dst->wTerm + v26) = 0;
        ++v24;
        ++v9;
        v10 += 8;
        v26 += 4;
        M = __dst->M;
      } while (M / 2 > v9);
    LABEL_9:
      N = __dst->N;
      ++v22;
    } while (v22 < N / 2);
  }
LABEL_10:
  v15 = __src->N;
  v16 = __src->M;
  v17 = va("watersetup%i", a2);
  result = R_CreateWaterMap(v17, v16, v15);
  __dst->image = result;
  return result;
}

unsigned int R_AvailableTextureMemory(void) {
  unsigned int v0;    // esi
  unsigned int v1;    // eax
  unsigned int v2;    // ebx
  int v4;             // [esp+18h] [ebp-20h] BYREF
  unsigned int v5[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  MacDisplay::GetVideoMemoryInfo((MacDisplay *)v5, &v4);
  v0 = v5[0];
  v1 = (*(int(__cdecl **)(int))(*(_DWORD *)dword_117D8A8 + 16))(dword_117D8A8);
  v2 = v1 >> 20;
  if (!v0) {
    ri(0,
       "DirectX reports %i MB of available texture memory, but wouldn't tell "
       "available video memory.\n",
       v1 >> 20);
    return v2;
  }
  ri(0,
     "DirectX reports %i MB of video memory and %i MB of available texture "
     "memory.\n",
     v0, v1 >> 20);
  if (v0 >= v2)
    return v2;
  ri(0, "Using video memory size to cap used texture memory at %i MB.\n",
     v0 - 16);
  return v0 - 16;
}

int32_t __cdecl Wavelet_DecompressLevel(unsigned __int8 *a1,
                                        unsigned __int8 *a2,
                                        WaveletDecode *a3) {
  int32_t mipLevel;       // ecx
  unsigned __int8 *v4;    // edx
  int16_t value;          // si
  int v6;                 // ebx
  unsigned __int16 v7;    // dx
  int v8;                 // eax
  int v9;                 // eax
  unsigned __int8 *i;     // eax
  int v11;                // edi
  __int16 v12;            // si
  int v13;                // ebx
  unsigned int v14;       // edx
  unsigned __int16 v15;   // si
  int16_t v16;            // si
  __int16 v17;            // ax
  int v18;                // ebx
  unsigned __int16 v19;   // dx
  int16_t v20;            // di
  int v21;                // esi
  int v22;                // ebx
  unsigned int v23;       // edx
  int16_t v24;            // di
  __int16 v25;            // ax
  int v26;                // esi
  int v27;                // edi
  __int16 v28;            // si
  int v29;                // ebx
  unsigned int v30;       // edx
  unsigned __int16 v31;   // si
  int16_t v32;            // si
  __int16 v33;            // ax
  int v34;                // ebx
  int v35;                // edi
  __int16 v36;            // si
  int v37;                // ebx
  unsigned int v38;       // edx
  unsigned __int16 v39;   // si
  int16_t v40;            // si
  __int16 v41;            // ax
  int v42;                // edi
  int v43;                // edx
  int v44;                // ebx
  int v45;                // edx
  int v46;                // ecx
  int v47;                // ebx
  int16_t v48;            // di
  int v49;                // esi
  int v50;                // ebx
  unsigned int v51;       // edx
  int16_t v52;            // di
  __int16 v53;            // ax
  int v54;                // esi
  int v55;                // edi
  __int16 v56;            // si
  int v57;                // ebx
  unsigned int v58;       // edx
  unsigned __int16 v59;   // si
  int16_t v60;            // si
  __int16 v61;            // ax
  int v62;                // ebx
  int v63;                // edi
  __int16 v64;            // si
  int v65;                // ebx
  unsigned int v66;       // edx
  unsigned __int16 v67;   // si
  int16_t v68;            // bx
  __int16 v69;            // ax
  int v70;                // esi
  int v71;                // esi
  int v72;                // edx
  int v73;                // edx
  WaveletDecode *v74;     // edi
  int v75;                // ebx
  unsigned __int16 v76;   // dx
  int16_t v77;            // di
  int v78;                // esi
  int v79;                // ebx
  unsigned int v80;       // edx
  int16_t v81;            // di
  __int16 v82;            // ax
  int v83;                // edi
  __int16 v84;            // si
  int v85;                // ebx
  unsigned int v86;       // edx
  unsigned __int16 v87;   // si
  int16_t v88;            // si
  __int16 v89;            // ax
  int v90;                // edi
  __int16 v91;            // si
  int v92;                // ebx
  unsigned int v93;       // edx
  unsigned __int16 v94;   // si
  int16_t v95;            // si
  __int16 v96;            // ax
  int v97;                // edi
  unsigned __int8 *v98;   // ebx
  int v99;                // ebx
  unsigned __int16 v100;  // dx
  int16_t v101;           // di
  int v102;               // esi
  int v103;               // ebx
  unsigned int v104;      // edx
  int16_t v105;           // di
  __int16 v106;           // ax
  int v107;               // edi
  __int16 v108;           // si
  int v109;               // ebx
  unsigned int v110;      // edx
  unsigned __int16 v111;  // si
  int16_t v112;           // si
  __int16 v113;           // ax
  int v114;               // edi
  __int16 v115;           // si
  int v116;               // ebx
  unsigned int v117;      // edx
  unsigned __int16 v118;  // si
  int16_t v119;           // si
  __int16 v120;           // ax
  int v121;               // edx
  int v122;               // edx
  unsigned __int8 *v123;  // eax
  int v124;               // esi
  int v125;               // edi
  int v126;               // edi
  int v127;               // esi
  int v128;               // edi
  int32_t result;         // eax
  int v130;               // eax
  int v131;               // edi
  int32_t v132;           // eax
  int v133;               // esi
  int v134;               // ebx
  WaveletDecode *v135;    // edx
  int32_t v136;           // ecx
  WaveletDecode *j;       // edi
  unsigned __int8 *v138;  // edx
  int v139;               // edi
  __int16 v140;           // si
  int v141;               // ebx
  unsigned int v142;      // edx
  unsigned __int16 v143;  // si
  int16_t v144;           // si
  __int16 v145;           // ax
  char v146;              // di
  int v147;               // [esp+0h] [ebp-F0h]
  int v148;               // [esp+8h] [ebp-E8h]
  int v149;               // [esp+8h] [ebp-E8h]
  int v150;               // [esp+8h] [ebp-E8h]
  int v151;               // [esp+8h] [ebp-E8h]
  int v152;               // [esp+8h] [ebp-E8h]
  int v153;               // [esp+8h] [ebp-E8h]
  int v154;               // [esp+8h] [ebp-E8h]
  int v155;               // [esp+8h] [ebp-E8h]
  int v156;               // [esp+8h] [ebp-E8h]
  int32_t channels;       // [esp+Ch] [ebp-E4h]
  unsigned __int16 *data; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v159; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v160; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v161; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v162; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v163; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v164; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v165; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v166; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v167; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v168; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v169; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v170; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v171; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v172; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v173; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v174; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v175; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v176; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v177; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v178; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v179; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v180; // [esp+10h] [ebp-E0h]
  unsigned __int16 *v181; // [esp+10h] [ebp-E0h]
  int v182;               // [esp+1Ch] [ebp-D4h]
  int v183;               // [esp+24h] [ebp-CCh]
  int v184;               // [esp+34h] [ebp-BCh]
  int32_t v185;           // [esp+38h] [ebp-B8h]
  int v186;               // [esp+3Ch] [ebp-B4h]
  int32_t v187;           // [esp+40h] [ebp-B0h]
  char v188;              // [esp+44h] [ebp-ACh]
  int v189;               // [esp+48h] [ebp-A8h]
  int32_t bpp;            // [esp+4Ch] [ebp-A4h]
  int v191;               // [esp+50h] [ebp-A0h]
  int v192;               // [esp+54h] [ebp-9Ch]
  unsigned __int8 v193;   // [esp+5Bh] [ebp-95h]
  int v194;               // [esp+5Ch] [ebp-94h]
  __int16 v195;           // [esp+6Ah] [ebp-86h]
  __int16 v196;           // [esp+76h] [ebp-7Ah]
  __int16 v197;           // [esp+82h] [ebp-6Eh]
  __int16 v198;           // [esp+8Eh] [ebp-62h]
  int v199;               // [esp+98h] [ebp-58h]
  int v200;               // [esp+9Ch] [ebp-54h]
  int v201;               // [esp+A0h] [ebp-50h]
  int v202;               // [esp+A4h] [ebp-4Ch]
  int v203;               // [esp+A8h] [ebp-48h]
  int v204;               // [esp+ACh] [ebp-44h]
  int v205;               // [esp+B0h] [ebp-40h]
  int v206;               // [esp+B4h] [ebp-3Ch]
  int v207;               // [esp+B8h] [ebp-38h]
  int v208;               // [esp+C0h] [ebp-30h]
  unsigned __int8 *v209;  // [esp+C4h] [ebp-2Ch]
  int v210;               // [esp+C8h] [ebp-28h]
  unsigned __int8 v211;   // [esp+CFh] [ebp-21h]
  int v212;               // [esp+D0h] [ebp-20h]
  char v213;              // [esp+D4h] [ebp-1Ch]
  char v214;              // [esp+D8h] [ebp-18h]
  char v215;              // [esp+DCh] [ebp-14h]
  int v216;               // [esp+E0h] [ebp-10h]

  mipLevel = a3->mipLevel;
  v186 = (int)a3->width >> mipLevel;
  v187 = a3->height >> mipLevel;
  if (v186 <= 1) {
    v130 = 1;
    if (v186 > 0)
      v130 = (int)a3->width >> mipLevel;
    v131 = v130;
  } else {
    if (a3->height >> mipLevel > 1) {
      if (a3->dataInitialized) {
        data = (unsigned __int16 *)a3->data;
      } else {
        v4 = (unsigned __int8 *)a3->data;
        *(_DWORD *)&a3->value = (unsigned __int16)((v4[1] << 8) | *v4);
        data = (unsigned __int16 *)(v4 + 2);
        a3->data = (int32_t)(v4 + 2);
        a3->dataInitialized = 1;
      }
      bpp = a3->bpp;
      v189 = bpp * v186;
      v191 = bpp - 1;
      v192 = 2 * bpp - 1;
      value = a3->value;
      v6 = (int)(unsigned __int16)a3->value >> 1;
      a3->value = v6;
      a3->value = ((unsigned __int16)(((*((unsigned __int8 *)data + 3) << 24) |
                                       (*((unsigned __int8 *)data + 2) << 16) |
                                       (unsigned int)*data) >>
                                      a3->bit)
                   << 15) |
                  v6;
      v7 = a3->bit + 1;
      v159 = (unsigned __int16 *)((char *)data + (v7 >> 3));
      a3->data = (int32_t)v159;
      a3->bit = v7 & 7;
      if ((value & 1) != 0) {
        v8 = v187 * v186;
        if (v187 * v186 <= -1)
          v8 = v187 * v186 + 3;
        v9 = v8 >> 2;
        v182 = v9;
        channels = a3->channels;
        if (channels != a3->bpp) {
          v216 = 0;
          v210 = 0;
          while (1) {
            v209 = &a1[v216];
            v208 = 0;
            for (i = &a1[v216];; i = v209) {
              v193 = *i;
              v11 = 2 * (a3->value & 0xFFF);
              v12 = word_2F3102[v11];
              v13 = (int)(unsigned __int16)a3->value >> v12;
              a3->value = v13;
              v14 = v13 | (((*((unsigned __int8 *)v159 + 3) << 24) |
                            (*((unsigned __int8 *)v159 + 2) << 16) |
                            (unsigned int)*v159) >>
                           a3->bit << (16 - v12));
              a3->value = v14;
              v15 = a3->bit + v12;
              v160 = (unsigned __int16 *)((char *)v159 + (v15 >> 3));
              a3->data = (int32_t)v160;
              v16 = v15 & 7;
              a3->bit = v16;
              v17 = waveletDecodeAlpha[v11];
              if (v17 == (__int16)0x8000)
                break;
              *v209 = v17 + v193;
              ++v208;
              ++v209;
              if (channels == v208)
                goto LABEL_15;
            LABEL_12:
              v159 = (unsigned __int16 *)a3->data;
            }
            v148 = (int)(unsigned __int16)v14 >> 9;
            a3->value = v148;
            a3->value =
                ((unsigned __int16)(((*((unsigned __int8 *)v160 + 3) << 24) |
                                     (*((unsigned __int8 *)v160 + 2) << 16) |
                                     (unsigned int)*v160) >>
                                    v16)
                 << 7) |
                v148;
            a3->data = (int32_t)v160 + ((unsigned __int16)(v16 + 9) >> 3);
            a3->bit = ((_BYTE)v16 + 9) & 7;
            *v209 = v14 + 1 + v193;
            ++v208;
            ++v209;
            if (channels != v208)
              goto LABEL_12;
          LABEL_15:
            a1[v208 + v216] = -1;
            v216 += v208 + 1;
            if (++v210 == v182)
              goto LABEL_18;
            channels = a3->channels;
            v159 = (unsigned __int16 *)a3->data;
          }
        }
        v212 = bpp * v9;
        v194 = 0;
        while (1) {
          v211 = a1[v194];
          v139 = 2 * (a3->value & 0xFFF);
          v140 = word_2F3102[v139];
          v141 = (int)(unsigned __int16)a3->value >> v140;
          a3->value = v141;
          v142 = v141 | (((*((unsigned __int8 *)v159 + 3) << 24) |
                          (*((unsigned __int8 *)v159 + 2) << 16) |
                          (unsigned int)*v159) >>
                         a3->bit << (16 - v140));
          a3->value = v142;
          v143 = a3->bit + v140;
          v181 = (unsigned __int16 *)((char *)v159 + (v143 >> 3));
          a3->data = (int32_t)v181;
          v144 = v143 & 7;
          a3->bit = v144;
          v145 = waveletDecodeAlpha[v139];
          v146 = v145;
          if (v145 == (__int16)0x8000) {
            v146 = v142 + 1;
            v156 = (int)(unsigned __int16)v142 >> 9;
            a3->value = v156;
            a3->value =
                ((unsigned __int16)(((*((unsigned __int8 *)v181 + 3) << 24) |
                                     (*((unsigned __int8 *)v181 + 2) << 16) |
                                     (unsigned int)*v181) >>
                                    v144)
                 << 7) |
                v156;
            a3->data = (int32_t)v181 + ((unsigned __int16)(v144 + 9) >> 3);
            a3->bit = ((_BYTE)v144 + 9) & 7;
          }
          a1[v194] = v146 + v211;
          if (v212 == ++v194)
            break;
          v159 = (unsigned __int16 *)a3->data;
        }
      }
    LABEL_18:
      v185 = 0;
    LABEL_19:
      v184 = 0;
      while (a3->channels != 1) {
        v99 = (unsigned __int16)a3->value;
        v213 = v99 & 1;
        v99 >>= 1;
        a3->value = v99;
        v176 = (unsigned __int16 *)a3->data;
        LOWORD(v99) =
            ((unsigned __int16)(((*((unsigned __int8 *)v176 + 3) << 24) |
                                 (*((unsigned __int8 *)v176 + 2) << 16) |
                                 (unsigned int)*v176) >>
                                a3->bit)
             << 15) |
            v99;
        a3->value = v99;
        v100 = a3->bit + 1;
        v177 = (unsigned __int16 *)((char *)v176 + (v100 >> 3));
        a3->data = (int32_t)v177;
        v101 = v100 & 7;
        a3->bit = v101;
        v102 = 2 * (v99 & 0xFFF);
        v195 = word_2FB102[v102];
        v103 = (int)(unsigned __int16)v99 >> v195;
        a3->value = v103;
        v104 = v103 | (((*((unsigned __int8 *)v177 + 3) << 24) |
                        (*((unsigned __int8 *)v177 + 2) << 16) |
                        (unsigned int)*v177) >>
                       v101 << (16 - v195));
        a3->value = v104;
        v178 = (unsigned __int16 *)((char *)v177 +
                                    ((unsigned __int16)(v101 + v195) >> 3));
        a3->data = (int32_t)v178;
        v105 = ((_BYTE)v101 + (_BYTE)v195) & 7;
        a3->bit = v105;
        v106 = waveletDecodeBlue[v102];
        v207 = v106;
        if (v106 == (__int16)0x8000) {
          v207 = (v104 & 0x1FF) - 255;
          v127 = (int)(unsigned __int16)v104 >> 9;
          a3->value = v127;
          a3->value =
              ((unsigned __int16)(((*((unsigned __int8 *)v178 + 3) << 24) |
                                   (*((unsigned __int8 *)v178 + 2) << 16) |
                                   (unsigned int)*v178) >>
                                  v105)
               << 7) |
              v127;
          v178 = (unsigned __int16 *)((char *)v178 +
                                      ((unsigned __int16)(v105 + 9) >> 3));
          a3->data = (int32_t)v178;
          a3->bit = (v105 + 9) & 7;
        }
        v107 = 2 * (a3->value & 0xFFF);
        v108 = word_2FB102[v107];
        v109 = (int)(unsigned __int16)a3->value >> v108;
        a3->value = v109;
        v110 = v109 | (((*((unsigned __int8 *)v178 + 3) << 24) |
                        (*((unsigned __int8 *)v178 + 2) << 16) |
                        (unsigned int)*v178) >>
                       a3->bit << (16 - v108));
        a3->value = v110;
        v111 = a3->bit + v108;
        v179 = (unsigned __int16 *)((char *)v178 + (v111 >> 3));
        a3->data = (int32_t)v179;
        v112 = v111 & 7;
        a3->bit = v112;
        v113 = waveletDecodeBlue[v107];
        v206 = v113;
        if (v113 == (__int16)0x8000) {
          v206 = (v110 & 0x1FF) - 255;
          v126 = (int)(unsigned __int16)v110 >> 9;
          a3->value = v126;
          a3->value =
              ((unsigned __int16)(((*((unsigned __int8 *)v179 + 3) << 24) |
                                   (*((unsigned __int8 *)v179 + 2) << 16) |
                                   (unsigned int)*v179) >>
                                  v112)
               << 7) |
              v126;
          v179 = (unsigned __int16 *)((char *)v179 +
                                      ((unsigned __int16)(v112 + 9) >> 3));
          a3->data = (int32_t)v179;
          a3->bit = ((_BYTE)v112 + 9) & 7;
        }
        v114 = 2 * (a3->value & 0xFFF);
        v115 = word_2FB102[v114];
        v116 = (int)(unsigned __int16)a3->value >> v115;
        a3->value = v116;
        v117 = v116 | (((*((unsigned __int8 *)v179 + 3) << 24) |
                        (*((unsigned __int8 *)v179 + 2) << 16) |
                        (unsigned int)*v179) >>
                       a3->bit << (16 - v115));
        a3->value = v117;
        v118 = a3->bit + v115;
        v180 = (unsigned __int16 *)((char *)v179 + (v118 >> 3));
        a3->data = (int32_t)v180;
        v119 = v118 & 7;
        a3->bit = v119;
        v120 = waveletDecodeBlue[v114];
        v205 = v120;
        if (v120 == (__int16)0x8000) {
          v205 = (v117 & 0x1FF) - 255;
          v125 = (int)(unsigned __int16)v117 >> 9;
          a3->value = v125;
          a3->value =
              ((unsigned __int16)(((*((unsigned __int8 *)v180 + 3) << 24) |
                                   (*((unsigned __int8 *)v180 + 2) << 16) |
                                   (unsigned int)*v180) >>
                                  v119)
               << 7) |
              v125;
          a3->data = (int32_t)v180 + ((unsigned __int16)(v119 + 9) >> 3);
          a3->bit = ((_BYTE)v119 + 9) & 7;
        }
        v121 = 2 * *a1;
        *a2 = v213 + ((v121 + v207 + v205 + v206) >> 1);
        a2[bpp] = (v121 + v207 - (v205 + v206)) >> 1;
        v122 = v121 - v207;
        a2[v189] = (v122 + v206 - v205) >> 1;
        v183 = v189 + bpp;
        a2[v189 + bpp] = (v122 - (v206 - v205)) >> 1;
        if (a3->channels > 2) {
          v214 = a3->value & 1;
          v18 = (int)(unsigned __int16)a3->value >> 1;
          a3->value = v18;
          v161 = (unsigned __int16 *)a3->data;
          LOWORD(v18) =
              ((unsigned __int16)(((*((unsigned __int8 *)v161 + 3) << 24) |
                                   (*((unsigned __int8 *)v161 + 2) << 16) |
                                   (unsigned int)*v161) >>
                                  a3->bit)
               << 15) |
              v18;
          a3->value = v18;
          v19 = a3->bit + 1;
          v162 = (unsigned __int16 *)((char *)v161 + (v19 >> 3));
          a3->data = (int32_t)v162;
          v20 = v19 & 7;
          a3->bit = v20;
          v21 = 2 * (v18 & 0xFFF);
          v196 = word_2F7102[v21];
          v22 = (int)(unsigned __int16)v18 >> v196;
          a3->value = v22;
          v23 = v22 | (((*((unsigned __int8 *)v162 + 3) << 24) |
                        (*((unsigned __int8 *)v162 + 2) << 16) |
                        (unsigned int)*v162) >>
                       v20 << (16 - v196));
          a3->value = v23;
          v163 = (unsigned __int16 *)((char *)v162 +
                                      ((unsigned __int16)(v20 + v196) >> 3));
          a3->data = (int32_t)v163;
          v24 = ((_BYTE)v20 + (_BYTE)v196) & 7;
          a3->bit = v24;
          v25 = waveletDecodeRedGreen[v21];
          v26 = v25;
          if (v25 == (__int16)0x8000) {
            v26 = (v23 & 0x3FF) - 510;
            v155 = (int)(unsigned __int16)v23 >> 10;
            a3->value = v155;
            a3->value =
                ((unsigned __int16)(((*((unsigned __int8 *)v163 + 3) << 24) |
                                     (*((unsigned __int8 *)v163 + 2) << 16) |
                                     (unsigned int)*v163) >>
                                    v24)
                 << 6) |
                v155;
            v163 = (unsigned __int16 *)((char *)v163 +
                                        ((unsigned __int16)(v24 + 10) >> 3));
            a3->data = (int32_t)v163;
            a3->bit = ((_BYTE)v24 + 10) & 7;
          }
          v204 = v207 + v26;
          v27 = 2 * (a3->value & 0xFFF);
          v28 = word_2F7102[v27];
          v29 = (int)(unsigned __int16)a3->value >> v28;
          a3->value = v29;
          v30 = v29 | (((*((unsigned __int8 *)v163 + 3) << 24) |
                        (*((unsigned __int8 *)v163 + 2) << 16) |
                        (unsigned int)*v163) >>
                       a3->bit << (16 - v28));
          a3->value = v30;
          v31 = a3->bit + v28;
          v164 = (unsigned __int16 *)((char *)v163 + (v31 >> 3));
          a3->data = (int32_t)v164;
          v32 = v31 & 7;
          a3->bit = v32;
          v33 = waveletDecodeRedGreen[v27];
          v34 = v33;
          if (v33 == (__int16)0x8000) {
            v34 = (v30 & 0x3FF) - 510;
            v154 = (int)(unsigned __int16)v30 >> 10;
            a3->value = v154;
            a3->value =
                ((unsigned __int16)(((*((unsigned __int8 *)v164 + 3) << 24) |
                                     (*((unsigned __int8 *)v164 + 2) << 16) |
                                     (unsigned int)*v164) >>
                                    v32)
                 << 6) |
                v154;
            v164 = (unsigned __int16 *)((char *)v164 +
                                        ((unsigned __int16)(v32 + 10) >> 3));
            a3->data = (int32_t)v164;
            a3->bit = ((_BYTE)v32 + 10) & 7;
          }
          v203 = v206 + v34;
          v35 = 2 * (a3->value & 0xFFF);
          v36 = word_2F7102[v35];
          v37 = (int)(unsigned __int16)a3->value >> v36;
          a3->value = v37;
          v38 = v37 | (((*((unsigned __int8 *)v164 + 3) << 24) |
                        (*((unsigned __int8 *)v164 + 2) << 16) |
                        (unsigned int)*v164) >>
                       a3->bit << (16 - v36));
          a3->value = v38;
          v39 = a3->bit + v36;
          v165 = (unsigned __int16 *)((char *)v164 + (v39 >> 3));
          a3->data = (int32_t)v165;
          v40 = v39 & 7;
          a3->bit = v40;
          v41 = waveletDecodeRedGreen[v35];
          v42 = v41;
          if (v41 == (__int16)0x8000) {
            v42 = (v38 & 0x3FF) - 510;
            v153 = (int)(unsigned __int16)v38 >> 10;
            a3->value = v153;
            a3->value =
                ((unsigned __int16)(((*((unsigned __int8 *)v165 + 3) << 24) |
                                     (*((unsigned __int8 *)v165 + 2) << 16) |
                                     (unsigned int)*v165) >>
                                    v40)
                 << 6) |
                v153;
            a3->data = (int32_t)v165 + ((unsigned __int16)(v40 + 10) >> 3);
            a3->bit = ((_BYTE)v40 + 10) & 7;
          }
          v43 = 2 * a1[1];
          v44 = v42 + v205 + v203;
          a2[1] = v214 + ((v43 + v204 + v44) >> 1);
          a2[bpp + 1] = (v43 + v204 - v44) >> 1;
          v45 = v43 - v204;
          v46 = v203 - (v42 + v205);
          a2[v189 + 1] = (v45 + v46) >> 1;
          a2[v183 + 1] = (v45 - v46) >> 1;
          v215 = a3->value & 1;
          v47 = (int)(unsigned __int16)a3->value >> 1;
          a3->value = v47;
          v166 = (unsigned __int16 *)a3->data;
          LOWORD(v47) =
              ((unsigned __int16)(((*((unsigned __int8 *)v166 + 3) << 24) |
                                   (*((unsigned __int8 *)v166 + 2) << 16) |
                                   (unsigned int)*v166) >>
                                  a3->bit)
               << 15) |
              v47;
          a3->value = v47;
          LOWORD(v45) = a3->bit + 1;
          v167 =
              (unsigned __int16 *)((char *)v166 + ((unsigned __int16)v45 >> 3));
          a3->data = (int32_t)v167;
          v48 = v45 & 7;
          a3->bit = v48;
          v49 = 2 * (v47 & 0xFFF);
          v197 = word_2F7102[v49];
          v50 = (int)(unsigned __int16)v47 >> v197;
          a3->value = v50;
          v51 = v50 | (((*((unsigned __int8 *)v167 + 3) << 24) |
                        (*((unsigned __int8 *)v167 + 2) << 16) |
                        (unsigned int)*v167) >>
                       v48 << (16 - v197));
          a3->value = v51;
          v168 = (unsigned __int16 *)((char *)v167 +
                                      ((unsigned __int16)(v48 + v197) >> 3));
          a3->data = (int32_t)v168;
          v52 = ((_BYTE)v48 + (_BYTE)v197) & 7;
          a3->bit = v52;
          v53 = waveletDecodeRedGreen[v49];
          v54 = v53;
          if (v53 == (__int16)0x8000) {
            v54 = (v51 & 0x3FF) - 510;
            v152 = (int)(unsigned __int16)v51 >> 10;
            a3->value = v152;
            a3->value =
                ((unsigned __int16)(((*((unsigned __int8 *)v168 + 3) << 24) |
                                     (*((unsigned __int8 *)v168 + 2) << 16) |
                                     (unsigned int)*v168) >>
                                    v52)
                 << 6) |
                v152;
            v168 = (unsigned __int16 *)((char *)v168 +
                                        ((unsigned __int16)(v52 + 10) >> 3));
            a3->data = (int32_t)v168;
            a3->bit = ((_BYTE)v52 + 10) & 7;
          }
          v202 = v207 + v54;
          v55 = 2 * (a3->value & 0xFFF);
          v56 = word_2F7102[v55];
          v57 = (int)(unsigned __int16)a3->value >> v56;
          a3->value = v57;
          v58 = v57 | (((*((unsigned __int8 *)v168 + 3) << 24) |
                        (*((unsigned __int8 *)v168 + 2) << 16) |
                        (unsigned int)*v168) >>
                       a3->bit << (16 - v56));
          a3->value = v58;
          v59 = a3->bit + v56;
          v169 = (unsigned __int16 *)((char *)v168 + (v59 >> 3));
          a3->data = (int32_t)v169;
          v60 = v59 & 7;
          a3->bit = v60;
          v61 = waveletDecodeRedGreen[v55];
          v62 = v61;
          if (v61 == (__int16)0x8000) {
            v62 = (v58 & 0x3FF) - 510;
            v151 = (int)(unsigned __int16)v58 >> 10;
            a3->value = v151;
            a3->value =
                ((unsigned __int16)(((*((unsigned __int8 *)v169 + 3) << 24) |
                                     (*((unsigned __int8 *)v169 + 2) << 16) |
                                     (unsigned int)*v169) >>
                                    v60)
                 << 6) |
                v151;
            v169 = (unsigned __int16 *)((char *)v169 +
                                        ((unsigned __int16)(v60 + 10) >> 3));
            a3->data = (int32_t)v169;
            a3->bit = ((_BYTE)v60 + 10) & 7;
          }
          v201 = v206 + v62;
          v63 = 2 * (a3->value & 0xFFF);
          v64 = word_2F7102[v63];
          v65 = (int)(unsigned __int16)a3->value >> v64;
          a3->value = v65;
          v66 = v65 | (((*((unsigned __int8 *)v169 + 3) << 24) |
                        (*((unsigned __int8 *)v169 + 2) << 16) |
                        (unsigned int)*v169) >>
                       a3->bit << (16 - v64));
          a3->value = v66;
          v67 = a3->bit + v64;
          v170 = (unsigned __int16 *)((char *)v169 + (v67 >> 3));
          a3->data = (int32_t)v170;
          v68 = v67 & 7;
          a3->bit = v68;
          v69 = waveletDecodeRedGreen[v63];
          v70 = v69;
          if (v69 == (__int16)0x8000) {
            v70 = (v66 & 0x3FF) - 510;
            v150 = (int)(unsigned __int16)v66 >> 10;
            a3->value = v150;
            a3->value =
                ((unsigned __int16)(((*((unsigned __int8 *)v170 + 3) << 24) |
                                     (*((unsigned __int8 *)v170 + 2) << 16) |
                                     (unsigned int)*v170) >>
                                    v68)
                 << 6) |
                v150;
            a3->data = (int32_t)v170 + ((unsigned __int16)(v68 + 10) >> 3);
            a3->bit = ((_BYTE)v68 + 10) & 7;
          }
          v71 = v205 + v70;
          v72 = 2 * a1[2];
          a2[2] = v215 + ((v72 + v202 + v71 + v201) >> 1);
          a2[bpp + 2] = (v72 + v202 - (v71 + v201)) >> 1;
          v73 = v72 - v202;
          a2[v189 + 2] = (v73 + v201 - v71) >> 1;
          a2[v183 + 2] = (v73 - (v201 - v71)) >> 1;
          v74 = a3;
        LABEL_33:
          if (v74->channels != 3)
            goto LABEL_34;
          goto LABEL_51;
        }
        v74 = a3;
        if (a3->channels != 3) {
        LABEL_34:
          v188 = v74->value & 1;
          v75 = (int)(unsigned __int16)v74->value >> 1;
          v74->value = v75;
          v171 = (unsigned __int16 *)v74->data;
          LOWORD(v75) =
              ((unsigned __int16)(((*((unsigned __int8 *)v171 + 3) << 24) |
                                   (*((unsigned __int8 *)v171 + 2) << 16) |
                                   (unsigned int)*v171) >>
                                  v74->bit)
               << 15) |
              v75;
          v74->value = v75;
          v76 = v74->bit + 1;
          v172 = (unsigned __int16 *)((char *)v171 + (v76 >> 3));
          v74->data = (int32_t)v172;
          v77 = v76 & 7;
          a3->bit = v77;
          v78 = 2 * (v75 & 0xFFF);
          v198 = word_2F3102[v78];
          v79 = (int)(unsigned __int16)v75 >> v198;
          a3->value = v79;
          v80 = v79 | (((*((unsigned __int8 *)v172 + 3) << 24) |
                        (*((unsigned __int8 *)v172 + 2) << 16) |
                        (unsigned int)*v172) >>
                       v77 << (16 - v198));
          a3->value = v80;
          v173 = (unsigned __int16 *)((char *)v172 +
                                      ((unsigned __int16)(v77 + v198) >> 3));
          a3->data = (int32_t)v173;
          v81 = ((_BYTE)v77 + (_BYTE)v198) & 7;
          a3->bit = v81;
          v82 = waveletDecodeAlpha[v78];
          v200 = v82;
          if (v82 == (__int16)0x8000) {
            v200 = (v80 & 0x1FF) - 255;
            v124 = (int)(unsigned __int16)v80 >> 9;
            a3->value = v124;
            a3->value =
                ((unsigned __int16)(((*((unsigned __int8 *)v173 + 3) << 24) |
                                     (*((unsigned __int8 *)v173 + 2) << 16) |
                                     (unsigned int)*v173) >>
                                    v81)
                 << 7) |
                v124;
            v173 = (unsigned __int16 *)((char *)v173 +
                                        ((unsigned __int16)(v81 + 9) >> 3));
            a3->data = (int32_t)v173;
            a3->bit = (v81 + 9) & 7;
          }
          v83 = 2 * (a3->value & 0xFFF);
          v84 = word_2F3102[v83];
          v85 = (int)(unsigned __int16)a3->value >> v84;
          a3->value = v85;
          v86 = v85 | (((*((unsigned __int8 *)v173 + 3) << 24) |
                        (*((unsigned __int8 *)v173 + 2) << 16) |
                        (unsigned int)*v173) >>
                       a3->bit << (16 - v84));
          a3->value = v86;
          v87 = a3->bit + v84;
          v174 = (unsigned __int16 *)((char *)v173 + (v87 >> 3));
          a3->data = (int32_t)v174;
          v88 = v87 & 7;
          a3->bit = v88;
          v89 = waveletDecodeAlpha[v83];
          v199 = v89;
          if (v89 == (__int16)0x8000) {
            v199 = (v86 & 0x1FF) - 255;
            v128 = (int)(unsigned __int16)v86 >> 9;
            a3->value = v128;
            a3->value =
                ((unsigned __int16)(((*((unsigned __int8 *)v174 + 3) << 24) |
                                     (*((unsigned __int8 *)v174 + 2) << 16) |
                                     (unsigned int)*v174) >>
                                    v88)
                 << 7) |
                v128;
            v174 = (unsigned __int16 *)((char *)v174 +
                                        ((unsigned __int16)(v88 + 9) >> 3));
            a3->data = (int32_t)v174;
            a3->bit = ((_BYTE)v88 + 9) & 7;
          }
          v90 = 2 * (a3->value & 0xFFF);
          v91 = word_2F3102[v90];
          v92 = (int)(unsigned __int16)a3->value >> v91;
          a3->value = v92;
          v93 = v92 | (((*((unsigned __int8 *)v174 + 3) << 24) |
                        (*((unsigned __int8 *)v174 + 2) << 16) |
                        (unsigned int)*v174) >>
                       a3->bit << (16 - v91));
          a3->value = v93;
          v94 = a3->bit + v91;
          v175 = (unsigned __int16 *)((char *)v174 + (v94 >> 3));
          a3->data = (int32_t)v175;
          v95 = v94 & 7;
          a3->bit = v95;
          v96 = waveletDecodeAlpha[v90];
          v97 = v96;
          if (v96 == (__int16)0x8000) {
            v97 = (v93 & 0x1FF) - 255;
            v149 = (int)(unsigned __int16)v93 >> 9;
            a3->value = v149;
            a3->value =
                ((unsigned __int16)(((*((unsigned __int8 *)v175 + 3) << 24) |
                                     (*((unsigned __int8 *)v175 + 2) << 16) |
                                     (unsigned int)*v175) >>
                                    v95)
                 << 7) |
                v149;
            a3->data = (int32_t)v175 + ((unsigned __int16)(v95 + 9) >> 3);
            a3->bit = (v95 + 9) & 7;
          }
          v147 = 2 * a1[v191];
          a2[v191] = ((v147 + v200 + v97 + v199) >> 1) + v188;
          a2[v192] = (v147 + v200 - (v97 + v199)) >> 1;
          v98 = &a2[v189];
          v98[v191] = (v147 - v200 + v199 - v97) >> 1;
          v98[v192] = (v147 - v200 - (v199 - v97)) >> 1;
          goto LABEL_41;
        }
      LABEL_51:
        if (v74->bpp != 3) {
          a2[v191] = -1;
          a2[v192] = -1;
          v123 = &a2[v189];
          v123[v191] = -1;
          v123[v192] = -1;
        }
      LABEL_41:
        a1 += bpp;
        a2 += 2 * bpp;
        v184 += 2;
        if (v186 <= v184) {
          a2 += v189;
          v185 += 2;
          result = v185;
          if (v187 <= v185)
            return result;
          goto LABEL_19;
        }
      }
      v74 = a3;
      goto LABEL_33;
    }
    v131 = (int)a3->width >> mipLevel;
  }
  v132 = 1;
  if (v187 > 0)
    v132 = a3->height >> mipLevel;
  v133 = v131 + v132 - 1;
  v134 = 0;
  do {
    v135 = a3;
    result = a3->channels;
    if (result > 0) {
      v136 = 0;
      for (j = a3;; j = a3) {
        v138 = (unsigned __int8 *)j->data;
        *a2++ = *v138;
        a3->data = (int32_t)(v138 + 1);
        ++v136;
        v135 = a3;
        result = a3->channels;
        if (v136 >= result)
          break;
      }
    }
    if (v135->bpp != result)
      *a2++ = -1;
    ++v134;
  } while (v133 != v134);
  return result;
}

void IN_Shutdown(void) { ; }

__sFILE **__cdecl yy_create_buffer(__sFILE *a1, __sFILE *a2) {
  __sFILE **v2; // eax
  __sFILE **v3; // ebx
  char *v4;     // eax
  int v5;       // eax

  v2 = (__sFILE **)malloc(0x28u);
  v3 = v2;
  if (!v2 || (v2[3] = a2, v4 = (char *)malloc((size_t)&a2->_p + 2),
              (v3[1] = (__sFILE *)v4) == 0)) {
    fprintf((FILE *)&__sF + 2, "%s\n",
            "out of dynamic memory in yy_create_buffer()");
    j__exit(2);
  }
  v3[5] = (__sFILE *)1;
  v3[4] = 0;
  *v4 = 0;
  v4[1] = 0;
  v3[2] = (__sFILE *)v4;
  v3[7] = (__sFILE *)1;
  v3[9] = 0;
  if (v3 == (__sFILE **)yy_current_buffer) {
    yy_n_chars = 0;
    yy_c_buf_p = (int)v4;
    yytext = v4;
    yyin = *v3;
    yy_hold_char = 0;
  }
  *v3 = a1;
  v3[8] = (__sFILE *)1;
  if (a1 && (v5 = fileno(a1), isatty(v5) > 0)) {
    v3[6] = (__sFILE *)1;
    return v3;
  } else {
    v3[6] = 0;
    return v3;
  }
}

_BOOL4 __cdecl AIL_startup(unsigned int a1) {
  CThread *v1; // ebx

  sHighQualityEngine = MacPreferences::GetBoolean(
      kHighQualityKey, (const char *)(sHighQualityEngine != 0));
  v1 = (CThread *)operator new(0x1D8u);
  CSoundEngine::CSoundEngine(v1, a1, sHighQualityEngine);
  sSoundEngine = (CSoundEngine *)v1;
  return v1 != 0;
}

void AIL_shutdown(void) {
  if (sSoundEngine) {
    MacPreferences::PutBoolean(kHighQualityKey,
                               (const char *)(sHighQualityEngine != 0));
    if (sSoundEngine)
      (*(void(__cdecl **)(CSoundEngine *))(*(_DWORD *)sSoundEngine + 4))(
          sSoundEngine);
    sSoundEngine = 0;
  }
}

int __cdecl AIL_set_preference() {
  return CSoundEngine::mixer_count(sSoundEngine);
}

int AIL_open_digital_driver() { return 1296319561; }

int __cdecl AIL_digital_CPU_percent() {
  CSoundEngine::UpdateAllSounds((CStreamSound *)sSoundEngine);
  return CSoundEngine::get_cpu_percent((AUGraph *)sSoundEngine);
}

CSoundObject *__cdecl AIL_allocate_sample_handle() {
  return CSoundEngine::NewSampleSound(sSoundEngine);
}

void __cdecl AIL_release_sample_handle(int a1) {
  CSoundObject *SampleSound; // eax

  SampleSound =
      (CSoundObject *)CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (SampleSound)
    CSoundObject::Release(SampleSound);
}

void __cdecl AIL_init_sample(int a1) {
  CSoundObject *SampleSound; // eax

  SampleSound =
      (CSoundObject *)CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (SampleSound)
    CSoundObject::init_sample(SampleSound);
}

void __cdecl AIL_set_sample_adpcm_block_size(int a1, uint32_t a2) {
  CSoundObject *SampleSound; // eax

  SampleSound =
      (CSoundObject *)CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (SampleSound)
    CSoundObject::set_sample_adpcm_block_size(SampleSound, a2);
}

void __cdecl AIL_set_sample_address(int a1, const void *a2, uint32_t a3) {
  CSoundObject *SampleSound; // eax

  SampleSound =
      (CSoundObject *)CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (SampleSound)
    CSoundObject::set_sample_address(SampleSound, a2, a3);
}

void __cdecl AIL_set_sample_type(int a1, int32_t a2) {
  CSoundObject *SampleSound; // eax

  SampleSound =
      (CSoundObject *)CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (SampleSound)
    CSoundObject::set_sample_type(SampleSound, a2);
}

int __cdecl AIL_stop_sample(int a1) {
  int result; // eax

  result = CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (result)
    return (*(int(__cdecl **)(int))(*(_DWORD *)result + 12))(result);
  return result;
}

int __cdecl AIL_resume_sample(int a1) {
  int result; // eax

  result = CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (result)
    return (*(int(__cdecl **)(int))(*(_DWORD *)result + 16))(result);
  return result;
}

int __cdecl AIL_end_sample(int a1) {
  int result; // eax

  result = CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (result)
    return (*(int(__cdecl **)(int))(*(_DWORD *)result + 20))(result);
  return result;
}

int __cdecl AIL_set_sample_playback_rate(int a1, int a2) {
  int result; // eax

  result = CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (result)
    return (*(int(__cdecl **)(int, int))(*(_DWORD *)result + 32))(result, a2);
  return result;
}

void __cdecl AIL_set_sample_volume_levels(int a1, float a2, float a3) {
  CSoundObject *SampleSound; // eax

  SampleSound =
      (CSoundObject *)CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (SampleSound)
    CSoundObject::set_sample_volume_levels(SampleSound, a2, a3);
}

void __cdecl AIL_set_sample_reverb_levels(int a1, int32_t a2, int32_t a3) {
  CSoundObject *SampleSound; // eax

  SampleSound =
      (CSoundObject *)CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (SampleSound)
    CSoundObject::set_sample_reverb_levels(SampleSound, a2, a3);
}

void __cdecl AIL_set_sample_loop_count(int a1, int32_t a2) {
  CSoundObject *SampleSound; // eax

  SampleSound =
      (CSoundObject *)CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (SampleSound)
    CSoundObject::set_sample_loop_count(SampleSound, a2);
}

int __cdecl AIL_sample_status(int a1) {
  CSoundObject *SampleSound; // eax

  SampleSound =
      (CSoundObject *)CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (SampleSound)
    return CSoundObject::get_sample_status(SampleSound);
  else
    return 1;
}

int32_t __cdecl AIL_sample_playback_rate(int a1) {
  CSoundObject *SampleSound; // eax

  SampleSound =
      (CSoundObject *)CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (SampleSound)
    return CSoundObject::get_sample_playback_rate(SampleSound);
  else
    return 0;
}

CSoundObject *__cdecl AIL_sample_volume_pan(int a1, float *a2, float *a3) {
  CSoundObject *result; // eax

  result = (CSoundObject *)CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (result)
    return (CSoundObject *)CSoundObject::get_sample_volume_pan(result, a2, a3);
  return result;
}

CSoundObject *__cdecl AIL_sample_volume_levels(int a1, float *a2, float *a3) {
  CSoundObject *result; // eax

  result = (CSoundObject *)CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (result)
    return CSoundObject::get_sample_volume_levels(result, a2, a3);
  return result;
}

CSoundEngine *__cdecl AIL_set_digital_master_room_type(unsigned int a1,
                                                       int a2) {
  return CSoundEngine::set_digital_master_room_type(sSoundEngine, a2);
}

void __cdecl AIL_set_digital_master_reverb_levels() {
  CSoundEngine::set_digital_master_reverb_levels();
}

int __cdecl AIL_minimum_sample_buffer_size() {
  return CSoundEngine::minimum_sample_buffer_size();
}

int __cdecl AIL_sample_buffer_ready(int a1) {
  CSoundObject *SampleSound; // eax

  SampleSound =
      (CSoundObject *)CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (SampleSound)
    return CSoundObject::sample_buffer_ready(SampleSound);
  else
    return -1;
}

CSoundObject *__cdecl AIL_load_sample_buffer(int a1, unsigned int a2,
                                             const void *a3, uint32_t a4) {
  CSoundObject *result; // eax

  result = (CSoundObject *)CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (result)
    return (CSoundObject *)CSoundObject::load_sample_buffer(result, a2, a3, a4);
  return result;
}

uint32_t __cdecl AIL_sample_position(int a1) {
  CSoundObject *SampleSound; // eax

  SampleSound =
      (CSoundObject *)CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (SampleSound)
    return CSoundObject::get_sample_position(SampleSound);
  else
    return 0;
}

int __cdecl AIL_set_sample_ms_position(int a1, int a2) {
  int result; // eax

  result = CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (result)
    return (*(int(__cdecl **)(int, int))(*(_DWORD *)result + 28))(result, a2);
  return result;
}

int __cdecl AIL_sample_ms_position(int a1, int a2, int a3) {
  int result; // eax

  result = CSoundEngine::GetSampleSound((int)sSoundEngine, a1);
  if (result)
    return (*(int(__cdecl **)(int, int, int))(*(_DWORD *)result + 24))(result,
                                                                       a2, a3);
  return result;
}

CSoundObject *__cdecl AIL_open_stream(unsigned int a1, char *__big) {
  CSoundObject *v3; // ebx

  if (!__big)
    return 0;
  if (strstr(__big, ".mp3")) {
    if (access(__big, 4))
      return 0;
    v3 = (CSoundObject *)CSoundEngine::NewStreamSound(sSoundEngine);
  } else {
    if (!strstr(__big, ".wav"))
      return 0;
    v3 = CSoundEngine::NewSampleSound3D(sSoundEngine);
  }
  if (!v3)
    return 0;
  if ((*(unsigned __int8(__cdecl **)(CSoundObject *, char *))(
          *(_DWORD *)v3->_vptr$CSoundObject + 40))(v3, __big))
    return v3;
  CSoundObject::Release(v3);
  return 0;
}

void __cdecl AIL_close_stream(int a1) {
  CSoundObject *StreamSound; // eax

  StreamSound =
      (CSoundObject *)CSoundEngine::GetStreamSound((int)sSoundEngine, a1);
  if (StreamSound)
    CSoundObject::Release(StreamSound);
}

int __cdecl AIL_pause_stream(int a1, int a2) {
  int result; // eax

  result = CSoundEngine::GetStreamSound((int)sSoundEngine, a1);
  if (result) {
    if (a2)
      return (*(int(__cdecl **)(int))(*(_DWORD *)result + 12))(result);
    else
      return (*(int(__cdecl **)(int))(*(_DWORD *)result + 16))(result);
  }
  return result;
}

void __cdecl AIL_set_stream_volume_levels(int a1, float a2, float a3) {
  CSoundObject *StreamSound; // eax

  StreamSound =
      (CSoundObject *)CSoundEngine::GetStreamSound((int)sSoundEngine, a1);
  if (StreamSound)
    CSoundObject::set_sample_volume_levels(StreamSound, a2, a3);
}

void __cdecl AIL_set_stream_reverb_levels(int a1, int32_t a2, int32_t a3) {
  CSoundObject *StreamSound; // eax

  StreamSound =
      (CSoundObject *)CSoundEngine::GetStreamSound((int)sSoundEngine, a1);
  if (StreamSound)
    CSoundObject::set_sample_reverb_levels(StreamSound, a2, a3);
}

CSoundObject *__cdecl AIL_stream_volume_pan(int a1, float *a2, float *a3) {
  CSoundObject *result; // eax

  result = (CSoundObject *)CSoundEngine::GetStreamSound((int)sSoundEngine, a1);
  if (result)
    return (CSoundObject *)CSoundObject::get_sample_volume_pan(result, a2, a3);
  return result;
}

CSoundObject *__cdecl AIL_stream_volume_levels(int a1, float *a2, float *a3) {
  CSoundObject *result; // eax

  result = (CSoundObject *)CSoundEngine::GetStreamSound((int)sSoundEngine, a1);
  if (result)
    return CSoundObject::get_sample_volume_levels(result, a2, a3);
  return result;
}

int __cdecl AIL_set_stream_playback_rate(int a1, int a2) {
  int result; // eax

  result = CSoundEngine::GetStreamSound((int)sSoundEngine, a1);
  if (result)
    return (*(int(__cdecl **)(int, int))(*(_DWORD *)result + 32))(result, a2);
  return result;
}

int32_t __cdecl AIL_stream_playback_rate(int a1) {
  CSoundObject *StreamSound; // eax

  StreamSound =
      (CSoundObject *)CSoundEngine::GetStreamSound((int)sSoundEngine, a1);
  if (StreamSound)
    return CSoundObject::get_sample_playback_rate(StreamSound);
  else
    return 0;
}

void __cdecl AIL_set_stream_loop_count(int a1, int32_t a2) {
  CSoundObject *StreamSound; // eax

  StreamSound =
      (CSoundObject *)CSoundEngine::GetStreamSound((int)sSoundEngine, a1);
  if (StreamSound)
    CSoundObject::set_sample_loop_count(StreamSound, a2);
}

int __cdecl AIL_stream_status(int a1) {
  CSoundObject *StreamSound; // eax

  StreamSound =
      (CSoundObject *)CSoundEngine::GetStreamSound((int)sSoundEngine, a1);
  if (StreamSound)
    return CSoundObject::get_sample_status(StreamSound);
  else
    return 1;
}

int *__cdecl AIL_stream_info(int a1, int *a2, int *a3, int *a4, int *a5) {
  int *result; // eax

  result = (int *)CSoundEngine::GetStreamSound((int)sSoundEngine, a1);
  if (result)
    return CSoundObject::get_stream_info((CSoundObject *)result, a2, a3, a4,
                                         a5);
  if (a2)
    *a2 = 0;
  if (a3)
    *a3 = 0;
  if (a4)
    *a4 = 0;
  if (a5) {
    result = a5;
    *a5 = 0;
  }
  return result;
}

int __cdecl AIL_set_stream_ms_position(int a1, int a2) {
  int result; // eax

  result = CSoundEngine::GetStreamSound((int)sSoundEngine, a1);
  if (result)
    return (*(int(__cdecl **)(int, int))(*(_DWORD *)result + 28))(result, a2);
  return result;
}

int __cdecl AIL_stream_ms_position(int a1, int a2, int a3) {
  int result; // eax

  result = CSoundEngine::GetStreamSound((int)sSoundEngine, a1);
  if (result)
    return (*(int(__cdecl **)(int, int, int))(*(_DWORD *)result + 24))(result,
                                                                       a2, a3);
  return result;
}

CSoundObject *__cdecl AIL_is_3D_stream(int a1) {
  CSoundObject *result; // eax

  result = (CSoundObject *)CSoundEngine::GetStreamSound((int)sSoundEngine, a1);
  if (result)
    return (CSoundObject *)CSoundObject::Is3DSound(result);
  return result;
}

void __cdecl AIL_set_3D_stream_position(int a1, float a2, float a3, float a4) {
  CSoundObject *StreamSound; // eax

  StreamSound =
      (CSoundObject *)CSoundEngine::GetStreamSound((int)sSoundEngine, a1);
  if (StreamSound)
    CSoundObject::set_3D_position(StreamSound, a2, a3, a4);
}

int AIL_size_processed_digital_audio() {
  return CSoundEngine::size_processed_digital_audio();
}

int AIL_process_digital_audio() {
  return CSoundEngine::process_digital_audio();
}

int __cdecl AIL_enumerate_3D_providers(unsigned int *a1, unsigned int *a2,
                                       char **a3) {
  if (*a1)
    return 0;
  *a1 = 1;
  *a2 = 1297107268;
  *a3 = CSoundEngine::device_name(sSoundEngine);
  return 1;
}

int AIL_open_3D_provider() { return 0; }

void AIL_close_3D_provider() { ; }

int __cdecl AIL_3D_provider_attribute(unsigned int a1, const char *a2,
                                      int *a3) {
  int result; // eax

  result = CSoundEngine::mixer_count_3D(sSoundEngine);
  *a3 = result;
  return result;
}

CSoundObject *__cdecl AIL_allocate_3D_sample_handle() {
  return CSoundEngine::NewSampleSound3D(sSoundEngine);
}

void *__cdecl AIL_stop_3D_sample(void *a1) {
  void *result; // eax

  result = CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
  if (result)
    return (void *)(*(int(__cdecl **)(void *))(*(_DWORD *)result + 12))(result);
  return result;
}

void *__cdecl AIL_resume_3D_sample(void *a1) {
  void *result; // eax

  result = CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
  if (result)
    return (void *)(*(int(__cdecl **)(void *))(*(_DWORD *)result + 16))(result);
  return result;
}

void *__cdecl AIL_end_3D_sample(void *a1) {
  void *result; // eax

  result = CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
  if (result)
    return (void *)(*(int(__cdecl **)(void *))(*(_DWORD *)result + 20))(result);
  return result;
}

int __cdecl AIL_set_3D_sample_info(void *a1, _DWORD *a2) {
  CSoundObject *SampleSound3D; // eax
  CSoundObject *v3;            // ebx

  SampleSound3D =
      (CSoundObject *)CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
  v3 = SampleSound3D;
  if (!SampleSound3D)
    return 0;
  CSoundObject::init_sample(SampleSound3D);
  return CSoundObject::set_sample_info(v3, a2);
}

void __cdecl AIL_set_3D_sample_volume(void *a1, int32_t a2) {
  CSoundObject *SampleSound3D; // eax

  SampleSound3D =
      (CSoundObject *)CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
  if (SampleSound3D)
    CSoundObject::set_sample_volume(SampleSound3D, a2);
}

void __cdecl AIL_set_3D_sample_offset(void *a1, uint32_t a2) {
  CSoundObject *SampleSound3D; // eax

  SampleSound3D =
      (CSoundObject *)CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
  if (SampleSound3D)
    CSoundObject::set_sample_position(SampleSound3D, a2);
}

void *__cdecl AIL_set_3D_sample_playback_rate(void *a1, int a2) {
  void *result; // eax

  result = CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
  if (result)
    return (void *)(*(int(__cdecl **)(void *, int))(*(_DWORD *)result + 32))(
        result, a2);
  return result;
}

void __cdecl AIL_set_3D_sample_loop_count(void *a1, int32_t a2) {
  CSoundObject *SampleSound3D; // eax

  SampleSound3D =
      (CSoundObject *)CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
  if (SampleSound3D)
    CSoundObject::set_sample_loop_count(SampleSound3D, a2);
}

int __cdecl AIL_3D_sample_status(void *a1) {
  CSoundObject *SampleSound3D; // eax

  SampleSound3D =
      (CSoundObject *)CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
  if (SampleSound3D)
    return CSoundObject::get_sample_status(SampleSound3D);
  else
    return 1;
}

long double __cdecl AIL_3D_sample_volume(void *a1) {
  CSoundObject *SampleSound3D; // eax

  SampleSound3D =
      (CSoundObject *)CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
  if (SampleSound3D)
    return CSoundObject::get_sample_volume(SampleSound3D);
  else
    return 0.0;
}

uint32_t __cdecl AIL_3D_sample_offset(void *a1) {
  CSoundObject *SampleSound3D; // eax

  SampleSound3D =
      (CSoundObject *)CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
  if (SampleSound3D)
    return CSoundObject::get_sample_position(SampleSound3D);
  else
    return 0;
}

int32_t __cdecl AIL_3D_sample_playback_rate(void *a1) {
  CSoundObject *SampleSound3D; // eax

  SampleSound3D =
      (CSoundObject *)CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
  if (SampleSound3D)
    return CSoundObject::get_sample_playback_rate(SampleSound3D);
  else
    return 0;
}

uint32_t __cdecl AIL_3D_sample_length(void *a1) {
  CSoundObject *SampleSound3D; // eax

  SampleSound3D =
      (CSoundObject *)CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
  if (SampleSound3D)
    return CSoundObject::get_sample_length(SampleSound3D);
  else
    return 0;
}

CSoundEngine *__cdecl AIL_set_3D_room_type(unsigned int a1, int a2) {
  return CSoundEngine::set_3D_room_type(sSoundEngine, a2);
}

CSoundEngine *__cdecl AIL_set_3D_rolloff_factor(unsigned int a1, float a2) {
  return CSoundEngine::set_3D_rolloff_factor(sSoundEngine, a2);
}

CSoundEngine *__cdecl AIL_set_3D_distance_factor(unsigned int a1, float a2) {
  return CSoundEngine::set_3D_distance_factor(sSoundEngine, a2);
}

void *__cdecl AIL_set_3D_sample_distances(void *a1, float a2, float a3) {
  void *result; // eax

  result = CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
  if (result)
    return (void *)(*(int(__cdecl **)(void *, _DWORD, _DWORD))(
        *(_DWORD *)result + 36))(result, LODWORD(a2), LODWORD(a3));
  return result;
}

void __cdecl AIL_set_3D_sample_effects_level(void *a1, int32_t a2) {
  CSoundObject *SampleSound3D; // eax

  SampleSound3D =
      (CSoundObject *)CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
  if (SampleSound3D)
    CSoundObject::set_3D_sample_effects_level(SampleSound3D, a2);
}

void __cdecl AIL_set_3D_position(void *a1, float a2, float a3, float a4) {
  CSoundObject *SampleSound3D; // eax

  if (a1 == (void *)-1) {
    CSoundEngine::set_3D_position(sSoundEngine, a2, a3, a4);
  } else {
    SampleSound3D =
        (CSoundObject *)CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
    if (SampleSound3D)
      CSoundObject::set_3D_position(SampleSound3D, a2, a3, a4);
  }
}

void __cdecl AIL_3D_position(void *a1, float *a2, float *a3, float *a4) {
  CSoundObject *SampleSound3D; // eax

  if (a1 == (void *)-1) {
    CSoundEngine::get_3D_position(sSoundEngine, a2, a3, a4);
  } else {
    SampleSound3D =
        (CSoundObject *)CSoundEngine::GetSampleSound3D(sSoundEngine, a1);
    if (SampleSound3D)
      CSoundObject::get_3D_position(SampleSound3D, a2, a3, a4);
  }
}

int __cdecl AIL_WAV_info(int a1, _DWORD *a2) {
  unsigned __int32 v3;  // eax
  unsigned int v4;      // ebx
  int v5;               // edi
  char v6;              // al
  int v8;               // ecx
  int v9;               // edi
  int v10;              // ecx
  unsigned __int32 v11; // eax
  __int16 v12;          // ax
  char v13;             // al
  int v14;              // edx
  int v15;              // eax
  int v16;              // ecx
  int v17;              // edx
  int v18;              // eax
  int v19;              // ecx
  unsigned int v20;     // [esp+0h] [ebp-18h]
  int v21;              // [esp+4h] [ebp-14h]
  int v22;              // [esp+8h] [ebp-10h]

  memset(a2, 0, 0x24u);
  while (1) {
    while (1) {
      while (1) {
        v3 = _byteswap_ulong(*(_DWORD *)a1);
        v4 = *(_DWORD *)(a1 + 4);
        v5 = a1 + 8;
        if (v3 != 1380533830)
          break;
        v11 = _byteswap_ulong(*(_DWORD *)(a1 + 8));
        a1 += 12;
        if (v11 != 1463899717)
          goto LABEL_7;
      }
      if (v3 > 0x52494646)
        break;
      switch (v3) {
      case 0x4C495354u:
        goto LABEL_17;
      case 0x50414420u:
        a1 = v5 + v4;
        if (!a2[1])
          a2[1] = -1;
        break;
      case 0x4A554E4Bu:
      LABEL_17:
        a1 = v5 + v4;
        break;
      default:
        goto LABEL_7;
      }
    }
    if (v3 == 1717658484)
      goto LABEL_17;
    if (v3 != 1718449184)
      break;
    if (v4 > 0xF) {
      v12 = *(_WORD *)(a1 + 8);
      if (v12 == 1) {
        v21 = *(unsigned __int16 *)(a1 + 20);
        v14 = *(unsigned __int16 *)(a1 + 10);
        v15 = *(unsigned __int16 *)(v5 + 14);
        v16 = *(_DWORD *)(v5 + 4);
        *a2 = 1;
        a2[3] = v16;
        a2[4] = v15;
        a2[5] = v14;
        a2[7] = v21;
        v13 = 0;
      } else if (v12 == 17) {
        v22 = *(unsigned __int16 *)(a1 + 20);
        v17 = *(unsigned __int16 *)(a1 + 10);
        v18 = *(unsigned __int16 *)(v5 + 14);
        v19 = *(_DWORD *)(v5 + 4);
        *a2 = 17;
        a2[3] = v19;
        a2[4] = v18;
        a2[5] = v17;
        a2[7] = v22;
        v13 = 0;
      } else {
        v13 = 1;
      }
      a1 = v5 + v4;
      if (!v13)
        continue;
    }
    goto LABEL_7;
  }
  if (v3 != 1684108385 || (v20 = a2[5]) == 0 || (v8 = a2[4]) == 0) {
  LABEL_7:
    v6 = 0;
    return v6 & 1;
  }
  a2[1] = v5;
  a2[2] = v4;
  v9 = v8;
  v10 = v8 + 7;
  if (v9 <= -1)
    v9 = v10;
  a2[6] = v4 / v20 / (v9 >> 3);
  a2[8] = 0;
  v6 = 1;
  return v6 & 1;
}

int __cdecl RB_CompareTouchImages(int *a1, const void *a2) {
  int v2;             // edx
  unsigned __int8 v3; // bl
  unsigned __int8 v4; // cl
  int v5;             // edx

  v2 = *a1;
  v3 = *(_BYTE *)(*(_DWORD *)a2 + 10);
  if (!v3)
    return -1;
  v4 = *(_BYTE *)(v2 + 10);
  if (!v4)
    return 1;
  v5 = *(_DWORD *)(*(_DWORD *)a2 + 16) - *(_DWORD *)(v2 + 16);
  if (!v5)
    return v4 - v3;
  return v5;
}

unsigned __int8 *__cdecl Com_GetBsp(int *a1, unsigned int *a2) {
  if (a1)
    *a1 = dword_CEB384;
  if (a2)
    *a2 = dword_CEB388;
  return comBspGlob;
}

void Com_UnloadBsp(void) {
  Z_FreeInternal(comBspGlob);
  comBspGlob = 0;
}

void Com_CleanupBsp(void) {
  if (comBspGlob) {
    Z_FreeInternal(comBspGlob);
    comBspGlob = 0;
  }
}

_BOOL4 Com_HasPlayerProfile(void) {
  return *(_BYTE *)com_playerProfile->current.integer != 0;
}

signed __int32 Com_BuildPlayerProfilePath(char *__str, signed __int32 __size,
                                          char *__format, ...) {
  dvar_s *v3;        // edx
  int v4;            // eax
  int v5;            // ebx
  signed __int32 v6; // edx
  int v8;            // eax
  char v9;           // [esp+8h] [ebp-30h]
  va_list va;        // [esp+4Ch] [ebp+14h] BYREF

  va_start(va, __format);
  v3 = com_playerProfile;
  if (!*(_BYTE *)com_playerProfile->current.integer) {
    Com_Error(0,
              "Tried to use a player profile before it was set.  This is "
              "probably a menu bug.\n",
              v9);
    v3 = com_playerProfile;
  }
  v4 = Com_sprintf(__str, __size, "players/%s/",
                   (const char *)v3->current.integer);
  v5 = v4;
  if (v4 < 0 || __size <= v4)
    return __size;
  v8 = vsnprintf(&__str[v4], __size - v4, __format, va);
  v6 = v5 + v8;
  if (v8 >= 0 && __size > v6)
    return v6;
  __str[__size - 1] = 0;
  return __size;
}

signed __int32 Com_BuildPlayerProfilePathForPlayer(char *__str,
                                                   signed __int32 __size,
                                                   const char *a3,
                                                   char *__format, ...) {
  int v4;            // eax
  int v5;            // ebx
  signed __int32 v6; // edx
  int v8;            // eax
  va_list va;        // [esp+50h] [ebp+18h] BYREF

  va_start(va, __format);
  v4 = Com_sprintf(__str, __size, "players/%s/", a3);
  v5 = v4;
  if (v4 < 0 || __size <= v4)
    return __size;
  v8 = vsnprintf(&__str[v4], __size - v4, __format, va);
  v6 = v5 + v8;
  if (v8 >= 0 && __size > v6)
    return v6;
  __str[__size - 1] = 0;
  return __size;
}

int __cdecl Com_DeletePlayerProfile(char *a1) {
  void **v2;       // esi
  int v3;          // ebx
  int v4;          // ebx
  UInt8 path[256]; // [esp+2Ch] [ebp-15Ch] BYREF
  char __str[64];  // [esp+12Ch] [ebp-5Ch] BYREF
  int v7[7];       // [esp+16Ch] [ebp-1Ch] BYREF

  if (!*a1)
    return 0;
  v2 = (void **)FS_ListFiles("players", "/", FS_LIST_ALL, v7);
  if (v7[0] > 0) {
    v4 = 0;
    while (I_stricmp((char *)v2[v4], a1)) {
      if (v7[0] <= ++v4)
        goto LABEL_4;
    }
    v3 = 1;
  } else {
  LABEL_4:
    v3 = 0;
  }
  FS_FreeFileList(v2);
  if (!v3)
    return 0;
  Com_BuildPlayerProfilePathForPlayer(__str, 64, a1, (char *)&inData, 3);
  FS_BuildOSPath((const char *)fs_basepath->current.integer, fs_gamedir, __str,
                 (char *)path);
  if (!Sys_RemoveDirTree(path))
    return 0;
  if (!I_stricmp(a1, (char *)com_playerProfile->current.integer))
    Dvar_SetString(com_playerProfile, (char *)&inData);
  return 1;
}

void __cdecl Com_ChangePlayerProfile(char *__src) {
  void **v1;      // edi
  int v2;         // ebx
  int v3;         // ebx
  char v4;        // [esp+8h] [ebp-C0h]
  char __str[64]; // [esp+2Ch] [ebp-9Ch] BYREF
  char __dst[64]; // [esp+6Ch] [ebp-5Ch] BYREF
  int v7[7];      // [esp+ACh] [ebp-1Ch] BYREF

  if (I_stricmp(__src, (char *)com_playerProfile->current.integer)) {
    I_strncpyz(__dst, __src, 64);
    if (__dst[0]) {
      v1 = (void **)FS_ListFiles("players", "/", FS_LIST_ALL, v7);
      if (v7[0] > 0) {
        v3 = 0;
        while (I_stricmp((char *)v1[v3], __dst)) {
          if (v7[0] <= ++v3)
            goto LABEL_5;
        }
        v2 = 1;
      } else {
      LABEL_5:
        v2 = 0;
      }
      FS_FreeFileList(v1);
      if (v2) {
        FS_WriteFile("players/active.txt", __dst, strlen(__dst));
        Cbuf_ExecuteText(0, "disconnect", v4);
        Dvar_ResetDvars(0xFFFFu, DVAR_SOURCE_EXTERNAL);
        Dvar_SetString(com_playerProfile, __dst);
        Com_BuildPlayerProfilePath(__str, 64, "config_mp.cfg");
        Com_ExecStartupConfigs(__str);
        Com_CheckSetRecommended();
        if ((unsigned __int8)Dvar_AnyLatchedValues())
          Cbuf_AddText("snd_restart\n");
      }
    }
  }
}

void Com_InitPlayerProfiles(void) {
  char *v0;       // esi
  void **v1;      // edi
  int v2;         // ebx
  int v3;         // ebx
  char __str[64]; // [esp+24h] [ebp-64h] BYREF
  int v5;         // [esp+64h] [ebp-24h] BYREF
  char *v6;       // [esp+68h] [ebp-20h] BYREF
  int v7;         // [esp+6Ch] [ebp-1Ch] BYREF

  ui_playerProfileAlreadyChosen =
      (int)Dvar_RegisterInt("ui_playerProfileAlreadyChosen", 0, 0, 1, 0x1200u);
  Dvar_ChangeResetValue((const dvar_s *)ui_playerProfileAlreadyChosen,
                        (DvarValue)1);
  com_playerProfile =
      Dvar_RegisterString("com_playerProfile", (DvarValue)&inData, 0x1040u);
  if ((FS_ReadFile("players/active.txt", (char **)&v7) & 0x80000000) != 0)
    goto LABEL_3;
  v6 = (char *)v7;
  v0 = Com_Parse(&v6);
  FS_FreeFile((void *)v7);
  if (!*v0)
    goto LABEL_3;
  v1 = (void **)FS_ListFiles("players", "/", FS_LIST_ALL, &v5);
  if (v5 > 0) {
    v3 = 0;
    while (I_stricmp((char *)v1[v3], v0)) {
      if (v5 <= ++v3)
        goto LABEL_5;
    }
    v2 = 1;
  } else {
  LABEL_5:
    v2 = 0;
  }
  FS_FreeFileList(v1);
  if (v2) {
    Dvar_SetString(com_playerProfile, v0);
    Com_BuildPlayerProfilePath(__str, 64, "config_mp.cfg");
    Com_ExecStartupConfigs(__str);
  } else {
  LABEL_3:
    Com_ExecStartupConfigs(0);
  }
}

int __cdecl Com_NewPlayerProfile(char *a1) {
  void **v2;       // edi
  int v3;          // ebx
  int v4;          // ebx
  int v5;          // [esp+10h] [ebp-178h]
  char __big[256]; // [esp+2Ch] [ebp-15Ch] BYREF
  char __str[64];  // [esp+12Ch] [ebp-5Ch] BYREF
  int v8[7];       // [esp+16Ch] [ebp-1Ch] BYREF

  if (!*a1)
    goto LABEL_2;
  v5 = 3;
  v2 = (void **)FS_ListFiles("players", "/", FS_LIST_ALL, v8);
  if (v8[0] > 0) {
    v4 = 0;
    while (I_stricmp((char *)v2[v4], a1)) {
      if (v8[0] <= ++v4)
        goto LABEL_6;
    }
    v3 = 1;
  } else {
  LABEL_6:
    v3 = 0;
  }
  FS_FreeFileList(v2);
  if (v3) {
    Com_Printf("Profile '%s' already exists\n", a1);
    return 0;
  } else {
  LABEL_2:
    Com_BuildPlayerProfilePathForPlayer(__str, 64, a1, (char *)&inData, v5);
    FS_BuildOSPath((const char *)fs_basepath->current.integer, fs_gamedir,
                   __str, __big);
    if (FS_CreatePath(__big)) {
      Com_Printf("Unable to create new profile path: %s\n", __big);
      return 0;
    } else {
      return 1;
    }
  }
}

void __tcf_0(void) {
  GetMacGameEngine(void)::theGameEngine._vptr$CMacGameEngine = off_332228;
  CMacGameEngine::~CMacGameEngine(&GetMacGameEngine(void)::theGameEngine);
}

int __cdecl CalculateScore(_DWORD *a1, unsigned __int16 *a2) {
  unsigned __int16 *v2;   // ebx
  unsigned __int8 v3;     // di
  int v4;                 // ecx
  char v5;                // al
  bool v6;                // zf
  char v7;                // cl
  unsigned __int8 v9;     // [esp+2h] [ebp-1Ah]
  unsigned __int8 v10;    // [esp+3h] [ebp-19h]
  unsigned __int16 **v11; // [esp+4h] [ebp-18h]
  int v12;                // [esp+8h] [ebp-14h]
  unsigned __int16 *v13;  // [esp+Ch] [ebp-10h]

  v2 = (unsigned __int16 *)a1[2];
  v12 = a1[4];
  v11 = (unsigned __int16 **)a1[5];
  v13 = (unsigned __int16 *)a1[6];
  v9 = 0;
  v10 = 0;
  v3 = 0;
  while (v13 != v2) {
    while (1) {
      v4 = *v2;
      if (*a2 == v4)
        v3 = 1;
      v5 = v10;
      if (v4 == a2[1])
        v5 = 1;
      v10 = v5;
      v6 = v4 == a2[2];
      v7 = v9;
      if (v6)
        v7 = 1;
      v9 = v7;
      if ((unsigned __int16 *)v12 != ++v2)
        break;
      v12 = (int)(*++v11 + 256);
      v2 = *v11;
      if (v13 == *v11)
        return v10 + v3 + v9;
    }
  }
  return v10 + v3 + v9;
}

void *__stdcall ChooseAndRemoveBestTriangle(void *__dst, _DWORD *a2,
                                            std::_List_node_base *a3) {
  std::_List_node_base *v3; // edi
  unsigned __int16 *v4;     // esi

  v3 = a3;
  v4 = *(unsigned __int16 **)a3;
  if (*(std::_List_node_base **)a3 != a3) {
    do {
      *((_DWORD *)v4 + 4) = CalculateScore(a2, v4 + 4);
      if (v3 == a3 || *((_DWORD *)v4 + 4) > *((_DWORD *)v3 + 4))
        v3 = (std::_List_node_base *)v4;
      v4 = *(unsigned __int16 **)v4;
    } while (a3 != (std::_List_node_base *)v4);
  }
  memmove(__dst, (char *)v3 + 8, 0xCu);
  std::_List_node_base::unhook(v3);
  operator delete(v3);
  return __dst;
}

int __cdecl Score(unsigned __int16 *a1, unsigned int a2) {
  int v2;                // edx
  unsigned __int16 *v3;  // ebx
  void **v4;             // ecx
  char *v5;              // eax
  int v7;                // ecx
  void **i;              // edi
  unsigned __int16 *v9;  // edx
  void **v10;            // [esp+10h] [ebp-68h]
  char *v11;             // [esp+14h] [ebp-64h]
  char *v12;             // [esp+18h] [ebp-60h]
  unsigned __int16 v13;  // [esp+1Eh] [ebp-5Ah]
  int v14;               // [esp+20h] [ebp-58h]
  int v15;               // [esp+24h] [ebp-54h]
  _DWORD v17[2];         // [esp+38h] [ebp-40h] BYREF
  char *v18;             // [esp+40h] [ebp-38h]
  void *v19;             // [esp+44h] [ebp-34h]
  char *v20;             // [esp+48h] [ebp-30h]
  void **v21;            // [esp+4Ch] [ebp-2Ch]
  unsigned __int16 *v22; // [esp+50h] [ebp-28h]
  int v23;               // [esp+54h] [ebp-24h]
  int v24;               // [esp+58h] [ebp-20h]
  int v25;               // [esp+5Ch] [ebp-1Ch]

  v17[0] = 0;
  v17[1] = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  std::_Deque_base<unsigned short>::_M_initialize_map(v17, 0);
  if (a2) {
    v15 = 0;
    v14 = 0;
    v12 = v18;
    v11 = v20;
    v10 = v21;
    v3 = v22;
    v7 = (int)v20;
    for (i = v21;; i = v10) {
      v13 = *a1;
      v9 = (unsigned __int16 *)v12;
    LABEL_10:
      if (v3 == v9) {
      LABEL_14:
        if ((unsigned __int16 *)(v24 - 2) == v3)
          goto LABEL_24;
      } else {
        while (*v9 != v13) {
          if ((unsigned __int16 *)v7 != ++v9)
            goto LABEL_10;
          v7 = (int)*++i + 512;
          v9 = (unsigned __int16 *)*i;
          if (v3 == *i)
            goto LABEL_14;
        }
        ++v14;
        if ((unsigned __int16 *)(v24 - 2) == v3) {
        LABEL_24:
          std::deque<unsigned short>::_M_push_back_aux(v17, (__int16 *)a1);
          v12 = v18;
          v11 = v20;
          v10 = v21;
          v3 = v22;
          goto LABEL_18;
        }
      }
      if (v3) {
        *v3 = v13;
        v12 = v18;
        v11 = v20;
        v10 = v21;
        v3 = v22;
      }
      v22 = ++v3;
    LABEL_18:
      if ((unsigned int)(((v11 - v12) >> 1) + ((v25 - (int)v10) >> 2 << 8) +
                         (((int)v3 - v23) >> 1) - 256) > 0xA) {
        if (v12 == v11 - 2) {
          operator delete(v19);
          v10 = ++v21;
          v19 = *v21;
          v11 = (char *)v19 + 512;
          v20 = (char *)v19 + 512;
          v12 = (char *)v19;
          v18 = (char *)v19;
          v3 = v22;
        } else {
          v12 += 2;
          v18 = v12;
        }
      }
      ++v15;
      ++a1;
      if (a2 == v15) {
        v2 = (int)v11;
        v4 = v10;
        goto LABEL_3;
      }
      v7 = (int)v11;
    }
  }
  v14 = 0;
  v12 = v18;
  v2 = (int)v20;
  v3 = v22;
  v4 = v21;
LABEL_3:
  v5 = v12;
  while (v3 != (unsigned __int16 *)v5) {
    while (1) {
      v5 += 2;
      if ((char *)v2 != v5)
        break;
      v5 = (char *)*++v4;
      v2 = (int)*v4 + 512;
      if (v3 == *v4)
        goto LABEL_7;
    }
  }
LABEL_7:
  std::_Deque_base<unsigned short>::~_Deque_base((int)v17);
  return v14;
}

unsigned int *__cdecl GetHighAndLowIndices(unsigned int *a1, unsigned int *a2,
                                           const unsigned __int16 *a3,
                                           unsigned int a4) {
  unsigned int v4;             // eax
  int v5;                      // eax
  const unsigned __int16 *v6;  // ebx
  int v7;                      // esi
  int v8;                      // ecx
  unsigned int *result;        // eax
  const unsigned __int16 *i;   // edx
  int v11;                     // ebx
  int v12;                     // esi
  int v13;                     // edi
  int v14;                     // ecx
  __int64 v15;                 // rax
  int v16;                     // edi
  unsigned int v17;            // [esp+4h] [ebp-24h]
  int v18;                     // [esp+8h] [ebp-20h]
  int v19;                     // [esp+Ch] [ebp-1Ch]
  const unsigned __int16 *v20; // [esp+10h] [ebp-18h]
  unsigned int v21;            // [esp+14h] [ebp-14h]
  unsigned int v22;            // [esp+18h] [ebp-10h]

  v4 = *a3;
  *a2 = v4;
  *a1 = v4;
  v22 = v4;
  v21 = *a2;
  v17 = a4 >> 2;
  if (a4 >> 2) {
    v20 = a3;
    v18 = 0;
    for (i = a3;; i = v20) {
      v11 = *i;
      v12 = i[1];
      v13 = i[2];
      v19 = i[3];
      v14 = v12 - (v11 - (((int)(v11 - v21) >> 31) & (v11 - v21)));
      v15 = (int)(v11 + (((int)(v22 - v11) >> 31) & (v22 - v11)) - v12);
      v22 = v19 + (((int)(v13 +
                          (((int)(v12 + (HIDWORD(v15) & v15) - v13) >> 31) &
                           (v12 + (HIDWORD(v15) & v15) - v13)) -
                          v19) >>
                    31) &
                   (v13 +
                    (((int)(v12 + (HIDWORD(v15) & v15) - v13) >> 31) &
                     (v12 + (HIDWORD(v15) & v15) - v13)) -
                    v19));
      v16 = v13 - (((v13 - (v12 - ((v14 >> 31) & v14))) >> 31) &
                   (v13 - (v12 - ((v14 >> 31) & v14))));
      v21 = v19 - (((v19 - v16) >> 31) & (v19 - v16));
      ++v18;
      v20 += 4;
      if (v17 == v18)
        break;
    }
    v5 = 4 * v17;
  } else {
    v5 = 0;
  }
  if ((a4 & 3) != 0) {
    v6 = &a3[v5];
    v7 = 0;
    do {
      v8 = *v6;
      v22 = v8 + (((int)(v22 - v8) >> 31) & (v22 - v8));
      v21 = v8 - (((int)(v8 - v21) >> 31) & (v8 - v21));
      ++v7;
      ++v6;
    } while ((a4 & 3) != v7);
  }
  *a1 = v22;
  result = a2;
  *a2 = v21;
  return result;
}

int __cdecl D3DXGetShaderConstantTable(int a1, CD3DXConstantTable **a2) {
  unsigned int v2;        // ebx
  int *v3;                // eax
  char *v4;               // esi
  CD3DXConstantTable *v5; // ebx
  int v6;                 // edi
  const char *v7;         // ebx
  int v8;                 // ebx
  int v9;                 // ebx
  const char *v11;        // [esp+20h] [ebp-28h] BYREF
  int v12;                // [esp+24h] [ebp-24h] BYREF
  int v13;                // [esp+28h] [ebp-20h] BYREF
  char v14;               // [esp+2Ch] [ebp-1Ch] BYREF
  char v15;               // [esp+2Dh] [ebp-1Bh] BYREF
  char v16;               // [esp+2Eh] [ebp-1Ah] BYREF
  _BYTE v17[25];          // [esp+2Fh] [ebp-19h] BYREF

  std::string::string(&v13, a1, v17);
  v2 = std::string::find((std::string *)&v13, "::", 0, 2u);
  if (v2 + 2 > *(_DWORD *)(v13 - 12))
    std::__throw_out_of_range("basic_string::substr");
  std::string::string((std::string *)&v12, (const std::string *)&v13, v2 + 2,
                      *(_DWORD *)(v13 - 12));
  std::string::string((std::string *)&v11, (const std::string *)&v13, 0, v2);
  std::string::replace((std::string *)&v11, *((_DWORD *)v11 - 3) - 2, 2u, "c",
                       1u);
  v3 = (int *)
      std::_Rb_tree<std::string, std::pair<std::string const, std::string>,
                    std::_Select1st<std::pair<std::string const, std::string>>,
                    std::less<std::string>,
                    std::allocator<std::pair<std::string const, std::string>>>::
          find((int)&sShaderPrograms, &v11);
  if (v3 == &dword_CEB504) {
    *a2 = 0;
    v6 = -2005529767;
  } else {
    v4 = (char *)v3[5];
    v5 = (CD3DXConstantTable *)operator new(0x10u);
    CD3DXConstantTable::CD3DXConstantTable(v5, v4);
    *a2 = v5;
    v6 = 0;
  }
  v7 = v11 - 12;
  if (v11 - 12 != (const char *)&std::string::_Rep::_S_empty_rep_storage &&
      (int)__gnu_cxx::__exchange_and_add((volatile int *)v11 - 1, -1) <= 0) {
    std::string::_Rep::_M_destroy(v7, &v15);
  }
  v8 = v12 - 12;
  if (&std::string::_Rep::_S_empty_rep_storage != (_UNKNOWN *)(v12 - 12) &&
      (int)__gnu_cxx::__exchange_and_add((volatile int *)(v12 - 4), -1) <= 0) {
    std::string::_Rep::_M_destroy(v8, &v16);
  }
  v9 = v13 - 12;
  if (&std::string::_Rep::_S_empty_rep_storage != (_UNKNOWN *)(v13 - 12) &&
      (int)__gnu_cxx::__exchange_and_add((volatile int *)(v13 - 4), -1) <= 0) {
    std::string::_Rep::_M_destroy(v9, &v14);
  }
  return v6;
}

void __cdecl SV_SetExpectedHunkUsage(char *a1) {
  int v1;          // eax
  unsigned int v2; // esi
  size_t v3;       // ebx
  void *v4;        // edi
  char *v5;        // eax
  char *v6;        // eax
  int v7;          // eax
  char *v8;        // [esp+18h] [ebp-20h] BYREF
  int v9[7];       // [esp+1Ch] [ebp-1Ch] BYREF

  v1 = FS_FOpenFileByMode("hunkusage.dat", v9, FS_READ);
  v2 = v1;
  if (v1 >= 0) {
    v3 = v1 + 1;
    v4 = Z_MallocInternal(v1 + 1);
    memset(v4, 0, v3);
    FS_Read((char *)v4, v2, v9[0]);
    FS_FCloseFile(v9[0]);
    v8 = (char *)v4;
    while (1) {
      v5 = Com_Parse(&v8);
      if (!v5 || !*v5)
        break;
      if (!I_stricmp(v5, a1)) {
        v6 = Com_Parse(&v8);
        if (v6) {
          if (*v6) {
            v7 = atoi(v6);
            Dvar_SetInt(com_expectedHunkUsage, v7);
            Z_FreeInternal(v4);
            return;
          }
        }
      }
    }
    Z_FreeInternal(v4);
  }
}

void CL_OpenedIWDList_f(void) {
  char *v0; // eax

  v0 = FS_LoadedIwdNames();
  Com_Printf("Opened IWD Names: %s\n", v0);
}

void CL_ReferencedIWDList_f(void) {
  char *v0; // eax

  v0 = FS_ReferencedIwdNames();
  Com_Printf("Referenced IWD Names: %s\n", v0);
}

_BOOL4 Voice_SendVoiceData(void) {
  if (!*(_BYTE *)(sv_voice + 8) || !*(_BYTE *)(cl_voice + 8) ||
      Dvar_GetInt("rate") <= 4999 || *(_DWORD *)clc != 8)
    return 0;
  if (*(_BYTE *)(cl_talking + 8) || (unsigned __int8)IsTalking())
    return 1;
  return *((_DWORD *)cl + 386819) != 0;
}

int CL_SyncGpu(void) { return dword_121C7F4(); }

void CL_SetRecommended_f(void) { Com_SetRecommended(1); }

void CL_OpenScriptMenu_f(void) {
  char *v0;            // esi
  const gentity_s *v1; // eax
  const char *v2;      // edi
  int v3;              // ebx
  char *ConfigString;  // eax
  int Int;             // eax
  char *v6;            // eax
  char v7;             // [esp+8h] [ebp-20h]

  if (Cmd_Argc() == 3) {
    if (*(_BYTE *)(legacyHacks + 1261)) {
      if (dword_1220A70) {
        v0 = (char *)Cmd_Argv(1);
        v1 = Cmd_Argv(2);
        v2 = (const char *)v1;
        if (v0) {
          if (v1) {
            v3 = 0;
            while (1) {
              ConfigString = CL_GetConfigString(v3 + 1246);
              if (*ConfigString) {
                if (!I_stricmp(v0, ConfigString))
                  break;
              }
              if (++v3 == 32) {
                v3 = -1;
                break;
              }
            }
            Int = Dvar_GetInt("sv_serverId");
            v6 = va("cmd mr %i %i %s\n", Int, v3, v2);
            Cbuf_ExecuteText(2, v6, v7);
          }
        }
      }
    }
  } else {
    Com_Printf(
        "USAGE: openscriptmenu <parent menu name> <script menu response>\n");
    Com_Printf("EXAMPLE: openscriptmenu ingame changeweapon\n");
  }
}

int __cdecl Client_SendVoiceData(int __n, char *__src) {
  _DWORD *v2; // ebx
  int v3;     // edx

  if (__n > 0) {
    memcpy((char *)&unk_1682E28 + 260 * dword_168384C, __src, __n);
    v2 = cl;
    *((_DWORD *)cl + 65 * *((_DWORD *)cl + 386819) + 386169) = __n;
    v3 = v2[386819] + 1;
    v2[386819] = v3;
    if (v3 > 0 && (v2[2492] - v2[386820] > 199 || v3 > 9)) {
      CL_WriteVoicePacket();
      v2[386819] = 0;
      v2[386820] = v2[2492];
    }
  }
  return __n;
}

int __cdecl UI_PlayerProfilesQsortCompare(_DWORD *a1, _DWORD *a2) {
  int v2; // ecx

  if (*a1 == *a2)
    return 0;
  v2 = I_stricmp(*((char **)&uiInfo[1].cursory + *a1),
                 *((char **)&uiInfo[1].cursory + *a2));
  if (!*(_DWORD *)&uiInfo[1].Menus[228])
    return -v2;
  return v2;
}

void __usercall UI_AddServerToFavoritesList(char *a1 @<eax>, char *a2 @<edx>) {
  int v3;          // eax
  const char *v4;  // eax
  char *v5;        // eax
  const char *v6;  // eax
  const char *v7;  // eax
  const char *v8;  // eax
  const char *v9;  // eax
  const char *v10; // eax

  if (*a1) {
    if (*a2) {
      v3 = LAN_AddServer(2, a1, a2);
      if (v3) {
        if (v3 == -1) {
          v10 = UI_SafeTranslateString("EXE_FAVORITELISTFULL");
          Com_Printf("%s\n", v10);
          Dvar_SetStringByName("ui_favorite_message", "@EXE_FAVORITELISTFULL");
        } else if (v3 == -2) {
          v8 = UI_SafeTranslateString("EXE_BADSERVERADDRESS");
          Com_Printf("%s\n", v8);
          Dvar_SetStringByName("ui_favorite_message", "@EXE_BADSERVERADDRESS");
        } else {
          v4 = UI_SafeTranslateString("EXE_FAVORITEADDED");
          v5 = va("%s\n", v4);
          Com_Printf(v5, a2);
          Dvar_SetStringByName("ui_favorite_message", "@EXE_FAVORITEADDED");
        }
      } else {
        v9 = UI_SafeTranslateString("EXE_FAVORITEINLIST");
        Com_Printf("%s\n", v9);
        Dvar_SetStringByName("ui_favorite_message", "@EXE_FAVORITEINLIST");
      }
    } else {
      v6 = UI_SafeTranslateString("EXE_FAVORITEADDRESSEMPTY");
      Com_Printf("%s\n", v6);
      Dvar_SetStringByName("ui_favorite_message", "@EXE_FAVORITEADDRESSEMPTY");
    }
  } else {
    v7 = UI_SafeTranslateString("EXE_FAVORITENAMEEMPTY");
    Com_Printf("%s\n", v7);
    Dvar_SetStringByName("ui_favorite_message", "@EXE_FAVORITENAMEEMPTY");
  }
}

int __cdecl UI_DrawRecordLevel(rectDef_s *a1) {
  float v1;         // xmm1_4
  __int64 v3;       // [esp+0h] [ebp-38h]
  __int64 v4;       // [esp+0h] [ebp-38h]
  __int64 v5;       // [esp+0h] [ebp-38h]
  __int64 v6;       // [esp+0h] [ebp-38h]
  float VoiceLevel; // [esp+2Ch] [ebp-Ch]

  VoiceLevel = Voice_GetVoiceLevel();
  if (VoiceLevel > 0.0) {
    v1 = (float)(VoiceLevel * *(float *)&a1->w) - 4.0;
    if (v1 > 0.0) {
      *((float *)&v3 + 1) = *(float *)&a1->y + 2.0;
      *(float *)&v3 = *(float *)&a1->x + 2.0;
      UI_FillRect(v3, v1, *(float *)&a1->h - 4.0, 0, 0, colorWhite);
    }
  }
  UI_FillRect(*(_QWORD *)&a1->x, *(float *)&a1->w, 1.0, 0, 0, colorWhite);
  *((float *)&v4 + 1) = (float)(*(float *)&a1->y + *(float *)&a1->h) - 1.0;
  LODWORD(v4) = a1->x;
  UI_FillRect(v4, *(float *)&a1->w, 1.0, 0, 0, colorWhite);
  *((float *)&v5 + 1) = *(float *)&a1->y + 1.0;
  LODWORD(v5) = a1->x;
  UI_FillRect(v5, 1.0, *(float *)&a1->h - 2.0, 0, 0, colorWhite);
  *((float *)&v6 + 1) = *(float *)&a1->y + 1.0;
  *(float *)&v6 = (float)(*(float *)&a1->x + *(float *)&a1->w) - 1.0;
  UI_FillRect(v6, 1.0, *(float *)&a1->h - 2.0, 0, 0, colorWhite);
  return 1;
}

int __cdecl CL_CompareAdrSigned(netadr_t *a1, netadr_t *a2) {
  return NET_CompareAdrSigned(a1, a2);
}

void __cdecl CL_SetServerInfo(serverInfo_t *a1, char *a2, __int16 a3) {
  const char *v3;  // eax
  char *v4;        // eax
  char *v5;        // eax
  const char *v6;  // eax
  char *v7;        // eax
  char *v8;        // eax
  const char *v9;  // eax
  const char *v10; // eax
  const char *v11; // eax
  const char *v12; // eax
  const char *v13; // eax
  const char *v14; // eax
  const char *v15; // eax
  const char *v16; // eax
  const char *v17; // eax
  const char *v18; // eax
  const char *v19; // eax
  const char *v20; // eax

  if (a1) {
    if (a2) {
      v3 = (const char *)Info_ValueForKey(a2, "clients");
      a1->dirty = atoi(v3);
      v4 = (char *)Info_ValueForKey(a2, "hostname");
      I_strncpyz(&a1->hostName[2], v4, 32);
      v5 = (char *)Info_ValueForKey(a2, "mapname");
      I_strncpyz(&a1->mapName[2], v5, 32);
      v6 = (const char *)Info_ValueForKey(a2, "sv_maxclients");
      a1->allowAnonymous = atoi(v6);
      v7 = (char *)Info_ValueForKey(a2, "game");
      I_strncpyz((char *)&a1->game[2], v7, 24);
      v8 = (char *)Info_ValueForKey(a2, "gametype");
      I_strncpyz(&a1->gameType[2], v8, 16);
      v9 = (const char *)Info_ValueForKey(a2, "nettype");
      a1->maxClients = atoi(v9);
      v10 = (const char *)Info_ValueForKey(a2, "minping");
      a1->maxPing = atoi(v10);
      v11 = (const char *)Info_ValueForKey(a2, "maxping");
      a1->ping = atoi(v11);
      v12 = (const char *)Info_ValueForKey(a2, "sv_allowAnonymous");
      a1->pure = atoi(v12);
      v13 = (const char *)Info_ValueForKey(a2, "con_disabled");
      a1->mod = atoi(v13);
      v14 = (const char *)Info_ValueForKey(a2, "pswrd");
      a1->friendlyfire = atoi(v14);
      v15 = (const char *)Info_ValueForKey(a2, "pure");
      a1->killcam = atoi(v15);
      v16 = (const char *)Info_ValueForKey(a2, "ff");
      a1->consoleDisabled = atoi(v16);
      v17 = (const char *)Info_ValueForKey(a2, "kc");
      a1->hardware = atoi(v17);
      v18 = (const char *)Info_ValueForKey(a2, "hw");
      a1->voice = atoi(v18);
      v19 = (const char *)Info_ValueForKey(a2, "mod");
      a1->requestCount = atoi(v19);
      v20 = (const char *)Info_ValueForKey(a2, "voice");
      LOBYTE(a1->minPing) = atoi(v20);
    }
    *(_WORD *)a1->hostName = a3;
  }
}

void __cdecl CL_SetServerInfoByAddress(netadr_t a1, char *a2, __int16 a3) {
  int v3;            // esi
  _DWORD *i;         // edx
  int v5;            // ebx
  int v6;            // edi
  int v7;            // eax
  int v8;            // esi
  netadr_t *v9;      // edi
  serverInfo_t *v10; // ebx
  netadr_t v11;      // [esp+Ch] [ebp-7Ch]
  netadr_t v12;      // [esp+Ch] [ebp-7Ch]
  serverInfo_t *v13; // [esp+20h] [ebp-68h]
  serverInfo_t *v14; // [esp+24h] [ebp-64h]
  int v15;           // [esp+2Ch] [ebp-5Ch]
  char *v16;         // [esp+30h] [ebp-58h]
  char *v17;         // [esp+34h] [ebp-54h]
  int v18;           // [esp+38h] [ebp-50h]
  int v19;           // [esp+3Ch] [ebp-4Ch]

  Com_PumpMessageLoop();
  v19 = 0;
  v17 = (char *)&cls;
  v13 = (serverInfo_t *)&unk_1220A9C;
  do {
    while (1) {
      *(_QWORD *)&v11.type = *(_QWORD *)(v17 + 316);
      v11.port = *((_DWORD *)v17 + 81);
      if (NET_CompareAdr(a1, v11))
        break;
      ++v19;
      v13 = (serverInfo_t *)((char *)v13 + 136);
      v17 += 136;
      if (v19 == 128)
        goto LABEL_5;
    }
    CL_SetServerInfo(v13, a2, a3);
    ++v19;
    v13 = (serverInfo_t *)((char *)v13 + 136);
    v17 += 136;
  } while (v19 != 128);
LABEL_5:
  v3 = dword_1224EA0;
  if (dword_1224EA0 > 0) {
    v15 = 0;
    while (1) {
      while (1) {
        v5 = (v3 + v15) / 2;
        v6 = v5;
        v7 = NET_CompareAdrSigned(
            &a1, (netadr_t *)((char *)&cls + 136 * v5 + 17732));
        if (v7 >= 0)
          break;
        v3 = (v3 + v15) / 2;
        if (v15 >= v5)
          goto LABEL_6;
      }
      if (v7 <= 0)
        break;
      v15 = v5 + 1;
      if (v5 + 1 >= v3)
        goto LABEL_6;
    }
    do
      --v6;
    while (v6 >= 0 && !NET_CompareAdrSigned(
                          &a1, (netadr_t *)((char *)&cls + 136 * v6 + 17732)));
    v8 = v6 + 1;
    v9 = (netadr_t *)((char *)&cls + 136 * v6 + 17868);
    v10 = (serverInfo_t *)v9;
    do {
      CL_SetServerInfo(v10, a2, a3);
      ++v8;
      v10 = (serverInfo_t *)((char *)v10 + 136);
      v9 = (netadr_t *)((char *)v9 + 136);
    } while (v8 < dword_1224EA0 && !NET_CompareAdrSigned(&a1, v9));
  }
LABEL_6:
  v18 = 0;
  v16 = (char *)&unk_14BCFA8;
  v14 = (serverInfo_t *)&unk_14BCFA8;
  for (i = &unk_14BCFA8;; i = v16) {
    *(_QWORD *)&v12.type = *(_QWORD *)i;
    v12.port = i[2];
    if (NET_CompareAdr(a1, v12))
      break;
    ++v18;
    v14 = (serverInfo_t *)((char *)v14 + 136);
    v16 += 136;
    if (v18 == 128)
      return;
  LABEL_8:;
  }
  CL_SetServerInfo(v14, a2, a3);
  ++v18;
  v14 = (serverInfo_t *)((char *)v14 + 136);
  v16 += 136;
  if (v18 != 128)
    goto LABEL_8;
}

void __cdecl CL_ServerInfoPacket(netadr_t a1, msg_t *a2, int a3) {
  const char *v3;     // eax
  int v4;             // ebx
  const char *String; // eax
  int v6;             // eax
  int v7;             // esi
  int *v8;            // ebx
  int v9;             // ebx
  int *v10;           // esi
  char *v11;          // eax
  char *v12;          // ebx
  char *v13;          // eax
  int v14;            // eax
  int v15;            // esi
  char *i;            // ebx
  char *v17;          // eax
  char *v18;          // eax
  char *v19;          // eax
  __int128 v20;       // [esp+0h] [ebp-4A8h]
  netadr_t v21;       // [esp+Ch] [ebp-49Ch]
  netadr_t v22;       // [esp+Ch] [ebp-49Ch]
  char *__src;        // [esp+20h] [ebp-488h]
  _BYTE v24[2];       // [esp+3Ah] [ebp-46Eh]
  char __dst[1024];   // [esp+3Ch] [ebp-46Ch] BYREF
  __int64 v26;        // [esp+43Ch] [ebp-6Ch]
  int v27;            // [esp+444h] [ebp-64h]
  int32_t type;       // [esp+448h] [ebp-60h]
  int32_t ip;         // [esp+44Ch] [ebp-5Ch]
  int v30;            // [esp+450h] [ebp-58h]
  int32_t v31;        // [esp+454h] [ebp-54h]
  int32_t v32;        // [esp+458h] [ebp-50h]
  int v33;            // [esp+45Ch] [ebp-4Ch]
  int32_t v34;        // [esp+460h] [ebp-48h]
  int32_t v35;        // [esp+464h] [ebp-44h]
  int v36;            // [esp+468h] [ebp-40h]
  __int64 v37;        // [esp+46Ch] [ebp-3Ch]
  int v38;            // [esp+474h] [ebp-34h]
  int32_t v39;        // [esp+478h] [ebp-30h]
  int32_t v40;        // [esp+47Ch] [ebp-2Ch]
  int v41;            // [esp+480h] [ebp-28h]
  int32_t v42;        // [esp+484h] [ebp-24h]
  int32_t v43;        // [esp+488h] [ebp-20h]
  int v44;            // [esp+48Ch] [ebp-1Ch]

  __src = MSG_ReadString(a2);
  v3 = (const char *)Info_ValueForKey(__src, "protocol");
  v4 = atoi(v3);
  String = (const char *)Dvar_GetString("debug_protocol");
  if (*String)
    v6 = atoi(String);
  else
    v6 = 115;
  if (v6 == v4) {
    v7 = 0;
    v8 = dword_121C808;
    do {
      if (*(_WORD *)v8) {
        if (!v8[2]) {
          v26 = *((_QWORD *)v8 - 1);
          v27 = *v8;
          v21.port = v27;
          LOWORD(v30) = a1.port;
          ip = a1.ip;
          type = a1.type;
          *(_QWORD *)&v21.type = v26;
          if (NET_CompareAdr(a1, v21)) {
            v9 = 261 * v7;
            v10 = &cl_pinglist[261 * v7];
            v10[4] = a3 - v10[3] + 1;
            LOWORD(v33) = a1.port;
            v32 = a1.ip;
            v31 = a1.type;
            *(_QWORD *)&v20 = *(_QWORD *)&a1.type;
            DWORD2(v20) = v33;
            v11 = NET_AdrToString(v20);
            Com_DPrintf("ping time %dms from %s\n", v10[4], v11);
            v12 = (char *)&cl_pinglist[v9 + 5];
            I_strncpyz(v12, __src, 1024);
            v13 = va("%d", (unsigned int)(a1.type - 3) <= 1);
            Info_SetValueForKey(v12, "nettype", v13);
            v14 = v10[4];
            LOWORD(v36) = a1.port;
            v35 = a1.ip;
            v34 = a1.type;
            CL_SetServerInfoByAddress(a1, __src, v14);
            return;
          }
        }
      }
      ++v7;
      v8 += 261;
    } while (v7 != 16);
    if (!dword_14C13A8) {
      v15 = 0;
      for (i = (char *)&cls; *((_WORD *)i + 162); i += 136) {
        v37 = *(_QWORD *)(i + 316);
        v38 = *((_DWORD *)i + 81);
        v22.port = v38;
        LOWORD(v41) = a1.port;
        v40 = a1.ip;
        v39 = a1.type;
        *(_QWORD *)&v22.type = v37;
        if (NET_CompareAdr(a1, v22))
          return;
        if (++v15 == 128) {
          Com_DPrintf("MAX_OTHER_SERVERS hit, dropping infoResponse\n");
          return;
        }
      }
      dword_1220A98 = v15 + 1;
      v17 = (char *)&cls + 136 * v15;
      *(netadr_t *)(v17 + 316) = a1;
      v17[329] = 0;
      v17[348] = 0;
      v17[380] = 0;
      v17[330] = 0;
      *((_WORD *)v17 + 172) = 0;
      *((_WORD *)v17 + 171) = 0;
      *((_WORD *)v17 + 173) = -1;
      v17[412] = 0;
      v17[436] = 0;
      v17[328] = a1.type;
      v17[332] = 0;
      v18 = MSG_ReadString(a2);
      I_strncpyz(__dst, v18, 1024);
      if (__dst[0]) {
        if (v24[strlen(__dst) + 1] != 10)
          *(_WORD *)&__dst[strlen(__dst)] = 10;
        LOWORD(v44) = a1.port;
        v43 = a1.ip;
        v42 = a1.type;
        *(_QWORD *)&v20 = *(_QWORD *)&a1.type;
        DWORD2(v20) = v44;
        v19 = NET_AdrToString(v20);
        Com_Printf("%s: %s", v19, __dst);
      }
    }
  } else {
    Com_DPrintf("Different protocol info packet: %s\n", __src);
  }
}

_BOOL4 __cdecl CL_CDKeyValidate(const char *a1, char *a2) {
  unsigned int v2; // edx
  int i;           // ecx
  int v4;          // eax
  char v6[13];     // [esp+1Bh] [ebp-Dh] BYREF

  v2 = 0;
  for (i = 1; i != 17; ++i) {
    v2 ^= a1[i - 1];
    v4 = 8;
    do {
      while ((v2 & 1) != 0) {
        v2 = (v2 >> 1) ^ 0xA001;
        if (!--v4)
          goto LABEL_6;
      }
      v2 >>= 1;
      --v4;
    } while (v4);
  LABEL_6:;
  }
  sprintf(v6, "%04x", v2);
  return !a2 || !I_strnicmp(v6, a2, 4);
}

void CL_SortGlobalServers(void) {
  qsort(&unk_1224EA4, dword_1224EA0, 0x88u,
        (int(__cdecl *)(const void *, const void *))CL_CompareAdrSigned);
}

void CL_RconInit(void) {
  rconGlob = 0;
  stru_F006D8.type = 1;
}

void CL_Rcon_f(void) {
  char *v0;         // ebx
  int v1;           // eax
  int v2;           // ebx
  int i;            // edi
  int v4;           // ebx
  char *v5;         // eax
  char ip_high;     // di
  char v7;          // bl
  char v8;          // cl
  int32_t type;     // eax
  const char *v10;  // edx
  size_t v11;       // ecx
  char *v12;        // eax
  netadr_t v13;     // [esp+8h] [ebp-460h]
  char ip;          // [esp+2Fh] [ebp-439h]
  uint16_t port;    // [esp+3Eh] [ebp-42Ah]
  char v16[1024];   // [esp+44h] [ebp-424h] BYREF
  int32_t v17;      // [esp+444h] [ebp-24h]
  unsigned int v18; // [esp+448h] [ebp-20h]
  int v19;          // [esp+44Ch] [ebp-1Ch]

  if (Cmd_Argc() <= 1) {
    Com_Printf("USAGE: rcon <command> <options...>\n");
    return;
  }
  v0 = (char *)Cmd_Argv(1);
  if (I_stricmp(v0, "login")) {
    if (I_stricmp(v0, "logout")) {
      if (I_stricmp(v0, "host")) {
        if (!rconGlob) {
          Com_Printf("You need to log in with 'rcon login <password>' before "
                     "using rcon.\n");
          return;
        }
        v16[0] = -1;
        v16[1] = -1;
        v16[2] = -1;
        v16[3] = -1;
        v16[4] = 0;
        v1 = Com_AddToString("rcon ", v16, 4, 1024, 0);
        v2 = Com_AddToString(&rconGlob, v16, v1, 1024, 0);
        for (i = 1; i < Cmd_Argc(); ++i) {
          v4 = Com_AddToString(" ", v16, v2, 1024, 0);
          v5 = (char *)Cmd_Argv(i);
          v2 = Com_AddToString(v5, v16, v4, 1024, 1);
        }
        if (v2 == 1024) {
          Com_Printf("rcon commands are limited to %i characters\n", 1023);
          return;
        }
        v16[v2] = 0;
        if (*(int *)clc <= 4) {
          type = stru_F006D8.type;
          if (stru_F006D8.type == 1) {
            Com_Printf(
                "Can't determine rcon target.  You can fix this by either:\n");
            Com_Printf("1) Joining the server as a player.\n");
            Com_Printf(
                "2) Setting the host server with 'rcon host <address>'.\n");
            return;
          }
          port = stru_F006D8.port;
          ip_high = HIBYTE(stru_F006D8.ip);
          v7 = BYTE2(stru_F006D8.ip);
          v8 = BYTE1(stru_F006D8.ip);
          ip = stru_F006D8.ip;
        } else {
          port = *((_WORD *)clc + 132080);
          ip_high = *((_BYTE *)&loc_407DF + (_DWORD)clc);
          v7 = *((_BYTE *)clc + 264158);
          v8 = *((_BYTE *)clc + 264157);
          ip = *((_BYTE *)clc + 264156);
          type = *((_DWORD *)clc + 66038);
        }
        LOWORD(v19) = port;
        HIBYTE(v18) = ip_high;
        BYTE2(v18) = v7;
        BYTE1(v18) = v8;
        LOBYTE(v18) = ip;
        v17 = type;
        *(_QWORD *)&v13.type = __PAIR64__(v18, type);
        v13.port = port;
        CL_Netchan_SendOOBPacket(strlen(v16) + 1, v16, v13);
        return;
      }
      if (Cmd_Argc() == 3) {
        v12 = (char *)Cmd_Argv(2);
        if (NET_StringToAdr(v12, &stru_F006D8)) {
          if (!stru_F006D8.port)
            stru_F006D8.port = 8305;
        } else {
          Com_Printf("bad host address\n");
        }
      } else {
        Com_Printf("USAGE: rcon host <address>\n");
      }
    } else if (rconGlob) {
      rconGlob = 0;
    } else {
      Com_Printf("Not logged in\n");
    }
  } else if (Cmd_Argc() == 3) {
    v10 = (const char *)Cmd_Argv(2);
    v11 = strlen(v10) + 1;
    if (v11 - 1 <= 0x17)
      memcpy(&rconGlob, v10, v11);
    else
      Com_Printf("rcon password must be %i characters or less\n", 24);
  } else {
    Com_Printf("USAGE: rcon login <password>\n");
  }
}

int __cdecl CL_ServerStatusResponse(netadr_t a1, msg_t *a2) {
  char *v2;         // edi
  char *i;          // esi
  int result;       // eax
  char *StringLine; // edi
  unsigned int v6;  // kr04_4
  char *v7;         // ebx
  unsigned int v8;  // kr08_4
  char j;           // al
  int v10;          // edx
  unsigned int v11; // kr0C_4
  char *v12;        // eax
  char *v13;        // eax
  const char *v14;  // eax
  netadr_t v15;     // [esp+Ch] [ebp-47Ch]
  int v16;          // [esp+2Ch] [ebp-45Ch]
  int v17;          // [esp+3Ch] [ebp-44Ch]
  int v18;          // [esp+4Ch] [ebp-43Ch]
  char v19[1024];   // [esp+50h] [ebp-438h] BYREF
  __int64 v20;      // [esp+450h] [ebp-38h]
  int v21;          // [esp+458h] [ebp-30h]
  int32_t type;     // [esp+45Ch] [ebp-2Ch]
  int32_t ip;       // [esp+460h] [ebp-28h]
  int v24;          // [esp+464h] [ebp-24h]
  int v25;          // [esp+468h] [ebp-20h] BYREF
  int v26;          // [esp+46Ch] [ebp-1Ch] BYREF

  v16 = 0;
  v2 = cl_serverStatusList;
  for (i = cl_serverStatusList;; i += 8224) {
    v20 = *((_QWORD *)v2 + 1024);
    v21 = *((_DWORD *)v2 + 2050);
    LOWORD(v24) = a1.port;
    ip = a1.ip;
    type = a1.type;
    *(_QWORD *)&v15.type = v20;
    v15.port = v21;
    result = NET_CompareAdr(a1, v15);
    if (result)
      break;
    ++v16;
    v2 += 8224;
    if (v16 == 16)
      return result;
  }
  if (i) {
    StringLine = MSG_ReadStringLine(a2);
    Com_sprintf(i, 0x2000u, "%s", StringLine);
    if (!*((_DWORD *)i + 2054)) {
    LABEL_7:
      v6 = strlen(i) + 1;
      Com_sprintf(&i[v6 - 1], 0x2000 - (v6 - 1), "\\");
      if (*((_DWORD *)i + 2054)) {
        Com_Printf("\nPlayers:\n");
        Com_Printf("num: score: ping: name:\n");
      }
      v7 = MSG_ReadStringLine(a2);
      if (*v7) {
        v17 = 0;
        do {
          v11 = strlen(i) + 1;
          Com_sprintf(&i[v11 - 1], 0x2000 - (v11 - 1), "\\%s", v7);
          if (*((_DWORD *)i + 2054)) {
            v25 = 0;
            v26 = 0;
            sscanf(v7, "%d %d", &v26, &v25);
            v12 = strchr(v7, 32);
            if (v12 && (v13 = strchr(v12 + 1, 32)) != 0)
              v14 = v13 + 1;
            else
              v14 = "unknown";
            Com_Printf("%-2d   %-3d    %-3d   %s\n", v17, v26, v25, v14);
          }
          v7 = MSG_ReadStringLine(a2);
          ++v17;
        } while (*v7);
      }
      v8 = strlen(i) + 1;
      Com_sprintf(&i[v8 - 1], 0x2000 - (v8 - 1), "\\");
      *((_DWORD *)i + 2051) = Sys_Milliseconds();
      *(netadr_t *)(i + 0x2000) = a1;
      result = a1.type;
      *((_DWORD *)i + 2053) = 0;
      if (*((_DWORD *)i + 2054))
        *((_DWORD *)i + 2055) = 1;
      return result;
    }
    Com_Printf("Server settings:\n");
    for (j = *StringLine;; j = *StringLine) {
      if (!j)
        goto LABEL_7;
      v18 = 0;
      if (j == 92)
        goto LABEL_25;
      while (1) {
        v10 = 0;
        while (j) {
          v19[v10] = j;
          if (++v10 == 1023)
            break;
          if (*++StringLine == 92)
            break;
          j = *StringLine;
        }
        v19[v10] = 0;
        if (v18)
          Com_Printf("%s\n", v19);
        else
          Com_Printf("%-24s", v19);
        if (++v18 == 2)
          break;
        j = *StringLine;
        if (!*StringLine)
          goto LABEL_7;
        if (j == 92)
        LABEL_25:
          j = *++StringLine;
      }
    }
  }
  return result;
}

int __cdecl CL_ResetPlayerMuting(int a1) {
  int result; // eax

  result = a1;
  s_playerMute[a1] = 0;
  return result;
}

void __cdecl CL_MutePlayer(int a1) {
  bool v1;  // al
  char *v2; // eax
  char v3;  // [esp+8h] [ebp-10h]

  v1 = s_playerMute[a1] == 0;
  s_playerMute[a1] = v1;
  if (v1)
    v2 = va("muteplayer %i", a1);
  else
    v2 = va("unmuteplayer %i", a1);
  Cbuf_ExecuteText(2, v2, v3);
}

int __cdecl CL_IsPlayerMuted(int a1) {
  return (unsigned __int8)s_playerMute[a1];
}

void CL_GlobalServers_f(void) {
  int v0;           // edi
  char v1;          // al
  const char *v2;   // eax
  char *v3;         // ebx
  int v4;           // esi
  int i;            // edi
  const char *v6;   // eax
  char __src[1024]; // [esp+28h] [ebp-430h] BYREF
  _BYTE v9[12];     // [esp+428h] [ebp-30h] BYREF
  __int64 v10;      // [esp+434h] [ebp-24h]
  int v11;          // [esp+43Ch] [ebp-1Ch]

  if (Cmd_Argc() > 2) {
    if (dword_1224EA0 > 0) {
      v0 = 0;
      do {
        v1 = -1;
        if (*((_BYTE *)&cls + 136 * v0 + 17757) != 0xFF)
          v1 = *((_BYTE *)&cls + 136 * v0 + 17757) + 1;
        *((_BYTE *)&cls + 136 * v0++ + 17757) = v1;
      } while (v0 < dword_1224EA0);
    }
    Com_Printf("Requesting servers from the master...\n");
    NET_StringToAdr("cod2master.activision.com", (netadr_t *)v9);
    unk_1224E9C = 1;
    dword_14C13A8 = 1;
    *(_DWORD *)v9 = 4;
    *(_WORD *)&v9[8] = -6576;
    v2 = (const char *)Cmd_Argv(2);
    sprintf(__src, "getservers %s", v2);
    v3 = &__src[strlen(__src)];
    v4 = Cmd_Argc();
    if (v4 > 3) {
      for (i = 3; i != v4; ++i) {
        v6 = (const char *)Cmd_Argv(i);
        v3 += sprintf(v3, " %s", v6);
      }
      if (!(unsigned __int8)Dvar_GetBool("fs_restrict"))
        goto LABEL_9;
    } else if (!(unsigned __int8)Dvar_GetBool("fs_restrict")) {
    LABEL_9:
      v10 = *(_QWORD *)v9;
      v11 = *(_DWORD *)&v9[8];
      NET_OutOfBandPrint(NS_SERVER, *(netadr_t *)v9, __src);
      return;
    }
    strcpy(v3, " demo");
    goto LABEL_9;
  }
  Com_Printf("usage: globalservers <master# 0-1> <protocol> [keywords]\n");
}

void __cdecl CL_ServersResponsePacket(netadr_t a1, msg_t *a2) {
  _BYTE *data;          // esi
  unsigned int v3;      // edi
  _BYTE *i;             // ebx
  unsigned __int8 v5;   // cl
  __int16 v6;           // ax
  char *v7;             // edx
  _BYTE *v8;            // eax
  int v9;               // esi
  int v10;              // ebx
  int v11;              // edi
  int v12;              // eax
  int v13;              // edi
  char *v14;            // eax
  char *v15;            // esi
  unsigned __int8 v16;  // dl
  char v17;             // cl
  char ip;              // bl
  unsigned __int16 v19; // [esp+2Eh] [ebp-65Ah]
  netadr_t *v20;        // [esp+38h] [ebp-650h]
  unsigned __int8 v21;  // [esp+41h] [ebp-647h]
  unsigned __int8 v22;  // [esp+42h] [ebp-646h]
  unsigned __int8 v23;  // [esp+43h] [ebp-645h]
  int v24;              // [esp+44h] [ebp-644h]
  int __nel;            // [esp+48h] [ebp-640h]
  int v26;              // [esp+4Ch] [ebp-63Ch]
  int v27;              // [esp+50h] [ebp-638h]
  uint16_t v28;         // [esp+56h] [ebp-632h]
  char v29;             // [esp+58h] [ebp-630h]
  char v30;             // [esp+59h] [ebp-62Fh]
  char v31;             // [esp+5Ah] [ebp-62Eh]
  char v32;             // [esp+5Bh] [ebp-62Dh]
  unsigned __int8 *v33; // [esp+5Ch] [ebp-62Ch]
  _BYTE v34[3];         // [esp+64h] [ebp-624h] BYREF
  char v35;             // [esp+67h] [ebp-621h] BYREF
  netadr_t v36;         // [esp+664h] [ebp-24h] BYREF

  Com_PumpMessageLoop();
  Com_Printf("CL_ServersResponsePacket\n");
  unk_1224E9C = 0;
  data = (_BYTE *)a2->data;
  v3 = (unsigned int)&data[a2->cursize];
  v26 = 0;
  v33 = (unsigned __int8 *)&v35;
  for (i = data + 1; v3 > (unsigned int)(data + 1); i = data + 1) {
    while (*data != 92 && v3 > (unsigned int)i)
      data = i++;
    if ((unsigned int)i >= v3 - 6)
      break;
    v23 = data[1];
    *(v33 - 3) = v23;
    v22 = i[1];
    *(v33 - 2) = v22;
    v21 = i[2];
    *(v33 - 1) = v21;
    v5 = i[3];
    *v33 = v5;
    v6 = (unsigned __int8)i[4] << 8;
    *(_WORD *)(v33 + 1) = v6;
    data += 7;
    v19 = __ROL2__((unsigned __int8)i[5] + v6, 8);
    *(_WORD *)(v33 + 1) = v19;
    if (*data != 92)
      break;
    Com_DPrintf("server: %d ip: %d.%d.%d.%d:%d\n", v26, v23, v22, v21, v5, v19);
    if (++v26 == 256 || i[7] == 69 && i[8] == 79 && i[9] == 84)
      break;
    v33 += 6;
  }
  __nel = dword_1224EA0;
  if (v26 > 0 && dword_1224EA0 <= 19999) {
    v24 = 0;
    do {
      v8 = &v34[6 * v24];
      v32 = *v8;
      v31 = v8[1];
      v30 = v8[2];
      v29 = v8[3];
      v28 = *((_WORD *)v8 + 2);
      v36.port = v28;
      HIBYTE(v36.ip) = v29;
      BYTE2(v36.ip) = v30;
      BYTE1(v36.ip) = v31;
      LOBYTE(v36.ip) = v32;
      v36.type = 4;
      v9 = dword_1224EA0;
      if (dword_1224EA0 <= 0) {
      LABEL_14:
        v7 = (char *)&cls + 136 * __nel++ + 17728;
        *((_WORD *)v7 + 6) = v28;
        v7[11] = v29;
        v7[10] = v30;
        v7[9] = v31;
        v7[8] = v32;
        *((_DWORD *)v7 + 1) = 4;
        v7[17] = 0;
        v7[36] = 0;
        v7[68] = 0;
        v7[18] = 0;
        *((_WORD *)v7 + 16) = 0;
        *((_WORD *)v7 + 15) = 0;
        *((_WORD *)v7 + 17) = -1;
        v7[100] = 0;
        v7[124] = 0;
        v7[16] = 0;
        v7[20] = 0;
        v7[19] = 1;
        v7[29] = 0;
      } else {
        v27 = 0;
        while (1) {
          while (1) {
            v10 = (v9 + v27) / 2;
            v11 = v10;
            v12 = NET_CompareAdrSigned(
                &v36, (netadr_t *)((char *)&cls + 136 * v10 + 17732));
            if (v12 >= 0)
              break;
            v9 = (v9 + v27) / 2;
            if (v10 <= v27)
              goto LABEL_14;
          }
          if (v12 <= 0)
            break;
          v27 = v10 + 1;
          if (v9 <= v10 + 1)
            goto LABEL_14;
        }
        do
          --v11;
        while (v11 >= 0 &&
               !NET_CompareAdrSigned(
                   &v36, (netadr_t *)((char *)&cls + 136 * v11 + 17732)));
        v13 = v11 + 1;
        v14 = (char *)&cls + 136 * v13;
        v20 = (netadr_t *)(v14 + 17732);
        v15 = v14 + 17728;
        do {
          v16 = BYTE2(v36.ip);
          v17 = BYTE1(v36.ip);
          ip = v36.ip;
          *((_WORD *)v15 + 6) = v36.port;
          *((_WORD *)v15 + 5) = __PAIR16__(HIBYTE(v36.ip), v16);
          v15[9] = v17;
          v15[8] = ip;
          *((_DWORD *)v15 + 1) = v36.type;
          v15[17] = 0;
          v15[36] = 0;
          v15[68] = 0;
          v15[18] = 0;
          *((_WORD *)v15 + 16) = 0;
          *((_WORD *)v15 + 15) = 0;
          *((_WORD *)v15 + 17) = -1;
          v15[100] = 0;
          v15[124] = 0;
          v15[16] = 0;
          v15[20] = 0;
          v15[19] = 1;
          v15[29] = 0;
          ++v13;
          v15 += 136;
          v20 = (netadr_t *)((char *)v20 + 136);
        } while (v13 < dword_1224EA0 && !NET_CompareAdrSigned(&v36, v20));
      }
      ++v24;
    } while (v26 != v24 && __nel <= 19999);
  }
  dword_1224EA0 = __nel;
  qsort(byte_1224EA4, __nel, 0x88u,
        (int(__cdecl *)(const void *, const void *))CL_CompareAdrSigned);
  Com_Printf("%d servers parsed (total %d)\n", v26, __nel);
}

void CL_Ping_f(void) {
  char *v0;      // eax
  int v1;        // edi
  int *v2;       // ebx
  int *v3;       // edx
  int v4;        // eax
  int *v5;       // edx
  signed int v6; // esi
  netadr_t v7;   // [esp+0h] [ebp-78h]
  _BYTE v8[12];  // [esp+3Ch] [ebp-3Ch] BYREF
  __int64 v9;    // [esp+48h] [ebp-30h]
  int v10;       // [esp+50h] [ebp-28h]
  __int64 v11;   // [esp+54h] [ebp-24h]
  int v12;       // [esp+5Ch] [ebp-1Ch]

  if (Cmd_Argc() == 2) {
    memset(v8, 0, sizeof(v8));
    v0 = (char *)Cmd_Argv(1);
    if (NET_StringToAdr(v0, (netadr_t *)v8)) {
      v1 = Sys_Milliseconds();
      v2 = cl_pinglist;
      v3 = dword_121C808;
      do {
        if (!*(_WORD *)v3) {
        LABEL_11:
          *((_WORD *)v2 + 4) = 0;
          goto LABEL_12;
        }
        v4 = v3[2];
        if (v4) {
          if (v4 > 499)
            goto LABEL_11;
        } else if (v1 - v3[1] > 499) {
          goto LABEL_11;
        }
        v2 += 261;
        v3 += 261;
      } while (&g_waitingForServer != (char *)v2);
      v2 = cl_pinglist;
      v5 = cl_pinglist;
      v6 = 0x80000000;
      do {
        if (v1 - v5[3] > v6) {
          v2 = v5;
          v6 = v1 - v5[3];
        }
        v5 += 261;
      } while (&g_waitingForServer != (char *)v5);
    LABEL_12:
      *(_QWORD *)v2 = *(_QWORD *)v8;
      v2[2] = *(_DWORD *)&v8[8];
      v2[3] = Sys_Milliseconds();
      v2[4] = 0;
      v9 = *(_QWORD *)v2;
      v10 = v2[2];
      *(_QWORD *)&v7.type = v9;
      v7.port = v10;
      CL_SetServerInfoByAddress(v7, 0, 0);
      v11 = *(_QWORD *)v8;
      v12 = *(_DWORD *)&v8[8];
      NET_OutOfBandPrint(NS_CLIENT1, *(netadr_t *)v8, "getinfo xxx");
    }
  } else {
    Com_Printf("usage: ping [server]\n");
  }
}

void __usercall CL_Connect_f(long double a1 @<st0>, float a2 @<xmm0>,
                             __m128 a3 @<xmm1>, __m128 a4 @<xmm2>,
                             __m128 a5 @<xmm3>, __m128 a6 @<xmm4>,
                             __m128 a7 @<xmm6>) {
  char *v7;            // ebx
  unsigned __int8 *v8; // ebx
  unsigned int v9;     // edx
  char *v10;           // ecx
  int v11;             // eax
  _DWORD *v12;         // ebx
  _DWORD *v13;         // edx
  _BYTE *v14;          // eax
  _DWORD *v15;         // eax
  netadr_t v16;        // [esp+0h] [ebp-58h]
  netadr_t v17;        // [esp+0h] [ebp-58h]
  char v18[29];        // [esp+3Bh] [ebp-1Dh] BYREF

  if (Cmd_Argc() == 2) {
    SND_StopSounds(SND_STOP_ALL);
    *((_BYTE *)clc + 40) = 0;
    v7 = (char *)Cmd_Argv(1);
    if (*(_BYTE *)(com_sv_running + 8) && !strcmp(v7, "localhost"))
      *(_BYTE *)(legacyHacks + 221) = 1;
    *(_BYTE *)(legacyHacks + 92) = 0;
    *(_BYTE *)(legacyHacks + 156) = 0;
    SV_Frame(0);
    CL_Disconnect(a1, a2, a3, a4, a5, a6, a7);
    Con_Close();
    I_strncpyz(&byte_1220968, v7, 256);
    v8 = (unsigned __int8 *)clc;
    if (NET_StringToAdr(&byte_1220968, (netadr_t *)clc + 2)) {
      if (!*((_WORD *)v8 + 14))
        *((_WORD *)v8 + 14) = 8305;
      Com_Printf("%s resolved to %i.%i.%i.%i:%i\n", &byte_1220968, v8[24],
                 v8[25], v8[26], v8[27],
                 (__int16)__ROL2__(*((_WORD *)v8 + 14), 8));
      *(_QWORD *)&v16.type = *(_QWORD *)(v8 + 20);
      v16.port = *((_DWORD *)v8 + 7);
      if (NET_IsLocalAddress(v16))
        goto LABEL_15;
      v9 = 0;
      v10 = cl_cdkey;
      do {
        v9 ^= *v10;
        v11 = 8;
        do {
          while ((v9 & 1) != 0) {
            v9 = (v9 >> 1) ^ 0xA001;
            if (!--v11)
              goto LABEL_13;
          }
          v9 >>= 1;
          --v11;
        } while (v11);
      LABEL_13:
        ++v10;
      } while (v10 != &byte_308B7C);
      sprintf(v18, "%04x", v9);
      if (I_strnicmp(v18, cl_cdkeychecksum, 4)) {
        Com_Error(a1, a2, a3, a4, a5, a6, a7, 1, "EXE_ERR_INVALID_CD_KEY");
      } else {
      LABEL_15:
        v12 = clc;
        *(_QWORD *)&v17.type = *(_QWORD *)((char *)clc + 20);
        v17.port = *((_DWORD *)clc + 7);
        if (NET_IsLocalAddress(v17)) {
          *v12 = 4;
          v13 = clc;
        } else {
          v15 = clc;
          *(_DWORD *)clc = 3;
          v13 = v15;
        }
        v14 = cl;
        *((_DWORD *)cl + 1) = 0;
        v14[8] = 0;
        v13[8] = -99999;
        v13[9] = 0;
        v13[1] = g_qport[0];
        UI_CloseAll(a1, a2, a3, a4, a5, a6, a7);
        SCR_UpdateScreen(a1, a2, a3, a4, a5, a6, a7);
      }
    } else {
      Com_Printf("Bad server address\n");
      *(_DWORD *)v8 = 0;
    }
  } else {
    Com_Printf("usage: connect [server]\n");
  }
}

int __cdecl CL_ServerStatus(char *__src, char *__dst, int a3) {
  int v3;           // esi
  char *v4;         // ebx
  int v5;           // edx
  char *v6;         // eax
  int v7;           // eax
  char *v8;         // edx
  int v9;           // ecx
  unsigned int v10; // ecx
  unsigned int v11; // edx
  uint16_t v12;     // ax
  char *v14;        // eax
  int v15;          // ebx
  netadr_t v16;     // [esp+0h] [ebp-B8h]
  netadr_t v17;     // [esp+4h] [ebp-B4h]
  __int64 v18;      // [esp+Ch] [ebp-ACh] OVERLAPPED
  netadr_t v19;     // [esp+Ch] [ebp-ACh]
  int v20;          // [esp+14h] [ebp-A4h] OVERLAPPED
  unsigned int v21; // [esp+2Ch] [ebp-8Ch]
  char *v22;        // [esp+34h] [ebp-84h]
  unsigned int v23; // [esp+3Ah] [ebp-7Eh]
  uint16_t v24;     // [esp+3Eh] [ebp-7Ah]
  _BYTE v25[12];    // [esp+4Ch] [ebp-6Ch] BYREF
  __int64 v26;      // [esp+58h] [ebp-60h]
  int v27;          // [esp+60h] [ebp-58h]
  __int64 v28;      // [esp+64h] [ebp-54h]
  int v29;          // [esp+6Ch] [ebp-4Ch]
  unsigned int v30; // [esp+70h] [ebp-48h]
  unsigned int v31; // [esp+74h] [ebp-44h]
  int v32;          // [esp+78h] [ebp-40h]
  __int64 v33;      // [esp+7Ch] [ebp-3Ch]
  int v34;          // [esp+84h] [ebp-34h]
  __int64 v35;      // [esp+88h] [ebp-30h]
  int v36;          // [esp+90h] [ebp-28h]
  __int64 v37;      // [esp+94h] [ebp-24h]
  int v38;          // [esp+9Ch] [ebp-1Ch]

  if (!__src) {
    v14 = cl_serverStatusList;
    do {
      *((_WORD *)v14 + 4100) = 0;
      *((_DWORD *)v14 + 2055) = 1;
      v14 += 8224;
    } while (&unk_172A7A0 != (_UNKNOWN *)v14);
    return 0;
  }
  if (!NET_StringToAdr(__src, (netadr_t *)v25))
    return 0;
  v24 = *(_WORD *)&v25[8];
  v23 = *(_DWORD *)&v25[4];
  v21 = *(_DWORD *)v25;
  v3 = 0;
  v4 = cl_serverStatusList;
  while (1) {
    v35 = *((_QWORD *)v4 + 1024);
    v36 = *((_DWORD *)v4 + 2050);
    LOWORD(v32) = v24;
    v31 = v23;
    v30 = v21;
    v18 = v35;
    v20 = *((_DWORD *)v4 + 2050);
    *(_QWORD *)&v16.type = __PAIR64__(v23, v21);
    v16.port = v24;
    if (NET_CompareAdr(v16, *(netadr_t *)&v18))
      break;
    ++v3;
    v4 += 8224;
    if (v3 == 16) {
      v5 = 0;
      v6 = cl_serverStatusList;
      do {
        if (*((_DWORD *)v6 + 2055)) {
          v22 = &cl_serverStatusList[8224 * v5];
          goto LABEL_16;
        }
        ++v5;
        v6 += 8224;
      } while (v5 != 16);
      do {
        v3 = 0;
      LABEL_12:;
      } while (v3 == -1);
      v8 = (char *)&unk_170C5C0 + 8224 * v3;
      v9 = v3;
      while (++v9 <= 15) {
        v7 = *((_DWORD *)v8 + 2052);
        v8 += 8224;
        if (dword_170C5B0[2056 * v3] > v7) {
          v3 = v9;
          goto LABEL_12;
        }
      }
      break;
    }
  }
  v22 = &cl_serverStatusList[8224 * v3];
LABEL_16:
  if (!__dst) {
    *((_DWORD *)v22 + 2055) = 1;
    return 0;
  }
  v26 = *((_QWORD *)v22 + 1024);
  v27 = *((_DWORD *)v22 + 2050);
  v28 = *(_QWORD *)v25;
  v29 = *(_DWORD *)&v25[8];
  *(_QWORD *)&v19.type = v26;
  v19.port = v27;
  if (!NET_CompareAdr(*(netadr_t *)v25, v19)) {
    if (*((_DWORD *)v22 + 2055)) {
      *((_QWORD *)v22 + 1024) = *(_QWORD *)v25;
      *((_DWORD *)v22 + 2050) = *(_DWORD *)&v25[8];
      *((_DWORD *)v22 + 2054) = 0;
      *((_DWORD *)v22 + 2053) = 1;
      *((_DWORD *)v22 + 2055) = 0;
      *((_DWORD *)v22 + 2052) = Sys_Milliseconds();
      *((_DWORD *)v22 + 2051) = 0;
      v10 = *(_DWORD *)v25;
      v11 = *(_DWORD *)&v25[4];
      v33 = *(_QWORD *)v25;
      v12 = *(_WORD *)&v25[8];
      v34 = *(_DWORD *)&v25[8];
    LABEL_20:
      *(_QWORD *)&v17.type = __PAIR64__(v11, v10);
      v17.port = v12;
      NET_OutOfBandPrint(NS_CLIENT1, v17, "getstatus");
      return 0;
    }
    return 0;
  }
  if (*((_DWORD *)v22 + 2053)) {
    v15 = *((_DWORD *)v22 + 2052);
    if (v15 < Sys_Milliseconds() - *(_DWORD *)(cl_serverStatusResendTime + 8)) {
      *((_DWORD *)v22 + 2054) = 0;
      *((_DWORD *)v22 + 2053) = 1;
      *((_DWORD *)v22 + 2055) = 0;
      *((_DWORD *)v22 + 2051) = 0;
      *((_DWORD *)v22 + 2052) = Sys_Milliseconds();
      v10 = *(_DWORD *)v25;
      v11 = *(_DWORD *)&v25[4];
      v37 = *(_QWORD *)v25;
      v12 = *(_WORD *)&v25[8];
      v38 = *(_DWORD *)&v25[8];
      goto LABEL_20;
    }
    return 0;
  }
  I_strncpyz(__dst, v22, a3);
  *((_DWORD *)v22 + 2055) = 1;
  *((_DWORD *)v22 + 2052) = 0;
  return 1;
}

void CL_ServerStatus_f(void) {
  char *v0;         // eax
  int v1;           // esi
  char *v2;         // ebx
  int v3;           // edx
  char *v4;         // eax
  int v5;           // ebx
  char *v6;         // edx
  int v7;           // ecx
  int v8;           // eax
  char *v9;         // edx
  netadr_t v10;     // [esp+0h] [ebp-88h]
  netadr_t v11;     // [esp+4h] [ebp-84h]
  __int64 v12;      // [esp+Ch] [ebp-7Ch] OVERLAPPED
  int v13;          // [esp+14h] [ebp-74h] OVERLAPPED
  unsigned int v14; // [esp+2Ch] [ebp-5Ch]
  unsigned int v15; // [esp+3Ah] [ebp-4Eh]
  uint16_t v16;     // [esp+3Eh] [ebp-4Ah]
  __int64 __b;      // [esp+40h] [ebp-48h] BYREF
  int v18;          // [esp+48h] [ebp-40h]
  __int64 v19;      // [esp+4Ch] [ebp-3Ch]
  int v20;          // [esp+54h] [ebp-34h]
  __int64 v21;      // [esp+58h] [ebp-30h]
  int v22;          // [esp+60h] [ebp-28h]
  unsigned int v23; // [esp+64h] [ebp-24h]
  unsigned int v24; // [esp+68h] [ebp-20h]
  int v25;          // [esp+6Ch] [ebp-1Ch]

  Com_Memset(&__b, 0, 0xCu);
  if (Cmd_Argc() == 2) {
    v0 = (char *)Cmd_Argv(1);
  } else {
    if (*(_DWORD *)clc != 8 || *(_DWORD *)((char *)&loc_407A0 + (_DWORD)clc)) {
      Com_Printf("Not connected to a server.\n");
      Com_Printf("Usage: serverstatus [server]\n");
      return;
    }
    v0 = &byte_1220968;
  }
  if (NET_StringToAdr(v0, (netadr_t *)&__b)) {
    v19 = __b;
    v20 = v18;
    *(_QWORD *)&v11.type = __b;
    v11.port = v18;
    NET_OutOfBandPrint(NS_CLIENT1, v11, "getstatus");
    v16 = v18;
    v15 = HIDWORD(__b);
    v14 = __b;
    v1 = 0;
    v2 = cl_serverStatusList;
    do {
      v21 = *((_QWORD *)v2 + 1024);
      v22 = *((_DWORD *)v2 + 2050);
      LOWORD(v25) = v16;
      v24 = v15;
      v23 = v14;
      v12 = v21;
      v13 = *((_DWORD *)v2 + 2050);
      *(_QWORD *)&v10.type = __PAIR64__(v15, v14);
      v10.port = v16;
      if (NET_CompareAdr(v10, *(netadr_t *)&v12)) {
        v9 = &cl_serverStatusList[8224 * v1];
        goto LABEL_22;
      }
      ++v1;
      v2 += 8224;
    } while (v1 != 16);
    v3 = 0;
    v4 = cl_serverStatusList;
    do {
      if (*((_DWORD *)v4 + 2055)) {
        v9 = &cl_serverStatusList[8224 * v3];
        goto LABEL_22;
      }
      ++v3;
      v4 += 8224;
    } while (v3 != 16);
    v5 = 0;
  LABEL_15:
    while (v5 == -1)
      v5 = 0;
    v6 = (char *)&unk_170C5C0 + 8224 * v5;
    v7 = v5;
    while (++v7 <= 15) {
      v8 = *((_DWORD *)v6 + 2052);
      v6 += 8224;
      if (dword_170C5B0[2056 * v5] > v8) {
        v5 = v7;
        goto LABEL_15;
      }
    }
    v9 = &cl_serverStatusList[8224 * v5];
  LABEL_22:
    *((_QWORD *)v9 + 1024) = __b;
    *((_DWORD *)v9 + 2050) = v18;
    *((_DWORD *)v9 + 2054) = 1;
    *((_DWORD *)v9 + 2053) = 1;
  }
}

int __cdecl Menu_HandleMouseMove(displayContextDef_s *a1, menuDef_t *a2,
                                 __int64 a3) {
  uint32_t itemCount; // edx
  int v5;             // esi
  int32_t items;      // eax
  int v7;             // edx
  int v8;             // edx
  int v9;             // ebx
  int v10;            // eax
  int v11;            // eax
  int v12;            // ebx
  float v13;          // xmm0_4
  int v14;            // eax
  int v15;            // esi
  menuDef_t *k;       // edi
  int v17;            // edx
  windowDef_t *v18;   // eax
  uint32_t v19;       // [esp+2Ch] [ebp-4Ch]
  int i;              // [esp+30h] [ebp-48h]
  int v21;            // [esp+34h] [ebp-44h]
  int v22;            // [esp+38h] [ebp-40h]
  int j;              // [esp+3Ch] [ebp-3Ch]
  float v24;          // [esp+40h] [ebp-38h] BYREF
  float v25;          // [esp+44h] [ebp-34h] BYREF
  float v26;          // [esp+48h] [ebp-30h] BYREF
  float v27[3];       // [esp+4Ch] [ebp-2Ch] BYREF
  float v28[8];       // [esp+58h] [ebp-20h] BYREF

  if (!a2 || (*(_DWORD *)a2->window.dynamicFlags & 0x4004) == 0 ||
      itemCapture || g_waitingForKey || g_editingField)
    return 0;
  v21 = 0;
  v22 = 0;
  for (i = 0; i != 2; ++i) {
    itemCount = a2->itemCount;
    v19 = itemCount;
    if ((int)(itemCount - 1) >= 0) {
      v5 = 4 * (itemCount - 1);
      for (j = 0; j != v19; ++j) {
        items = a2->items;
        v7 = *(_DWORD *)(v5 + items);
        if ((*(_DWORD *)(v7 + 232) & 0x4004) != 0) {
          if ((*(_BYTE *)(v7 + 720) & 3) != 0) {
            if (!Item_EnableShowViaDvar((const itemDef_s *)v7, 1))
              goto LABEL_38;
            items = a2->items;
          }
          v8 = *(_DWORD *)(v5 + items);
          if ((*(_BYTE *)(v8 + 720) & 0xC) == 0) {
            v9 = *(_DWORD *)(v5 + items);
            goto LABEL_14;
          }
          if (Item_EnableShowViaDvar((const itemDef_s *)v8, 4)) {
            v9 = *(_DWORD *)(v5 + a2->items);
          LABEL_14:
            v10 = *(_DWORD *)(v9 + 232);
            if ((v10 & 4) != 0 && (v10 & 2) != 0) {
              v11 = v22;
              if (!v22)
                v11 = v9;
              v22 = v11;
            }
            v24 = *(float *)v9;
            v25 = *(float *)(v9 + 4);
            v26 = *(float *)(v9 + 8);
            v27[0] = *(float *)(v9 + 12);
            *(_QWORD *)v28 = __PAIR64__(a3, HIDWORD(a3));
            CalcScreenX(&v28[1], 4);
            CalcScreenY(v28, 4);
            CalcScreenPlacement(&v24, &v25, &v26, v27, *(_DWORD *)(v9 + 16),
                                *(_DWORD *)(v9 + 20));
            if (v28[1] < v24 || (float)(v24 + v26) < v28[1] || v28[0] < v25 ||
                (float)(v25 + v27[0]) < v28[0]) {
              if ((*(_BYTE *)(*(_DWORD *)(v5 + a2->items) + 232) & 1) != 0) {
                Item_MouseLeave(a1, *(windowDef_t **)(v5 + a2->items));
                v18 = *(windowDef_t **)(v5 + a2->items);
                if (v18)
                  Window_RemoveDynamicFlags(v18, 1);
              }
            } else if (i == 1) {
              v12 = *(_DWORD *)(v5 + a2->items);
              if (*(_DWORD *)(v12 + 624) || !*(_DWORD *)(v12 + 660))
                goto LABEL_63;
              memset(&Item_CorrectedTextRect(itemDef_s *)::rect, 0, 0x18u);
              Item_CorrectedTextRect(itemDef_s *)::rect = *(float *)(v12 + 528);
              dword_F00748 = *(_DWORD *)(v12 + 532);
              flt_F0074C = *(float *)(v12 + 536);
              flt_F00750 = *(float *)(v12 + 540);
              dword_F00754 = *(_DWORD *)(v12 + 544);
              dword_F00758 = *(_DWORD *)(v12 + 548);
              if (flt_F0074C == 0.0) {
                v13 = *(float *)&dword_F00748;
              } else {
                v13 = *(float *)&dword_F00748 - flt_F00750;
                *(float *)&dword_F00748 = *(float *)&dword_F00748 - flt_F00750;
              }
              v24 = Item_CorrectedTextRect(itemDef_s *)::rect;
              v25 = v13;
              v26 = flt_F0074C;
              v27[0] = flt_F00750;
              *(_QWORD *)v28 = a3;
              CalcScreenX(v28, 4);
              CalcScreenY(&v28[1], 4);
              CalcScreenPlacement(&v24, &v25, &v26, v27, dword_F00754,
                                  dword_F00758);
              if (v28[0] >= v24 && (float)(v24 + v26) >= v28[0] &&
                  v28[1] >= v25 && (float)(v25 + v27[0]) >= v28[1]) {
              LABEL_63:
                v14 = *(_DWORD *)(v12 + 232);
                if ((v14 & 4) != 0 && (v14 & 0x10) == 0) {
                  Item_MouseEnter(a1, (itemDef_s *)v12, a3);
                  if (!v21) {
                    v21 = Item_SetFocus(a1, (itemDef_s *)v12, *(float *)&a3,
                                        *((float *)&a3 + 1));
                    if (v21)
                      v22 = v12;
                  }
                }
              }
            }
          }
        }
      LABEL_38:
        v5 -= 4;
      }
    }
  }
  if (v21)
    return 1;
  if (v22) {
    v24 = *(float *)v22;
    v25 = *(float *)(v22 + 4);
    v26 = *(float *)(v22 + 8);
    v27[0] = *(float *)(v22 + 12);
    *(_QWORD *)v28 = a3;
    CalcScreenX(v28, 4);
    CalcScreenY(&v28[1], 4);
    CalcScreenPlacement(&v24, &v25, &v26, v27, *(_DWORD *)(v22 + 16),
                        *(_DWORD *)(v22 + 20));
    if ((v28[0] < v24 || (float)(v24 + v26) < v28[0] || v28[1] < v25 ||
         (float)(v25 + v27[0]) < v28[1]) &&
        (int)a2->itemCount > 0) {
      v15 = 0;
      for (k = a2;; k = a2) {
        Window_RemoveDynamicFlags(*(windowDef_t **)(4 * v15 + k->items), 2);
        v17 = *(_DWORD *)(4 * v15 + k->items);
        if (*(_DWORD *)(v17 + 700))
          Item_RunScript(a1, (itemDef_s *)v17, *(const char **)(v17 + 700));
        if (++v15 >= (signed int)a2->itemCount)
          break;
      }
    }
  }
  return 0;
}

int __cdecl Display_MouseMove(displayContextDef_s *a1, menuDef_t *a2, int a3,
                              int a4) {
  menuDef_t *v4;          // ebx
  signed int v6;          // edi
  uint8_t *v7;            // edx
  int v8;                 // ecx
  int v9;                 // eax
  menuDef_t **v10;        // ebx
  int v11;                // esi
  uint32_t openMenuCount; // edi
  __int64 v13;            // [esp+8h] [ebp-50h]
  rectDef_s v14;          // [esp+28h] [ebp-30h] BYREF

  v4 = a2;
  if (a2) {
    v14.x = *(_DWORD *)a2->window.rect;
    v14.y = *(_DWORD *)&a2->window.rect[4];
    v14.w = *(_DWORD *)&a2->window.rect[8];
    v14.h = *(_DWORD *)&a2->window.rect[12];
    v14.horzAlign = *(_DWORD *)&a2->window.rect[16];
    v14.vertAlign = *(_DWORD *)&a2->window.rect[20];
    *(float *)&v14.x = (float)a3 + *(float *)&v14.x;
    *(float *)&v14.y = (float)a4 + *(float *)&v14.y;
    Window_SetRect(&a2->window, &v14);
    Menu_UpdatePosition(a2);
  } else {
    v6 = a1->openMenuCount - 1;
    if (v6 >= 0) {
      v7 = &a1->menuStack[4 * v6];
      while (1) {
        v8 = *(_DWORD *)v7;
        v9 = *(_DWORD *)(*(_DWORD *)v7 + 232);
        if ((v9 & 4) != 0 && (v9 & 2) != 0)
          break;
        v4 = (menuDef_t *)((char *)v4 + 1);
        v7 -= 4;
        if (v4 == (menuDef_t *)a1->openMenuCount)
          goto LABEL_10;
      }
      if (v8 && (*(_BYTE *)(v8 + 231) & 1) != 0) {
        *((float *)&v13 + 1) = (float)a4;
        *(float *)&v13 = (float)a3;
        Menu_HandleMouseMove(a1, (menuDef_t *)v8, v13);
        return 1;
      }
    LABEL_10:
      v10 = (menuDef_t **)&a1->menuStack[4 * v6];
      v11 = 0;
      openMenuCount = a1->openMenuCount;
      while (
          !Menu_HandleMouseMove(a1, *v10, __SPAIR64__((float)a4, (float)a3))) {
        ++v11;
        --v10;
        if (v11 == openMenuCount)
          return 1;
      }
    }
  }
  return 1;
}

void __cdecl Menus_HandleOOBClick(displayContextDef_s *a1, menuDef_t *a2,
                                  int a3, int a4) {
  displayContextDef_s *v4;  // edx
  signed int v5;            // ecx
  uint8_t *v6;              // esi
  float cursorx;            // xmm0_4
  _DWORD *v8;               // ebx
  _DWORD *v9;               // edi
  int v10;                  // edx
  float v11;                // xmm0_4
  uint32_t openMenuCount;   // edi
  windowDef_t **v13;        // esi
  int v14;                  // ebx
  displayContextDef_s *v15; // eax
  int menuCount;            // esi
  uint8_t *v17;             // eax
  _DWORD *v18;              // ebx
  int j;                    // esi
  int v20;                  // eax
  int v21;                  // edx
  int v22;                  // esi
  int v23;                  // eax
  int v24;                  // edi
  displayContextDef_s *v25; // edx
  int v26;                  // ebx
  int i;                    // ecx
  uint32_t v28;             // [esp+24h] [ebp-344h]
  int v29;                  // [esp+34h] [ebp-334h]
  __int64 v30;              // [esp+38h] [ebp-330h]
  int v31;                  // [esp+40h] [ebp-328h]
  int v32;                  // [esp+44h] [ebp-324h]
  uint8_t *v33;             // [esp+48h] [ebp-320h]
  signed int v34;           // [esp+4Ch] [ebp-31Ch]
  itemDef_s v35;            // [esp+54h] [ebp-314h] BYREF
  float v36[8];             // [esp+348h] [ebp-20h] BYREF

  if (!a2)
    return;
  if (a4 && (a2->window.staticFlags & 0x2000000) != 0) {
    if ((a2->window.dynamicFlags[0] & 4) != 0 && a2->onClose) {
      v35.parent = (int32_t)a2;
      Item_RunScript(a1, &v35, (const char *)a2->onClose);
    }
    Window_RemoveDynamicFlags(&a2->window, 6);
    v4 = a1;
    v5 = a1->openMenuCount - 1;
    if (v5 < 0)
      goto LABEL_65;
  } else {
    v4 = a1;
    v5 = a1->openMenuCount - 1;
    if (v5 < 0) {
    LABEL_65:
      v15 = v4;
      goto LABEL_35;
    }
  }
  v6 = &v4->menuStack[4 * v5];
  v34 = v5;
  while (1) {
    *(float *)&v30 = (float)a1->cursory;
    cursorx = (float)a1->cursorx;
    *((float *)&v30 + 1) = cursorx;
    v8 = *(_DWORD **)v6;
    if (*(_DWORD *)v6) {
      if ((v8[58] & 0x4004) != 0) {
        *(_DWORD *)v35.window = *v8;
        *(_DWORD *)&v35.window[4] = v8[1];
        *(_DWORD *)&v35.window[8] = v8[2];
        *(_DWORD *)&v35.window[12] = v8[3];
        *(_QWORD *)v36 = __PAIR64__(v30, LODWORD(cursorx));
        CalcScreenX(v36, 4);
        CalcScreenY(&v36[1], 4);
        CalcScreenPlacement((float *)v35.window, (float *)&v35.window[4],
                            (float *)&v35.window[8], (float *)&v35.window[12],
                            v8[4], v8[5]);
        if (v36[0] >= *(float *)v35.window &&
            (float)(*(float *)v35.window + *(float *)&v35.window[8]) >=
                v36[0] &&
            v36[1] >= *(float *)&v35.window[4] &&
            (float)(*(float *)&v35.window[4] + *(float *)&v35.window[12]) >=
                v36[1] &&
            (int)v8[134] > 0) {
          break;
        }
      }
    }
  LABEL_5:
    --v34;
    v6 -= 4;
    if (v34 == -1) {
      v15 = a1;
      goto LABEL_35;
    }
  }
  v29 = 0;
  while (1) {
    v9 = *(_DWORD **)(4 * v29 + v8[159]);
    if ((v9[58] & 0x4004) != 0 && (v9[57] & 0x100000) == 0) {
      *(_DWORD *)v35.window = *v9;
      *(_DWORD *)&v35.window[4] = v9[1];
      *(_DWORD *)&v35.window[8] = v9[2];
      *(_DWORD *)&v35.window[12] = v9[3];
      *(_QWORD *)v36 = v30;
      CalcScreenX(&v36[1], 4);
      CalcScreenY(v36, 4);
      CalcScreenPlacement((float *)v35.window, (float *)&v35.window[4],
                          (float *)&v35.window[8], (float *)&v35.window[12],
                          v9[4], v9[5]);
      if (v36[1] >= *(float *)v35.window &&
          (float)(*(float *)v35.window + *(float *)&v35.window[8]) >= v36[1] &&
          v36[0] >= *(float *)&v35.window[4] &&
          (float)(*(float *)&v35.window[4] + *(float *)&v35.window[12]) >=
              v36[0]) {
        v10 = *(_DWORD *)(4 * v29 + v8[159]);
        if (*(_DWORD *)(v10 + 624) || !*(_DWORD *)(v10 + 660))
          break;
        memset(&Item_CorrectedTextRect(itemDef_s *)::rect, 0, 0x18u);
        Item_CorrectedTextRect(itemDef_s *)::rect = *(float *)(v10 + 528);
        dword_F00748 = *(_DWORD *)(v10 + 532);
        flt_F0074C = *(float *)(v10 + 536);
        flt_F00750 = *(float *)(v10 + 540);
        dword_F00754 = *(_DWORD *)(v10 + 544);
        dword_F00758 = *(_DWORD *)(v10 + 548);
        if (flt_F0074C == 0.0) {
          v11 = *(float *)&dword_F00748;
        } else {
          v11 = *(float *)&dword_F00748 - flt_F00750;
          *(float *)&dword_F00748 = *(float *)&dword_F00748 - flt_F00750;
        }
        *(float *)v35.window = Item_CorrectedTextRect(itemDef_s *)::rect;
        *(float *)&v35.window[4] = v11;
        *(float *)&v35.window[8] = flt_F0074C;
        *(float *)&v35.window[12] = flt_F00750;
        *(_QWORD *)v36 = __PAIR64__(v30, HIDWORD(v30));
        CalcScreenX(v36, 4);
        CalcScreenY(&v36[1], 4);
        CalcScreenPlacement((float *)v35.window, (float *)&v35.window[4],
                            (float *)&v35.window[8], (float *)&v35.window[12],
                            dword_F00754, dword_F00758);
        if (v36[0] >= *(float *)v35.window &&
            (float)(*(float *)v35.window + *(float *)&v35.window[8]) >=
                v36[0] &&
            v36[1] >= *(float *)&v35.window[4] &&
            (float)(*(float *)&v35.window[4] + *(float *)&v35.window[12]) >=
                v36[1]) {
          break;
        }
      }
    }
    if (v8[134] <= ++v29)
      goto LABEL_5;
  }
  openMenuCount = a1->openMenuCount;
  if ((int)(openMenuCount - 1) >= 0) {
    v13 = (windowDef_t **)&a1->Menus[4 * openMenuCount + 512];
    v14 = 0;
    do {
      Window_RemoveDynamicFlags(*v13, 2);
      ++v14;
      --v13;
    } while (openMenuCount != v14);
  }
  Window_AddDynamicFlags(*(windowDef_t **)&a1->menuStack[4 * v34], 6);
  Display_MouseMove(a1, 0, a1->cursorx, a1->cursory);
  Menu_HandleKey(a1, *(menuDef_t **)&a1->menuStack[4 * v34], a3, a4);
  v15 = a1;
LABEL_35:
  menuCount = v15->menuCount;
  if (menuCount <= 0)
    goto LABEL_36;
  v25 = v15;
  v26 = 0;
  for (i = 0; i != menuCount; ++i) {
    v26 -= ((*(_DWORD *)(*(_DWORD *)v25->Menus + 232) & 0x4004) == 0) - 1;
    v25 = (displayContextDef_s *)((char *)v25 + 4);
  }
  if (!v26)
  LABEL_36:
    UI_Pause(0);
  v28 = a1->openMenuCount;
  if ((int)(v28 - 1) >= 0) {
    v17 = &a1->Menus[4 * v28 + 512];
    v33 = v17;
    v32 = 0;
    while (1) {
      v18 = *(_DWORD **)v17;
      if (*(_DWORD *)v17) {
        if (v18[52] == 5 && (int)v18[51] >= 0) {
          CIN_StopCinematic(v18[51]);
          v18[51] = -1;
        }
        if ((int)v18[134] > 0)
          break;
      }
    LABEL_51:
      ++v32;
      v33 -= 4;
      if (v32 == v28)
        return;
      v17 = v33;
    }
    v31 = 0;
    for (j = 0;; j = v21) {
      v22 = 4 * j;
      v23 = v18[159];
      v24 = *(_DWORD *)(v23 + v22);
      if (*(_DWORD *)(v24 + 208) != 5)
        break;
      if (*(int *)(v24 + 204) < 0) {
        v20 = *(_DWORD *)(v23 + v22);
      LABEL_44:
        if (*(_DWORD *)(v20 + 624) != 8)
          goto LABEL_45;
        goto LABEL_50;
      }
      CIN_StopCinematic(*(_DWORD *)(v24 + 204));
      *(_DWORD *)(v24 + 204) = -1;
      v20 = *(_DWORD *)(v18[159] + v22);
      if (*(_DWORD *)(v20 + 624) != 8) {
      LABEL_45:
        v21 = ++v31;
        if (v31 >= v18[134])
          goto LABEL_51;
        continue;
      }
    LABEL_50:
      CIN_StopCinematic(-*(_DWORD *)(v20 + 216));
      v21 = ++v31;
      if (v31 >= v18[134])
        goto LABEL_51;
    }
    v20 = *(_DWORD *)(v23 + v22);
    goto LABEL_44;
  }
}

void __cdecl CL_SetExpectedHunkUsage(char *a1) {
  int v1;          // eax
  unsigned int v2; // esi
  size_t v3;       // ebx
  void *v4;        // edi
  char *v5;        // eax
  char *v6;        // eax
  int v7;          // eax
  char *v8;        // [esp+18h] [ebp-20h] BYREF
  int v9[7];       // [esp+1Ch] [ebp-1Ch] BYREF

  v1 = FS_FOpenFileByMode("hunkusage.dat", v9, FS_READ);
  v2 = v1;
  if (v1 >= 0) {
    v3 = v1 + 1;
    v4 = Z_MallocInternal(v1 + 1);
    memset(v4, 0, v3);
    FS_Read((char *)v4, v2, v9[0]);
    FS_FCloseFile(v9[0]);
    v8 = (char *)v4;
    while (1) {
      v5 = Com_Parse(&v8);
      if (!v5 || !*v5)
        break;
      if (!I_stricmp(v5, a1)) {
        v6 = Com_Parse(&v8);
        if (v6) {
          if (*v6) {
            v7 = atoi(v6);
            Dvar_SetInt(com_expectedHunkUsage, v7);
            Z_FreeInternal(v4);
            return;
          }
        }
      }
    }
    Z_FreeInternal(v4);
  }
  Dvar_SetInt(com_expectedHunkUsage, 0);
}

int CL_Material_Duplicate() { return unk_121C7DC(); }

int CL_DuplicateFont() { return unk_121C7E0(); }

int CL_DrawQuadPic() { return (*(int (**)(void)) & algn_121C738[8])(); }

int CL_MarkFragments() { return (*(int (**)(void)) & algn_121C738[56])(); }

void __usercall CL_LoadSoundAliases(long double a1 @<st0>, float a2 @<xmm0>,
                                    __m128 a3 @<xmm1>, __m128 a4 @<xmm2>,
                                    __m128 a5 @<xmm3>, __m128 a6 @<xmm4>,
                                    __m128 a7 @<xmm6>, char *__src) {
  Com_LoadSoundAliases(a1, a2, a3, a4, a5, a6, a7, __src, "all_mp",
                       SASYS_CGAME);
}

void __usercall CL_UpdateLevelHunkUsage(long double a1 @<st0>, float a2 @<xmm0>,
                                        __m128 a3 @<xmm1>, __m128 a4 @<xmm2>,
                                        __m128 a5 @<xmm3>, __m128 a6 @<xmm4>,
                                        __m128 a7 @<xmm6>) {
  int v7;           // eax
  unsigned int v8;  // edi
  size_t v9;        // ebx
  _BYTE *v10;       // esi
  char *v11;        // eax
  char *v12;        // edi
  char *v13;        // eax
  char *v14;        // eax
  unsigned int v15; // kr04_4
  char *v16;        // eax
  char *v17;        // eax
  void *v18;        // [esp+28h] [ebp-130h]
  int v19;          // [esp+2Ch] [ebp-12Ch]
  char __str[256];  // [esp+38h] [ebp-120h] BYREF
  char *v21;        // [esp+138h] [ebp-20h] BYREF
  char v22[4];      // [esp+13Ch] [ebp-1Ch] BYREF

  v19 = Hunk_Used();
  v7 = FS_FOpenFileByMode("hunkusage.dat", (int *)v22, FS_READ);
  v8 = v7;
  if (v7 >= 0) {
    v9 = v7 + 1;
    v18 = Z_MallocInternal(v7 + 1);
    memset(v18, 0, v9);
    v10 = Z_MallocInternal(v9);
    memset(v10, 0, v9);
    FS_Read((char *)v18, v8, *(int *)v22);
    FS_FCloseFile(*(int *)v22);
    v21 = (char *)v18;
    *v10 = 0;
  LABEL_3:
    v11 = Com_Parse(&v21);
    v12 = v11;
    if (v11) {
      while (*v11) {
        if (!I_stricmp(v12, (char *)cl + 34192)) {
          v13 = Com_Parse(&v21);
          if (v13 && *v13 && v19 == atoi(v13)) {
            Z_FreeInternal(v18);
            Z_FreeInternal(v10);
            return;
          }
          goto LABEL_3;
        }
        I_strncat(v10, v9, v12);
        I_strncat(v10, v9, " ");
        v14 = Com_Parse(&v21);
        if (v14 && *v14) {
          I_strncat(v10, v9, v14);
          I_strncat(v10, v9, "\n");
          goto LABEL_3;
        }
        Com_Error(a1, a2, a3, a4, a5, a6, a7, 1, "EXE_ERR_HUNGUSAGE_CORRUPT");
        v11 = Com_Parse(&v21);
        v12 = v11;
        if (!v11)
          break;
      }
    }
    *(_DWORD *)v22 = FS_FOpenFileWrite("hunkusage.dat");
    if (!*(_DWORD *)v22) {
      v17 = va("EXE_ERR_CANT_CREATE\x15%s", "hunkusage.dat");
      Com_Error(a1, a2, a3, a4, a5, a6, a7, 1, v17);
    }
    v15 = strlen(v10) + 1;
    if (v15 - 1 != FS_Write(v10, v15 - 1, *(int *)v22)) {
      v16 = va("EXE_ERR_CANT_WRITE\x15%s", "hunkusage.dat");
      Com_Error(a1, a2, a3, a4, a5, a6, a7, 1, v16);
    }
    FS_FCloseFile(*(int *)v22);
    Z_FreeInternal(v18);
    Z_FreeInternal(v10);
  }
  FS_FOpenFileByMode("hunkusage.dat", (int *)v22, FS_APPEND);
  if (!*(_DWORD *)v22)
    Com_Error(a1, a2, a3, a4, a5, a6, a7, 1, "EXE_ERR_HUNKUSAGE_CANT_WRITE");
  Com_sprintf(__str, 0x100u, "%s %i\n", (const char *)cl + 34192, v19);
  FS_Write(__str, strlen(__str), *(int *)v22);
  FS_FCloseFile(*(int *)v22);
  if (FS_FOpenFileByMode("hunkusage.dat", (int *)v22, FS_READ) >= 0)
    FS_FCloseFile(*(int *)v22);
}

void *__cdecl SV_AuthorizeRequest(netadr_t a1, int a2) {
  void *result;         // eax
  dvar_s *v3;           // eax
  const char *integer;  // eax
  char *v5;             // eax
  unsigned __int8 Bool; // al
  char *v7;             // eax
  __int128 v8;          // [esp+0h] [ebp-468h]
  char __dst[1024];     // [esp+38h] [ebp-430h] BYREF
  int32_t type;         // [esp+438h] [ebp-30h]
  int32_t ip;           // [esp+43Ch] [ebp-2Ch]
  int v12;              // [esp+440h] [ebp-28h]
  int32_t v13;          // [esp+444h] [ebp-24h]
  int32_t v14;          // [esp+448h] [ebp-20h]
  int v15;              // [esp+44Ch] [ebp-1Ch]

  result = &svs;
  if (stru_170A4E8.type != 1) {
    __dst[0] = 0;
    v3 = Dvar_RegisterString("fs_game", (DvarValue)&inData, 0x101Cu);
    if (v3) {
      integer = (const char *)v3->current.integer;
      if (*integer)
        strcpy(__dst, integer);
    }
    LOWORD(v12) = a1.port;
    type = a1.type;
    ip = a1.ip;
    *(_QWORD *)&v8 = *(_QWORD *)&a1.type;
    DWORD2(v8) = v12;
    v5 = NET_AdrToString(v8);
    Com_DPrintf("sending getIpAuthorize for %s\n", v5);
    Bool = Dvar_GetBool("sv_allowAnonymous");
    v7 = va("getIpAuthorize %i %i.%i.%i.%i %s %i", a2, LOBYTE(a1.ip),
            BYTE1(a1.ip), BYTE2(a1.ip), HIBYTE(a1.ip), __dst, Bool);
    v13 = stru_170A4E8.type;
    v14 = stru_170A4E8.ip;
    v15 = *(_DWORD *)&stru_170A4E8.port;
    return (void *)NET_OutOfBandPrint(NS_SERVER, stru_170A4E8, v7);
  }
  return result;
}

void __cdecl SV_AuthorizeIpPacket(__int128 a1) {
  const char *v1;   // eax
  int v2;           // eax
  int v3;           // esi
  _DWORD *i;        // edx
  char *v5;         // ebx
  char *v6;         // edi
  char *v7;         // eax
  unsigned int v8;  // esi
  unsigned int v9;  // ecx
  int v10;          // edx
  unsigned int v11; // ecx
  unsigned int v12; // edx
  int v13;          // eax
  const char *v14;  // eax
  int v15;          // eax
  int v16;          // ebx
  char *v17;        // eax
  _DWORD *v18;      // ebx
  _DWORD *v19;      // ecx
  unsigned int v20; // edx
  unsigned int v21; // ecx
  int v22;          // eax
  netadr_t v23;     // [esp+4h] [ebp-514h]
  netadr_t v24;     // [esp+4h] [ebp-514h]
  netadr_t v25;     // [esp+4h] [ebp-514h]
  netadr_t v26;     // [esp+4h] [ebp-514h]
  netadr_t v27;     // [esp+4h] [ebp-514h]
  netadr_t v28;     // [esp+4h] [ebp-514h]
  const char *v29;  // [esp+10h] [ebp-508h]
  char *v30;        // [esp+10h] [ebp-508h]
  char *v31;        // [esp+28h] [ebp-4F0h]
  int v32;          // [esp+2Ch] [ebp-4ECh]
  char __src[1024]; // [esp+4Ch] [ebp-4CCh] BYREF
  __int64 v34;      // [esp+44Ch] [ebp-CCh]
  int v35;          // [esp+454h] [ebp-C4h]
  __int64 v36;      // [esp+458h] [ebp-C0h]
  int v37;          // [esp+460h] [ebp-B8h]
  unsigned int v38; // [esp+464h] [ebp-B4h]
  unsigned int v39; // [esp+468h] [ebp-B0h]
  int v40;          // [esp+46Ch] [ebp-ACh]
  __int64 v41;      // [esp+470h] [ebp-A8h]
  __int64 v42;      // [esp+47Ch] [ebp-9Ch]
  __int64 v43;      // [esp+488h] [ebp-90h]
  unsigned int v44; // [esp+494h] [ebp-84h]
  unsigned int v45; // [esp+498h] [ebp-80h]
  int v46;          // [esp+49Ch] [ebp-7Ch]
  unsigned int v47; // [esp+4A0h] [ebp-78h]
  unsigned int v48; // [esp+4A4h] [ebp-74h]
  int v49;          // [esp+4A8h] [ebp-70h]
  unsigned int v50; // [esp+4ACh] [ebp-6Ch]
  unsigned int v51; // [esp+4B0h] [ebp-68h]
  int v52;          // [esp+4B4h] [ebp-64h]
  unsigned int v53; // [esp+4B8h] [ebp-60h]
  unsigned int v54; // [esp+4BCh] [ebp-5Ch]
  int v55;          // [esp+4C0h] [ebp-58h]
  unsigned int v56; // [esp+4C4h] [ebp-54h]
  unsigned int v57; // [esp+4C8h] [ebp-50h]
  int v58;          // [esp+4CCh] [ebp-4Ch]
  unsigned int v59; // [esp+4D0h] [ebp-48h]
  unsigned int v60; // [esp+4D4h] [ebp-44h]
  int v61;          // [esp+4D8h] [ebp-40h]
  unsigned int v62; // [esp+4DCh] [ebp-3Ch]
  unsigned int v63; // [esp+4E0h] [ebp-38h]
  int v64;          // [esp+4E4h] [ebp-34h]
  unsigned int v65; // [esp+4E8h] [ebp-30h]
  unsigned int v66; // [esp+4ECh] [ebp-2Ch]
  int v67;          // [esp+4F0h] [ebp-28h]
  unsigned int v68; // [esp+4F4h] [ebp-24h]
  unsigned int v69; // [esp+4F8h] [ebp-20h]
  int v70;          // [esp+4FCh] [ebp-1Ch]

  v34 = *(_QWORD *)&stru_170A4E8.type;
  v35 = *(_DWORD *)&stru_170A4E8.port;
  LOWORD(v37) = WORD4(a1);
  v36 = a1;
  if (!NET_CompareBaseAdr((netadr_t)a1, stru_170A4E8)) {
    Com_Printf("SV_AuthorizeIpPacket: not from authorize server\n");
    return;
  }
  v1 = (const char *)SV_Cmd_Argv(1);
  v2 = atoi(v1);
  v3 = 0;
  for (i = &svs; v2 != i[26]; i += 10) {
    if (++v3 == 1024) {
      Com_Printf("SV_AuthorizeIpPacket: challenge not found\n");
      return;
    }
  }
  v32 = 40 * v3;
  v31 = (char *)&svs + 40 * v3;
  *((_DWORD *)v31 + 28) = dword_1700484;
  v5 = (char *)SV_Cmd_Argv(2);
  v6 = (char *)SV_Cmd_Argv(3);
  if (!I_stricmp(v5, "demo")) {
    if (!(unsigned __int8)Dvar_GetBool("fs_restrict")) {
      v41 = *(_QWORD *)(v31 + 92);
      *(_QWORD *)&v24.type = v41;
      v24.port = *((_DWORD *)v31 + 25);
      NET_OutOfBandPrint(NS_SERVER, v24, "error\nEXE_ERR_NOT_A_DEMO_SERVER");
      memset((char *)&svs + v32 + 92, 0, 0x28u);
      return;
    }
    v7 = va("challengeResponse %i", *((_DWORD *)v31 + 26));
    v8 = *((_DWORD *)v31 + 23);
    v38 = v8;
    v9 = *((_DWORD *)v31 + 24);
    v39 = v9;
    v10 = *((_DWORD *)v31 + 25);
    v40 = v10;
  LABEL_10:
    *(_QWORD *)&v23.type = __PAIR64__(v9, v8);
    v23.port = v10;
    NET_OutOfBandPrint(NS_SERVER, v23, v7);
    return;
  }
  if (I_stricmp(v5, "accept")) {
    if (I_stricmp(v5, "deny")) {
      if (!v6 || !*v6) {
        v11 = *((_DWORD *)v31 + 23);
        v65 = v11;
        v12 = *((_DWORD *)v31 + 24);
        v66 = v12;
        v13 = *((_DWORD *)v31 + 25);
        v67 = v13;
        v29 = "error\nEXE_ERR_BAD_CDKEY";
        goto LABEL_24;
      }
      sprintf(__src, "error\n%s", v6);
      v20 = *((_DWORD *)v31 + 23);
      v68 = v20;
      v21 = *((_DWORD *)v31 + 24);
      v69 = v21;
      v22 = *((_DWORD *)v31 + 25);
      v70 = v22;
      v30 = __src;
    } else {
      if (!v6 || !*v6) {
        v11 = *((_DWORD *)v31 + 23);
        v47 = v11;
        v12 = *((_DWORD *)v31 + 24);
        v48 = v12;
        v13 = *((_DWORD *)v31 + 25);
        v49 = v13;
        v29 = "error\nEXE_ERR_CDKEY_IN_USE";
      LABEL_24:
        *(_QWORD *)&v25.type = __PAIR64__(v12, v11);
        v25.port = v13;
        NET_OutOfBandPrint(NS_SERVER, v25, v29);
      LABEL_25:
        memset((char *)&svs + 40 * v3 + 92, 0, 0x28u);
        return;
      }
      if (I_stricmp(v6, "CLIENT_UNKNOWN_TO_AUTH")) {
        if (I_stricmp(v6, "BAD_CDKEY")) {
          if (I_stricmp(v6, "INVALID_CDKEY")) {
            if (I_stricmp(v6, "BANNED_CDKEY")) {
              v20 = *((_DWORD *)v31 + 23);
              v62 = v20;
              v21 = *((_DWORD *)v31 + 24);
              v63 = v21;
              v22 = *((_DWORD *)v31 + 25);
              v64 = v22;
            } else {
              v20 = *((_DWORD *)v31 + 23);
              v59 = v20;
              v21 = *((_DWORD *)v31 + 24);
              v60 = v21;
              v22 = *((_DWORD *)v31 + 25);
              v61 = v22;
            }
            v30 = "error\nEXE_ERR_BAD_CDKEY";
          } else {
            v20 = *((_DWORD *)v31 + 23);
            v56 = v20;
            v21 = *((_DWORD *)v31 + 24);
            v57 = v21;
            v22 = *((_DWORD *)v31 + 25);
            v58 = v22;
            v30 = "error\nEXE_ERR_CDKEY_IN_USE";
          }
        } else {
          v20 = *((_DWORD *)v31 + 23);
          v53 = v20;
          v21 = *((_DWORD *)v31 + 24);
          v54 = v21;
          v22 = *((_DWORD *)v31 + 25);
          v55 = v22;
          v30 = "needcdkey";
        }
      } else {
        v20 = *((_DWORD *)v31 + 23);
        v50 = v20;
        v21 = *((_DWORD *)v31 + 24);
        v51 = v21;
        v22 = *((_DWORD *)v31 + 25);
        v52 = v22;
        v30 = "needcdkey";
      }
    }
    *(_QWORD *)&v27.type = __PAIR64__(v21, v20);
    v27.port = v22;
    NET_OutOfBandPrint(NS_SERVER, v27, v30);
    goto LABEL_25;
  }
  v14 = (const char *)SV_Cmd_Argv(4);
  v15 = atoi(v14);
  *((_DWORD *)v31 + 32) = v15;
  if (SV_IsBannedGuid(v15)) {
    Com_Printf("rejected connection from permanently banned GUID %i\n",
               *((_DWORD *)v31 + 32));
    v42 = *(_QWORD *)(v31 + 92);
    *(_QWORD *)&v28.type = v42;
    v28.port = *((_DWORD *)v31 + 25);
    NET_OutOfBandPrint(
        NS_SERVER, v28,
        "error\n\x15You are permanently banned from this server");
    memset((char *)&svs + v32 + 92, 0, 0x28u);
    return;
  }
  v16 = *((_DWORD *)v31 + 32);
  if (v16) {
    v19 = &svs;
    while (v16 != v19[10270] ||
           (float)(dword_1700484 - v19[10271]) >
               (float)(*(float *)(sv_kickBanTime + 8) * 1000.0)) {
      v19 += 2;
      if (v19 == (_DWORD *)&unk_1700500)
        goto LABEL_18;
    }
    Com_Printf("rejected connection from temporarily banned GUID %i\n", v16);
    v43 = *(_QWORD *)((char *)&svs + 40 * v3 + 92);
    *(_QWORD *)&v26.type = v43;
    v26.port = *((_DWORD *)&svs + 10 * v3 + 25);
    NET_OutOfBandPrint(
        NS_SERVER, v26,
        "error\n\x15You are temporarily banned from this server");
    memset((char *)&svs + 40 * v3 + 92, 0, 0x28u);
  } else {
  LABEL_18:
    v17 = (char *)&svs + 40 * v3;
    if (!*((_DWORD *)v17 + 31)) {
      v18 = v17 + 80;
      v7 = va("challengeResponse %i", *((_DWORD *)v17 + 26));
      v8 = v18[3];
      v44 = v8;
      v9 = v18[4];
      v45 = v9;
      v10 = v18[5];
      v46 = v10;
      goto LABEL_10;
    }
  }
}

void __usercall SV_DoneDownload_f(float a1 @<xmm0>, client_s *a2) {
  Com_DPrintf("clientDownload: %s Done\n", &a2->name[2]);
  SV_SendClientGameState(a1, a2);
}

int __cdecl SV_RetransmitDownload_f(client_s *a1) {
  const char *v1; // eax
  int result;     // eax

  v1 = (const char *)SV_Cmd_Argv(1);
  result = atoi(v1);
  if (result == *(_DWORD *)((char *)&loc_20CB4 + (_DWORD)a1))
    *(_DWORD *)&a1->downloadXmitBlock[2] = result;
  return result;
}

void __cdecl SV_WriteDownloadToClient(client_s *a1, msg_t *a2) {
  int v2;               // edx
  int v3;               // eax
  DvarValue v4;         // ebx
  const dvar_s *v5;     // edx
  DvarValue current;    // eax
  int v7;               // edx
  int v8;               // eax
  int v9;               // eax
  int v10;              // edx
  int v11;              // eax
  int v12;              // edi
  unsigned int v13;     // ebx
  int v14;              // edx
  int v15;              // edx
  int v16;              // ebx
  int v17;              // eax
  int v18;              // ecx
  unsigned __int8 *v19; // eax
  int v20;              // [esp+1Ch] [ebp-41Ch]
  char __str[1048];     // [esp+20h] [ebp-418h] BYREF

  if (!*((_BYTE *)&loc_20C68 + (_DWORD)a1))
    return;
  if (!*(_DWORD *)((char *)&loc_20CA8 + (_DWORD)a1)) {
    Com_Printf("clientDownload: %d : begining \"%s\"\n",
               931767531 * (((char *)a1 - (char *)dword_170048C) >> 2),
               (const char *)&loc_20C68 + (_DWORD)a1);
    v14 = FS_iwIwd((char *)&loc_20C68 + (_DWORD)a1, "main");
    if (*(_BYTE *)(sv_allowDownload + 8)) {
      if (v14) {
      LABEL_31:
        Com_Printf("clientDownload: %d : \"%s\" cannot download iwd files\n",
                   931767531 * (((char *)a1 - (char *)dword_170048C) >> 2),
                   (const char *)&loc_20C68 + (_DWORD)a1);
        Com_sprintf(__str, 0x400u, "EXE_CANTAUTODLGAMEIWD\x15%s",
                    (const char *)&loc_20C68 + (_DWORD)a1);
      LABEL_32:
        MSG_WriteByte(a2, 5);
        MSG_WriteShort(a2, 0);
        MSG_WriteLong(a2, -1);
        MSG_WriteString(a2, __str);
        *((_BYTE *)&loc_20C68 + (_DWORD)a1) = 0;
        return;
      }
      v19 = FS_SV_FOpenFileRead((char *)&loc_20C68 + (_DWORD)a1,
                                (int *)((char *)&loc_20CA8 + (_DWORD)a1));
      *(_DWORD *)&a1->downloadSize[2] = v19;
      if ((int)v19 > 0) {
        *(_DWORD *)&a1->downloadXmitBlock[2] = 0;
        *(_DWORD *)((char *)&loc_20CB4 + (_DWORD)a1) = 0;
        *(_DWORD *)&a1->downloadCurrentBlock[2] = 0;
        *(_DWORD *)((char *)&loc_20CB0 + (_DWORD)a1) = 0;
        *(_DWORD *)((char *)&loc_20D00 + (_DWORD)a1) = 0;
        goto LABEL_3;
      }
    } else if (v14) {
      goto LABEL_31;
    }
    if (*(_BYTE *)(sv_allowDownload + 8)) {
      Com_Printf("clientDownload: %d : \"%s\" file not found on server\n",
                 931767531 * (((char *)a1 - (char *)dword_170048C) >> 2),
                 (const char *)&loc_20C68 + (_DWORD)a1);
      Com_sprintf(__str, 0x400u, "EXE_AUTODL_FILENOTONSERVER\x15%s",
                  (const char *)&loc_20C68 + (_DWORD)a1);
    } else {
      Com_Printf("clientDownload: %d : \"%s\" download disabled",
                 931767531 * (((char *)a1 - (char *)dword_170048C) >> 2),
                 (const char *)&loc_20C68 + (_DWORD)a1);
      if (*(_BYTE *)(sv_pure + 8))
        Com_sprintf(__str, 0x400u, "EXE_AUTODL_SERVERDISABLED_PURE\x15%s",
                    (const char *)&loc_20C68 + (_DWORD)a1);
      else
        Com_sprintf(__str, 0x400u, "EXE_AUTODL_SERVERDISABLED\x15%s",
                    (const char *)&loc_20C68 + (_DWORD)a1);
    }
    goto LABEL_32;
  }
LABEL_3:
  v2 = *(_DWORD *)&a1->downloadCurrentBlock[2];
  if (v2 - *(_DWORD *)((char *)&loc_20CB4 + (_DWORD)a1) <= 7) {
    if (*(_DWORD *)&a1->downloadSize[2] ==
        *(_DWORD *)((char *)&loc_20CB0 + (_DWORD)a1))
      goto LABEL_35;
    while (1) {
      v16 = v2 % 8;
      if (!*(_DWORD *)&a1->downloadBlocks[4 * v16 + 2])
        *(_DWORD *)&a1->downloadBlocks[4 * v16 + 2] = Z_MallocInternal(0x800u);
      v17 = FS_Read(*(char **)&a1->downloadBlocks[4 * v16 + 2], 0x800u,
                    *(_DWORD *)((char *)&loc_20CA8 + (_DWORD)a1));
      *(_DWORD *)&a1->downloadBlockSize[4 * v16 + 2] = v17;
      if (v17 < 0) {
        v3 = *(_DWORD *)&a1->downloadSize[2];
        *(_DWORD *)((char *)&loc_20CB0 + (_DWORD)a1) = v3;
        goto LABEL_5;
      }
      v18 = *(_DWORD *)((char *)&loc_20CB0 + (_DWORD)a1) + v17;
      *(_DWORD *)((char *)&loc_20CB0 + (_DWORD)a1) = v18;
      v2 = *(_DWORD *)&a1->downloadCurrentBlock[2] + 1;
      *(_DWORD *)&a1->downloadCurrentBlock[2] = v2;
      if (v2 - *(_DWORD *)((char *)&loc_20CB4 + (_DWORD)a1) > 7)
        break;
      if (v18 == *(_DWORD *)&a1->downloadSize[2])
        goto LABEL_35;
    }
    v3 = v18;
  } else {
    v3 = *(_DWORD *)((char *)&loc_20CB0 + (_DWORD)a1);
  }
LABEL_5:
  if (v3 == *(_DWORD *)&a1->downloadSize[2]) {
  LABEL_35:
    if (!*(_DWORD *)((char *)&loc_20D00 + (_DWORD)a1)) {
      v15 = *(_DWORD *)&a1->downloadCurrentBlock[2];
      if (v15 - *(_DWORD *)((char *)&loc_20CB4 + (_DWORD)a1) <= 7) {
        *(_DWORD *)&a1->downloadBlockSize[4 * (v15 % 8) + 2] = 0;
        *(_DWORD *)&a1->downloadCurrentBlock[2] = v15 + 1;
        *(_DWORD *)((char *)&loc_20D00 + (_DWORD)a1) = 1;
      }
    }
  }
  v4 = *(DvarValue *)((char *)&a1->rate + 2);
  v5 = sv_maxRate;
  current = sv_maxRate->current;
  if (current.integer) {
    if (current.integer <= 999) {
      Dvar_SetInt((dvar_s *)sv_maxRate, 1000);
      v5 = sv_maxRate;
    }
    if (v4.integer > v5->current.integer)
      v4 = v5->current;
  }
  if (!v4.integer)
    goto LABEL_15;
  v7 = *(int32_t *)((char *)&a1->snapshotMsec + 2) * v4.integer / 1000;
  v8 = v7 + 2048;
  if (v7 + 2048 < 0)
    v8 = v7 + 4095;
  v9 = v8 >> 11;
  if (v9 >= 0) {
    v20 = v9 - 1;
    if (!v9)
      return;
  } else {
  LABEL_15:
    v20 = 0;
  }
  v10 = *(_DWORD *)((char *)&loc_20CB4 + (_DWORD)a1);
  v11 = *(_DWORD *)&a1->downloadCurrentBlock[2];
  if (v11 != v10) {
    v12 = 0;
    while (v11 != *(_DWORD *)&a1->downloadXmitBlock[2]) {
      v13 = *(_DWORD *)&a1->downloadXmitBlock[2] & 0x80000007;
      if (*(int *)&a1->downloadXmitBlock[2] < 0)
        goto LABEL_28;
    LABEL_20:
      MSG_WriteByte(a2, 5);
      MSG_WriteShort(a2, *(_DWORD *)&a1->downloadXmitBlock[2]);
      if (!*(_DWORD *)&a1->downloadXmitBlock[2])
        MSG_WriteLong(a2, *(_DWORD *)&a1->downloadSize[2]);
      MSG_WriteShort(a2, *(_DWORD *)&a1->downloadBlockSize[4 * v13 + 2]);
      if (*(_DWORD *)&a1->downloadBlockSize[4 * v13 + 2])
        MSG_WriteData(a2, *(void **)&a1->downloadBlocks[4 * v13 + 2],
                      *(_DWORD *)&a1->downloadBlockSize[4 * v13 + 2]);
      Com_DPrintf("clientDownload: %d : writing block %d\n",
                  931767531 * (((char *)a1 - (char *)dword_170048C) >> 2),
                  *(_DWORD *)&a1->downloadXmitBlock[2]);
      ++*(_DWORD *)&a1->downloadXmitBlock[2];
      *(_DWORD *)&a1->downloadSendTime[2] = dword_1700484;
      if (v20 != v12) {
        v10 = *(_DWORD *)((char *)&loc_20CB4 + (_DWORD)a1);
        v11 = *(_DWORD *)&a1->downloadCurrentBlock[2];
        ++v12;
        if (v10 != v11)
          continue;
      }
      return;
    }
    if (dword_1700484 - *(_DWORD *)&a1->downloadSendTime[2] <= 1000)
      return;
    *(_DWORD *)&a1->downloadXmitBlock[2] = v10;
    v13 = v10 & 0x80000007;
    if (v10 >= 0)
      goto LABEL_20;
  LABEL_28:
    v13 = (((_BYTE)v13 - 1) | 0xFFFFFFF8) + 1;
    goto LABEL_20;
  }
}

client_s *__cdecl SV_VerifyIwds_f(client_s *a1) {
  int v1;           // esi
  client_s *result; // eax
  int v3;           // edi
  char *v4;         // eax
  int v5;           // eax
  int v6;           // esi
  int v7;           // ebx
  const char *v8;   // eax
  int v9;           // ecx
  int v10;          // edx
  int v11;          // eax
  int v12;          // edx
  int j;            // eax
  int i;            // eax
  int v15;          // ebx
  const char *v16;  // eax
  int v17;          // ecx
  int v18;          // edx
  _DWORD v19[2054]; // [esp+10h] [ebp-2018h] BYREF

  v1 = SV_Cmd_Argc();
  if (v1 <= 1 || LOBYTE(SV_Cmd_Argv(1)->s.number) != 64)
    goto LABEL_3;
  if (v1 > 2) {
    for (i = 2;; i = v15) {
      v15 = i + 1;
      v16 = (const char *)SV_Cmd_Argv(i);
      v19[v15 + 1021] = atoi(v16);
      if (v1 == v15)
        break;
    }
    v3 = v15 - 3;
    if (v15 - 3 > 0) {
      v17 = 0;
    LABEL_30:
      v18 = 0;
      while (v17 == v18 || v19[v17 + 1024] != v19[v18 + 1024]) {
        if (++v18 == v3) {
          if (++v17 != v3)
            goto LABEL_30;
          goto LABEL_6;
        }
      }
      goto LABEL_3;
    }
  } else {
    v3 = -1;
  }
LABEL_6:
  v4 = FS_LoadedIwdPureChecksums();
  SV_Cmd_TokenizeString(v4);
  v5 = SV_Cmd_Argc();
  v6 = v5;
  if (v5 <= 1024) {
    if (v5 <= 0)
      goto LABEL_10;
  } else {
    v6 = 1024;
  }
  v7 = 0;
  do {
    v8 = (const char *)SV_Cmd_Argv(v7);
    v19[v7++] = atoi(v8);
  } while (v6 != v7);
LABEL_10:
  if (v3 > 0) {
    if (v6 > 0) {
      v9 = 0;
      while (1) {
        v10 = v19[v9 + 1024];
        if (v19[0] != v10)
          break;
      LABEL_17:
        if (++v9 == v3)
          goto LABEL_18;
      }
      v11 = 0;
      while (v6 != ++v11) {
        if (v10 == v19[v11])
          goto LABEL_17;
      }
    }
    goto LABEL_3;
  }
LABEL_18:
  v12 = sv[3];
  if (v3 > 0) {
    for (j = 0; j != v3; ++j)
      v12 ^= v19[j + 1024];
  }
  if ((v3 ^ v12) != v19[v3 + 1024]) {
  LABEL_3:
    result = a1;
    *(int32_t *)((char *)&a1->pureAuthentic + 2) = 2;
    return result;
  }
  result = a1;
  *(int32_t *)((char *)&a1->pureAuthentic + 2) = 1;
  return result;
}

client_s *__cdecl SV_ResetPureClient_f(client_s *a1) {
  client_s *result; // eax

  result = a1;
  *(int32_t *)((char *)&a1->pureAuthentic + 2) = 0;
  return result;
}

void __cdecl SV_StopDownload_f(client_s *a1) {
  client_s *v1; // ebx
  int v2;       // eax
  int v3;       // esi

  v1 = a1;
  if (*((_BYTE *)&loc_20C68 + (_DWORD)a1)) {
    Com_DPrintf("clientDownload: %d : file \"%s\" aborted\n",
                931767531 * (((char *)a1 - (char *)dword_170048C) >> 2),
                (const char *)&loc_20C68 + (_DWORD)a1);
    v2 = *(_DWORD *)((char *)&loc_20CA8 + (_DWORD)a1);
    if (!v2)
      goto LABEL_3;
  LABEL_9:
    FS_FCloseFile(v2);
    goto LABEL_3;
  }
  v2 = *(_DWORD *)((char *)&loc_20CA8 + (_DWORD)a1);
  if (v2)
    goto LABEL_9;
LABEL_3:
  *(_DWORD *)((char *)&loc_20CA8 + (_DWORD)a1) = 0;
  *((_BYTE *)&loc_20C68 + (_DWORD)a1) = 0;
  v3 = 8;
  do {
    if (*(_DWORD *)&v1->downloadBlocks[2]) {
      Z_FreeInternal(*(void **)&v1->downloadBlocks[2]);
      *(_DWORD *)&v1->downloadBlocks[2] = 0;
    }
    v1 = (client_s *)((char *)v1 + 4);
    --v3;
  } while (v3);
}

void __usercall SV_NextDownload_f(float a1 @<xmm0>, client_s *a2) {
  client_s *v2;   // ebx
  const char *v3; // eax
  int v4;         // eax
  int v5;         // edx
  int v6;         // esi

  v2 = a2;
  v3 = (const char *)SV_Cmd_Argv(1);
  v4 = atoi(v3);
  if (v4 == *(_DWORD *)((char *)&loc_20CB4 + (_DWORD)a2)) {
    Com_DPrintf("clientDownload: %d : client acknowledge of block %d\n",
                931767531 * (((char *)a2 - (char *)dword_170048C) >> 2), v4);
    v5 = *(_DWORD *)((char *)&loc_20CB4 + (_DWORD)a2);
    if (*(_DWORD *)&a2->downloadBlockSize[4 * (v5 % 8) + 2]) {
      *(_DWORD *)&a2->downloadSendTime[2] = dword_1700484;
      *(_DWORD *)((char *)&loc_20CB4 + (_DWORD)a2) = v5 + 1;
    } else {
      Com_Printf("clientDownload: %d : file \"%s\" completed\n",
                 931767531 * (((char *)a2 - (char *)dword_170048C) >> 2),
                 (const char *)&loc_20C68 + (_DWORD)a2);
      if (*(_DWORD *)((char *)&loc_20CA8 + (_DWORD)a2))
        FS_FCloseFile(*(_DWORD *)((char *)&loc_20CA8 + (_DWORD)a2));
      *(_DWORD *)((char *)&loc_20CA8 + (_DWORD)a2) = 0;
      *((_BYTE *)&loc_20C68 + (_DWORD)a2) = 0;
      v6 = 8;
      do {
        if (*(_DWORD *)&v2->downloadBlocks[2]) {
          Z_FreeInternal(*(void **)&v2->downloadBlocks[2]);
          *(_DWORD *)&v2->downloadBlocks[2] = 0;
        }
        v2 = (client_s *)((char *)v2 + 4);
        --v6;
      } while (v6);
    }
  } else {
    SV_DropClient(a1, a2, "broken download");
  }
}

char *__cdecl SV_BeginDownload_f(client_s *a1) {
  client_s *v1; // ebx
  int v2;       // esi
  char *v3;     // eax

  if (*(_DWORD *)((char *)&loc_20CA8 + (_DWORD)a1))
    FS_FCloseFile(*(_DWORD *)((char *)&loc_20CA8 + (_DWORD)a1));
  *(_DWORD *)((char *)&loc_20CA8 + (_DWORD)a1) = 0;
  *((_BYTE *)&loc_20C68 + (_DWORD)a1) = 0;
  v1 = a1;
  v2 = 8;
  do {
    if (*(_DWORD *)&v1->downloadBlocks[2]) {
      Z_FreeInternal(*(void **)&v1->downloadBlocks[2]);
      *(_DWORD *)&v1->downloadBlocks[2] = 0;
    }
    v1 = (client_s *)((char *)v1 + 4);
    --v2;
  } while (v2);
  v3 = (char *)SV_Cmd_Argv(1);
  return I_strncpyz((char *)&loc_20C68 + (_DWORD)a1, v3, 64);
}

int __cdecl LAN_GetServerStatus(char *__src, char *__dst, int a3) {
  return CL_ServerStatus(__src, __dst, a3);
}

void __usercall UI_LoadSoundAliases(long double a1 @<st0>, float a2 @<xmm0>,
                                    __m128 a3 @<xmm1>, __m128 a4 @<xmm2>,
                                    __m128 a5 @<xmm3>, __m128 a6 @<xmm4>,
                                    __m128 a7 @<xmm6>) {
  Com_LoadSoundAliases(a1, a2, a3, a4, a5, a6, a7, "menu", "all_mp", SASYS_UI);
}

void IN_TalkDown(void) { IN_KeyDown(kb + 30); }

int IN_TalkUp(void) { return IN_KeyUp(kb + 30); }

int IsTalking(void) { return (unsigned __int8)kb[30].active; }

void __usercall CL_Input(__m128 a1 @<xmm3>, __m128 a2 @<xmm4>) {
  if (*(_DWORD *)clc == 8) {
    CL_SyncGpu();
    CL_SendCmdInternal(a1, a2);
  }
}

unsigned __int8 *__cdecl CL_Netchan_Decode(unsigned __int8 *a1,
                                           unsigned __int8 *a2) {
  unsigned __int8 *v2;     // edi
  char v3;                 // bl
  unsigned __int8 *result; // eax
  int v5;                  // esi
  unsigned __int8 *i;      // edx
  unsigned __int8 *v7;     // eax

  v2 = (unsigned __int8 *)clc + 1024 * (*((_DWORD *)clc + 77) & 0x7F) + 312;
  v3 = *(_DWORD *)((char *)&loc_20138 + (_DWORD)clc) ^ *((_BYTE *)clc + 296);
  result = a2;
  if ((int)a2 > 0) {
    v5 = 0;
    for (i = 0; i != a2; ++i) {
      while (1) {
        v7 = &v2[v5];
        if (v2[v5])
          break;
        v5 = 1;
        v3 ^= *v2 << ((unsigned __int8)i & 1);
        result = a1;
        a1[(_DWORD)i++] ^= v3;
        if (i == a2)
          return result;
      }
      ++v5;
      v3 ^= *v7 << ((unsigned __int8)i & 1);
      result = a1;
      a1[(_DWORD)i] ^= v3;
    }
  }
  return result;
}

unsigned __int8 *__cdecl SV_Netchan_Decode(client_s *a1, unsigned __int8 *a2,
                                           unsigned __int8 *a3) {
  char *v3;                // edi
  char v4;                 // bl
  unsigned __int8 *result; // eax
  int v6;                  // esi
  unsigned __int8 *i;      // edx
  char *v8;                // eax

  v3 = &a1->reliableCommandInfo[1032 * (a1->reliableAcknowledge & 0x7F)];
  v4 = a1->messageAcknowledge[0] ^ *(_DWORD *)a1->voicePackets ^
       *((_BYTE *)COpenGL::SetColorMaterialEnable + (_DWORD)a1);
  result = a3;
  if ((int)a3 > 0) {
    v6 = 0;
    for (i = 0; i != a3; ++i) {
      while (1) {
        v8 = &v3[v6];
        if (v3[v6])
          break;
        v6 = 1;
        v4 ^= (unsigned __int8)*v3 << ((unsigned __int8)i & 1);
        result = a2;
        a2[(_DWORD)i++] ^= v4;
        if (a3 == i)
          return result;
      }
      ++v6;
      v4 ^= (unsigned __int8)*v8 << ((unsigned __int8)i & 1);
      result = a2;
      a2[(_DWORD)i] ^= v4;
    }
  }
  return result;
}

_BOOL4 __cdecl SV_FlushRedirect(char *a1) {
  const char *v1;   // edx
  int v2;           // esi
  char *v4;         // edi
  char v5;          // [esp+2Fh] [ebp-559h]
  const char *v6;   // [esp+3Ch] [ebp-54Ch]
  char __str[1300]; // [esp+44h] [ebp-544h] BYREF
  __int64 v8;       // [esp+558h] [ebp-30h]
  int v9;           // [esp+560h] [ebp-28h]
  __int64 v10;      // [esp+564h] [ebp-24h]
  int v11;          // [esp+56Ch] [ebp-1Ch]

  v1 = a1;
  v2 = strlen(a1);
  if (v2 > 1294) {
    v4 = a1;
    do {
      v6 = v4 + 1294;
      v5 = v4[1294];
      v4[1294] = 0;
      Com_sprintf(__str, 0x514u, "print\n%s", v4);
      v8 = *(_QWORD *)&stru_170A4DC.type;
      v9 = *(_DWORD *)&stru_170A4DC.port;
      NET_OutOfBandPrint(NS_SERVER, stru_170A4DC, __str);
      v2 -= 1294;
      v4[1294] = v5;
      v4 += 1294;
    } while (v2 > 1294);
    v1 = v6;
  }
  Com_sprintf(__str, 0x514u, "print\n%s", v1);
  v10 = *(_QWORD *)&stru_170A4DC.type;
  v11 = *(_DWORD *)&stru_170A4DC.port;
  return NET_OutOfBandPrint(NS_SERVER, stru_170A4DC, __str);
}

int __cdecl SVC_RemoteCommand(netadr_t a1) {
  int v1;         // edx
  int result;     // eax
  const char *v3; // ebx
  char *v4;       // eax
  int v5;         // ebx
  const char *v6; // ebx
  char *v7;       // eax
  int v8;         // ebx
  int i;          // esi
  char *v10;      // eax
  int v11;        // eax
  __int128 v12;   // [esp+0h] [ebp-4458h]
  __int64 v13;    // [esp+0h] [ebp-4458h]
  char *__s1;     // [esp+28h] [ebp-4430h]
  char v15;       // [esp+38h] [ebp-4420h] BYREF
  char v16[1024]; // [esp+4028h] [ebp-430h] BYREF
  int32_t v17;    // [esp+4428h] [ebp-30h]
  int32_t v18;    // [esp+442Ch] [ebp-2Ch]
  int v19;        // [esp+4430h] [ebp-28h]
  int32_t type;   // [esp+4434h] [ebp-24h]
  int32_t ip;     // [esp+4438h] [ebp-20h]
  int v22;        // [esp+443Ch] [ebp-1Ch]

  v1 = Com_Milliseconds();
  result = SVC_RemoteCommand(netadr_t, msg_t *)::lasttime;
  if (!SVC_RemoteCommand(netadr_t, msg_t *)::lasttime ||
      v1 - SVC_RemoteCommand(netadr_t, msg_t *)::lasttime > 499) {
    SVC_RemoteCommand(netadr_t, msg_t *)::lasttime = v1;
    __s1 = (char *)SV_Cmd_Argv(1);
    if (**(_BYTE **)(rcon_password + 8) &&
        !strcmp(__s1, *(const char **)(rcon_password + 8))) {
      v6 = (const char *)SV_Cmd_Argv(2);
      LOWORD(v22) = a1.port;
      ip = a1.ip;
      type = a1.type;
      *(_QWORD *)&v12 = *(_QWORD *)&a1.type;
      DWORD2(v12) = v22;
      v7 = NET_AdrToString(v12);
      Com_Printf("Rcon from %s:\n%s\n", v7, v6);
      v5 = 1;
    } else {
      v3 = (const char *)SV_Cmd_Argv(2);
      LOWORD(v19) = a1.port;
      v18 = a1.ip;
      v17 = a1.type;
      *(_QWORD *)&v12 = *(_QWORD *)&a1.type;
      DWORD2(v12) = v19;
      v4 = NET_AdrToString(v12);
      Com_Printf("Bad rcon from %s:\n%s\n", v4, v3);
      v5 = 0;
    }
    stru_170A4DC = a1;
    HIDWORD(v13) = 16368;
    LODWORD(v13) = &v15;
    Com_BeginRedirect(v13, (void (*)(char *))SV_FlushRedirect);
    if (!**(_BYTE **)(rcon_password + 8)) {
      Com_Printf(
          "The server must set 'rcon_password' for clients to use 'rcon'.\n");
      return Com_EndRedirect();
    }
    if (v5) {
      v8 = 0;
      for (i = 2; i < SV_Cmd_Argc(); ++i) {
        v10 = (char *)SV_Cmd_Argv(i);
        v11 = Com_AddToString(v10, v16, v8, 1024, 1);
        v8 = Com_AddToString(" ", v16, v11, 1024, 0);
      }
      if (v8 <= 1023) {
        v16[v8] = 0;
        SV_Cmd_ExecuteString(v16);
        return Com_EndRedirect();
      }
    } else {
      if (*__s1) {
        Com_Printf("Invalid password.\n");
        return Com_EndRedirect();
      }
      Com_Printf("You must log in with 'rcon login <password>' before using "
                 "'rcon'.\n");
    }
    return Com_EndRedirect();
  }
  return result;
}

void SV_MatchEnd(void) { ; }

void SV_MasterGameCompleteStatus(void) {
  netadr_t *v0; // ebx
  __int128 v1;  // [esp+0h] [ebp-28h]

  if (com_dedicated && *(_DWORD *)(com_dedicated + 8) == 2) {
    v0 = SV_MasterAddress();
    if (v0->type != 1) {
      Com_Printf("Sending gameCompleteStatus to cod2master.activision.com\n");
      *(_QWORD *)&v1 = *(_QWORD *)&v0->type;
      DWORD2(v1) = *(_DWORD *)&v0->port;
      SVC_GameCompleteStatus(v1);
    }
  }
}

void __cdecl SV_MasterHeartbeat(const char *a1) {
  int v1;       // eax
  netadr_t *v2; // eax
  netadr_t *v3; // edi
  char *v4;     // eax
  __int128 v5;  // [esp+0h] [ebp-58h]
  netadr_t v6;  // [esp+4h] [ebp-54h]

  if (com_dedicated && *(_DWORD *)(com_dedicated + 8) == 2) {
    v1 = dword_1700484;
    if (dword_1700484 >= dword_17004D4) {
      dword_17004D4 = dword_1700484 + 180000;
      v3 = SV_MasterAddress();
      if (v3->type != 1) {
        Com_Printf("Sending heartbeat to cod2master.activision.com\n");
        v4 = va("heartbeat %s\n", a1);
        *(_QWORD *)&v6.type = *(_QWORD *)&v3->type;
        v6.port = *(_DWORD *)&v3->port;
        NET_OutOfBandPrint(NS_SERVER, v6, v4);
      }
      v1 = dword_1700484;
    }
    if (v1 >= dword_17004D8) {
      dword_17004D8 = v1 + 600000;
      v2 = SV_MasterAddress();
      if (v2->type != 1) {
        *(_QWORD *)&v5 = *(_QWORD *)&v2->type;
        DWORD2(v5) = *(_DWORD *)&v2->port;
        SVC_Status(v5);
      }
    }
  }
}

void SV_MasterShutdown(void) {
  dword_17004D4 = 0x80000000;
  SV_MasterHeartbeat("flatline");
}

int __cdecl Scr_GetFunction(const char **a1, int *a2) {
  int v2;          // esi
  const char **v3; // ebx
  int v4;          // edi
  const char *i;   // edx
  const char *v7;  // [esp+1Ch] [ebp-1Ch]

  v7 = *a1;
  v2 = 0;
  v3 = (const char **)&functions;
  v4 = 0;
  for (i = *a1;; i = v7) {
    if (!strcmp(i, *v3)) {
      *a1 = (&functions)[v4];
      *a2 = dword_313208[v4];
      return *(int *)((char *)&off_313204 + v4 * 4);
    }
    ++v2;
    v4 += 3;
    v3 += 3;
    if (v2 == 144)
      break;
  }
  return 0;
}

int __cdecl Scr_GetMethod(char **a1, int *a2) {
  int result;      // eax
  const char **v3; // edi
  const char *i;   // edx
  int v5;          // [esp+14h] [ebp-24h]
  int v6;          // [esp+18h] [ebp-20h]
  const char *v7;  // [esp+1Ch] [ebp-1Ch]

  *a2 = 0;
  result = Player_GetMethod((const char **)a1);
  if (!result) {
    result = ScriptEnt_GetMethod((const char **)a1);
    if (!result) {
      result = HudElem_GetMethod((const char **)a1);
      if (!result) {
        v7 = *a1;
        v6 = 0;
        v3 = (const char **)&methods;
        v5 = 0;
        for (i = *a1;; i = v7) {
          if (!strcmp(i, *v3)) {
            *a1 = (&methods)[v5];
            *a2 = dword_3138C8[v5];
            return *(int *)((char *)&off_3138C4 + v5 * 4);
          }
          ++v6;
          v5 += 3;
          v3 += 3;
          if (v6 == 59)
            break;
        }
        return 0;
      }
    }
  }
  return result;
}

void __usercall UI_MapLoadInfo(long double a1 @<st0>, float a2 @<xmm0>,
                               __m128 a3 @<xmm1>, __m128 a4 @<xmm2>,
                               __m128 a5 @<xmm3>, __m128 a6 @<xmm4>,
                               __m128 a7 @<xmm6>, char *__src) {
  char *v8;        // eax
  char *v9;        // eax
  char *v10;       // esi
  size_t v11;      // ebx
  char __dst[256]; // [esp+28h] [ebp-160h] BYREF
  char __str[64];  // [esp+128h] [ebp-60h] BYREF
  char *v14;       // [esp+168h] [ebp-20h] BYREF
  int v15;         // [esp+16Ch] [ebp-1Ch] BYREF

  if (*__src) {
    if ((FS_ReadFile(__src, (char **)&v15) & 0x80000000) != 0) {
      Com_Printf("^3WARNING: Could not find '%s'.\n", __src);
    } else {
      v14 = (char *)v15;
      Com_BeginParseSession(__src);
      Com_SetCSV(1);
      while (1) {
        v9 = Com_Parse(&v14);
        v10 = v9;
        if (!*v9)
          break;
        v11 = strlen(v9) + 1;
        if (v11 <= 0xFF) {
          memcpy(__dst, v9, v11);
          v8 = Com_ParseOnLine(&v14);
          if (!*v8)
            goto LABEL_9;
        } else {
          Com_EndParseSession();
          Com_Error(a1, a2, a3, a4, a5, a6, a7, 1,
                    "key '%s' is %i > %i characters long", __dst, v11 - 1, 255);
          memcpy(__dst, v10, v11);
          v8 = Com_ParseOnLine(&v14);
          if (!*v8) {
          LABEL_9:
            Com_EndParseSession();
            Com_Error(a1, a2, a3, a4, a5, a6, a7, 1,
                      "key '%s' missing value in '%s'\n", __dst, __src);
            break;
          }
        }
        CL_RegisterMaterialNoMip(v8, 3);
        Com_sprintf(__str, 0x40u, "$%s", __dst);
        I_strlwr(__str);
        CL_Material_Duplicate();
      }
      Com_EndParseSession();
      FS_FreeFile((void *)v15);
    }
  }
}

void PC_SourceError(int a1, char *__format, ...) {
  char __dst[128]; // [esp+18h] [ebp-90h] BYREF
  va_list v3;      // [esp+98h] [ebp-10h]
  int v4[3];       // [esp+9Ch] [ebp-Ch] BYREF
  va_list va;      // [esp+B8h] [ebp+10h] BYREF

  va_start(va, __format);
  va_copy(v3, va);
  vsnprintf(PC_SourceError(int, char *, ...)::string, 0x1000u, __format, va);
  __dst[0] = 0;
  v4[0] = 0;
  PC_SourceFileAndLine(a1, __dst, v4);
  Com_Printf("^1Menu load error: %s, line %d: %s\n", __dst, v4[0],
             PC_SourceError(int, char *, ...)::string);
}

void __cdecl Item_InitControls(itemDef_s *a1) {
  itemDefData_t v1; // esi

  if (a1 && a1->type == 6) {
    v1.listBox = Item_GetListBoxDef(a1).listBox;
    Item_SetCursorPos(a1, 0);
    if (v1.listBox) {
      ListBox_SetCursorPos((listBoxDef_s *)v1.listBox, 0);
      ListBox_SetStartPos((listBoxDef_s *)v1.listBox, 0);
      ListBox_SetEndPos((listBoxDef_s *)v1.listBox, 0);
    }
  }
}

void __usercall Item_ValidateTypeData(itemDef_s *a1 @<eax>, int a2 @<edx>) {
  int32_t dataType; // ecx
  int32_t type;     // eax
  int32_t v5;       // eax
  int32_t v6;       // eax
  itemDefData_t v7; // eax

  if (a1->typeData.listBox) {
    dataType = a1->dataType;
    type = a1->type;
    if (dataType != type)
      PC_SourceError(a2,
                     "Attempting to change type from %d to %d.\nMove the type "
                     "definition higher up in the itemDef.\n",
                     dataType, type);
  } else {
    v5 = a1->type;
    a1->dataType = v5;
    switch (v5) {
    case 6:
      a1->typeData.listBox = (int32_t)UI_Alloc(0x110u, 4);
      break;
    case 4:
    case 9:
    case 16:
    case 18:
    case 11:
    case 14:
    case 10:
    case 0:
    case 17:
      a1->typeData.listBox = (int32_t)UI_Alloc(0x20u, 4);
      v6 = a1->type;
      if (v6 == 4 || v6 == 16 || v6 == 9 || v6 == 18 || v6 == 17) {
        v7.listBox = Item_GetEditFieldDef(a1).listBox;
        if (!*(_DWORD *)(v7.listBox + 24))
          *(_DWORD *)(v7.listBox + 24) = 256;
      }
      break;
    case 12:
      a1->typeData.listBox = (int32_t)UI_Alloc(0x188u, 4);
      break;
    }
  }
}

int __cdecl ItemParse_textsavegame(itemDef_s *a1) {
  *(_DWORD *)a1->text = "savegameinfo";
  *(_DWORD *)a1->textSavegameInfo = 1;
  return 1;
}

itemDefData_t __cdecl ItemParse_notselectable(itemDef_s *a1, int a2) {
  itemDefData_t result; // eax

  Item_ValidateTypeData(a1, a2);
  result.listBox = Item_GetListBoxDef(a1).listBox;
  if (result.listBox) {
    if (a1->type == 6)
      *(_DWORD *)(result.listBox + 264) = 1;
    return (itemDefData_t)1;
  }
  return result;
}

itemDefData_t __cdecl ItemParse_noScrollBars(itemDef_s *a1, int a2) {
  itemDefData_t result; // eax

  Item_ValidateTypeData(a1, a2);
  result.listBox = Item_GetListBoxDef(a1).listBox;
  if (result.listBox) {
    if (a1->type == 6)
      *(_DWORD *)(result.listBox + 268) = 1;
    return (itemDefData_t)1;
  }
  return result;
}

int __cdecl ItemParse_horizontalscroll(windowDef_t *a1) {
  Window_SetStaticFlags(a1, a1->staticFlags | 0x200000);
  return 1;
}

int __cdecl Item_Parse_maxCharsGotoNext(itemDef_s *a1, int a2) {
  itemDefData_t v2; // eax

  Item_ValidateTypeData(a1, a2);
  if (!a1->typeData.listBox)
    return 0;
  v2.listBox = Item_GetEditFieldDef(a1).listBox;
  if (!v2.listBox)
    return 0;
  *(_DWORD *)(v2.listBox + 20) = 1;
  return 1;
}

int __cdecl ItemParse_dvarStrList(itemDef_s *a1, int a2) {
  int MultiDef;   // esi
  int v4;         // ebx
  int v5;         // ebx
  int v6;         // ebx
  int v7;         // eax
  itemDef_s *v8;  // [esp+0h] [ebp-438h]
  int v9;         // [esp+4h] [ebp-434h]
  pc_token_s v10; // [esp+10h] [ebp-428h] BYREF

  Item_ValidateTypeData(v8, v9);
  if (!a1->typeData.listBox)
    return 0;
  if (a1->type != 12)
    return 0;
  MultiDef = Item_GetMultiDef(a1);
  *(_DWORD *)(MultiDef + 384) = 0;
  *(_DWORD *)(MultiDef + 388) = 1;
  if (!PC_ReadTokenHandle(a2, &v10) || v10.string[0] != 123)
    return 0;
  while (2) {
    v4 = 0;
  LABEL_7:
    if (PC_ReadTokenHandle(a2, &v10)) {
      while (1) {
        if (v10.string[0] == 125)
          return 1;
        if (v10.string[0] == 44 || v10.string[0] == 59)
          goto LABEL_7;
        if (v4)
          break;
        v5 = *(_DWORD *)(MultiDef + 384);
        *(_DWORD *)(MultiDef + 4 * v5) = String_Alloc(v10.string);
        v4 = 1;
        if (!PC_ReadTokenHandle(a2, &v10))
          goto LABEL_13;
      }
      v6 = *(_DWORD *)(MultiDef + 384);
      *(_DWORD *)(MultiDef + 4 * v6 + 128) = String_Alloc(v10.string);
      v7 = *(_DWORD *)(MultiDef + 384) + 1;
      *(_DWORD *)(MultiDef + 384) = v7;
      if (v7 <= 31)
        continue;
      return 0;
    }
    break;
  }
LABEL_13:
  PC_SourceError(a2, "end of file inside menu item\n");
  return 0;
}

int __cdecl Menu_PostParse(menuDef_t *a1) {
  size_t v1;    // ebx
  void *v2;     // eax
  rectDef_s v4; // [esp+18h] [ebp-20h] BYREF

  v1 = 4 * a1->itemCount;
  v2 = UI_Alloc(v1, 4);
  a1->items = (int32_t)v2;
  memcpy(v2, &unk_F39BC0, v1);
  if (a1->fullScreen) {
    v4.horzAlign = *(_DWORD *)&a1->window.rect[16];
    v4.vertAlign = *(_DWORD *)&a1->window.rect[20];
    v4.x = 0;
    v4.y = 0;
    v4.w = 1142947840;
    v4.h = 1139802112;
    Window_SetRect(&a1->window, &v4);
  }
  return Menu_UpdatePosition(a1);
}

int __cdecl MenuParse_popup(windowDef_t *a1) {
  Window_SetStaticFlags(a1, a1->staticFlags | 0x1000000);
  return 1;
}

int __cdecl MenuParse_outOfBounds(windowDef_t *a1) {
  Window_SetStaticFlags(a1, a1->staticFlags | 0x2000000);
  return 1;
}

int __cdecl MenuParse_legacySplitScreenScale(windowDef_t *a1) {
  Window_SetStaticFlags(a1, a1->staticFlags | 0x4000000);
  return 1;
}

int __cdecl ItemParse_decoration(windowDef_t *a1) {
  Window_SetStaticFlags(a1, a1->staticFlags | 0x100000);
  return 1;
}

int __cdecl ItemParse_wrapped(windowDef_t *a1) {
  Window_SetStaticFlags(a1, a1->staticFlags | 0x400000);
  return 1;
}

int __cdecl ItemParse_autowrapped(windowDef_t *a1) {
  Window_SetStaticFlags(a1, a1->staticFlags | 0x800000);
  return 1;
}

int __cdecl ItemParse_group(itemDef_s *a1, int a2) {
  int result;    // eax
  pc_token_s v3; // [esp+10h] [ebp-418h] BYREF

  result = PC_ReadTokenHandle(a2, &v3);
  if (result) {
    *(_DWORD *)&a1->window[196] = String_Alloc(v3.string);
    return 1;
  }
  return result;
}

int __cdecl ItemParse_textscale(itemDef_s *a1, int a2) {
  char *textscale; // edi
  int v3;          // eax
  pc_token_s v5;   // [esp+10h] [ebp-428h] BYREF

  textscale = a1->textscale;
  if (!PC_ReadTokenHandle(a2, &v5))
    return 0;
  if (v5.string[0] != 45) {
    v3 = 0;
    goto LABEL_4;
  }
  if (!PC_ReadTokenHandle(a2, &v5))
    return 0;
  v3 = 1;
LABEL_4:
  if (v5.type == 3) {
    if (v3)
      *(_DWORD *)textscale = LODWORD(v5.floatvalue) ^ 0x80000000;
    else
      *(float *)textscale = v5.floatvalue;
    return 1;
  } else {
    PC_SourceError(a2, "expected float but found %s\n", v5.string);
    return 0;
  }
}

int __cdecl ItemParse_origin(windowDef_t *a1, int a2) {
  int v2;           // eax
  int32_t intvalue; // edi
  int v4;           // eax
  int32_t v5;       // ecx
  int32_t v6;       // eax
  int32_t v7;       // edx
  pc_token_s v9;    // [esp+18h] [ebp-440h] BYREF
  rectDef_s v10;    // [esp+428h] [ebp-30h] BYREF

  if (!PC_ReadTokenHandle(a2, &v9))
    return 0;
  if (v9.string[0] == 45) {
    if (!PC_ReadTokenHandle(a2, &v9))
      return 0;
    v2 = 1;
  } else {
    v2 = 0;
  }
  if (v9.type != 3) {
  LABEL_15:
    PC_SourceError(a2, "expected integer but found %s\n", v9.string);
    return 0;
  }
  intvalue = v9.intvalue;
  if (v2) {
    intvalue = -v9.intvalue;
    if (!PC_ReadTokenHandle(a2, &v9))
      return 0;
  } else if (!PC_ReadTokenHandle(a2, &v9)) {
    return 0;
  }
  if (v9.string[0] != 45) {
    v4 = 0;
    goto LABEL_9;
  }
  if (!PC_ReadTokenHandle(a2, &v9))
    return 0;
  v4 = 1;
LABEL_9:
  if (v9.type != 3)
    goto LABEL_15;
  v5 = v9.intvalue;
  if (v4)
    v5 = -v9.intvalue;
  v10.x = *(_DWORD *)a1->rectClient;
  v10.y = *(_DWORD *)&a1->rectClient[4];
  v10.w = *(_DWORD *)&a1->rectClient[8];
  v10.h = *(_DWORD *)&a1->rectClient[12];
  v6 = *(_DWORD *)&a1->rectClient[16];
  v7 = *(_DWORD *)&a1->rectClient[20];
  *(float *)&v10.x = (float)intvalue + *(float *)&v10.x;
  *(float *)&v10.y = (float)v5 + *(float *)&v10.y;
  v10.horzAlign = v6;
  v10.vertAlign = v7;
  Window_SetRectClient(a1, &v10);
  return 1;
}

int __cdecl ItemParse_visible(windowDef_t *a1, int a2) {
  int v2;           // eax
  int32_t intvalue; // ebx
  const char *v5;   // edx
  pc_token_s v6;    // [esp+10h] [ebp-428h] BYREF

  if (!PC_ReadTokenHandle(a2, &v6))
    return 0;
  if (v6.string[0] != 45) {
    v2 = 0;
    goto LABEL_4;
  }
  if (!PC_ReadTokenHandle(a2, &v6))
    return 0;
  v2 = 1;
LABEL_4:
  if (v6.type != 3) {
    PC_SourceError(a2, "expected integer but found %s\n", v6.string);
    return 0;
  }
  intvalue = v6.intvalue;
  if (v2) {
    intvalue = -v6.intvalue;
    v5 = *(const char **)&a1[1].rectClient[36];
    if (v5) {
    LABEL_10:
      if (!strcmp(v5, "@MENU_SHADOWS"))
        return 1;
    }
  } else {
    v5 = *(const char **)&a1[1].rectClient[36];
    if (v5)
      goto LABEL_10;
  }
  if ((!*(_DWORD *)&a1[1].rectClient[80] ||
       strcmp(*(const char **)&a1[1].rectClient[80], "ui_sc_enable")) &&
      intvalue) {
    Window_SetDynamicFlags(a1, *(_DWORD *)a1->dynamicFlags | 4);
    return 1;
  }
  return 1;
}

int __cdecl HudElem_GetMethod(const char **a1) {
  int v1;          // esi
  const char **v2; // ebx
  int v3;          // edi
  const char *i;   // edx
  const char *v6;  // [esp+1Ch] [ebp-1Ch]

  v6 = *a1;
  v1 = 0;
  v2 = (const char **)&methods_0;
  v3 = 0;
  for (i = *a1; strcmp(i, *v2); i = v6) {
    ++v1;
    v3 += 3;
    v2 += 3;
    if (v1 == 18)
      return 0;
  }
  *a1 = (&methods_0)[v3];
  return *(int *)((char *)&off_333424 + v3 * 4);
}

int __cdecl ScriptEnt_GetMethod(const char **a1) {
  int v1;          // esi
  const char **v2; // ebx
  int v3;          // edi
  const char *i;   // edx
  const char *v6;  // [esp+1Ch] [ebp-1Ch]

  v6 = *a1;
  v1 = 0;
  v2 = (const char **)&methods_1;
  v3 = 0;
  for (i = *a1; strcmp(i, *v2); i = v6) {
    ++v1;
    v3 += 3;
    v2 += 3;
    if (v1 == 12)
      return 0;
  }
  *a1 = (&methods_1)[v3];
  return *(int *)((char *)&off_3336C4 + v3 * 4);
}

int __cdecl SV_ClientWantsVoiceData(int a1) {
  return *((unsigned __int8 *)&dword_170048C[1].state + 495372 * a1 + 3);
}

int __cdecl Player_GetMethod(const char **a1) {
  int v1;          // esi
  const char **v2; // ebx
  int v3;          // edi
  const char *i;   // edx
  const char *v6;  // [esp+1Ch] [ebp-1Ch]

  v6 = *a1;
  v1 = 0;
  v2 = (const char **)&methods_2;
  v3 = 0;
  for (i = *a1;; i = v6) {
    if (!strcmp(i, *v2)) {
      *a1 = (&methods_2)[v3];
      return *(int *)((char *)&off_333884 + v3 * 4);
    }
    ++v1;
    v3 += 3;
    v2 += 3;
    if (v1 == 59)
      break;
  }
  return 0;
}

int __cdecl LAN_AddServer(int a1, char *__src, char *a3) {
  int v4;       // edx
  int v5;       // edx
  char *v6;     // edi
  netadr_t v7;  // [esp+0h] [ebp-78h]
  int v8;       // [esp+2Ch] [ebp-4Ch]
  _BYTE v9[12]; // [esp+3Ch] [ebp-3Ch] BYREF
  __int64 v10;  // [esp+48h] [ebp-30h]
  int v11;      // [esp+50h] [ebp-28h]
  __int64 v12;  // [esp+54h] [ebp-24h]
  int v13;      // [esp+5Ch] [ebp-1Ch]

  if (a1 != 2 || dword_14BCFA4 > 127)
    return -1;
  if (!NET_StringToAdr(a3, (netadr_t *)v9))
    return -2;
  if (dword_14BCFA4 <= 0) {
  LABEL_6:
    v4 = dword_14BCFA4;
  LABEL_7:
    v5 = 136 * v4;
    *(_QWORD *)&byte_14BCFA8[v5] = *(_QWORD *)v9;
    *(_DWORD *)&byte_14BCFA8[v5 + 8] = *(_DWORD *)&v9[8];
    I_strncpyz(&byte_14BCFA8[136 * dword_14BCFA4 + 32], __src, 32);
    byte_14BCFA8[136 * dword_14BCFA4++ + 15] = 1;
    return 1;
  }
  v8 = 0;
  v6 = byte_14BCFA8;
  while (1) {
    v10 = *(_QWORD *)v9;
    v11 = *(_DWORD *)&v9[8];
    v12 = *(_QWORD *)v6;
    v13 = *((_DWORD *)v6 + 2);
    v7.port = v13;
    *(_QWORD *)&v7.type = v12;
    if (NET_CompareAdr(v7, *(netadr_t *)v9))
      break;
    ++v8;
    v6 += 136;
    if (v8 >= dword_14BCFA4)
      goto LABEL_6;
  }
  v4 = dword_14BCFA4;
  if (dword_14BCFA4 <= v8)
    goto LABEL_7;
  return 0;
}

void __cdecl LAN_RemoveServer(int a1, char *__src) {
  char *i;      // edx
  int v3;       // eax
  int v4;       // esi
  int v5;       // ebx
  netadr_t v6;  // [esp+Ch] [ebp-6Ch]
  int v7;       // [esp+28h] [ebp-50h]
  char *v8;     // [esp+2Ch] [ebp-4Ch]
  _BYTE v9[12]; // [esp+3Ch] [ebp-3Ch] BYREF
  __int64 v10;  // [esp+48h] [ebp-30h]
  int v11;      // [esp+50h] [ebp-28h]
  __int64 v12;  // [esp+54h] [ebp-24h]
  int v13;      // [esp+5Ch] [ebp-1Ch]

  if (a1 == 2) {
    NET_StringToAdr(__src, (netadr_t *)v9);
    if (dword_14BCFA4 > 0) {
      v7 = 0;
      v8 = byte_14BCFA8;
      for (i = byte_14BCFA8;; i = v8) {
        v10 = *(_QWORD *)i;
        v11 = *((_DWORD *)i + 2);
        v12 = *(_QWORD *)v9;
        v13 = *(_DWORD *)&v9[8];
        *(_QWORD *)&v6.type = v10;
        v6.port = v11;
        if (NET_CompareAdr(*(netadr_t *)v9, v6))
          break;
        ++v7;
        v8 += 136;
        if (v7 >= dword_14BCFA4)
          return;
      }
      v3 = dword_14BCFA4 - 1;
      if (v7 < dword_14BCFA4 - 1) {
        v4 = 136 * v7;
        v5 = v7;
        do {
          Com_Memcpy((char *)&cls + v4 + 2737736, (char *)&cls + v4 + 2737872,
                     0x88u);
          ++v5;
          v3 = dword_14BCFA4 - 1;
          v4 += 136;
        } while (v5 < dword_14BCFA4 - 1);
      }
      dword_14BCFA4 = v3;
    }
  }
}

char *__cdecl LAN_GetServerAddressString(char *a1, int a2, char *a3, int a4) {
  char *result;    // eax
  unsigned int v5; // ecx
  unsigned int v6; // edx
  int v7;          // eax
  char *v8;        // eax
  __int128 v9;     // [esp+0h] [ebp-48h]

  result = a1;
  if (a1 == (char *)1) {
    if (a2 >= 0 && a2 < dword_1224EA0) {
      v5 = *((_DWORD *)&cls + 34 * a2 + 4433);
      v6 = *((_DWORD *)&cls + 34 * a2 + 4434);
      v7 = *((_DWORD *)&cls + 34 * a2 + 4435);
      goto LABEL_7;
    }
  LABEL_4:
    *a3 = 0;
    return result;
  }
  if (a1 == (char *)2) {
    if ((unsigned int)a2 <= 0x7F) {
      v5 = *((_DWORD *)&cls + 34 * a2 + 684434);
      v6 = *((_DWORD *)&cls + 34 * a2 + 684435);
      v7 = *((_DWORD *)&cls + 34 * a2 + 684436);
      goto LABEL_7;
    }
    goto LABEL_4;
  }
  if (a1 || (unsigned int)a2 > 0x7F)
    goto LABEL_4;
  v5 = *((_DWORD *)&cls + 34 * a2 + 79);
  v6 = *((_DWORD *)&cls + 34 * a2 + 80);
  v7 = *((_DWORD *)&cls + 34 * a2 + 81);
LABEL_7:
  *(_QWORD *)&v9 = __PAIR64__(v6, v5);
  DWORD2(v9) = v7;
  v8 = NET_AdrToString(v9);
  return I_strncpyz(a3, v8, a4);
}

void LAN_LoadCachedServers(void) {
  int v0;    // ebx
  int v1;    // ebx
  int v2;    // [esp+14h] [ebp-14h] BYREF
  int v3;    // [esp+18h] [ebp-10h] BYREF
  int v4[3]; // [esp+1Ch] [ebp-Ch] BYREF

  if (FS_SV_FOpenFileRead("servercache.dat", v4) &&
      ((v0 = v4[0], FS_Read((char *)&v2, 4u, v4[0]) != 4) || v2 != 1 ||
               FS_Read((char *)&dword_1224EA0, 4u, v0) != 4 ||
               (unsigned int)dword_1224EA0 > 0x4E1F ||
               FS_Read((char *)&dword_14BCFA4, 4u, v0) != 4 ||
               (unsigned int)dword_14BCFA4 > 0x7F ||
               FS_Read((char *)&v3, 4u, v0) != 4 || v3 != 2737408 ||
               FS_Read(byte_1224EA4, 0x298100u, v0) != 2720000 ||
               FS_Read(byte_14BCFA8, 0x4400u, v0) != 17408
           ? (v1 = 0)
           : (v1 = 1),
       FS_FCloseFile(v4[0]), v1)) {
    CL_SortGlobalServers();
  } else {
    dword_1224EA0 = 0;
    dword_14BCFA4 = 0;
  }
}

void __usercall CL_ParseDownload(long double a1 @<st0>, double a2 @<xmm0>,
                                 __m128 a3 @<xmm1>, __m128 a4 @<xmm2>,
                                 __m128 a5 @<xmm3>, __m128 a6 @<xmm4>,
                                 __m128 a7 @<xmm6>, msg_t *a8) {
  int Short;          // esi
  void *v9;           // ebx
  int Long;           // eax
  signed __int32 v11; // eax
  size_t v12;         // edi
  const char *v13;    // ebx
  int v14;            // eax
  int v15;            // eax
  void *v16;          // ebx
  char *v17;          // eax
  size_t v18;         // edx
  char *String;       // eax
  char *v20;          // eax
  char *v21;          // eax
  void *__dst;        // [esp+1Ch] [ebp-2Ch]
  LargeLocal v23;     // [esp+2Ch] [ebp-1Ch] BYREF

  LargeLocal::LargeLocal(&v23, 0x4000);
  __dst = (void *)LargeLocal::GetBuf(&v23);
  Short = MSG_ReadShort(a8);
  if (!Short) {
    v9 = clc;
    Long = MSG_ReadLong(a8);
    *(_DWORD *)((char *)&loc_40354 + (_DWORD)v9) = Long;
    *(_DWORD *)(legacyHacks + 16) = Long;
    if (*(int *)((char *)&loc_40354 + (_DWORD)v9) < 0) {
      String = MSG_ReadString(a8);
      v20 = va("%s", String);
      Com_Error(a1, *(float *)&a2, a3, a4, a5, a6, a7, 1, v20);
      goto LABEL_18;
    }
  }
  v11 = MSG_ReadShort(a8);
  v12 = v11;
  if (v11 > 0)
    MSG_ReadData(a8, __dst, v11);
  v13 = (const char *)clc;
  v14 = *((_DWORD *)clc + 65747);
  if (Short == v14) {
    if (!*(_DWORD *)((char *)&loc_40144 + (_DWORD)clc)) {
      if (!*((_BYTE *)clc + 262472)) {
        Com_Printf("Server sending download, but no download was requested\n");
        CL_AddReliableCommand("stopdl");
        goto LABEL_18;
      }
      v15 = FS_SV_FOpenFileWrite((char *)clc + 262472);
      *(_DWORD *)((char *)&loc_40144 + (_DWORD)v13) = v15;
      if (!v15) {
        Com_Printf("Could not create %s\n", v13 + 262472);
        CL_AddReliableCommand("stopdl");
        CL_NextDownload(a1, a2, a3, a4, a5, a6, a7);
        goto LABEL_18;
      }
    }
    if (v12)
      FS_Write((char *)__dst, v12,
               *(_DWORD *)((char *)&loc_40144 + (_DWORD)clc));
    v16 = clc;
    v17 = va("nextdl %d", *((_DWORD *)clc + 65747));
    CL_AddReliableCommand(v17);
    ++*((_DWORD *)v16 + 65747);
    v18 = *((_DWORD *)v16 + 65748) + v12;
    *((_DWORD *)v16 + 65748) = v18;
    *(_DWORD *)(legacyHacks + 20) = v18;
    if (!v12) {
      if (*(_DWORD *)((char *)&loc_40144 + (_DWORD)v16)) {
        FS_FCloseFile(*(_DWORD *)((char *)&loc_40144 + (_DWORD)v16));
        *(_DWORD *)((char *)&loc_40144 + (_DWORD)v16) = 0;
        FS_SV_Rename((char *)v16 + 262472, (char *)v16 + 262728);
      }
      *((_BYTE *)v16 + 262728) = 0;
      *((_BYTE *)v16 + 262472) = 0;
      *(_BYTE *)(legacyHacks + 28) = 0;
      CL_WritePacket();
      CL_WritePacket();
      CL_NextDownload(a1, a2, a3, a4, a5, a6, a7);
    }
  } else {
    Com_DPrintf("CL_ParseDownload: Expected block %d, got %d\n", v14, Short);
    if (Short > *((_DWORD *)v13 + 65747)) {
      Com_DPrintf("CL_ParseDownload: Sending retransmit request to get the "
                  "missed block\n");
      v21 = va("retransdl %d", *((_DWORD *)v13 + 65747));
      CL_AddReliableCommand(v21);
    }
  }
LABEL_18:
  LargeLocal::~LargeLocal(&v23);
}

int __cdecl compare_impact_files(const char **a1, const char **a2) {
  return stricmp(*a1, *a2);
}

void __usercall CG_RegisterImpactEffectsForDir(
    char *a1 @<eax>, int a2 @<edx>, char *a3 @<ecx>, long double a4 @<st0>,
    float a5 @<xmm0>, __m128 a6 @<xmm1>, __m128 a7 @<xmm2>, __m128 a8 @<xmm3>,
    __m128 a9 @<xmm4>, __m128 a10 @<xmm6>) {
  unsigned int FileList;        // eax
  int v12;                      // edx
  int i;                        // ecx
  int v14;                      // eax
  unsigned int v15;             // esi
  char *TempMemoryHighInternal; // ebx
  char *v17;                    // edi
  char *v18;                    // ebx
  int v19;                      // esi
  const char **v20;             // ebx
  char *v21;                    // eax
  const char *v22;              // ebx
  char *v23;                    // ebx
  size_t v24;                   // ecx
  char *TempMemoryInternal;     // eax
  const char *v26;              // [esp+2Ch] [ebp-404Ch]
  int __nel;                    // [esp+40h] [ebp-4038h]
  signed int v30;               // [esp+44h] [ebp-4034h]
  char *__src;                  // [esp+48h] [ebp-4030h]
  int v32;                      // [esp+4Ch] [ebp-402Ch]
  _DWORD __base[4096];          // [esp+58h] [ebp-4020h] BYREF
  char *j;                      // [esp+4058h] [ebp-20h] BYREF
  int v35[7];                   // [esp+405Ch] [ebp-1Ch] BYREF

  FileList = FS_GetFileList(a1, "csv", FS_LIST_PURE_ONLY, a3, 0x10000);
  __nel = FileList;
  if (FileList) {
    if (FileList > 0x1000)
      __nel = 4096;
    v26 = a3;
    v12 = 0;
    do {
      __base[v12] = v26;
      v26 += strlen(v26) + 1;
      ++v12;
    } while (__nel != v12);
    qsort(__base, __nel, 4u,
          (int(__cdecl *)(const void *, const void *))compare_impact_files);
    if (__nel > 0) {
      v32 = 0;
      for (i = 0;; i = v32) {
        __src = va("%s/%s", a1, (const char *)__base[i]);
        v14 = FS_FOpenFileByMode(__src, v35, FS_READ);
        v15 = v14;
        if (v14 >= 0) {
          TempMemoryHighInternal = (char *)Hunk_AllocateTempMemoryHighInternal(
              a4, a5, a6, a7, a8, a9, a10, v14 + 1);
          FS_Read(TempMemoryHighInternal, v15, v35[0]);
          FS_FCloseFile(v35[0]);
          TempMemoryHighInternal[v15] = 0;
          Com_BeginParseSession(__src);
          Com_SetCSV(1);
          for (j = TempMemoryHighInternal;;
               Com_SkipRestOfLine((unsigned __int8 **)&j)) {
            v17 = Com_Parse(&j);
            if (!j) {
            LABEL_14:
              v18 = 0;
              goto LABEL_19;
            }
            while (!*v17 || *v17 == 35) {
              Com_SkipRestOfLine((unsigned __int8 **)&j);
              v17 = Com_Parse(&j);
              if (!j)
                goto LABEL_14;
            }
            v19 = 0;
            v20 = (const char **)&g_TypeName;
            while (stricmp(*v20, v17)) {
              ++v19;
              ++v20;
              if (v19 == 11) {
                v18 =
                    va("unknown effect type '%s' in first column of file '%s'",
                       v17, __src);
                goto LABEL_19;
              }
            }
            v21 = Com_ParseOnLine(&j);
            v22 = v21;
            if (!*v21)
              break;
            v30 = Com_SurfaceTypeFromName(v21);
            if (v30 < 0) {
              v18 =
                  va("unknown surface type '%s' in second column of file '%s'",
                     v22, __src);
              goto LABEL_19;
            }
            v23 = Com_ParseOnLine(&j);
            v24 = strlen(v23) + 1;
            if ((int)(v24 - 1) > 63) {
              v18 = va("effect filename '%s' in third column of file '%s' is "
                       "longer than %i characters",
                       v23, __src, 63);
              goto LABEL_19;
            }
            TempMemoryInternal = (char *)Hunk_AllocateTempMemoryInternal(v24);
            *(_DWORD *)(4 * v30 + 92 * v19 + a2) = TempMemoryInternal;
            strcpy(TempMemoryInternal, v23);
          }
          v18 = va("missing surface type in second column of file '%s'", __src);
        LABEL_19:
          Com_EndParseSession();
          Hunk_ClearTempMemoryHigh();
          if (v18)
            break;
        }
        if (__nel == ++v32)
          return;
      }
      Com_Printf("^1ERROR: %s", v18);
    }
  }
}

int __cdecl G_ParseWeaponAccurayGraphs(WeaponDef *a1) {
  int32_t weapType; // eax
  unsigned int v3;  // ebx
  char *v4;         // eax
  int v5;           // esi
  float *i;         // ebx
  char *v7;         // eax
  float v8;         // xmm0_4
  char *v9;         // eax
  float v10;        // xmm0_4
  void *v11;        // eax
  WeaponDef *v12;   // [esp+1Ch] [ebp-210Ch]
  int v13;          // [esp+20h] [ebp-2108h]
  int v14;          // [esp+24h] [ebp-2104h]
  const char **v15; // [esp+3Ch] [ebp-20ECh]
  char v16[8192];   // [esp+48h] [ebp-20E0h] BYREF
  char __b[128];    // [esp+2048h] [ebp-E0h] BYREF
  char __src[64];   // [esp+20C8h] [ebp-60h] BYREF
  char *v19;        // [esp+2108h] [ebp-20h] BYREF
  int v20[7];       // [esp+210Ch] [ebp-1Ch] BYREF

  v12 = a1;
  v15 = (const char **)&accuracyDirName;
  while (1) {
    memset(__b, 0, sizeof(__b));
    weapType = a1->weapType;
    if (weapType && weapType != 2 || !**(_BYTE **)v12->accuracyGraphName)
      goto LABEL_4;
    sprintf(__src, "accuracy/%s/%s", *v15,
            *(const char **)v12->accuracyGraphName);
    v13 = FS_FOpenFileByMode(__src, v20, FS_READ);
    if (v13 < 0) {
      Com_Printf("^3WARNING: Could not load ai weapon accuracy file '%s'\n",
                 __src);
      return 0;
    }
    FS_Read(v16, 0xEu, v20[0]);
    v16[14] = 0;
    if (memcmp(v16, "WEAPONACCUFILE", 14)) {
      Com_Printf("^3WARNING: \"%s\" does not appear to be an ai weapon "
                 "accuracy file\n",
                 __src);
      goto LABEL_11;
    }
    v3 = v13 - 14;
    if (v13 - 14 > 0x1FFF) {
      Com_Printf("^3WARNING: \"%s\" Is too long of an ai weapon accuracy file "
                 "to parse\n",
                 __src);
    LABEL_11:
      FS_FCloseFile(v20[0]);
      return 0;
    }
    memset(v16, 0, sizeof(v16));
    FS_Read(v16, v3, v20[0]);
    v16[v3] = 0;
    FS_FCloseFile(v20[0]);
    v19 = v16;
    Com_BeginParseSession(__src);
    v4 = Com_Parse(&v19);
    v14 = atoi(v4);
    v5 = 0;
    for (i = (float *)&__b[4];; i += 2) {
      v7 = Com_Parse(&v19);
      if (!*v7)
        break;
      if (*v7 == 125)
        break;
      v8 = atof(v7);
      *(i - 1) = v8;
      v9 = Com_Parse(&v19);
      if (!*v9 || *v9 == 125)
        break;
      v10 = atof(v9);
      *i = v10;
      if (++v5 == 16) {
        Com_Printf("^3WARNING: \"%s\" has too many graph knots\n", __src);
        Com_EndParseSession();
        return 0;
      }
    }
    Com_EndParseSession();
    if (v14 != v5)
      break;
    if (v14 > 0) {
      v11 = Hunk_AllocLowAlignInternal(8 * v14, 4);
      LODWORD(v12->accuracyGraphKnots) = v11;
      memcpy(v11, __b, 8 * v14);
      LODWORD(v12->accuracyGraphKnotCount) = v14;
    }
  LABEL_4:
    v12 = (WeaponDef *)((char *)v12 + 4);
    if (++v15 == (const char **)&unk_314B48)
      return 1;
  }
  Com_Printf("^3WARNING: \"%s\" Error in parsing an ai weapon accuracy file\n",
             __src);
  return 0;
}

int __cdecl Sys_IsLANAddress(netadr_t a1) {
  int v2;  // edx
  char *i; // eax

  if (a1.type != 2 && a1.type) {
    if (a1.type != 4)
      return 0;
    if (LOBYTE(a1.ip) != 10 && LOBYTE(a1.ip) != 127 &&
        LOWORD(a1.ip) != 0xFEA9 &&
        (LOBYTE(a1.ip) != 0xAC || (BYTE1(a1.ip) & 0xF0) != 0x10) &&
        LOWORD(a1.ip) != 0xA8C0) {
      if (numIP <= 0)
        return 0;
      v2 = 0;
      for (i = &localIP; LOBYTE(a1.ip) != *i ||
                         *(_WORD *)((char *)&a1.ip + 1) != *(_WORD *)(i + 1);
           i += 4) {
        if (++v2 == numIP)
          return 0;
      }
    }
  }
  return 1;
}

void Sys_ShowIP(void) {
  int v0;              // esi
  unsigned __int8 *v1; // ebx

  if (numIP > 0) {
    v0 = 0;
    v1 = (unsigned __int8 *)byte_FF0D83;
    do {
      Com_Printf("IP: %i.%i.%i.%i\n", *(v1 - 3), *(v1 - 2), *(v1 - 1), *v1);
      ++v0;
      v1 += 4;
    } while (numIP > v0);
  }
}

_BOOL4 NET_GetDvars(void) {
  _BOOL4 v0; // ebx

  v0 = net_noudp && *(_BYTE *)(net_noudp + 7);
  net_noudp = (int)Dvar_RegisterBool("net_noudp", 0, 0x1021u);
  if (net_noipx && *(_BYTE *)(net_noipx + 7))
    v0 = 1;
  net_noipx = (int)Dvar_RegisterBool("net_noipx", 0, 0x1021u);
  if (net_socksEnabled && *(_BYTE *)(net_socksEnabled + 7))
    v0 = 1;
  net_socksEnabled = (int)Dvar_RegisterBool("net_socksEnabled", 0, 0x1021u);
  if (net_socksServer && *(_BYTE *)(net_socksServer + 7))
    v0 = 1;
  net_socksServer =
      (int)Dvar_RegisterString("net_socksServer", (DvarValue)&inData, 0x1021u);
  if (net_socksPort && *(_BYTE *)(net_socksPort + 7))
    v0 = 1;
  net_socksPort =
      (int)Dvar_RegisterInt("net_socksPort", 1080, 0, 0xFFFF, 0x1021u);
  if (net_socksUsername && *(_BYTE *)(net_socksUsername + 7))
    v0 = 1;
  net_socksUsername = (int)Dvar_RegisterString("net_socksUsername",
                                               (DvarValue)&inData, 0x1021u);
  if (net_socksPassword && *(_BYTE *)(net_socksPassword + 7))
    v0 = 1;
  net_socksPassword = (int)Dvar_RegisterString("net_socksPassword",
                                               (DvarValue)&inData, 0x1021u);
  return v0;
}

int __cdecl NET_Sleep(int a1) {
  int v1;     // ebx
  int result; // eax
  fd_set __b; // [esp+28h] [ebp-A0h] BYREF
  timeval v4; // [esp+A8h] [ebp-20h] BYREF

  if (ip_socket) {
    memset(&__b, 0, sizeof(__b));
    v1 = ip_socket;
    *(_DWORD *)&__b.fds_bits[4 * ((unsigned int)ip_socket >> 5)] |=
        1 << (ip_socket & 0x1F);
    v4.tv_sec = a1 / 1000;
    v4.tv_usec = 1000 * (a1 % 1000);
    return select(v1 + 1, &__b, 0, 0, &v4);
  }
  return result;
}

hostent *__cdecl Sys_StringToAdr(char *a1, netadr_t *a2) {
  hostent *result; // eax
  int32_t v3;      // [esp+14h] [ebp-24h]

  if (I_isdigit(*a1)) {
    v3 = inet_addr(a1);
  LABEL_6:
    a2->type = 4;
    a2->ip = v3;
    a2->port = 0;
    return (hostent *)1;
  }
  result = gethostbyname(a1);
  if (result) {
    v3 = **(_DWORD **)result->h_addr_list;
    goto LABEL_6;
  }
  return result;
}

int __cdecl Sys_GetPacket(netadr_t *a1, msg_t *a2) {
  int v2;           // ebx
  int v3;           // esi
  char *v5;         // eax
  _BYTE *data;      // eax
  int Error;        // eax
  int *v8;          // eax
  char *v9;         // eax
  __int128 v10;     // [esp+0h] [ebp-78h]
  signed int v11;   // [esp+2Ch] [ebp-4Ch]
  sockaddr v12;     // [esp+40h] [ebp-38h] BYREF
  __int64 v13;      // [esp+50h] [ebp-28h]
  int v14;          // [esp+58h] [ebp-20h]
  socklen_t v15[7]; // [esp+5Ch] [ebp-1Ch] BYREF

  v2 = 0;
LABEL_2:
  v3 = ip_socket;
  if (ip_socket)
    goto LABEL_7;
  while (1) {
    while (1) {
      while (1) {
        do {
          if (++v2 > 1)
            return 0;
          if (!v2)
            goto LABEL_2;
          v3 = ipx_socket;
        } while (!ipx_socket);
      LABEL_7:
        v15[0] = 16;
        v11 = recvfrom(v3, (void *)a2->data, a2->maxsize, 0, &v12, v15);
        if (v11 != -1)
          break;
        Error = WSAGetLastError();
        if (Error != 10035 && Error != 10054) {
          v8 = __error();
          v9 = strerror(*v8);
          Com_Printf("NET_GetPacket: %s\n", v9);
        }
      }
      if (v3 == ip_socket) {
        *(_DWORD *)&v12.sa_data[6] = 0;
        *(_DWORD *)&v12.sa_data[10] = 0;
      }
      if (!usingSocks || v3 != ip_socket ||
          memcmp((const char *)&v12, (const char *)&socksRelayAddr, v15[0]))
        break;
      if (v11 > 9) {
        data = (_BYTE *)a2->data;
        if (!*data && !data[1] && !data[2] && data[3] == 1) {
          a1->type = 4;
          a1->ip = *(_DWORD *)(a2->data + 4);
          a1->port = *(_WORD *)(a2->data + 8);
          a2->readcount = 10;
          goto LABEL_14;
        }
      }
    }
    if (v12.sa_family == 2) {
      a1->type = 4;
      a1->ip = *(_DWORD *)&v12.sa_data[2];
      a1->port = *(_WORD *)v12.sa_data;
    }
    a2->readcount = 0;
  LABEL_14:
    if (v11 != a2->maxsize)
      break;
    v13 = *(_QWORD *)&a1->type;
    v14 = *(_DWORD *)&a1->port;
    *(_QWORD *)&v10 = v13;
    DWORD2(v10) = v14;
    v5 = NET_AdrToString(v10);
    Com_Printf("Oversize packet from %s\n", v5);
  }
  a2->cursize = v11;
  return 1;
}

int __cdecl Sys_SendPacket(size_t __n, void *__src, netadr_t a3) {
  int v4;       // ebx
  ssize_t v5;   // eax
  int Error;    // eax
  int *v7;      // eax
  char *v8;     // eax
  char v9;      // [esp+8h] [ebp-30h]
  sockaddr v10; // [esp+20h] [ebp-18h] BYREF

  if (a3.type == 3 || a3.type == 4) {
    v4 = ip_socket;
    if (!ip_socket)
      return 1;
    memset(&v10, 0, sizeof(v10));
    v10.sa_family = 2;
    if (a3.type == 3) {
      *(_WORD *)v10.sa_data = a3.port;
      *(_DWORD *)&v10.sa_data[2] = -1;
    } else {
      *(_DWORD *)&v10.sa_data[2] = a3.ip;
      *(_WORD *)v10.sa_data = a3.port;
    }
    if (usingSocks && a3.type == 4) {
      socksBuf = 0;
      byte_FF0DE1 = 0;
      byte_FF0DE2 = 0;
      byte_FF0DE3 = 1;
      dword_FF0DE4 = *(_DWORD *)&v10.sa_data[2];
      word_FF0DE8 = *(_WORD *)v10.sa_data;
      memcpy(&unk_FF0DEA, __src, __n);
      v5 = sendto(v4, &socksBuf, __n + 10, 0, &socksRelayAddr, 0x10u);
    } else {
      v5 = sendto(ip_socket, __src, __n, 0, &v10, 0x10u);
    }
    if (v5 != -1)
      return 1;
    Error = WSAGetLastError();
    if (Error == 10035 || Error == 10049 && a3.type == 3) {
      return 1;
    } else {
      v7 = __error();
      v8 = strerror(*v7);
      Com_Printf("Sys_SendPacket: %s\n", v8);
      return 0;
    }
  } else {
    Com_Error(0, "\x15Sys_SendPacket: bad address type", v9);
    return 1;
  }
}

void NET_OpenIP(void) {
  dvar_s *v0;           // eax
  int v1;               // eax
  int v2;               // esi
  char *integer;        // edi
  int v4;               // ebx
  unsigned int v5;      // esi
  unsigned int v6;      // edi
  int v7;               // ecx
  int v8;               // eax
  unsigned int v9;      // ebx
  int v10;              // eax
  _BYTE *v11;           // eax
  int v12;              // edx
  unsigned __int32 v13; // eax
  int v14;              // ecx
  int *v15;             // eax
  char *v16;            // eax
  int *v17;             // eax
  char *v18;            // eax
  int *v19;             // eax
  char *v20;            // eax
  hostent *v21;         // eax
  int *v22;             // eax
  char *v23;            // eax
  int *v24;             // eax
  hostent *v25;         // eax
  int *v26;             // eax
  _BOOL4 v27;           // eax
  size_t v28;           // edx
  ssize_t v29;          // eax
  int *v30;             // eax
  char *v31;            // eax
  int *v32;             // eax
  int *v33;             // eax
  char *v34;            // eax
  int *v35;             // eax
  char *v36;            // eax
  int *v37;             // eax
  char *v38;            // eax
  int *v39;             // eax
  char *v40;            // eax
  ssize_t v41;          // eax
  size_t v42;           // esi
  unsigned int v43;     // kr04_4
  size_t v44;           // ebx
  ssize_t v45;          // eax
  int *v46;             // eax
  char *v47;            // eax
  int v48;              // [esp+2Ch] [ebp-29Ch]
  unsigned int v49;     // [esp+30h] [ebp-298h]
  int v50;              // [esp+34h] [ebp-294h]
  dvar_s *v51;          // [esp+38h] [ebp-290h]
  dvar_s *v52;          // [esp+3Ch] [ebp-28Ch]
  int v53;              // [esp+40h] [ebp-288h]
  int v54;              // [esp+44h] [ebp-284h]
  int v55;              // [esp+48h] [ebp-280h]
  char v56;             // [esp+58h] [ebp-270h] BYREF
  char __dst;           // [esp+258h] [ebp-70h] BYREF
  unsigned __int8 v58;  // [esp+259h] [ebp-6Fh]
  char v59;             // [esp+25Ah] [ebp-6Eh] BYREF
  unsigned __int8 v60;  // [esp+25Bh] [ebp-6Dh]
  int v61;              // [esp+25Ch] [ebp-6Ch]
  int v62;              // [esp+260h] [ebp-68h]
  unsigned int v63;     // [esp+26Ch] [ebp-5Ch]
  sockaddr v64;         // [esp+298h] [ebp-30h] BYREF
  int v65;              // [esp+2A8h] [ebp-20h] BYREF
  int v66[7];           // [esp+2ACh] [ebp-1Ch] BYREF

  v51 = Dvar_RegisterString("net_ip", (DvarValue) "localhost", 0x1020u);
  v0 = Dvar_RegisterInt("net_port", 28960, 0, 0xFFFF, 0x1020u);
  v52 = v0;
  v53 = 0;
  while (1) {
    v2 = v0->current.integer + v53;
    integer = (char *)v51->current.integer;
    v66[0] = 1;
    v65 = 1;
    if (integer)
      Com_Printf("Opening IP socket: %s:%i\n", integer, v2);
    else
      Com_Printf("Opening IP socket: localhost:%i\n", v2);
    v4 = socket(2, 2, 17);
    if (v4 != -1)
      break;
    if (WSAGetLastError() != 10047) {
      v19 = __error();
      v20 = strerror(*v19);
      Com_Printf("WARNING: UDP_OpenSocket: socket: %s\n", v20);
      v50 = 0;
      v1 = 0;
      goto LABEL_10;
    }
    ip_socket = 0;
  LABEL_11:
    if (++v53 == 10) {
      Com_Printf("WARNING: Couldn't allocate IP port\n");
      return;
    }
    v0 = v52;
  }
  if (ioctlsocket(v4, -2147195266, v66) == -1) {
    v17 = __error();
    v18 = strerror(*v17);
    Com_Printf("WARNING: UDP_OpenSocket: ioctl FIONBIO: %s\n", v18);
    v50 = 0;
    v1 = 0;
    goto LABEL_10;
  }
  v50 = v4;
  if (setsockopt(v4, 0xFFFF, 32, &v65, 4u) != -1) {
    if (integer && *integer && I_stricmp(integer, "localhost")) {
      *(_DWORD *)&v64.sa_len = 512;
      memset(&v64.sa_data[2], 0, 12);
      if (I_isdigit(*integer)) {
        *(_DWORD *)&v64.sa_data[2] = inet_addr(integer);
      } else {
        v21 = gethostbyname(integer);
        if (v21)
          *(_DWORD *)&v64.sa_data[2] = **(_DWORD **)v21->h_addr_list;
      }
    } else {
      *(_DWORD *)&v64.sa_data[2] = 0;
    }
    if (v2 == -1) {
      *(_WORD *)v64.sa_data = 0;
      v64.sa_family = 2;
      if (bind(v4, &v64, 0x10u) != -1) {
      LABEL_9:
        v1 = v4;
        goto LABEL_10;
      }
    } else {
      *(_WORD *)v64.sa_data = __ROL2__(v2, 8);
      v64.sa_family = 2;
      if (bind(v4, &v64, 0x10u) != -1)
        goto LABEL_9;
    }
    v15 = __error();
    v16 = strerror(*v15);
    Com_Printf("WARNING: UDP_OpenSocket: bind: %s\n", v16);
    closesocket(v4);
    v50 = 0;
    v1 = 0;
    goto LABEL_10;
  }
  v22 = __error();
  v23 = strerror(*v22);
  Com_Printf("WARNING: UDP_OpenSocket: setsockopt SO_BROADCAST: %s\n", v23);
  v50 = 0;
  v1 = 0;
LABEL_10:
  ip_socket = v1;
  if (!v50)
    goto LABEL_11;
  Dvar_SetInt(v52, v52->current.integer + v53);
  if (!*(_BYTE *)(net_socksEnabled + 8))
    goto LABEL_19;
  v54 = v52->current.integer + v53;
  usingSocks = 0;
  Com_Printf("Opening connection to SOCKS server.\n");
  socks_socket = socket(2, 1, 6);
  if (socks_socket == -1) {
    WSAGetLastError();
    v30 = __error();
    v31 = strerror(*v30);
    Com_Printf("WARNING: NET_OpenSocks: socket: %s\n", v31);
    goto LABEL_19;
  }
  v25 = gethostbyname(*(const char **)(net_socksServer + 8));
  if (!v25) {
    WSAGetLastError();
    v33 = __error();
    v34 = strerror(*v33);
    Com_Printf("WARNING: NET_OpenSocks: gethostbyname: %s\n", v34);
    goto LABEL_19;
  }
  if (v25->h_addrtype != 2) {
    Com_Printf("WARNING: NET_OpenSocks: gethostbyname: address type was not "
               "AF_INET\n");
    goto LABEL_19;
  }
  v64.sa_family = 2;
  *(_DWORD *)&v64.sa_data[2] = **(_DWORD **)v25->h_addr_list;
  *(_WORD *)v64.sa_data = __ROL2__(*(_WORD *)(net_socksPort + 8), 8);
  if (connect(socks_socket, &v64, 0x10u) == -1) {
    WSAGetLastError();
    v37 = __error();
    v38 = strerror(*v37);
    Com_Printf("NET_OpenSocks: connect: %s\n", v38);
    goto LABEL_19;
  }
  v27 = **(_BYTE **)(net_socksUsername + 8) ||
        **(_BYTE **)(net_socksPassword + 8);
  __dst = 5;
  if (v27) {
    v58 = 2;
    v28 = 4;
  } else {
    v58 = 1;
    v28 = 3;
  }
  v59 = v27 ? 2 : 0;
  if (send(socks_socket, &__dst, v28, 0) == -1)
    goto LABEL_77;
  v29 = recv(socks_socket, &__dst, 0x40u, 0);
  if (v29 == -1)
    goto LABEL_79;
  if (v29 != 2 || __dst != 5) {
  LABEL_71:
    Com_Printf("NET_OpenSocks: bad response\n");
    goto LABEL_19;
  }
  if (!v58)
    goto LABEL_83;
  if (v58 != 2) {
    Com_Printf("NET_OpenSocks: request denied\n");
    goto LABEL_19;
  }
  v49 = strlen(*(const char **)(net_socksUsername + 8)) + 1;
  v42 = v49 - 1;
  v43 = strlen(*(const char **)(net_socksPassword + 8)) + 1;
  v44 = v43 - 1;
  __dst = 1;
  v58 = v49 - 1;
  if (v49 != 1)
    memcpy(&v59, *(const void **)(net_socksUsername + 8), v42);
  *(&v59 + v42) = v44;
  if (v43 != 1)
    memcpy(&v59 + v49, *(const void **)(net_socksPassword + 8), v44);
  if (send(socks_socket, &__dst, v42 + v44 + 3, 0) == -1) {
  LABEL_77:
    WSAGetLastError();
    v35 = __error();
    v36 = strerror(*v35);
    Com_Printf("NET_OpenSocks: send: %s\n", v36);
    goto LABEL_19;
  }
  v45 = recv(socks_socket, &__dst, 0x40u, 0);
  if (v45 == -1)
    goto LABEL_79;
  if (v45 != 2 || __dst != 1)
    goto LABEL_71;
  if (v58) {
    Com_Printf("NET_OpenSocks: authentication failed\n");
    goto LABEL_19;
  }
LABEL_83:
  __dst = 5;
  v58 = 3;
  v59 = 0;
  v60 = 1;
  v61 = 0;
  LOWORD(v62) = __ROL2__(v54, 8);
  if (send(socks_socket, &__dst, 0xAu, 0) == -1) {
    WSAGetLastError();
    v46 = __error();
    v47 = strerror(*v46);
    Com_Printf("NET_OpenSocks: send: %s\n", v47);
  }
  v41 = recv(socks_socket, &__dst, 0x40u, 0);
  if (v41 == -1) {
  LABEL_79:
    WSAGetLastError();
    v39 = __error();
    v40 = strerror(*v39);
    Com_Printf("NET_OpenSocks: recv: %s\n", v40);
    goto LABEL_19;
  }
  if (v41 <= 1 || __dst != 5)
    goto LABEL_71;
  if (v58) {
    Com_Printf("NET_OpenSocks: request denied: %i\n", v58);
  } else if (v60 == 1) {
    socksRelayAddr.sa_family = 2;
    *(_DWORD *)&socksRelayAddr.sa_data[2] = v61;
    *(_WORD *)socksRelayAddr.sa_data = v62;
    *(_DWORD *)&socksRelayAddr.sa_data[6] = 0;
    *(_DWORD *)&socksRelayAddr.sa_data[10] = 0;
    usingSocks = 1;
  } else {
    Com_Printf("NET_OpenSocks: relay address is not IPV4: %i\n", v60);
  }
LABEL_19:
  numIP = 0;
  *(_DWORD *)&v64.sa_len = 512;
  *(_DWORD *)&v64.sa_data[2] = &v56;
  v55 = socket(2, 2, 0);
  if (v55 < 0) {
    v26 = __error();
    Com_Printf(
        "NET_GetLocalAddress: Unable to create temporary socket, errno = %d\n",
        *v26);
  } else if (ioctl(v55, 0xC0086924, &v64)) {
    v24 = __error();
    Com_Printf("NET_GetLocalAddress: Unable to get list of network interfaces, "
               "errno = %d\n",
               *v24);
  } else {
    v5 = *(_DWORD *)&v64.sa_data[2];
    v6 = *(_DWORD *)&v64.sa_data[2];
    v48 = *(_DWORD *)&v64.sa_len;
    if (*(_DWORD *)&v64.sa_data[2] <
        (unsigned int)(*(_DWORD *)&v64.sa_data[2] + *(_DWORD *)&v64.sa_len)) {
      do {
        if (*(_BYTE *)(v5 + 17) == 18) {
          v9 = v6;
          v7 = v48;
          if (v6 >= v6 + v48)
            goto LABEL_24;
          do {
            if (*(_BYTE *)(v9 + 17) == 2 &&
                !strncmp((const char *)v9, (const char *)v5, 0x10u)) {
              v11 = (_BYTE *)v5;
              v12 = 16;
              do {
                if (!*v11)
                  break;
                ++v11;
                --v12;
              } while (v12);
              if (*(_BYTE *)(v5 + 20) != 24) {
                strncpy(&__dst, (const char *)v9, 0x10u);
                if (ioctl(v55, 0xC020690D, &__dst) < 0) {
                  v32 = __error();
                  Com_Printf("NET_GetLocalAddress: Unable to get local address "
                             "for interface '%s', errno = %d\n",
                             (const char *)v9, *v32);
                } else {
                  v13 = _byteswap_ulong(v63);
                  v14 = numIP;
                  localIP[4 * numIP] = HIBYTE(v13);
                  byte_FF0D81[4 * v14] = BYTE2(v13);
                  byte_FF0D82[4 * v14] = BYTE1(v13);
                  byte_FF0D83[4 * v14] = v13;
                  Com_Printf("IP: %i.%i.%i.%i (%s)\n",
                             (unsigned __int8)localIP[4 * v14],
                             (unsigned __int8)byte_FF0D81[4 * v14],
                             (unsigned __int8)byte_FF0D82[4 * v14],
                             (unsigned __int8)v13, (const char *)v9);
                  ++numIP;
                }
                v6 = *(_DWORD *)&v64.sa_data[2];
                v48 = *(_DWORD *)&v64.sa_len;
              }
            }
            v10 = *(unsigned __int8 *)(v9 + 16) - 16;
            if (v10 < 0)
              v10 = 0;
            v9 += v10 + 32;
          } while (v9 < v6 + v48);
        }
        v7 = v48;
      LABEL_24:
        v8 = *(unsigned __int8 *)(v5 + 16) - 16;
        if (v8 < 0)
          v8 = 0;
        v5 += v8 + 32;
      } while (v5 < v6 + v7);
    }
    close(v55);
  }
}

void __cdecl NET_Config(int a1) {
  _BOOL4 Dvars; // edx
  int v3;       // eax
  int v4;       // esi

  Dvars = NET_GetDvars();
  if (*(_BYTE *)(net_noudp + 8) && *(_BYTE *)(net_noipx + 8))
    a1 = 0;
  if (a1 == networkingEnabled) {
    if (!Dvars || !a1)
      return;
    v4 = 1;
    goto LABEL_8;
  }
  if (a1) {
    v3 = 0;
    v4 = 1;
  } else {
    v3 = 1;
    v4 = 0;
  }
  networkingEnabled = a1;
  if (v3) {
  LABEL_8:
    if ((unsigned int)(ip_socket - 1) <= 0xFFFFFFFD) {
      closesocket(ip_socket);
      ip_socket = 0;
    }
    if ((unsigned int)(socks_socket - 1) <= 0xFFFFFFFD) {
      closesocket(socks_socket);
      socks_socket = 0;
    }
  }
  if (v4) {
    if (!*(_BYTE *)(net_noudp + 8))
      NET_OpenIP();
  }
}

void NET_Init(void) {
  int v0; // eax

  v0 = WSAStartup(257, winsockdata);
  if (v0) {
    Com_Printf("WARNING: Network initialization failed, returned %d\n", v0);
  } else {
    winsockInitialized = 1;
    Com_Printf("Network Initialized\n");
    NET_GetDvars();
    NET_Config(1);
  }
}

void NET_Restart(void) { NET_Config(networkingEnabled); }

int Voice_Init(void) {
  int v1;   // eax
  char *v2; // ebx

  winvoice_mic_mute = (int)Dvar_RegisterBool("winvoice_mic_mute", 1u, 0x1001u);
  winvoice_mic_reclevel = (int)Dvar_RegisterFloat(
      "winvoice_mic_reclevel", (DvarValue)1199570688, 0.0, 65535.0, 0x1001u);
  winvoice_save_voice =
      (int)Dvar_RegisterBool("winvoice_save_voice", 0, 0x1001u);
  winvoice_mic_scaler = (int)Dvar_RegisterFloat(
      "winvoice_mic_scaler", (DvarValue)1065353216, 0.25, 2.0, 0x1001u);
  g_current_bandwidth_setting = 0;
  if (!Record_Init())
    return 0;
  Sound_Init();
  Encode_Init(g_current_bandwidth_setting);
  Decode_Init(g_current_bandwidth_setting);
  mixerGetRecordSource(old_rec_source);
  mixerSetRecordSource();
  LOWORD(v1) = mixerGetRecordLevel();
  mic_old_reclevel = v1;
  mic_current_reclevel =
      (unsigned __int16)(int)*(float *)(winvoice_mic_reclevel + 8);
  mixerSetRecordLevel("Mic", (int)*(float *)(winvoice_mic_reclevel + 8));
  mixerSetMicrophoneMute(*(_BYTE *)(winvoice_mic_mute + 8));
  g_voice_initialized = 1;
  memset(s_clientTalkTime, 0, sizeof(s_clientTalkTime));
  v2 = (char *)&s_clientSamples;
  do {
    *(_DWORD *)v2 = Sound_NewSample();
    v2 += 4;
  } while (v2 != &playing);
  return 0;
}

long double Voice_GetVoiceLevel(void) {
  float v0; // xmm0_4
  int v1;   // ecx
  int *v2;  // eax

  v0 = 0.0;
  if (g_voice_initialized) {
    v1 = sampleCount;
    levelSamples[sampleCount % 6] =
        (float)(*(float *)&voice_current_voicelevel / 32767.0) / 6.0;
    sampleCount = v1 + 1;
    v0 = 0.0;
    v2 = (int *)levelSamples;
    do
      v0 = v0 + *(float *)v2++;
    while (v2 != &voice_current_voicelevel);
  }
  return v0;
}

void Voice_Playback(void) {
  dsound_sample_t **v0; // ebx

  if (g_voice_initialized) {
    if ((unsigned __int16)(int)*(float *)(winvoice_mic_reclevel + 8) !=
        mic_current_reclevel) {
      mic_current_reclevel =
          (unsigned __int16)(int)*(float *)(winvoice_mic_reclevel + 8);
      mixerSetRecordLevel("Mic", (int)*(float *)(winvoice_mic_reclevel + 8));
    }
    v0 = &s_clientSamples;
    do
      Sound_SampleFrame(*v0++);
    while (v0 != (dsound_sample_t **)&playing);
    Sound_Frame();
  }
}

_BOOL4 __cdecl Voice_IsClientTalking(int a1) {
  return Sys_Milliseconds() - s_clientTalkTime[a1] <= 299;
}

int Voice_Shutdown(void) {
  char *v0;   // ebx
  int result; // eax

  if (g_voice_initialized) {
    v0 = (char *)&s_clientSamples;
    do {
      Sound_DestroySample();
      v0 += 4;
    } while (&playing != v0);
    if (recording) {
      Record_Stop();
      Record_DestroySample();
      recording = 0;
    }
    Record_Shutdown();
    Encode_Shutdown();
    Decode_Shutdown();
    Sound_Shutdown();
    mixerSetMicrophoneMute(1);
    mixerSetRecordLevel("Mic", mic_old_reclevel);
    result = mixerSetRecordSource();
    g_voice_initialized = 0;
  }
  return result;
}

int Voice_GetLocalVoiceData() {
  __m128 v0; // xmm3
  __m128 v2; // xmm0

  if (g_voice_initialized) {
    if (!recording) {
      currentRecordingSample = (dsound_sample_t *)Record_NewSample();
      Record_Start(currentRecordingSample);
      recording = 1;
      ++Voice_StartRecording(void)::count;
    }
    v0.i32[0] = *(_DWORD *)(winvoice_mic_scaler + 8);
    if (v0.f32[0] != *(float *)&voice_current_scaler) {
      voice_current_scaler = *(_DWORD *)(winvoice_mic_scaler + 8);
      if (v0.f32[0] >= 0.5) {
        v2 = _mm_cmpge_ss((__m128)0x3FC00000u, v0);
        voice_current_scaler = _mm_andnot_ps(v2, (__m128)0x3FC00000u).u32[0] |
                               v0.i32[0] & v2.i32[0];
      } else {
        voice_current_scaler = 1056964608;
      }
    }
    Record_Frame();
  }
  return 0;
}

int __cdecl Record_Start(dsound_sample_t *a1) { return DSOUNDRecord_Start(a1); }

int Record_Stop() { return DSOUNDRecord_Stop(); }

int Record_NewSample(void) { return DSOUNDRecord_NewSample(); }

_BOOL4 Record_DestroySample() { return DSOUNDRecord_DestroySample(); }

void Record_Shutdown(void) {
  Encode_Shutdown();
  DSOUNDRecord_Shutdown();
}

void Record_Frame(void) { DSOUNDRecord_Frame(); }

int __cdecl Record_Init() {
  current_audioCallback = (int)Record_AudioCallback;
  return DSOUNDRecord_Init();
}

int __cdecl Decode_Init(int a1) {
  const SpeexMode *v1; // eax

  switch (a1) {
  case 1:
    v1 = (const SpeexMode *)&speex_wb_mode;
    goto LABEL_5;
  case 2:
    v1 = (const SpeexMode *)&speex_uwb_mode;
    goto LABEL_5;
  case 0:
    v1 = (const SpeexMode *)&speex_nb_mode;
  LABEL_5:
    g_decoder = (void *)speex_decoder_init(v1);
    speex_decoder_ctl(g_decoder);
    speex_decoder_ctl(g_decoder);
    speex_encoder_ctl(g_decoder);
    g_current_decode_bandwidth_setting = a1;
    speex_bits_init(&decodeBits);
    return 1;
  }
  Com_Printf("Unknown bandwidth mode %i\n", a1);
  return 0;
}

int __cdecl Decode_Sample(char *a1, int a2, __int16 *a3, int a4) {
  int v4;         // ecx
  int v6;         // edx
  float v7[4098]; // [esp+10h] [ebp-4008h]

  speex_bits_read_from(&decodeBits, a1, a2);
  if (speex_decode(g_decoder))
    return 0;
  v4 = 2 * a4;
  if (2 * a4 <= 0)
    return v4;
  v6 = 0;
  do {
    a3[v6] = (int)v7[v6];
    ++v6;
  } while (v6 != v4);
  return 2 * a4;
}

int __cdecl Encode_SetOptions(int a1, int a2) {
  int result; // eax

  speex_encoder_ctl(g_encoder);
  speex_encoder_ctl(g_encoder);
  speex_encoder_ctl(g_encoder);
  speex_encoder_ctl(g_encoder);
  speex_encoder_ctl(g_encoder);
  g_encoder_quality = a2;
  result = a1;
  g_encoder_samplerate = a1;
  return result;
}

_BOOL4 __cdecl Encode_Init(int a1) {
  const SpeexMode *v1; // eax

  switch (a1) {
  case 1:
    v1 = (const SpeexMode *)&speex_wb_mode;
    goto LABEL_5;
  case 2:
    v1 = (const SpeexMode *)&speex_uwb_mode;
    goto LABEL_5;
  case 0:
    v1 = (const SpeexMode *)&speex_nb_mode;
  LABEL_5:
    g_encoder = (void *)speex_encoder_init(v1);
    speex_bits_init(&encodeBits);
    g_speex_initialized = 1;
    Encode_SetOptions(g_encoder_samplerate, g_encoder_quality);
    speex_encoder_ctl(g_encoder);
    g_current_bandwidth_setting = a1;
    return g_encoder != 0;
  }
  Com_Printf("Unknown bandwidth mode %i\n", a1);
  return 0;
}

int Encode_Shutdown(void) {
  if (g_encoder)
    speex_encoder_destroy(g_encoder);
  g_encoder = 0;
  if (g_speex_initialized) {
    speex_bits_destroy(&encodeBits);
    g_speex_initialized = 0;
  }
  return 1;
}

int __cdecl Encode_Sample(__int16 *a1, char *a2, int a3) {
  if (*(_DWORD *)(sv_voiceQuality + 8) != g_encoder_quality) {
    g_encoder_quality = *(_DWORD *)(sv_voiceQuality + 8);
    speex_encoder_ctl(g_encoder);
  }
  speex_bits_reset(&encodeBits);
  speex_encode_int(g_encoder, a1, &encodeBits);
  return speex_bits_write(&encodeBits, a2, a3);
}

int Encode_GetFrameSize(void) { return g_frame_size; }

int __cdecl speex_encoder_init(const SpeexMode *a1) {
  return ((int (*)(void))a1->enc_init)();
}

int __cdecl speex_decoder_init(const SpeexMode *a1) {
  return ((int (*)(void))a1->dec_init)();
}

int __cdecl speex_encoder_destroy(void *a1) {
  return (*(int (**)(void))(*(_DWORD *)a1 + 24))();
}

int __cdecl speex_decoder_destroy(void *a1) {
  return (*(int (**)(void))(*(_DWORD *)a1 + 36))();
}

int __cdecl speex_encode_native(void *a1) {
  return (*(int (**)(void))(*(_DWORD *)a1 + 28))();
}

int __cdecl speex_decode_native(void *a1) {
  return (*(int (**)(void))(*(_DWORD *)a1 + 40))();
}

int __cdecl speex_encoder_ctl(void *a1) {
  return (*(int (**)(void))(*(_DWORD *)a1 + 44))();
}

int __cdecl speex_decode(void *a1) {
  return (*(int (**)(void))(*(_DWORD *)a1 + 40))();
}

int __cdecl speex_decoder_ctl(void *a1) {
  return (*(int (**)(void))(*(_DWORD *)a1 + 48))();
}

int __cdecl nb_mode_query(int *a1, int a2, int *a3) {
  int result; // eax
  int v4;     // eax

  if (a2) {
    if (a2 == 1) {
      result = *a3;
      if (*a3) {
        v4 = a1[result + 9];
        if (v4)
          *a3 = *(_DWORD *)(v4 + 64);
        else
          *a3 = -1;
        return 0;
      } else {
        *a3 = 5;
      }
    } else {
      speex_warning_int("Unknown nb_mode_query request: ", a2);
      return -1;
    }
  } else {
    *a3 = *a1;
    return 0;
  }
  return result;
}

int __cdecl wb_mode_query(_DWORD *a1, int a2, int *a3) {
  int result; // eax
  int v4;     // eax

  if (a2) {
    if (a2 == 1) {
      result = *a3;
      if (*a3) {
        v4 = a1[result + 10];
        if (v4)
          *a3 = *(_DWORD *)(v4 + 64);
        else
          *a3 = -1;
        return 0;
      } else {
        *a3 = 4;
      }
    } else {
      speex_warning_int("Unknown wb_mode_query request: ", a2);
      return -1;
    }
  } else {
    *a3 = 2 * a1[1];
    return 0;
  }
  return result;
}

int __cdecl speex_encode_int(void *a1, __int16 *a2, SpeexBits *a3) {
  int v3;        // ecx
  int v4;        // edx
  float v6[640]; // [esp+1Ch] [ebp-A0Ch] BYREF
  int v7[3];     // [esp+A1Ch] [ebp-Ch] BYREF

  (*(void(__cdecl **)(void *, int, int *))(*(_DWORD *)a1 + 44))(a1, 3, v7);
  v3 = v7[0];
  if (v7[0] > 0) {
    v4 = 0;
    do {
      v6[v4] = (float)a2[v4];
      ++v4;
    } while (v3 != v4);
  }
  return (*(int(__cdecl **)(void *, float *, SpeexBits *))(*(_DWORD *)a1 + 28))(
      a1, v6, a3);
}

int __cdecl Sound_UpdateSample(dsound_sample_t *a1, char *a2, unsigned int a3) {
  return DSound_UpdateSample(a1, a2, a3);
}

_BOOL4 Sound_DestroySample() { return Record_DestroySample(); }

void Sound_Frame(void) { DSound_Frame(); }

const void *__cdecl Sound_SampleFrame(dsound_sample_t *a1) {
  return DSound_SampleFrame(a1);
}

int __cdecl Sound_Init() { return DSound_Init(); }

void Sound_Shutdown(void) { DSound_Shutdown(); }

_BYTE *__cdecl speex_bits_init(SpeexBits *a1) {
  _BYTE *result; // eax

  result = (_BYTE *)speex_alloc(2000);
  a1->chars = (int32_t)result;
  a1->buf_size = 2000;
  *result = 0;
  a1->nbBits = 0;
  a1->charPtr = 0;
  a1->bitPtr = 0;
  a1->owner = 1;
  a1->overflow = 0;
  return result;
}

void __cdecl speex_bits_destroy(SpeexBits *a1) {
  if (a1->owner)
    speex_free((void *)a1->chars);
}

SpeexBits *__cdecl speex_bits_reset(SpeexBits *a1) {
  SpeexBits *result; // eax

  result = a1;
  *(_BYTE *)a1->chars = 0;
  a1->nbBits = 0;
  a1->charPtr = 0;
  a1->bitPtr = 0;
  a1->overflow = 0;
  return result;
}

int __cdecl speex_bits_read_from(SpeexBits *a1, char *a2, int a3) {
  signed int buf_size; // ebx
  int i;               // ecx
  int result;          // eax
  int32_t v6;          // eax

  buf_size = a3;
  if ((signed int)a1->buf_size < a3) {
    speex_warning_int("Packet if larger than allocated buffer: ", a3);
    if (a1->owner) {
      v6 = speex_realloc();
      if (v6) {
        a1->buf_size = a3;
        a1->chars = v6;
      } else {
        buf_size = a1->buf_size;
        speex_warning("Could not resize input buffer: truncating input");
      }
    } else {
      speex_warning("Do not own input buffer: truncating input");
      buf_size = a1->buf_size;
    }
  }
  if (buf_size > 0) {
    for (i = 0; i != buf_size; ++i)
      *(_BYTE *)(a1->chars + i) = a2[i];
  }
  result = 8 * buf_size;
  a1->nbBits = 8 * buf_size;
  a1->charPtr = 0;
  a1->bitPtr = 0;
  a1->overflow = 0;
  return result;
}

char *__cdecl speex_bits_pack(SpeexBits *a1, unsigned int a2, char *a3) {
  char *result;    // eax
  int v4;          // esi
  char *i;         // edi
  char *v6;        // edx
  size_t v7;       // edi
  char *v8;        // eax
  int32_t v9;      // esi
  const char *v10; // [esp+40h] [ebp+8h]

  if ((int)a1->charPtr + ((int)((int)a1->bitPtr + (unsigned int)a3) >> 3) >=
      (signed int)a1->buf_size) {
    speex_warning("Buffer too small to pack bits");
    if (a1->owner) {
      v7 = (signed int)(3 * a1->buf_size + 15) >> 1;
      v8 = (char *)speex_realloc();
      v9 = (int32_t)v8;
      if (v8) {
        speex_memset_bytes(v8, 0, v7);
        a1->buf_size = v7;
        a1->chars = v9;
        goto LABEL_2;
      }
      v10 = "Could not resize input buffer: not packing";
    } else {
      v10 = "Do not own input buffer: not packing";
    }
    return (char *)speex_warning(v10);
  }
LABEL_2:
  result = a3;
  if (a3) {
    v4 = (int)a3;
    for (i = 0; i != a3; ++i) {
      while (1) {
        *((_BYTE *)a1->charPtr + a1->chars) |= ((a2 >> --v4) & 1)
                                               << (7 - LOBYTE(a1->bitPtr));
        result = (char *)a1->bitPtr + 1;
        a1->bitPtr = result;
        if (result == (char *)8)
          break;
        ++a1->nbBits;
        if (a3 == ++i)
          return result;
      }
      a1->bitPtr = 0;
      v6 = (char *)a1->charPtr + 1;
      a1->charPtr = v6;
      result = (char *)a1->chars;
      v6[a1->chars] = 0;
      ++a1->nbBits;
    }
  }
  return result;
}

int __cdecl speex_bits_unpack_unsigned(SpeexBits *a1, int a2) {
  void *charPtr; // esi
  char *bitPtr;  // edx
  int v4;        // edi
  int32_t i;     // ecx
  void *v6;      // edx
  int32_t chars; // [esp+0h] [ebp-14h]
  int v9;        // [esp+4h] [ebp-10h]

  charPtr = a1->charPtr;
  bitPtr = (char *)a1->bitPtr;
  if ((int)&bitPtr[8 * (_DWORD)charPtr + a2] > a1->nbBits)
    a1->overflow = 1;
  if (a1->overflow || !a2)
    return 0;
  v4 = 0;
  v9 = 0;
  chars = a1->chars;
  for (i = a1->chars;; i = chars) {
    v4 = (*((char *)charPtr + i) >> (7 - (_BYTE)bitPtr)) & 1 | (2 * v4);
    v6 = bitPtr + 1;
    a1->bitPtr = v6;
    if (v6 == (void *)8) {
      a1->bitPtr = 0;
      a1->charPtr = (char *)charPtr + 1;
    }
    if (a2 == ++v9)
      break;
    charPtr = a1->charPtr;
    bitPtr = (char *)a1->bitPtr;
  }
  return v4;
}

int __cdecl speex_bits_peek(SpeexBits *a1) {
  void *charPtr; // ecx
  void *bitPtr;  // ebx

  charPtr = a1->charPtr;
  bitPtr = a1->bitPtr;
  if ((int)bitPtr + 8 * (int)charPtr + 1 > a1->nbBits)
    a1->overflow = 1;
  if (a1->overflow)
    return 0;
  else
    return (*((char *)charPtr + a1->chars) >> (7 - (_BYTE)bitPtr)) & 1;
}

char *__cdecl speex_bits_advance(SpeexBits *a1, int a2) {
  void *charPtr; // ebx
  char *bitPtr;  // edx
  char *result;  // eax
  int v5;        // edx

  charPtr = a1->charPtr;
  bitPtr = (char *)a1->bitPtr;
  result = &bitPtr[8 * (_DWORD)charPtr + a2];
  if ((int)result > a1->nbBits || (result = (char *)a1->overflow) != 0) {
    a1->overflow = 1;
  } else {
    v5 = (int)&bitPtr[a2];
    result = (char *)charPtr + (v5 >> 3);
    a1->charPtr = result;
    a1->bitPtr = (void *)(v5 & 7);
  }
  return result;
}

unsigned int __cdecl speex_bits_remaining(SpeexBits *a1) {
  if (a1->overflow)
    return -1;
  else
    return a1->nbBits - ((unsigned int)a1->bitPtr + 8 * (int)a1->charPtr);
}

int __cdecl speex_bits_write(SpeexBits *a1, char *a2, int a3) {
  int bitPtr;     // esi
  int32_t nbBits; // edi
  int v5;         // ecx
  int i;          // edx
  void *charPtr;  // [esp+1Ch] [ebp-1Ch]

  bitPtr = (int)a1->bitPtr;
  charPtr = a1->charPtr;
  nbBits = a1->nbBits;
  if (bitPtr <= 6)
    speex_bits_pack(a1, 0, (char *)1);
  while ((int)a1->bitPtr <= 6) {
    speex_bits_pack(a1, 1u, (char *)1);
    if ((int)a1->bitPtr > 6)
      break;
    speex_bits_pack(a1, 1u, (char *)1);
  }
  a1->bitPtr = (void *)bitPtr;
  a1->charPtr = charPtr;
  a1->nbBits = nbBits;
  v5 = (nbBits + 7) >> 3;
  if (a3 <= v5)
    v5 = a3;
  if (v5 > 0) {
    for (i = 0; i != v5; ++i)
      a2[i] = *(_BYTE *)(a1->chars + i);
  }
  return v5;
}

void *__cdecl speex_alloc(size_t __size) { return Z_MallocInternal(__size); }

int speex_realloc() { return 0; }

void __cdecl speex_free(void *a1) { Z_FreeInternal(a1); }

void *__cdecl speex_move(void *__dst, const void *__src, size_t __len) {
  return memmove(__dst, __src, __len);
}

void __cdecl __noreturn speex_error(const char *a1) {
  fprintf((FILE *)&__sF + 2, "Fatal error: %s\n", a1);
  j__exit(1);
}

int __cdecl speex_warning(const char *a1) {
  return fprintf((FILE *)&__sF + 2, "warning: %s\n", a1);
}

int __cdecl speex_warning_int(const char *a1, int a2) {
  return fprintf((FILE *)&__sF + 2, "warning: %s %d\n", a1, a2);
}

void __cdecl speex_rand_vec(float a1, float *a2, int a3) {
  int i;     // esi
  float v5;  // xmm0_4
  double v6; // [esp+0h] [ebp-28h]

  if (a3 > 0) {
    for (i = 0; i != a3; ++i) {
      v6 = *a2;
      v5 = ((float)((float)rand() * 4.6566129e-10) - 0.5) * (a1 * 3.0) + v6;
      *a2++ = v5;
    }
  }
}

long double __cdecl speex_rand(float a1) {
  return (float)((float)(a1 * 3.0) *
                 ((float)((float)rand() * 4.6566129e-10) - 0.5));
}

int __cdecl speex_mode_query(const SpeexMode *a1) {
  return ((int(__cdecl *)(int32_t))a1->query)(a1->mode);
}

int __cdecl split_cb_shape_sign_unquant(float *a1, int *a2, int a3,
                                        SpeexBits *a4, char *a5) {
  int v5;     // edi
  int result; // eax
  char *v7;   // edx
  int v8;     // ebx
  int v9;     // esi
  float i;    // xmm0_4
  float *v11; // ecx
  int j;      // ebx
  float v13;  // xmm1_4
  int v14;    // [esp+1Ch] [ebp-3Ch]
  int v15;    // [esp+24h] [ebp-34h]
  char *v16;  // [esp+28h] [ebp-30h]
  char *v17;  // [esp+2Ch] [ebp-2Ch]
  int v18;    // [esp+30h] [ebp-28h]
  int v19;    // [esp+34h] [ebp-24h]
  int v20;    // [esp+3Ch] [ebp-1Ch]

  v5 = *a2;
  v19 = a2[1];
  v18 = a2[2];
  result = 4 * v19;
  v7 = &a5[4 * v19 + ((4 - (_BYTE)a5) & 3)];
  v16 = &a5[(4 - (_BYTE)a5) & 3];
  v17 = &v7[(4 - (_BYTE)v7) & 3];
  if (v19 > 0) {
    v8 = 0;
    v9 = 0;
    if (a2[4]) {
      do {
        *(_DWORD *)&v17[4 * v8] = speex_bits_unpack_unsigned(a4, 1);
        *(_DWORD *)&v16[v9] = speex_bits_unpack_unsigned(a4, a2[3]);
        ++v8;
        v9 += 4;
      } while (v19 != v8);
    } else {
      do {
        *(_DWORD *)&v17[4 * v8] = 0;
        *(_DWORD *)&v16[v9] = speex_bits_unpack_unsigned(a4, a2[3]);
        ++v8;
        v9 += 4;
      } while (v19 != v8);
    }
    v20 = 0;
    v15 = 0;
    v14 = 0;
    if (!*(_DWORD *)v17)
      goto LABEL_12;
  LABEL_6:
    for (i = -1.0;; i = 1.0) {
      if (v5 > 0) {
        v11 = &a1[v15];
        for (j = 0; j != v5; ++j) {
          v13 = *v11 + (double)*(char *)(j + v18 + *(_DWORD *)&v16[v14] * v5) *
                           (i * 0.03125);
          *v11++ = v13;
        }
      }
      ++v20;
      result = 4 * v5;
      v15 += v5;
      if (v19 == v20)
        break;
      v14 = 4 * v20;
      if (*(_DWORD *)&v17[4 * v20])
        goto LABEL_6;
    LABEL_12:;
    }
  }
  return result;
}

int __cdecl noise_codebook_quant(float *a1, float *a2, float *a3, float *a4,
                                 const void *a5, int a6, int a7, float *a8,
                                 float *a9, SpeexBits *a10, char *a11) {
  float *v11; // esi
  int result; // eax
  int i;      // ecx

  v11 = (float *)&a11[-(int)a11 & 3];
  result = residue_percep_zero(a1, a2, a3, a4, v11, a7, a6, (char *)&v11[a7]);
  if (a7 > 0) {
    for (i = 0; i != a7; ++i)
      a8[i] = a8[i] + v11[i];
    for (result = 0; result != a7; ++result)
      a1[result] = 0.0;
  }
  return result;
}

int __cdecl noise_codebook_unquant(float *a1, const void *a2, int a3) {
  return speex_rand_vec(1.0, a1, a3);
}

int __cdecl split_cb_search_shape_sign(float *a1, float *a2, float *a3,
                                       float *a4, int *a5, int a6, int a7,
                                       float *a8, float *a9, SpeexBits *a10,
                                       char *a11, int a12, int a13) {
  int v13;           // eax
  int v14;           // esi
  int v15;           // ecx
  int v16;           // ecx
  int i;             // ecx
  float *v18;        // edi
  char *v19;         // edx
  int j;             // ecx
  int v21;           // ecx
  float *v22;        // edx
  int v23;           // eax
  float v24;         // xmm1_4
  float v25;         // xmm1_4
  int result;        // eax
  float v27;         // xmm1_4
  int v28;           // edi
  float *v29;        // ecx
  float *v30;        // eax
  int jj;            // edx
  double v32;        // xmm1_8
  char *v33;         // ecx
  float *v34;        // edx
  int ii;            // ebx
  float v36;         // xmm0_4
  float *v37;        // ebx
  int v38;           // edx
  double v39;        // xmm1_8
  float v40;         // xmm2_4
  float *v41;        // edx
  int v42;           // ecx
  int k;             // ecx
  int v44;           // esi
  char *v45;         // edx
  int v46;           // edx
  int v47;           // edx
  int v48;           // edx
  int v49;           // ecx
  int v50;           // eax
  int v51;           // eax
  int v52;           // eax
  int v53;           // edx
  int v54;           // ebx
  int v55;           // ecx
  int v56;           // eax
  int v57;           // eax
  int v58;           // eax
  int v59;           // eax
  int v60;           // eax
  int kk;            // eax
  int v62;           // eax
  int mm;            // ebx
  _DWORD *v64;       // ecx
  int nn;            // ecx
  int i1;            // esi
  int i2;            // ebx
  char *v68;         // esi
  float *v69;        // edi
  char *v70;         // edx
  int i3;            // ecx
  float *v72;        // ebx
  int v73;           // ecx
  float *v74;        // edx
  int v75;           // eax
  float v76;         // xmm1_4
  float v77;         // xmm1_4
  int i4;            // eax
  float *v79;        // eax
  int v80;           // esi
  _DWORD *v81;       // ecx
  _DWORD *v82;       // edx
  int v83;           // ebx
  int v84;           // eax
  float *v85;        // ecx
  float *v86;        // eax
  int i5;            // edx
  float v88;         // xmm3_4
  float *v89;        // eax
  int v90;           // edx
  int v91;           // edx
  _DWORD *v92;       // ecx
  _DWORD *v93;       // edx
  int v94;           // ebx
  float *v95;        // ebx
  int i7;            // esi
  int v97;           // edx
  double v98;        // xmm1_8
  float v99;         // xmm2_4
  float *v100;       // eax
  float *v101;       // edx
  int v102;          // ecx
  int v103;          // edi
  int v104;          // ebx
  int v105;          // ecx
  int i8;            // ebx
  int v107;          // ebx
  _DWORD *v108;      // ecx
  int v109;          // esi
  int v110;          // ebx
  _DWORD *i9;        // eax
  float *v112;       // eax
  int i6;            // edx
  float v114;        // xmm0_4
  int i10;           // esi
  int i11;           // ebx
  int i12;           // ecx
  char *v118;        // eax
  int i13;           // ebx
  unsigned int v120; // ecx
  int v121;          // esi
  int v122;          // edi
  float v123;        // xmm0_4
  double v124;       // xmm1_8
  float *v125;       // ecx
  int v126;          // ebx
  char *v127;        // edx
  float v128;        // xmm0_4
  int i14;           // ecx
  int i15;           // ecx
  int m;             // ecx
  float *v132;       // eax
  int n;             // edx
  int v134;          // [esp+3Ch] [ebp-17Ch]
  int v135;          // [esp+48h] [ebp-170h]
  float *v136;       // [esp+4Ch] [ebp-16Ch]
  int v137;          // [esp+74h] [ebp-144h]
  unsigned int v138; // [esp+78h] [ebp-140h]
  int v139;          // [esp+7Ch] [ebp-13Ch]
  int v140;          // [esp+80h] [ebp-138h]
  int v141;          // [esp+84h] [ebp-134h]
  int v142;          // [esp+88h] [ebp-130h]
  int v143;          // [esp+8Ch] [ebp-12Ch]
  int v144;          // [esp+90h] [ebp-128h]
  char *v145;        // [esp+94h] [ebp-124h]
  int v146;          // [esp+98h] [ebp-120h]
  int *v147;         // [esp+9Ch] [ebp-11Ch]
  int v148;          // [esp+A4h] [ebp-114h]
  int v149;          // [esp+A8h] [ebp-110h]
  int v150;          // [esp+ACh] [ebp-10Ch]
  float *v151;       // [esp+B0h] [ebp-108h]
  int v152;          // [esp+B4h] [ebp-104h]
  int v153;          // [esp+B8h] [ebp-100h]
  float *v154;       // [esp+BCh] [ebp-FCh]
  float *v155;       // [esp+C0h] [ebp-F8h]
  int v156;          // [esp+C4h] [ebp-F4h]
  float *v157;       // [esp+C8h] [ebp-F0h]
  float *v158;       // [esp+CCh] [ebp-ECh]
  float *v159;       // [esp+D0h] [ebp-E8h]
  int v160;          // [esp+D4h] [ebp-E4h]
  char *v161;        // [esp+D8h] [ebp-E0h]
  int v162;          // [esp+DCh] [ebp-DCh]
  char *v163;        // [esp+E0h] [ebp-D8h]
  char *v164;        // [esp+E4h] [ebp-D4h]
  _DWORD *v165;      // [esp+E8h] [ebp-D0h]
  int v166;          // [esp+ECh] [ebp-CCh]
  int v167;          // [esp+F0h] [ebp-C8h]
  int v168;          // [esp+F4h] [ebp-C4h]
  int v169;          // [esp+F8h] [ebp-C0h]
  int v170;          // [esp+FCh] [ebp-BCh]
  int v171;          // [esp+100h] [ebp-B8h]
  int v172;          // [esp+104h] [ebp-B4h]
  int *v173;         // [esp+108h] [ebp-B0h]
  float *v174;       // [esp+10Ch] [ebp-ACh]
  int v175;          // [esp+110h] [ebp-A8h]
  int v176;          // [esp+118h] [ebp-A0h]
  float *v177;       // [esp+11Ch] [ebp-9Ch]
  int v178;          // [esp+120h] [ebp-98h]
  int v179;          // [esp+124h] [ebp-94h]
  int v180;          // [esp+128h] [ebp-90h]
  int v181;          // [esp+12Ch] [ebp-8Ch]
  float *v182;       // [esp+130h] [ebp-88h]
  float *v183;       // [esp+134h] [ebp-84h]
  int v184;          // [esp+138h] [ebp-80h]
  int v185;          // [esp+13Ch] [ebp-7Ch]
  int v186;          // [esp+148h] [ebp-70h]
  int v187;          // [esp+150h] [ebp-68h]
  int v188;          // [esp+154h] [ebp-64h]
  int v189;          // [esp+158h] [ebp-60h]
  int v190;          // [esp+15Ch] [ebp-5Ch]
  char *v191;        // [esp+160h] [ebp-58h]
  float *v192;       // [esp+168h] [ebp-50h]
  int v193;          // [esp+16Ch] [ebp-4Ch]
  int v194;          // [esp+170h] [ebp-48h]
  int v195;          // [esp+174h] [ebp-44h]
  int v196;          // [esp+178h] [ebp-40h]
  int v197;          // [esp+17Ch] [ebp-3Ch]
  int v198;          // [esp+180h] [ebp-38h]
  int v199;          // [esp+184h] [ebp-34h]
  int v200;          // [esp+188h] [ebp-30h]
  int v201;          // [esp+18Ch] [ebp-2Ch]
  float v202;        // [esp+198h] [ebp-20h] BYREF
  int v203[7];       // [esp+19Ch] [ebp-1Ch] BYREF

  v13 = a12;
  if (a12 > 10) {
    v172 = 10;
    v13 = 10;
  } else {
    if (a12 <= 1) {
      v14 = *a5;
      v178 = a5[1];
      v15 = a5[3];
      v181 = 1 << v15;
      v184 = a5[2];
      v179 = a5[4];
      v183 = (float *)&a11[(4 - (_BYTE)a11) & 3];
      v182 = (float *)((char *)&v183[v14 * (1 << v15)] +
                       ((4 - ((_BYTE)a11 + ((4 - (_BYTE)a11) & 3) +
                              4 * (_BYTE)v14 * (1 << v15))) &
                        3));
      v16 = (int)&v182[(1 << v15) + a7] +
            ((4 - ((_BYTE)v182 + 4 * (1 << v15))) & 3);
      v176 = v16 - 4 * a7;
      v180 = 4 * a7 + ((4 - (_BYTE)v16) & 3) + v16;
      v177 = (float *)(((4 - (_BYTE)v16) & 3) + v16);
      if (a7 > 0) {
        for (i = 0; i != a7; ++i)
          *(float *)(v176 + 4 * i) = a1[i];
      }
      v192 = (float *)(v180 + (-v180 & 3));
      if (v181 > 0) {
        v185 = 0;
        v18 = v182;
        v137 = 0;
        do {
          if (v14 > 0) {
            v19 = (char *)(v137 + v184);
            for (j = 0; j != v14; ++j)
              v192[j] = (float)*v19++;
          }
          *v18 = 0.0;
          if (v14 > 0) {
            v136 = a9;
            v21 = 0;
            v22 = a9;
          LABEL_13:
            v23 = 0;
            v24 = 0.0;
            do
              v24 = v24 + (float)(v192[v23++] * *v22--);
            while (v21 >= v23);
            v25 = v24 * 0.03125;
            while (1) {
              *v18 = (float)(v25 * v25) + *v18;
              v183[v137 + v21++] = v25;
              ++v136;
              if (v14 == v21)
                break;
              v25 = 0.0;
              if (v21 >= 0) {
                v22 = v136;
                goto LABEL_13;
              }
            }
          }
          ++v185;
          v137 += v14;
          ++v18;
        } while (v181 != v185);
      }
      result = v178;
      if (v178 <= 0) {
      LABEL_40:
        if (a7 > 0) {
          for (k = 0; k != a7; ++k) {
            result = 4 * k;
            a8[k] = a8[k] + v177[k];
          }
        }
        if (a13) {
          result = syn_percep_zero(v177, a2, a3, a4, v192, a7, a6,
                                   (char *)&v192[a7]);
          if (a7 > 0) {
            for (m = 0; m != a7; ++m) {
              result = 4 * m;
              a1[m] = a1[m] - v192[m];
            }
          }
        }
        return result;
      }
      v193 = 0;
      v140 = 0;
      v139 = 0;
      v138 = 4 * v14;
      while (1) {
        if (v179)
          vq_nbest_sign((float *)(v139 + v176), v183, v14, v181, v182, 1, v203,
                        &v202);
        else
          vq_nbest((float *)(v139 + v176), v183, v14, v181, v182, 1, v203,
                   &v202);
        speex_bits_pack(a10, v203[0], (char *)(a5[3] + v179));
        result = v203[0];
        if (v181 <= v203[0]) {
          result = v203[0] - v181;
          v27 = -1.0;
        } else {
          v27 = 1.0;
        }
        v28 = v14 * result;
        v29 = &v183[v14 * result];
        if (v27 <= 0.0) {
          if (v14 > 0) {
            v132 = (float *)(v139 + v176);
            for (n = 0; n != v14; ++n) {
              *v132 = *v132 + v29[n];
              ++v132;
            }
          LABEL_30:
            v32 = v27 * 0.03125;
            v33 = (char *)(v28 + v184);
            v34 = (float *)((char *)v177 + v139);
            for (ii = 0; ii != v14; ++ii) {
              v36 = (double)*v33 * v32;
              *v34 = v36;
              ++v33;
              ++v34;
            }
            ++v193;
            v139 += v138;
            v140 += v14;
            v37 = &a9[v138 / 4];
            v201 = 0;
            v149 = v203[0];
            do {
              v38 = v149;
              if (v181 <= v149) {
                v38 = v149 - v181;
                v39 = -1.0;
              } else {
                v39 = 1.0;
              }
              v40 = v39 * 0.03125 * (double)*(char *)(v184 + v201 + v14 * v38);
              result = v140;
              if (a7 > v140) {
                result = v139 + v176;
                v41 = v37;
                v42 = 0;
                do {
                  *(float *)result = *(float *)result - (float)(v40 * *v41);
                  ++v42;
                  result += 4;
                  ++v41;
                } while (v42 != a7 - v140);
              }
              ++v201;
              --v37;
            } while (v14 != v201);
            goto LABEL_39;
          }
        } else if (v14 > 0) {
          v30 = (float *)(v139 + v176);
          for (jj = 0; jj != v14; ++jj) {
            *v30 = *v30 - v29[jj];
            ++v30;
          }
          goto LABEL_30;
        }
        ++v193;
        v139 += v138;
        v140 += v14;
      LABEL_39:
        if (v178 <= v193)
          goto LABEL_40;
      }
    }
    v172 = a12;
  }
  v44 = 4 * v13;
  v45 = &a11[4 * v13 + ((4 - (_BYTE)a11) & 3)];
  v161 = &a11[(4 - (_BYTE)a11) & 3];
  v46 = (int)&v45[4 * v13 + ((4 - (_BYTE)v45) & 3)];
  v162 = v46 - 4 * v13;
  v47 = 4 * v13 + ((4 - (_BYTE)v46) & 3) + v46;
  v166 = v47 - 4 * v13;
  v48 = 4 * v13 + ((4 - (_BYTE)v47) & 3) + v47;
  v165 = (_DWORD *)(v48 - 4 * v13);
  v170 = *a5;
  v171 = a5[1];
  v49 = a5[3];
  v169 = 1 << v49;
  v168 = a5[2];
  v175 = a5[4];
  v154 = (float *)(((4 - (_BYTE)v48) & 3) + v48);
  v155 = (float *)((char *)&v154[(1 << v49) * v170] +
                   ((4 - ((_BYTE)v154 + 4 * (1 << v49) * (_BYTE)v170)) & 3));
  v50 = (int)&v155[v169 + a7] + ((4 - ((_BYTE)v155 + 4 * (_BYTE)v169)) & 3);
  v156 = (int)&v155[v169] + ((4 - ((_BYTE)v155 + 4 * (_BYTE)v169)) & 3);
  v51 = 4 * a7 + ((4 - (_BYTE)v50) & 3) + v50;
  v157 = (float *)(v51 - 4 * a7);
  v52 = 4 * a7 + ((4 - (_BYTE)v51) & 3) + v51;
  v158 = (float *)(v52 - 4 * a7);
  v167 = ((4 - (_BYTE)v52) & 3) + v52;
  v53 = ((4 - ((_BYTE)v167 + 4 * (_BYTE)v171)) & 3) + v167 + 4 * v171;
  v196 = v53 + 8 * v172 * a7;
  v54 = 0;
  v55 = v53 + 4 * a7;
  v134 = 8 * a7;
  do {
    v135 = 4 * v54;
    *(_DWORD *)&v161[v135] = v53;
    *(_DWORD *)(v162 + v135) = v55;
    ++v54;
    v53 += v134;
    v55 += v134;
  } while (v172 != v54);
  v56 = v44 + v196 + ((4 - (_BYTE)v196) & 3);
  v173 = (int *)(v196 + ((4 - (_BYTE)v196) & 3));
  v57 = v44 + ((4 - (_BYTE)v56) & 3) + v56;
  v174 = (float *)(v57 - v44);
  v58 = v44 + ((4 - (_BYTE)v57) & 3) + v57;
  v159 = (float *)(v58 - v44);
  v59 = v44 + ((4 - (_BYTE)v58) & 3) + v58;
  v160 = v59 - v44;
  v60 = ((4 - (_BYTE)v59) & 3) + v59;
  v197 = v60 + 8 * v172 * v171;
  v199 = 0;
  v143 = v60 + 4 * v171;
  v142 = v60;
  v141 = 8 * v171;
  for (kk = 0;; kk = v199) {
    v62 = kk;
    v165[v62] = v142;
    *(_DWORD *)(v62 * 4 + v166) = v143;
    if (v171 > 0) {
      for (mm = 0; mm != v171; ++mm) {
        v64 = (_DWORD *)(v165[v62] + 4 * mm);
        *(_DWORD *)(*(_DWORD *)(v62 * 4 + v166) + 4 * mm) = -1;
        *v64 = -1;
      }
    }
    ++v199;
    v142 += v141;
    v143 += v141;
    if (v172 == v199)
      break;
  }
  if (a7 > 0) {
    for (nn = 0; nn != a7; ++nn)
      *(float *)(v156 + 4 * nn) = a1[nn];
  }
  for (i1 = 0; i1 != v172; ++i1) {
    if (a7 > 0) {
      for (i2 = 0; i2 != a7; ++i2)
        *(_DWORD *)(*(_DWORD *)&v161[4 * i1] + 4 * i2) =
            *(_DWORD *)(v156 + 4 * i2);
    }
  }
  v68 = (char *)((-v197 & 3) + v197);
  if (v169 > 0) {
    v186 = 0;
    v69 = v155;
    v144 = 0;
    do {
      if (v170 > 0) {
        v70 = (char *)(v144 + v168);
        for (i3 = 0; i3 != v170; ++i3)
          *(float *)&v68[4 * i3] = (float)*v70++;
      }
      *v69 = 0.0;
      if (v170 > 0) {
        v72 = a9;
        v73 = 0;
      LABEL_69:
        v74 = v72;
        v75 = 0;
        v76 = 0.0;
        do
          v76 = v76 + (float)(*(float *)&v68[4 * v75++] * *v74--);
        while (v73 >= v75);
        v77 = v76 * 0.03125;
        while (1) {
          *v69 = (float)(v77 * v77) + *v69;
          v154[v144 + v73++] = v77;
          ++v72;
          if (v170 == v73)
            break;
          v77 = 0.0;
          if (v73 >= 0)
            goto LABEL_69;
        }
      }
      ++v186;
      v144 += v170;
      ++v69;
    } while (v169 != v186);
  }
  for (result = 0; result != v172; ++result)
    *(_DWORD *)(v160 + 4 * result) = 0;
  if (v171 <= 0)
    goto LABEL_163;
  v151 = &v159[v172 - 1];
  v163 = &a11[(4 - (_BYTE)a11) & 3];
  v164 = (char *)v162;
  v200 = 0;
  while (2) {
    for (i4 = 0; i4 != v172; ++i4)
      v159[i4] = -2.0;
    v187 = v170 * v200;
    v188 = 4 * v170 * v200;
    v148 = v200 + 1;
    v189 = (v200 + 1) * v170;
    v198 = 0;
    v146 = 4 * v189;
    v145 = v163;
    v79 = (float *)(*(_DWORD *)v163 + v188);
    if (v175)
    LABEL_84:
      vq_nbest_sign(v79, v154, v170, v169, v155, v172, v173, v174);
    else
    LABEL_104:
      vq_nbest(v79, v154, v170, v169, v155, v172, v173, v174);
    v152 = 0;
    v147 = (int *)(v196 + ((4 - (_BYTE)v196) & 3));
    do {
      v80 = *(_DWORD *)v145;
      if (v189 > v187) {
        v81 = (_DWORD *)(v80 + v188);
        v82 = (_DWORD *)(v188 + v156);
        v83 = 0;
        do {
          *v82 = *v81;
          ++v83;
          ++v81;
          ++v82;
        } while (v83 != (v200 + 1) * v170 - v170 * v200);
      }
      v84 = *v147;
      if (v169 <= *v147) {
        v85 = &v154[v170 * (v84 - v169)];
        if (0.0 < -1.0) {
        LABEL_91:
          if (v170 > 0) {
            v86 = (float *)(v188 + v156);
            for (i5 = 0; i5 != v170; ++i5) {
              *v86 = *v86 - v85[i5];
              ++v86;
            }
          }
          goto LABEL_94;
        }
      } else {
        v85 = &v154[v170 * v84];
        if (0.0 < 1.0)
          goto LABEL_91;
      }
      if (v170 > 0) {
        v112 = (float *)(v188 + v156);
        for (i6 = 0; i6 != v170; ++i6) {
          *v112 = *v112 + v85[i6];
          ++v112;
        }
      }
    LABEL_94:
      v88 = *(float *)(v160 + 4 * v198);
      if (v189 > v187) {
        v89 = (float *)(v188 + v156);
        v90 = 0;
        do {
          v88 = v88 + (float)(*v89 * *v89);
          ++v90;
          ++v89;
        } while (v90 != (v200 + 1) * v170 - v170 * v200);
      }
      if (*v151 > v88 || *v151 < -1.0) {
        if (a7 > v189) {
          v92 = (_DWORD *)(v80 + v146);
          v93 = (_DWORD *)(v146 + v156);
          v94 = 0;
          do {
            *v93 = *v92;
            ++v94;
            ++v92;
            ++v93;
          } while (v94 != a7 - v189);
        }
        if (v170 > 0) {
          v95 = &a9[v170];
          for (i7 = 0; i7 != v170; ++i7) {
            v97 = *v147;
            if (v169 <= *v147) {
              v97 -= v169;
              v98 = -1.0;
            } else {
              v98 = 1.0;
            }
            v99 = v98 * 0.03125 * (double)*(char *)(i7 + v168 + v170 * v97);
            if (a7 > v189) {
              v100 = (float *)(4 * v189 + v156);
              v101 = v95;
              v102 = 0;
              do {
                *v100 = *v100 - (float)(v99 * *v101);
                ++v102;
                ++v100;
                ++v101;
              } while (v102 != a7 - v189);
            }
            --v95;
          }
        }
        if (*v159 > v88 || *v159 < -1.0) {
          v195 = 0;
          v150 = 0;
          v194 = 0;
          v103 = 0;
        } else {
          v195 = 0;
          while (1) {
            if (++v195 == v172) {
              v91 = v172;
              goto LABEL_100;
            }
            v150 = v195;
            v194 = v195;
            v114 = v159[v195];
            if (v114 > v88)
              break;
            if (v114 < -1.0) {
              v103 = v195;
              goto LABEL_118;
            }
          }
          v103 = v195;
        }
      LABEL_118:
        v153 = v172 - 1;
        if (v172 - 1 > v103) {
          v190 = v172 - 1;
          v191 = &v164[v190 * 4];
          do {
            if (a7 > v189) {
              v104 = 0;
              v105 = 4 * v189;
              do {
                *(_DWORD *)(*(_DWORD *)v191 + v105) =
                    *(_DWORD *)(*((_DWORD *)v191 - 1) + v105);
                ++v104;
                v105 += 4;
              } while (v104 != a7 - v189);
            }
            for (i8 = 0; i8 != v171; ++i8)
              *(_DWORD *)(v165[v190] + 4 * i8) =
                  *(_DWORD *)(v165[v190 - 1] + 4 * i8);
            v159[v190] = v159[v190 - 1];
            --v153;
            --v190;
            v191 -= 4;
          } while (v153 > v195);
        }
        if (a7 > v189) {
          v107 = 4 * v189;
          v108 = (_DWORD *)(v146 + v156);
          v109 = 0;
          do {
            *(_DWORD *)(*(_DWORD *)&v164[v194 * 4] + v107) = *v108;
            ++v109;
            v107 += 4;
            ++v108;
          } while (v109 != a7 - v189);
        }
        v110 = 0;
        for (i9 = &v165[v194];; i9 = &v165[v194]) {
          *(_DWORD *)(*i9 + 4 * v110) =
              *(_DWORD *)(*(_DWORD *)(v166 + 4 * v198) + 4 * v110);
          if (v171 == ++v110)
            break;
        }
        *(_DWORD *)(v165[v150] + 4 * v200) = *v147;
        v159[v150] = v88;
        v91 = v172;
      } else {
        v91 = v172;
      }
    LABEL_100:
      ++v152;
      ++v147;
    } while (v152 != v91);
    if (v200) {
      ++v198;
      v145 += 4;
      if (v198 != v91) {
        v79 = (float *)(*(_DWORD *)v145 + v188);
        if (v175)
          goto LABEL_84;
        goto LABEL_104;
      }
    }
    for (i10 = 0; i10 != v172; ++i10) {
      for (i11 = 0; i11 != v171; ++i11)
        *(_DWORD *)(*(_DWORD *)(v166 + 4 * i10) + 4 * i11) =
            *(_DWORD *)(v165[i10] + 4 * i11);
    }
    for (i12 = 0; i12 != v172; ++i12)
      *(float *)(v160 + 4 * i12) = v159[i12];
    ++v200;
    v118 = v163;
    v163 = v164;
    if (v171 != v148) {
      v164 = v118;
      continue;
    }
    break;
  }
  for (i13 = 0; i13 != v171; ++i13) {
    v120 = *(_DWORD *)(*v165 + 4 * i13);
    *(_DWORD *)(v167 + 4 * i13) = v120;
    speex_bits_pack(a10, v120, (char *)(a5[3] + v175));
  }
  v121 = 0;
  v122 = 0;
  do {
    result = *(_DWORD *)(v167 + 4 * v121);
    if (v169 <= result) {
      result -= v169;
      v123 = -1.0;
    } else {
      v123 = 1.0;
    }
    if (v170 > 0) {
      v124 = v123 * 0.03125;
      v125 = &v157[v122];
      v126 = 0;
      v127 = (char *)(v170 * result + v168);
      do {
        result = *v127;
        v128 = (double)result * v124;
        *v125 = v128;
        ++v126;
        ++v127;
        ++v125;
      } while (v170 != v126);
    }
    ++v121;
    v122 += v170;
  } while (v171 != v121);
LABEL_163:
  if (a7 > 0) {
    for (i14 = 0; i14 != a7; ++i14) {
      result = 4 * i14;
      a8[i14] = a8[i14] + v157[i14];
    }
  }
  if (a13) {
    result = syn_percep_zero(v157, a2, a3, a4, v158, a7, a6, (char *)v197);
    if (a7 > 0) {
      for (i15 = 0; i15 != a7; ++i15) {
        result = 4 * i15;
        a1[i15] = a1[i15] - v158[i15];
      }
    }
  }
  return result;
}

float *__cdecl sb_encoder_init(const SpeexMode *a1) {
  float *v1;       // eax
  float *v2;       // edi
  float *mode;     // ebx
  int v4;          // esi
  int v5;          // eax
  int v6;          // eax
  int v7;          // edx
  int v8;          // edx
  int i;           // esi
  int v11;         // ebx
  float v12;       // xmm0_4
  int j;           // eax
  int v14;         // esi
  int v15;         // ebx
  float v16;       // xmm0_4
  int v17;         // esi
  double v18;      // xmm0_8
  int v19;         // ebx
  long double v20; // [esp+0h] [ebp-68h]
  int v21;         // [esp+28h] [ebp-40h]
  int v22;         // [esp+2Ch] [ebp-3Ch]
  int v23[7];      // [esp+4Ch] [ebp-1Ch] BYREF

  v1 = (float *)speex_alloc(4248);
  v2 = v1;
  if (!v1)
    return 0;
  *((_DWORD *)v1 + 14) = v1 + 62;
  *(_DWORD *)v1 = a1;
  mode = (float *)a1->mode;
  *((_DWORD *)v1 + 1) = speex_encoder_init(*(const SpeexMode **)a1->mode);
  *((_DWORD *)v2 + 2) = 2 * *((_DWORD *)mode + 1);
  v4 = *((_DWORD *)mode + 1);
  *((_DWORD *)v2 + 3) = v4;
  v2[4] = mode[2];
  *((_DWORD *)v2 + 5) = *((_DWORD *)mode + 1) / *((_DWORD *)mode + 2);
  *((_DWORD *)v2 + 6) = 3 * v4 / 2;
  v2[7] = mode[3];
  v2[8] = mode[4];
  *((_DWORD *)v2 + 56) = 1;
  *((_DWORD *)v2 + 57) = mode + 10;
  v5 = *((_DWORD *)mode + 18);
  *((_DWORD *)v2 + 58) = v5;
  *((_DWORD *)v2 + 59) = v5;
  v23[0] = 9;
  speex_encoder_ctl(*((void **)v2 + 1), 4, v23);
  v2[10] = mode[7];
  v2[11] = mode[8];
  v2[12] = mode[5];
  v2[13] = mode[6];
  *((_DWORD *)v2 + 9) = 1;
  *((_DWORD *)v2 + 15) = speex_alloc(4 * *((_DWORD *)v2 + 3));
  *((_DWORD *)v2 + 16) = speex_alloc(4 * *((_DWORD *)v2 + 3));
  *((_DWORD *)v2 + 17) = speex_alloc(4 * *((_DWORD *)v2 + 2));
  *((_DWORD *)v2 + 18) = speex_alloc(4 * *((_DWORD *)v2 + 2));
  *((_DWORD *)v2 + 19) = speex_alloc(4 * *((_DWORD *)v2 + 2));
  *((_DWORD *)v2 + 20) = speex_alloc(256);
  *((_DWORD *)v2 + 21) = speex_alloc(256);
  *((_DWORD *)v2 + 22) = speex_alloc(256);
  *((_DWORD *)v2 + 23) = speex_alloc(256);
  *((_DWORD *)v2 + 26) = speex_alloc(4 * *((_DWORD *)v2 + 6));
  v6 = speex_alloc(4 * *((_DWORD *)v2 + 8));
  *((_DWORD *)v2 + 24) = v6;
  *((_DWORD *)v2 + 25) = v6 + 4 * *((_DWORD *)v2 + 8) - 4 * *((_DWORD *)v2 + 6);
  *((_DWORD *)v2 + 27) = speex_alloc(4 * *((_DWORD *)v2 + 3));
  *((_DWORD *)v2 + 28) = speex_alloc(4 * *((_DWORD *)v2 + 3));
  *((_DWORD *)v2 + 29) = speex_alloc(4 * *((_DWORD *)v2 + 3));
  v7 = *((_DWORD *)v2 + 4);
  v22 = 7 * v7 / 2;
  v21 = 5 * v7 / 2;
  *((_DWORD *)v2 + 30) = speex_alloc(4 * *((_DWORD *)v2 + 6));
  v23[0] = 0;
  if (v22 > 0) {
    for (i = 0; i < v22; v23[0] = i) {
      v11 = *((_DWORD *)v2 + 30);
      *(double *)&v20 = (double)i * 3.141592653589793 / (double)v22;
      v12 = (double)cos(v20) * -0.46 + 0.54;
      *(float *)(v11 + 4 * i) = v12;
      i = v23[0] + 1;
    }
    v23[0] = 0;
    if (v21 <= 0)
      goto LABEL_4;
    goto LABEL_9;
  }
  v23[0] = 0;
  if (v21 > 0) {
  LABEL_9:
    for (j = 0; j < v21; v23[0] = j) {
      v14 = j + v22;
      v15 = *((_DWORD *)v2 + 30);
      *(double *)&v20 = (double)j * 3.141592653589793 / (double)v21;
      v16 = (double)cos(v20) * 0.46 + 0.54;
      *(float *)(v15 + 4 * v14) = v16;
      j = v23[0] + 1;
    }
  }
LABEL_4:
  *((_DWORD *)v2 + 31) = speex_alloc(4 * *((_DWORD *)v2 + 7) + 4);
  v23[0] = 0;
  v8 = *((_DWORD *)v2 + 7);
  if (v8 + 1 > 0) {
    v17 = 0;
    do {
      v18 = v2[10] * 6.283185307179586 * (double)v17;
      v19 = *((_DWORD *)v2 + 31);
      *(double *)&v20 = v18 * v18 * -0.5;
      *(float *)&v18 = (double)exp(v20) * 16384.0;
      *(_DWORD *)(v19 + 4 * v17) = LODWORD(v18);
      v17 = v23[0] + 1;
      v23[0] = v17;
      v8 = *((_DWORD *)v2 + 7);
    } while (v8 + 1 > v17);
  }
  *((_DWORD *)v2 + 32) = speex_alloc(4 * v8 + 4);
  *((_DWORD *)v2 + 33) = speex_alloc(4 * *((_DWORD *)v2 + 7));
  *((_DWORD *)v2 + 42) = speex_alloc(4 * *((_DWORD *)v2 + 7));
  *((_DWORD *)v2 + 43) = speex_alloc(4 * *((_DWORD *)v2 + 7));
  *((_DWORD *)v2 + 34) = speex_alloc(4 * *((_DWORD *)v2 + 7));
  *((_DWORD *)v2 + 35) = speex_alloc(4 * *((_DWORD *)v2 + 7));
  *((_DWORD *)v2 + 36) = speex_alloc(4 * *((_DWORD *)v2 + 7));
  *((_DWORD *)v2 + 37) = speex_alloc(4 * *((_DWORD *)v2 + 7));
  *((_DWORD *)v2 + 38) = speex_alloc(4 * *((_DWORD *)v2 + 7));
  *((_DWORD *)v2 + 39) = speex_alloc(4 * *((_DWORD *)v2 + 7));
  *((_DWORD *)v2 + 40) = speex_alloc(4 * *((_DWORD *)v2 + 7));
  *((_DWORD *)v2 + 41) = speex_alloc(4 * *((_DWORD *)v2 + 7));
  *((_DWORD *)v2 + 47) = speex_alloc(4 * *((_DWORD *)v2 + 5));
  *((_DWORD *)v2 + 44) = speex_alloc(4 * *((_DWORD *)v2 + 7));
  *((_DWORD *)v2 + 45) = speex_alloc(4 * *((_DWORD *)v2 + 7));
  *((_DWORD *)v2 + 46) = speex_alloc(4 * *((_DWORD *)v2 + 7));
  v2[48] = 8.0;
  v2[49] = 0.0;
  v2[54] = 0.0;
  v2[50] = 0.0;
  v2[55] = 0.0;
  *((_DWORD *)v2 + 60) = 2;
  speex_encoder_ctl(*((void **)v2 + 1), 25, v2 + 61);
  *((_DWORD *)v2 + 61) *= 2;
  return v2;
}

void __cdecl sb_encoder_destroy(void **a1) {
  speex_encoder_destroy(a1[1]);
  speex_free(a1);
}

_BOOL4 __cdecl sb_encode(float *a1, float *a2, SpeexBits *a3) {
  int v3;           // edx
  int v4;           // esi
  int v5;           // ecx
  int v6;           // ebx
  int v7;           // ecx
  _DWORD *v8;       // edx
  int v9;           // ebx
  int v10;          // ebx
  int v11;          // ebx
  int v12;          // edx
  int v13;          // ebx
  int v14;          // ebx
  const float *v15; // ebx
  int v16;          // eax
  int i;            // esi
  int v18;          // edx
  int v19;          // ebx
  int v20;          // eax
  int v21;          // edx
  int v22;          // eax
  int v23;          // ebx
  int v24;          // edx
  int v25;          // ebx
  int v26;          // ebx
  int v27;          // ebx
  int v28;          // eax
  char *v29;        // edx
  int v30;          // ecx
  int v31;          // edx
  int v32;          // ebx
  int v33;          // ebx
  float v35;        // xmm0_4
  double v36;       // xmm2_8
  float v37;        // xmm0_4
  float v38;        // xmm0_4
  float v39;        // xmm0_4
  int v40;          // ebx
  int v41;          // eax
  float v42;        // xmm1_4
  int v43;          // ebx
  _DWORD *v44;      // ecx
  int v45;          // edx
  int v46;          // ecx
  float *v47;       // edx
  float v48;        // xmm0_4
  int v49;          // eax
  int v50;          // edx
  double v51;       // xmm1_8
  float v52;        // xmm0_4
  float v53;        // xmm0_4
  signed int v54;   // eax
  double v55;       // xmm0_8
  float v56;        // xmm0_4
  int v57;          // edx
  int v58;          // eax
  int v59;          // eax
  int j;            // ecx
  int v61;          // eax
  int k;            // ecx
  int v63;          // eax
  int m;            // ecx
  int v65;          // edx
  int v66;          // edx
  int v67;          // eax
  int n;            // eax
  int v69;          // ecx
  int ii;           // eax
  int v71;          // edx
  int v72;          // edx
  int v73;          // ecx
  int v74;          // eax
  _DWORD *v75;      // esi
  _DWORD *v76;      // ecx
  int v77;          // ebx
  int v78;          // eax
  int v79;          // ecx
  float *v80;       // edx
  int v81;          // eax
  int v82;          // ecx
  char *v83;        // edx
  float v84;        // xmm0_4
  int v85;          // eax
  int v86;          // ecx
  int v87;          // eax
  int v88;          // edx
  int jj;           // ecx
  int v90;          // ebx
  float v91;        // xmm3_4
  int v92;          // ecx
  float *v93;       // eax
  float v94;        // xmm0_4
  signed int v95;   // edx
  int v96;          // esi
  long double v97;  // [esp+0h] [ebp-128h]
  long double v98;  // [esp+0h] [ebp-128h]
  long double v99;  // [esp+0h] [ebp-128h]
  long double v100; // [esp+0h] [ebp-128h]
  long double v101; // [esp+0h] [ebp-128h]
  double v102;      // [esp+50h] [ebp-D8h]
  float v103;       // [esp+5Ch] [ebp-CCh]
  float v104;       // [esp+70h] [ebp-B8h]
  float v105;       // [esp+74h] [ebp-B4h]
  float v106;       // [esp+90h] [ebp-98h]
  int v107;         // [esp+94h] [ebp-94h]
  float v108;       // [esp+98h] [ebp-90h]
  float v109;       // [esp+98h] [ebp-90h]
  int v110;         // [esp+9Ch] [ebp-8Ch]
  float *v111;      // [esp+A0h] [ebp-88h]
  float *v112;      // [esp+A4h] [ebp-84h]
  float *v113;      // [esp+A8h] [ebp-80h]
  char *v114;       // [esp+B0h] [ebp-78h]
  char *v115;       // [esp+B4h] [ebp-74h]
  int v116;         // [esp+B8h] [ebp-70h]
  float v117;       // [esp+BCh] [ebp-6Ch]
  float *v118;      // [esp+C0h] [ebp-68h]
  float *v119;      // [esp+C4h] [ebp-64h]
  float *v120;      // [esp+C8h] [ebp-60h]
  float *v121;      // [esp+CCh] [ebp-5Ch]
  float *v122;      // [esp+D0h] [ebp-58h]
  float v123;       // [esp+D4h] [ebp-54h]
  float v124;       // [esp+D8h] [ebp-50h]
  float v125;       // [esp+DCh] [ebp-4Ch]
  float v126;       // [esp+E0h] [ebp-48h]
  char *v127;       // [esp+E4h] [ebp-44h]
  int v128;         // [esp+E8h] [ebp-40h]
  char *v129;       // [esp+F0h] [ebp-38h]
  char *v130;       // [esp+F4h] [ebp-34h]
  char *v131;       // [esp+F8h] [ebp-30h]
  int v132;         // [esp+FCh] [ebp-2Ch]
  int v133;         // [esp+104h] [ebp-24h]
  int v134;         // [esp+108h] [ebp-20h]
  int v135;         // [esp+10Ch] [ebp-1Ch]
  _BOOL4 v136;      // [esp+10Ch] [ebp-1Ch]

  v116 = **(_DWORD **)a1;
  v3 = (-*((_DWORD *)a1 + 14) & 3) + *((_DWORD *)a1 + 14);
  v129 = (char *)(v3 + 4 * *((_DWORD *)a1 + 3));
  v4 = v3;
  qmf_decomp(a2, &h0, *((float **)a1 + 15), *((float **)a1 + 16),
             *((_DWORD *)a1 + 2), 64, *((float **)a1 + 20), v129);
  if (*((int *)a1 + 3) > 0) {
    v5 = 0;
    do {
      *(_DWORD *)(v4 + 4 * v5) = *(_DWORD *)(*((_DWORD *)a1 + 15) + 4 * v5);
      ++v5;
    } while (v5 < *((_DWORD *)a1 + 3));
  }
  speex_encode_native(*((void **)a1 + 1));
  if (*((int *)a1 + 3) > 0) {
    v6 = 0;
    do {
      *(_DWORD *)(*((_DWORD *)a1 + 15) + 4 * v6) = *(_DWORD *)(v4 + 4 * v6);
      ++v6;
    } while (v6 < *((_DWORD *)a1 + 3));
  }
  v7 = *((_DWORD *)a1 + 3);
  v8 = (_DWORD *)*((_DWORD *)a1 + 6);
  if ((int)v8 - v7 > 0) {
    v9 = 0;
    do {
      *(_DWORD *)(*((_DWORD *)a1 + 17) + 4 * v9) =
          *(_DWORD *)(*((_DWORD *)a1 + 17) + 4 * (v9 + v7));
      ++v9;
      v7 = *((_DWORD *)a1 + 3);
      v8 = (_DWORD *)*((_DWORD *)a1 + 6);
    } while (v9 < (int)v8 - v7);
  }
  if (v7 > 0) {
    v10 = 0;
    while (1) {
      *(_DWORD *)(*((_DWORD *)a1 + 17) + 4 * ((_DWORD)v8 + v10 - v7)) =
          *(_DWORD *)(*((_DWORD *)a1 + 16) + 4 * v10);
      ++v10;
      v7 = *((_DWORD *)a1 + 3);
      if (v7 <= v10)
        break;
      v8 = (_DWORD *)*((_DWORD *)a1 + 6);
    }
  }
  speex_move(*((void **)a1 + 24), (const void *)(*((_DWORD *)a1 + 24) + 4 * v7),
             4 * (*((_DWORD *)a1 + 8) - v7));
  v11 = (int)&v129[4 * *((_DWORD *)a1 + 5) + ((4 - (_BYTE)v129) & 3)];
  v12 = 4 * *((_DWORD *)a1 + 3);
  v13 = v12 + ((4 - (_BYTE)v11) & 3) + v11;
  v114 = (char *)(v13 - v12);
  v14 = v12 + ((4 - (_BYTE)v13) & 3) + v13;
  v115 = (char *)(v14 - v12);
  speex_encoder_ctl(*((void **)a1 + 1));
  speex_encoder_ctl(*((void **)a1 + 1));
  speex_encoder_ctl(*((void **)a1 + 1));
  speex_encoder_ctl(*((void **)a1 + 1));
  v136 = v135 == 0;
  v15 = (const float *)(((4 - (_BYTE)v14) & 3) + v14);
  v16 = *((_DWORD *)a1 + 6);
  v130 = (char *)&v15[v16];
  if (v16 > 0) {
    for (i = 0; i < v16; ++i) {
      v15[i] = *(float *)(*((_DWORD *)a1 + 17) + 4 * i) *
               *(float *)(*((_DWORD *)a1 + 30) + 4 * i);
      v16 = *((_DWORD *)a1 + 6);
    }
  }
  _spx_autocorr(v15, *((float **)a1 + 32), *((_DWORD *)a1 + 7) + 1, v16);
  **((float **)a1 + 32) = **((float **)a1 + 32) * a1[11];
  v18 = *((_DWORD *)a1 + 7);
  if (v18 + 1 > 0) {
    v19 = 0;
    do {
      *(float *)(*((_DWORD *)a1 + 32) + 4 * v19) =
          *(float *)(*((_DWORD *)a1 + 32) + 4 * v19) *
          *(float *)(*((_DWORD *)a1 + 31) + 4 * v19);
      ++v19;
      v18 = *((_DWORD *)a1 + 7);
    } while (v18 + 1 > v19);
  }
  _spx_lpc(*((float **)a1 + 33), *((float **)a1 + 32), v18);
  v20 = lpc_to_lsp(*((float **)a1 + 33), *((_DWORD *)a1 + 7),
                   *((float **)a1 + 34), 15, 0.2, v130);
  v21 = *((_DWORD *)a1 + 7);
  if (v20 != v21) {
    v22 = lpc_to_lsp(*((float **)a1 + 33), v21, *((float **)a1 + 34), 11,
                     0.050000001, v130);
    v23 = *((_DWORD *)a1 + 7);
    if (v22 != v23 && v23 > 0) {
      v46 = 0;
      do {
        v47 = (float *)(*((_DWORD *)a1 + 34) + 4 * v46++);
        v48 = (float)v46 * 3.141592653589793 / (double)(v23 + 1);
        *v47 = v48;
        v23 = *((_DWORD *)a1 + 7);
      } while (v23 > v46);
    }
  }
  if ((*((_DWORD *)a1 + 49) || *((_DWORD *)a1 + 54)) && !v136) {
    if (*((_DWORD *)a1 + 50)) {
      if ((float)(a1[51] * a1[52]) <= 0.0) {
        v35 = 0.0;
      } else {
        v35 = a1[51] * -0.00001 / (float)(a1[53] + 1.0);
        v36 = v35;
        if (v35 > 0.1) {
          v35 = 0.1;
          v36 = 0.1000000014901161;
        }
        if (v36 < -0.1)
          v35 = -0.1;
      }
      v37 = v35 + a1[48];
      a1[48] = v37;
      if (v37 > 10.0)
        a1[48] = 10.0;
      if (a1[48] < 0.0)
        a1[48] = 0.0;
    }
    v117 =
        compute_rms((const float *)*((_DWORD *)a1 + 15), *((_DWORD *)a1 + 3));
    v103 =
        compute_rms((const float *)*((_DWORD *)a1 + 17), *((_DWORD *)a1 + 3));
    *(double *)&v97 = (float)((float)(v103 + 1.0) / (float)(v117 + 1.0));
    v102 = log(v97);
    v38 = v102 + v102;
    speex_encoder_ctl(*((void **)a1 + 1));
    if (v38 >= -4.0) {
      if (v38 > 2.0)
        v38 = 2.0;
    } else {
      v38 = -4.0;
    }
    if (*((_DWORD *)a1 + 49)) {
      v134 = *(_DWORD *)(v116 + 168) - 1;
      v39 = (float)(v38 + 2.0) + a1[55];
      a1[55] = v39;
      if (v39 < -1.0)
        a1[55] = -1.0;
      v40 = v134;
      if (v134) {
        v128 = 44 * v134;
        v96 = 0;
        v105 = a1[48];
        v104 = a1[55];
        v106 = floorf(v105);
        if ((int)v106 == 10) {
          do {
            if (v104 >= *(float *)(*(_DWORD *)(v116 + 164) + v128 + 40))
              break;
            --v40;
            ++v96;
            v128 -= 44;
          } while (v96 != v134);
        } else {
          do {
            if (v104 >=
                (float)((float)((float)(v105 - (float)(int)v106) *
                                *(float *)(*(_DWORD *)(v116 + 164) + v128 +
                                           4 * ((int)v106 + 1))) +
                        (float)((float)((float)((int)v106 + 1) - v105) *
                                *(float *)(*(_DWORD *)(v116 + 164) + v128 +
                                           4 * (int)v106))))
              break;
            --v40;
            ++v96;
            v128 -= 44;
          } while (v96 != v134);
        }
      }
      speex_encoder_ctl(a1);
      if (*((_DWORD *)a1 + 50)) {
        speex_encoder_ctl(a1);
        v41 = v133 - *((_DWORD *)a1 + 50);
        a1[51] = (float)v41 + a1[51];
        v42 = a1[52] * 0.95 + (double)v41 * 0.05;
        a1[52] = v42;
        a1[53] = a1[53] + 1.0;
      }
    } else {
      if (a1[55] >= 2.0)
        v49 = *((_DWORD *)a1 + 59);
      else
        v49 = 1;
      *((_DWORD *)a1 + 58) = v49;
    }
  }
  if (*((_DWORD *)a1 + 56)) {
    speex_bits_pack(a3, 1u, (char *)1);
    if (v136)
      speex_bits_pack(a3, 0, (char *)3);
    else
      speex_bits_pack(a3, *((_DWORD *)a1 + 58), (char *)3);
  }
  if (v136 || (v24 = *(_DWORD *)(*((_DWORD *)a1 + 57) +
                                 4 * *((_DWORD *)a1 + 58))) == 0) {
    if (*((int *)a1 + 3) > 0) {
      v43 = 0;
      do {
        v44 = (_DWORD *)(*((_DWORD *)a1 + 25) + 4 * v43);
        *(_DWORD *)(*((_DWORD *)a1 + 28) + 4 * v43) = 646978941;
        *v44 = 646978941;
        ++v43;
      } while (*((_DWORD *)a1 + 3) > v43);
    }
    if (*((int *)a1 + 7) > 0) {
      v45 = 0;
      do
        *(_DWORD *)(*((_DWORD *)a1 + 46) + 4 * v45++) = 0;
      while (*((_DWORD *)a1 + 7) > v45);
    }
    *((_DWORD *)a1 + 9) = 1;
    iir_mem2(*((const float **)a1 + 25), *((const float **)a1 + 41),
             *((float **)a1 + 17), *((_DWORD *)a1 + 3), *((_DWORD *)a1 + 7),
             *((float **)a1 + 44));
    return !v136;
  } else {
    (*(void(__cdecl **)(_DWORD *, _DWORD *, _DWORD *, SpeexBits *))(v24 + 16))(
        *((_DWORD **)a1 + 34), *((_DWORD **)a1 + 35), *((_DWORD **)a1 + 7), a3);
    if (*((_DWORD *)a1 + 9)) {
      if (*((int *)a1 + 7) > 0) {
        v25 = 0;
        do {
          *(_DWORD *)(*((_DWORD *)a1 + 36) + 4 * v25) =
              *(_DWORD *)(*((_DWORD *)a1 + 34) + 4 * v25);
          ++v25;
        } while (*((_DWORD *)a1 + 7) > v25);
        if (*((int *)a1 + 7) > 0) {
          v26 = 0;
          do {
            *(_DWORD *)(*((_DWORD *)a1 + 37) + 4 * v26) =
                *(_DWORD *)(*((_DWORD *)a1 + 35) + 4 * v26);
            ++v26;
          } while (*((_DWORD *)a1 + 7) > v26);
        }
      }
    }
    v27 = *((_DWORD *)a1 + 7);
    v111 = (float *)&v130[(4 - (_BYTE)v130) & 3];
    v28 = 4 * *((_DWORD *)a1 + 4);
    v29 = (char *)&v111[v27] +
          ((4 - ((_BYTE)v130 + ((4 - (_BYTE)v130) & 3) + 4 * (_BYTE)v27)) & 3) +
          v28;
    v113 = (float *)((char *)&v111[v27] +
                     ((4 - ((_BYTE)v130 + ((4 - (_BYTE)v130) & 3) +
                            4 * (_BYTE)v27)) &
                      3));
    v30 = (4 - (_BYTE)v29) & 3;
    v131 = &v29[v30 + v28];
    v112 = (float *)&v29[v30];
    v31 = *((_DWORD *)a1 + 5);
    if (v31 > 0) {
      v110 = 0;
      while (1) {
        v107 = 4 * *((_DWORD *)a1 + 4) * v110;
        v119 = (float *)(*((_DWORD *)a1 + 17) + v107);
        v118 = (float *)(*((_DWORD *)a1 + 25) + v107);
        v120 = (float *)(*((_DWORD *)a1 + 27) + v107);
        v121 = (float *)(*((_DWORD *)a1 + 29) + v107);
        v122 = (float *)(*((_DWORD *)a1 + 28) + v107);
        lsp_interpolate(*((float **)a1 + 36), *((float **)a1 + 34),
                        *((float **)a1 + 38), v27, v110, v31);
        lsp_interpolate(*((float **)a1 + 37), *((float **)a1 + 35),
                        *((float **)a1 + 39), *((_DWORD *)a1 + 7), v110,
                        *((_DWORD *)a1 + 5));
        lsp_enforce_margin(*((float **)a1 + 38), *((_DWORD *)a1 + 7),
                           0.050000001);
        lsp_enforce_margin(*((float **)a1 + 39), *((_DWORD *)a1 + 7),
                           0.050000001);
        lsp_to_lpc(*((float **)a1 + 38), *((float **)a1 + 40),
                   *((_DWORD *)a1 + 7), v131);
        lsp_to_lpc(*((float **)a1 + 39), *((float **)a1 + 41),
                   *((_DWORD *)a1 + 7), v131);
        bw_lpc(a1[12], *((const float **)a1 + 40), *((float **)a1 + 42),
               *((_DWORD *)a1 + 7));
        bw_lpc(a1[13], *((const float **)a1 + 40), *((float **)a1 + 43),
               *((_DWORD *)a1 + 7));
        *(_DWORD *)(*((_DWORD *)a1 + 47) + 4 * v110) = 1065353216;
        v50 = *((_DWORD *)a1 + 7);
        if (v50 > 0) {
          v90 = 0;
          v91 = 1.0;
          v92 = 0;
          do {
            v93 = (float *)(*((_DWORD *)a1 + 41) + v92);
            v91 = v91 + (float)(v93[1] - *v93);
            *(float *)(*((_DWORD *)a1 + 47) + 4 * v110) =
                (float)(v93[1] + *v93) +
                *(float *)(*((_DWORD *)a1 + 47) + 4 * v110);
            v90 += 2;
            v50 = *((_DWORD *)a1 + 7);
            v92 += 8;
          } while (v50 > v90);
          v51 = v91;
        } else {
          v51 = 1.0;
        }
        v52 = (*(float *)&v129[4 * v110 + ((4 - (_BYTE)v129) & 3)] + 0.01) /
              (v51 + 0.01);
        v123 = v52;
        fir_mem2(v119, *((const float **)a1 + 41), v118, *((_DWORD *)a1 + 4),
                 v50, *((float **)a1 + 45));
        v124 = compute_rms(v118, *((_DWORD *)a1 + 4));
        if (*(_DWORD *)(*(_DWORD *)(*((_DWORD *)a1 + 57) +
                                    4 * *((_DWORD *)a1 + 58)) +
                        36)) {
          v108 = compute_rms((const float *)&v114[v107], *((_DWORD *)a1 + 4));
          v109 = v108 + 1.0;
          v53 = (float)((float)(v124 + 1.0) * v52) / v109;
          if (*((_DWORD *)a1 + 4) == 80)
            v53 = v53 * 0.70711;
          *(double *)&v98 = v53;
          *(double *)&v99 = ((double)log(v98) + 0.15556) * 3.7 + 0.5;
          v54 = (int)(double)floor(v99);
          if (v54 < 0) {
            v54 = 0;
            v55 = 0.0;
          } else if (v54 <= 15) {
            v55 = (double)v54;
          } else {
            v54 = 15;
            v55 = 15.0;
          }
          speex_bits_pack(a3, v54, (char *)4);
          *(double *)&v100 = v55 * 0.2702702702702702 - 0.15556;
          v56 = exp(v100);
          v57 = *((_DWORD *)a1 + 4);
          if (v57 == 80)
            v56 = v56 * 1.4142;
          v126 = v109 * (float)(v56 / v123);
          compute_impulse_response(
              *((const float **)a1 + 41), *((const float **)a1 + 42),
              *((const float **)a1 + 43), v113, v57, *((_DWORD *)a1 + 7), v131);
          if (*((int *)a1 + 4) > 0) {
            v58 = 0;
            do
              v118[v58++] = 1.0e-15;
            while (*((_DWORD *)a1 + 4) > v58);
          }
          v59 = *((_DWORD *)a1 + 7);
          if (v59 > 0) {
            for (j = 0; j < v59; ++j) {
              v111[j] = *(float *)(*((_DWORD *)a1 + 44) + 4 * j);
              v59 = *((_DWORD *)a1 + 7);
            }
          }
          iir_mem2(v118, *((const float **)a1 + 41), v118, *((_DWORD *)a1 + 4),
                   v59, v111);
          v61 = *((_DWORD *)a1 + 7);
          if (v61 > 0) {
            for (k = 0; k < v61; ++k) {
              v111[k] = *(float *)(*((_DWORD *)a1 + 46) + 4 * k);
              v61 = *((_DWORD *)a1 + 7);
            }
          }
          filter_mem2(v118, *((const float **)a1 + 42),
                      *((const float **)a1 + 43), v120, *((_DWORD *)a1 + 4),
                      v61, v111);
          v63 = *((_DWORD *)a1 + 7);
          if (v63 > 0) {
            for (m = 0; m < v63; ++m) {
              v111[m] = *(float *)(*((_DWORD *)a1 + 46) + 4 * m);
              v63 = *((_DWORD *)a1 + 7);
            }
          }
          filter_mem2(v119, *((const float **)a1 + 42),
                      *((const float **)a1 + 43), v122, *((_DWORD *)a1 + 4),
                      v63, v111);
          v65 = *((_DWORD *)a1 + 4);
          if (v65 > 0) {
            v66 = 1;
            do {
              v121[v66 - 1] = v122[v66 - 1] - v120[v66 - 1];
              v67 = v66++;
            } while (*((_DWORD *)a1 + 4) > v67);
            v65 = *((_DWORD *)a1 + 4);
            if (v65 > 0) {
              for (n = 0; n < v65; ++n) {
                v118[n] = 0.0;
                v65 = *((_DWORD *)a1 + 4);
              }
            }
          }
          signal_div(v121, v121, v126, v65);
          v69 = *((_DWORD *)a1 + 4);
          if (v69 > 0) {
            for (ii = 0; ii < v69; ++ii) {
              v112[ii] = 0.0;
              v69 = *((_DWORD *)a1 + 4);
            }
          }
          v71 = *(_DWORD *)(*((_DWORD *)a1 + 57) + 4 * *((_DWORD *)a1 + 58));
          (*(void(__cdecl **)(float *, _DWORD *, _DWORD *, _DWORD *, _DWORD,
                              _DWORD *, int, float *, float *, SpeexBits *,
                              char *, int, _DWORD))(v71 + 36))(
              v121, *((_DWORD **)a1 + 41), *((_DWORD **)a1 + 42),
              *((_DWORD **)a1 + 43), *(_DWORD *)(v71 + 44),
              *((_DWORD **)a1 + 7), v69, v112, v113, a3, v131,
              (*((_DWORD *)a1 + 60) + 1) >> 1, *(_DWORD *)(v71 + 12));
          signal_mul(v112, v112, v126, *((_DWORD *)a1 + 4));
          v72 = *((_DWORD *)a1 + 4);
          if (v72 > 0) {
            v73 = 1;
            do {
              v118[v73 - 1] = v118[v73 - 1] + v112[v73 - 1];
              v74 = v73;
              v72 = *((_DWORD *)a1 + 4);
              ++v73;
            } while (v74 < v72);
          }
          v75 = (_DWORD *)*((_DWORD *)a1 + 58);
          v76 = (_DWORD *)*((_DWORD *)a1 + 57);
          if (*(_DWORD *)(v76[(_DWORD)v75] + 12)) {
            v132 = (int)&v131[4 * v72 + (-(int)v131 & 3)];
            v127 = &v131[-(int)v131 & 3];
            v77 = v72;
            if (v72 > 0) {
              v78 = 0;
              do
                *(_DWORD *)&v127[4 * v78++] = 0;
              while (v78 < *((_DWORD *)a1 + 4));
              v77 = *((_DWORD *)a1 + 4);
              if (v77 > 0) {
                v79 = 1;
                v80 = v121 + 1;
                do {
                  *(v80 - 1) = *(v80 - 1) * 2.5;
                  v81 = v79;
                  v77 = *((_DWORD *)a1 + 4);
                  ++v79;
                  ++v80;
                } while (v81 < v77);
              }
              v75 = (_DWORD *)*((_DWORD *)a1 + 58);
              v76 = (_DWORD *)*((_DWORD *)a1 + 57);
            }
            (*(void(__cdecl **)(float *, _DWORD *, _DWORD *, _DWORD *, _DWORD,
                                _DWORD *, int, char *, float *, SpeexBits *,
                                int, int, _DWORD))(v76[(_DWORD)v75] + 36))(
                v121, *((_DWORD **)a1 + 41), *((_DWORD **)a1 + 42),
                *((_DWORD **)a1 + 43), *(_DWORD *)(v76[(_DWORD)v75] + 44),
                *((_DWORD **)a1 + 7), v77, v127, v113, a3, v132,
                (*((_DWORD *)a1 + 60) + 1) >> 1, 0);
            if (*((int *)a1 + 4) > 0) {
              v82 = 1;
              v83 = v127 + 4;
              do {
                v84 = *((float *)v83 - 1) * (v126 * 0.4);
                *((float *)v83 - 1) = v84;
                v85 = v82++;
                v83 += 4;
              } while (*((_DWORD *)a1 + 4) > v85);
              if (*((int *)a1 + 4) > 0) {
                v86 = 1;
                do {
                  v118[v86 - 1] = v118[v86 - 1] + *(float *)&v127[4 * v86 - 4];
                  v87 = v86++;
                } while (v87 < *((_DWORD *)a1 + 4));
              }
            }
          }
        } else {
          v125 = compute_rms((const float *)&v115[v107], *((_DWORD *)a1 + 4));
          v94 = v124 / (v125 + 0.01);
          *(double *)&v98 = (float)(v94 * v123) + 0.0001;
          *(double *)&v101 = (double)log(v98) * 8.0 + 10.5;
          v95 = (int)(double)floor(v101);
          if (v95 < 0) {
            v95 = 0;
          } else if (v95 >= 32) {
            v95 = 31;
          }
          speex_bits_pack(a3, v95, (char *)5);
        }
        v88 = *((_DWORD *)a1 + 7);
        if (v88 > 0) {
          for (jj = 0; jj < v88; ++jj) {
            v111[jj] = *(float *)(*((_DWORD *)a1 + 44) + 4 * jj);
            v88 = *((_DWORD *)a1 + 7);
          }
        }
        iir_mem2(v118, *((const float **)a1 + 41), v119, *((_DWORD *)a1 + 4),
                 v88, *((float **)a1 + 44));
        filter_mem2(v119, *((const float **)a1 + 42),
                    *((const float **)a1 + 43), v122, *((_DWORD *)a1 + 4),
                    *((_DWORD *)a1 + 7), *((float **)a1 + 46));
        ++v110;
        v31 = *((_DWORD *)a1 + 5);
        if (v110 >= v31)
          break;
        v27 = *((_DWORD *)a1 + 7);
      }
    }
    if (*((int *)a1 + 7) > 0) {
      v32 = 0;
      do {
        *(_DWORD *)(*((_DWORD *)a1 + 36) + 4 * v32) =
            *(_DWORD *)(*((_DWORD *)a1 + 34) + 4 * v32);
        ++v32;
      } while (v32 < *((_DWORD *)a1 + 7));
      if (*((int *)a1 + 7) > 0) {
        v33 = 0;
        do {
          *(_DWORD *)(*((_DWORD *)a1 + 37) + 4 * v33) =
              *(_DWORD *)(*((_DWORD *)a1 + 35) + 4 * v33);
          ++v33;
        } while (v33 < *((_DWORD *)a1 + 7));
      }
    }
    a1[9] = 0.0;
    return 1;
  }
}

_DWORD *__cdecl sb_decoder_init(const SpeexMode *a1) {
  _DWORD *v1;   // eax
  _DWORD *v2;   // esi
  int32_t mode; // ebx

  v1 = speex_alloc(0x5E30u);
  v2 = v1;
  if (!v1)
    return 0;
  v1[10] = v1 + 28;
  *v1 = a1;
  mode = a1->mode;
  v1[25] = 1;
  v1[1] = speex_decoder_init(*(const SpeexMode **)mode);
  v2[2] = 2 * *(_DWORD *)(mode + 4);
  v2[3] = *(_DWORD *)(mode + 4);
  v2[4] = *(_DWORD *)(mode + 8);
  v2[5] = *(_DWORD *)(mode + 4) / *(_DWORD *)(mode + 8);
  v2[6] = *(_DWORD *)(mode + 12);
  speex_decoder_ctl((void *)v2[1]);
  v2[8] *= 2;
  v2[26] = mode + 40;
  v2[27] = *(_DWORD *)(mode + 72);
  v2[7] = 1;
  v2[11] = speex_alloc(4 * v2[3]);
  v2[12] = speex_alloc(4 * v2[3]);
  v2[13] = speex_alloc(4 * v2[2]);
  v2[14] = speex_alloc(4 * v2[2]);
  v2[15] = speex_alloc(4 * v2[2]);
  v2[16] = speex_alloc(0x100u);
  v2[17] = speex_alloc(0x100u);
  v2[18] = speex_alloc(4 * v2[3]);
  v2[19] = speex_alloc(4 * v2[6]);
  v2[20] = speex_alloc(4 * v2[6]);
  v2[21] = speex_alloc(4 * v2[6]);
  v2[22] = speex_alloc(4 * v2[6]);
  v2[24] = speex_alloc(4 * v2[5]);
  v2[23] = speex_alloc(8 * v2[6]);
  v2[9] = 0;
  return v2;
}

void __cdecl sb_decoder_destroy(void **a1) {
  speex_decoder_destroy(a1[1]);
  speex_free(a1);
}

int __cdecl sb_encoder_ctl(void *a1, int a2, int *a3) {
  int v4;          // ecx
  int v5;          // eax
  int v6;          // eax
  int v7;          // eax
  int v8;          // ebx
  int v9;          // ecx
  int v10;         // ecx
  int v11;         // eax
  int v12;         // edx
  float v13;       // xmm0_4
  int v14;         // eax
  int v15;         // edx
  float v16;       // xmm0_4
  int v17;         // ecx
  int v18;         // ebx
  float *v19;      // edx
  float v20;       // xmm0_4
  int v21;         // esi
  _DWORD *v22;     // ebx
  _DWORD *v23;     // ecx
  int v24;         // edx
  int i;           // esi
  _DWORD *v26;     // ebx
  _DWORD *v27;     // ecx
  _DWORD *v28;     // edx
  int v29;         // ebx
  long double v30; // [esp+0h] [ebp-58h]
  int v31;         // [esp+34h] [ebp-24h]
  int v32;         // [esp+38h] [ebp-20h]
  int v33;         // [esp+3Ch] [ebp-1Ch]

  switch (a2) {
  case 3:
    *a3 = *((_DWORD *)a1 + 2);
    return 0;
  case 4:
    v4 = *a3;
    if (*a3 < 0) {
      v4 = 0;
    } else if (v4 >= 11) {
      v4 = 10;
    }
    v5 = *(_DWORD *)(**(_DWORD **)a1 + 4 * v4 + 120);
    *((_DWORD *)a1 + 58) = v5;
    *((_DWORD *)a1 + 59) = v5;
    speex_encoder_ctl(*((void **)a1 + 1));
    return 0;
  case 6:
    goto LABEL_9;
  case 8:
  case 9:
  case 34:
  case 35:
    speex_encoder_ctl(*((void **)a1 + 1));
    return 0;
  case 10:
    v6 = *a3;
    *((_DWORD *)a1 + 58) = *a3;
    *((_DWORD *)a1 + 59) = v6;
    return 0;
  case 12:
    *((_DWORD *)a1 + 49) = *a3;
    speex_encoder_ctl(*((void **)a1 + 1));
    return 0;
  case 13:
    *a3 = *((_DWORD *)a1 + 49);
    return 0;
  case 14:
    *((_DWORD *)a1 + 48) = *a3;
    *(double *)&v30 = *(float *)a3 + 0.5;
    floor(v30);
    speex_encoder_ctl(*((void **)a1 + 1));
  LABEL_9:
    speex_encoder_ctl(a1);
    return 0;
  case 16:
    speex_encoder_ctl(*((void **)a1 + 1));
    v7 = *a3;
    *((_DWORD *)a1 + 60) = *a3;
    if (v7 > 0)
      return 0;
    *((_DWORD *)a1 + 60) = 1;
    return 0;
  case 17:
    *a3 = *((_DWORD *)a1 + 60);
    return 0;
  case 18:
    v32 = 10;
    v8 = *a3;
    break;
  case 19:
    speex_encoder_ctl(*((void **)a1 + 1));
    v9 = *(_DWORD *)(*((_DWORD *)a1 + 57) + 4 * *((_DWORD *)a1 + 58));
    if (v9)
      *a3 += *(_DWORD *)(v9 + 64) * *((_DWORD *)a1 + 61) / *((_DWORD *)a1 + 2);
    else
      *a3 += 4 * *((_DWORD *)a1 + 61) / *((_DWORD *)a1 + 2);
    return 0;
  case 24:
    *((_DWORD *)a1 + 61) = *a3;
    speex_encoder_ctl(*((void **)a1 + 1));
    return 0;
  case 25:
    *a3 = *((_DWORD *)a1 + 61);
    return 0;
  case 26:
    *((_DWORD *)a1 + 9) = 1;
    v17 = *((_DWORD *)a1 + 7);
    if (v17 > 0) {
      v18 = 0;
      do {
        v19 = (float *)(*((_DWORD *)a1 + 34) + 4 * v18++);
        v20 = (float)v18 * 3.141592653589793 / (double)(v17 + 1);
        *v19 = v20;
        v17 = *((_DWORD *)a1 + 7);
      } while (v18 < v17);
      if (v17 > 0) {
        v21 = 0;
        do {
          v22 = (_DWORD *)(*((_DWORD *)a1 + 46) + 4 * v21);
          v23 = (_DWORD *)(*((_DWORD *)a1 + 44) + 4 * v21);
          *(_DWORD *)(*((_DWORD *)a1 + 45) + 4 * v21) = 0;
          *v23 = 0;
          *v22 = 0;
          ++v21;
        } while (v21 < *((_DWORD *)a1 + 7));
      }
    }
    if (*((int *)a1 + 8) > 0) {
      v24 = 0;
      do
        *(_DWORD *)(*((_DWORD *)a1 + 24) + 4 * v24++) = 0;
      while (v24 < *((_DWORD *)a1 + 8));
    }
    for (i = 0; i != 256; i += 4) {
      v26 = (_DWORD *)(*((_DWORD *)a1 + 20) + i);
      v27 = (_DWORD *)(*((_DWORD *)a1 + 21) + i);
      v28 = (_DWORD *)(*((_DWORD *)a1 + 22) + i);
      *(_DWORD *)(*((_DWORD *)a1 + 23) + i) = 0;
      *v28 = 0;
      *v27 = 0;
      *v26 = 0;
    }
    return 0;
  case 29:
    *a3 = *((_DWORD *)a1 + 55);
    return 0;
  case 30:
    *((_DWORD *)a1 + 54) = *a3;
    speex_encoder_ctl(*((void **)a1 + 1));
    return 0;
  case 31:
    *a3 = *((_DWORD *)a1 + 54);
    return 0;
  case 32:
    *((_DWORD *)a1 + 50) = *a3;
    *((_DWORD *)a1 + 49) = 1;
    speex_encoder_ctl(*((void **)a1 + 1));
    v33 = 10;
    v29 = *a3;
    do {
      speex_encoder_ctl(a1);
      speex_encoder_ctl(a1);
      if (v29 >= v31)
        break;
      --v33;
    } while (v33 >= 0);
    speex_encoder_ctl(a1);
    *((_DWORD *)a1 + 53) = 0;
    *((_DWORD *)a1 + 51) = 0;
    *((_DWORD *)a1 + 52) = 0;
    return 0;
  case 33:
    *a3 = *((_DWORD *)a1 + 50);
    return 0;
  case 36:
    *((_DWORD *)a1 + 56) = *a3;
    speex_encoder_ctl(*((void **)a1 + 1));
    return 0;
  case 37:
    *a3 = *((_DWORD *)a1 + 56);
    return 0;
  case 39:
    speex_encoder_ctl(*((void **)a1 + 1));
    *a3 = 2 * *a3 + 63;
    return 0;
  case 100:
    if (*((int *)a1 + 5) <= 0)
      return 0;
    v10 = 0;
    do {
      a3[v10] = *(_DWORD *)(*((_DWORD *)a1 + 47) + 4 * v10);
      ++v10;
    } while (v10 < *((_DWORD *)a1 + 5));
    return 0;
  case 101:
    if (*((int *)a1 + 2) > 0) {
      v11 = 0;
      do
        a3[v11++] = 0;
      while (v11 < *((_DWORD *)a1 + 2));
    }
    if (*((int *)a1 + 3) <= 0)
      return 0;
    v12 = 0;
    do {
      v13 = *(float *)(*((_DWORD *)a1 + 25) + 4 * v12);
      *(float *)&a3[2 * v12++] = v13 + v13;
    } while (v12 < *((_DWORD *)a1 + 3));
    return 0;
  case 102:
    if (*((int *)a1 + 2) > 0) {
      v14 = 0;
      do
        a3[v14++] = 0;
      while (v14 < *((_DWORD *)a1 + 2));
    }
    if (*((int *)a1 + 3) <= 0)
      return 0;
    v15 = 0;
    do {
      v16 = *(float *)(*((_DWORD *)a1 + 25) + 4 * v15);
      *(float *)&a3[2 * v15++] = v16 + v16;
    } while (v15 < *((_DWORD *)a1 + 3));
    return 0;
  default:
    speex_warning_int("Unknown nb_ctl request: ", a2);
    return -1;
  }
  do {
    speex_encoder_ctl(a1);
    speex_encoder_ctl(a1);
    if (v8 >= v31)
      return 0;
    --v32;
  } while (v32 >= 0);
  return 0;
}

int __cdecl sb_decoder_ctl(void **a1, int a2, int *a3) {
  int result; // eax
  int v4;     // ecx
  int v5;     // ecx
  int v6;     // edx
  int i;      // ecx
  _DWORD *v8; // edx
  int v9;     // ecx
  int v10;    // eax
  int v11;    // edx
  float v12;  // xmm0_4
  int v13;    // eax
  int v14;    // edx
  float v15;  // xmm0_4

  switch (a2) {
  case 0:
    speex_decoder_ctl(a1[1]);
    a1[9] = (void *)*a3;
    return 0;
  case 3:
    *a3 = (int)a1[2];
    return 0;
  case 4:
  case 6:
    v4 = *a3;
    if (*a3 < 0) {
      v4 = 0;
    } else if (v4 >= 11) {
      v4 = 10;
    }
    a1[27] = *(void **)(*(_DWORD *)*a1 + 4 * v4 + 120);
    speex_decoder_ctl(a1[1]);
    return 0;
  case 8:
  case 9:
  case 20:
  case 22:
  case 103:
    speex_decoder_ctl(a1[1]);
    return 0;
  case 10:
    a1[27] = (void *)*a3;
    return 0;
  case 19:
    speex_decoder_ctl(a1[1]);
    v5 = *((_DWORD *)a1[26] + (_DWORD)a1[27]);
    if (v5)
      *a3 += *(_DWORD *)(v5 + 64) * (int)a1[8] / (int)a1[2];
    else
      *a3 += 4 * (int)a1[8] / (int)a1[2];
    return 0;
  case 24:
    a1[8] = (void *)*a3;
    speex_decoder_ctl(a1[1]);
    return 0;
  case 25:
    *a3 = (int)a1[8];
    return 0;
  case 26:
    if (2 * (int)a1[6] > 0) {
      v6 = 0;
      do
        *((_DWORD *)a1[23] + v6++) = 0;
      while (v6 < 2 * (int)a1[6]);
    }
    for (i = 0; i != 256; i += 4) {
      v8 = (char *)a1[16] + i;
      *(_DWORD *)((char *)a1[17] + i) = 0;
      *v8 = 0;
    }
    goto LABEL_22;
  case 36:
    a1[25] = (void *)*a3;
    speex_decoder_ctl(a1[1]);
    return 0;
  case 37:
    *a3 = (int)a1[25];
    return 0;
  case 100:
    if ((int)a1[5] <= 0)
      goto LABEL_22;
    v9 = 0;
    do {
      a3[v9] = *((_DWORD *)a1[24] + v9);
      ++v9;
    } while (v9 < (int)a1[5]);
    result = 0;
    break;
  case 101:
    if ((int)a1[2] > 0) {
      v10 = 0;
      do
        a3[v10++] = 0;
      while (v10 < (int)a1[2]);
    }
    if ((int)a1[3] <= 0)
      goto LABEL_22;
    v11 = 0;
    do {
      v12 = *((float *)a1[18] + v11);
      *(float *)&a3[2 * v11++] = v12 + v12;
    } while (v11 < (int)a1[3]);
    result = 0;
    break;
  case 102:
    if ((int)a1[2] > 0) {
      v13 = 0;
      do
        a3[v13++] = 0;
      while (v13 < (int)a1[2]);
    }
    if ((int)a1[3] <= 0) {
    LABEL_22:
      result = 0;
    } else {
      v14 = 0;
      do {
        v15 = *((float *)a1[18] + v14);
        *(float *)&a3[2 * v14++] = v15 + v15;
      } while (v14 < (int)a1[3]);
      result = 0;
    }
    break;
  default:
    speex_warning_int("Unknown nb_ctl request: ", a2);
    result = -1;
    break;
  }
  return result;
}

int __cdecl sb_decode(int **a1, SpeexBits *a2, _DWORD *a3) {
  int v3;          // esi
  int v4;          // ebx
  int v5;          // edx
  int v6;          // ebx
  int i;           // edx
  int v8;          // edx
  int v9;          // edx
  int v10;         // ecx
  int v11;         // ecx
  char *v12;       // eax
  int v13;         // edx
  int v14;         // ecx
  int *v15;        // esi
  int v16;         // edx
  __m128 v17;      // xmm3
  __m128 v18;      // xmm1
  __int32 v19;     // xmm4_4
  __m128 v20;      // xmm1
  int v21;         // ebx
  int v23;         // ebx
  int v24;         // edx
  int v25;         // ebx
  int *v26;        // esi
  int *v27;        // eax
  int v28;         // ecx
  __m128 v29;      // xmm3
  __int32 v30;     // xmm4_4
  __m128 v31;      // xmm1
  __m128 v32;      // xmm1
  double v33;      // xmm2_8
  float v34;       // xmm0_4
  int v35;         // eax
  int v36;         // ebx
  float v37;       // xmm0_4
  int *v38;        // ecx
  int v39;         // edx
  int *v40;        // edx
  int *v41;        // ebx
  int v42;         // ecx
  char *v43;       // esi
  int j;           // eax
  int v45;         // ecx
  char *v46;       // edx
  float v47;       // xmm0_4
  int v48;         // eax
  int v49;         // ecx
  int v50;         // eax
  int v51;         // ebx
  int v52;         // ecx
  int v53;         // eax
  int v54;         // edx
  int k;           // ecx
  int v56;         // ecx
  float v57;       // xmm3_4
  int v58;         // edx
  float *v59;      // eax
  float *v60;      // edx
  float v61;       // ebx
  float v62;       // esi
  float v63;       // xmm1_4
  float v64;       // xmm1_4
  float *v65;      // edx
  int v66;         // ecx
  int v67;         // eax
  long double v68; // [esp+0h] [ebp-C8h]
  int *v69;        // [esp+28h] [ebp-A0h]
  int v70;         // [esp+3Ch] [ebp-8Ch]
  int v71;         // [esp+54h] [ebp-74h]
  int v72;         // [esp+58h] [ebp-70h]
  int v73;         // [esp+5Ch] [ebp-6Ch]
  int v74;         // [esp+64h] [ebp-64h]
  char *v75;       // [esp+68h] [ebp-60h]
  float *v76;      // [esp+6Ch] [ebp-5Ch]
  float *v77;      // [esp+70h] [ebp-58h]
  float *v78;      // [esp+74h] [ebp-54h]
  int v79;         // [esp+78h] [ebp-50h]
  float *v80;      // [esp+7Ch] [ebp-4Ch]
  float *v81;      // [esp+80h] [ebp-48h]
  float v82;       // [esp+84h] [ebp-44h]
  float v83;       // [esp+88h] [ebp-40h]
  float v84;       // [esp+8Ch] [ebp-3Ch]
  SBDecState *v85; // [esp+90h] [ebp-38h]
  int v86;         // [esp+94h] [ebp-34h]
  char *v87;       // [esp+98h] [ebp-30h]
  int v88;         // [esp+9Ch] [ebp-2Ch]
  int v89;         // [esp+ACh] [ebp-1Ch]

  v79 = **a1;
  v85 = (SBDecState *)((char *)&a1[10][(_DWORD)a1[3]] + (-(int)a1[10] & 3));
  v3 = (int)a1[10] + (-(int)a1[10] & 3);
  v73 = speex_decode_native(a1[1]);
  if ((int)a1[3] > 0) {
    v4 = 0;
    do {
      a1[11][v4] = *(_DWORD *)(v3 + 4 * v4);
      ++v4;
    } while (v4 < (int)a1[3]);
  }
  speex_decoder_ctl(a1[1]);
  if (v73)
    return v73;
  if (!a2) {
    sb_decode_lost((int)a1, (int)a3, v89, v85);
    return v73;
  }
  if (!a1[25]) {
    v5 = (int)a1[27];
    goto LABEL_8;
  }
  if ((int)speex_bits_remaining(a2) > 0 && speex_bits_peek(a2)) {
    speex_bits_unpack_unsigned(a2, 1);
    v5 = speex_bits_unpack_unsigned(a2, 3);
    a1[27] = (int *)v5;
  } else {
    a1[27] = 0;
    v5 = (int)a1[27];
  }
  if (v5) {
    if (a1[26][v5])
      goto LABEL_9;
    speex_warning("Invalid mode encountered: corrupted stream?");
    return -2;
  }
LABEL_8:
  if (a1[26][v5]) {
  LABEL_9:
    v6 = (int)a1[3];
    if (v6 > 0) {
      for (i = 0; i < v6; ++i) {
        a1[18][i] = 0;
        v6 = (int)a1[3];
      }
    }
    v8 = (int)v85 + 4 * (_DWORD)a1[5] + ((4 - (_BYTE)v85) & 3);
    v9 = 4 * v6 + ((4 - (_BYTE)v8) & 3) + v8;
    v74 = v9 - 4 * v6;
    v10 = (4 - (_BYTE)v9) & 3;
    v86 = 4 * v6 + v10 + v9;
    v75 = (char *)(v10 + v9);
    speex_decoder_ctl(a1[1]);
    speex_decoder_ctl(a1[1]);
    speex_decoder_ctl(a1[1]);
    (*(void(__cdecl **)(int *, int *, SpeexBits *))(a1[26][(_DWORD)a1[27]] +
                                                    20))(a1[19], a1[6], a2);
    if (a1[7] && (int)a1[6] > 0) {
      v23 = 0;
      do {
        a1[20][v23] = a1[19][v23];
        ++v23;
      } while ((int)a1[6] > v23);
    }
    v70 = (int)a1[6];
    v76 = (float *)(v86 + ((4 - (_BYTE)v86) & 3));
    v77 = (float *)((char *)&v76[v70 + 1 + v70] +
                    (-(char)(v86 + ((4 - v86) & 3) + 4 * v70) & 3) + -4 * v70);
    v11 = -(char)(4 * v70 + (-(char)(v86 + ((4 - v86) & 3) + 4 * v70) & 3) +
                  v86 + ((4 - v86) & 3) + 4 * v70 + 4) &
          3;
    v12 = (char *)&v76[v70 + 3 + v70 + v70] +
          (-(char)(v86 + ((4 - v86) & 3) + 4 * v70) & 3) + v11;
    v87 = v12;
    v78 = (float *)((char *)&v76[v70 + 2 + v70 + v70] +
                    (-(char)(v86 + ((4 - v86) & 3) + 4 * v70) & 3) + v11 +
                    -4 * v70);
    v13 = (int)a1[5];
    if (v13 <= 0) {
    LABEL_15:
      fir_mem_up((const float *)a1[11], &h0, (float *)a1[14], (int)a1[2], 64,
                 (float *)a1[16], v12);
      fir_mem_up((const float *)a1[13], &h1, (float *)a1[15], (int)a1[2], 64,
                 (float *)a1[17], v87);
      v14 = (int)a1[2];
      v15 = a1[15];
      v69 = a1[14];
      if (v14 > 0) {
        v16 = 0;
        v17.i32[0] = -956301824;
        do {
          while (1) {
            v18 = (__m128)(unsigned int)v69[v16];
            v18.f32[0] = (float)(v18.f32[0] - *(float *)&v15[v16]) +
                         (float)(v18.f32[0] - *(float *)&v15[v16]);
            if (v18.f32[0] > 32767.0)
              break;
            v19 = v18.i32[0];
            v20 = _mm_cmpge_ss(v18, v17);
            a3[v16++] = _mm_andnot_ps(v20, (__m128)0xC6FFFE00).u32[0] |
                        v19 & v20.i32[0];
            if (v14 == v16)
              goto LABEL_19;
          }
          a3[v16++] = 1191181824;
        } while (v14 != v16);
      }
    LABEL_19:
      if ((int)a1[6] > 0) {
        v21 = 0;
        do {
          a1[20][v21] = a1[19][v21];
          ++v21;
        } while (v21 < (int)a1[6]);
      }
      a1[7] = 0;
      return 0;
    }
    v72 = 0;
    while (1) {
      v71 = (_DWORD)a1[4] * v72;
      v81 = (float *)&a1[13][v71];
      v80 = (float *)&a1[18][v71];
      lsp_interpolate((float *)a1[20], (float *)a1[19], (float *)a1[21], v70,
                      v72, v13);
      lsp_enforce_margin((float *)a1[21], (int)a1[6], 0.050000001);
      lsp_to_lpc((float *)a1[21], (float *)a1[22], (int)a1[6], v87);
      if (a1[9]) {
        v60 = (float *)a1[26][(_DWORD)a1[27]];
        v61 = v60[13];
        v62 = v60[14];
        bw_lpc(v60[12], (const float *)a1[22], v76, (int)a1[6]);
        bw_lpc(v61, (const float *)a1[22], v77, (int)a1[6]);
        bw_lpc(v62, (const float *)a1[22], v78, (int)a1[6]);
      }
      a1[24][v72] = 1065353216;
      if ((int)a1[6] > 0) {
        v56 = 0;
        v57 = 1.0;
        v58 = 0;
        do {
          v59 = (float *)&a1[22][v58];
          v57 = v57 + (float)(v59[1] - *v59);
          *(float *)&a1[24][v72] =
              (float)(v59[1] + *v59) + *(float *)&a1[24][v72];
          v56 += 2;
          v58 += 2;
        } while ((int)a1[6] > v56);
        v33 = v57;
      } else {
        v33 = 1.0;
      }
      v34 = (*(float *)((char *)&v85->mode + 4 * v72 + ((4 - (_BYTE)v85) & 3)) +
             0.01) /
            (v33 + 0.01);
      v82 = v34;
      if ((int)a1[4] > 0) {
        v35 = 0;
        do
          v80[v35++] = 0.0;
        while ((int)a1[4] > v35);
      }
      if (*(_DWORD *)(a1[26][(_DWORD)a1[27]] + 40)) {
        v36 = speex_bits_unpack_unsigned(a2, 4);
        v83 = compute_rms((const float *)(v71 * 4 + v74), (int)a1[4]);
        *(double *)&v68 = (double)v36 * 0.2702702702702702 - 0.15556;
        v37 = exp(v68);
        v38 = a1[4];
        if (v38 == (int *)80)
          v37 = v37 * 1.4142;
        v84 = (float)(v37 / v82) * (float)(v83 + 1.0);
        v39 = a1[26][(_DWORD)a1[27]];
        (*(void(__cdecl **)(float *, _DWORD, int *, SpeexBits *, char *))(
            v39 + 40))(v80, *(_DWORD *)(v39 + 44), v38, a2, v87);
        signal_mul(v80, v80, v84, (int)a1[4]);
        v40 = a1[27];
        v41 = a1[26];
        if (*(_DWORD *)(v41[(_DWORD)v40] + 12)) {
          v42 = (int)a1[4];
          v88 = (int)&v87[4 * v42 + (-(int)v87 & 3)];
          v43 = &v87[-(int)v87 & 3];
          if (v42 > 0) {
            for (j = 0; j < v42; ++j) {
              *(_DWORD *)&v43[4 * j] = 0;
              v42 = (int)a1[4];
            }
            v40 = a1[27];
            v41 = a1[26];
          }
          (*(void(__cdecl **)(char *, _DWORD, int, SpeexBits *, int))(
              v41[(_DWORD)v40] + 40))(v43, *(_DWORD *)(v41[(_DWORD)v40] + 44),
                                      v42, a2, v88);
          if ((int)a1[4] > 0) {
            v45 = 1;
            v46 = v43 + 4;
            do {
              v47 = *((float *)v46 - 1) * (v84 * 0.4);
              *((float *)v46 - 1) = v47;
              v48 = v45++;
              v46 += 4;
            } while ((int)a1[4] > v48);
            if ((int)a1[4] <= 0) {
            LABEL_87:
              v51 = (int)a1[4];
              goto LABEL_70;
            }
            v49 = 1;
            do {
              v80[v49 - 1] = v80[v49 - 1] + *(float *)&v43[4 * v49 - 4];
              v50 = v49++;
            } while ((int)a1[4] > v50);
          }
        }
      } else {
        *(double *)&v68 =
            (float)((float)speex_bits_unpack_unsigned(a2, 5) - 10.0) * 0.125;
        v63 = exp(v68);
        v64 = v63 / v34;
        if ((int)a1[4] <= 0)
          goto LABEL_87;
        v65 = (float *)&v75[v71 * 4];
        v66 = 1;
        do {
          v80[v66 - 1] = (float)(v64 * *(float *)(v79 + 36)) * *v65;
          v67 = v66++;
          ++v65;
        } while (v67 < (int)a1[4]);
      }
      v51 = (int)a1[4];
      if (v51 > 0) {
        v52 = 1;
        do {
          v81[v52 - 1] = v80[v52 - 1];
          v53 = v52;
          v51 = (int)a1[4];
          ++v52;
        } while (v53 < v51);
      }
    LABEL_70:
      if (a1[9]) {
        filter_mem2(v81, v77, v76, v81, v51, (int)a1[6],
                    (float *)&a1[23][(_DWORD)a1[6]]);
        filter_mem2(v81, v78, (const float *)a1[22], v81, (int)a1[4],
                    (int)a1[6], (float *)a1[23]);
        ++v72;
        v13 = (int)a1[5];
        if (v72 >= v13)
          goto LABEL_81;
      } else {
        v54 = (int)a1[6];
        if (v54 > 0) {
          for (k = 0; k < v54; ++k) {
            a1[23][k + v54] = 0;
            v54 = (int)a1[6];
          }
          v51 = (int)a1[4];
        }
        iir_mem2(v81, (const float *)a1[22], v81, v51, v54, (float *)a1[23]);
        ++v72;
        v13 = (int)a1[5];
        if (v72 >= v13) {
        LABEL_81:
          v12 = v87;
          goto LABEL_15;
        }
      }
      v70 = (int)a1[6];
    }
  }
  if (v89) {
    sb_decode_lost((int)a1, (int)a3, 1, v85);
    return 0;
  }
  if ((int)a1[3] > 0) {
    v24 = 0;
    do
      a1[18][v24++] = 646978941;
    while ((int)a1[3] > v24);
  }
  a1[7] = (int *)1;
  iir_mem2((const float *)a1[18], (const float *)a1[22], (float *)a1[13],
           (int)a1[3], (int)a1[6], (float *)a1[23]);
  fir_mem_up((const float *)a1[11], &h0, (float *)a1[14], (int)a1[2], 64,
             (float *)a1[16], (char *)v85);
  fir_mem_up((const float *)a1[13], &h1, (float *)a1[15], (int)a1[2], 64,
             (float *)a1[17], (char *)v85);
  v25 = (int)a1[2];
  v26 = a1[15];
  v27 = a1[14];
  if (v25 > 0) {
    v28 = 0;
    v29.i32[0] = -956301824;
    do {
      v32 = (__m128)(unsigned int)v27[v28];
      v32.f32[0] = (float)(v32.f32[0] - *(float *)&v26[v28]) +
                   (float)(v32.f32[0] - *(float *)&v26[v28]);
      if (v32.f32[0] <= 32767.0) {
        v30 = v32.i32[0];
        v31 = _mm_cmpge_ss(v32, v29);
        a3[v28] =
            _mm_andnot_ps(v31, (__m128)0xC6FFFE00).u32[0] | v30 & v31.i32[0];
      } else {
        a3[v28] = 1191181824;
      }
      ++v28;
    } while (v25 != v28);
  }
  return 0;
}

int __cdecl pitch_unquant_3tap(float *a1, int a2, int a3, float a4, _DWORD *a5,
                               int a6, int *a7, float *a8, SpeexBits *a9,
                               char *a10, int a11, int a12, float a13,
                               int a14) {
  int v14;      // ebx
  int v15;      // eax
  float v16;    // xmm3_4
  int v17;      // ebx
  float v18;    // xmm4_4
  float v19;    // xmm1_4
  int v20;      // edx
  float v21;    // xmm5_4
  int v22;      // esi
  int v23;      // ebx
  float *v24;   // edx
  int i;        // ecx
  int v26;      // edi
  float *v27;   // ecx
  _DWORD *v28;  // edx
  int v29;      // ebx
  int v30;      // esi
  _DWORD *v31;  // eax
  int v32;      // edx
  int result;   // eax
  char *v34;    // ebx
  char *v35;    // ecx
  int j;        // edx
  float v37;    // xmm0_4
  float v38;    // xmm5_4
  float v39;    // xmm0_4
  double v40;   // xmm2_8
  double v41;   // xmm0_8
  double v42;   // xmm2_8
  double v43;   // xmm0_8
  float v44;    // xmm0_4
  int v45;      // edx
  float *v46;   // eax
  int v47;      // [esp+14h] [ebp-54h]
  char *v48;    // [esp+18h] [ebp-50h]
  int v49;      // [esp+1Ch] [ebp-4Ch]
  int v50;      // [esp+20h] [ebp-48h]
  int v51;      // [esp+24h] [ebp-44h]
  float *v52;   // [esp+28h] [ebp-40h]
  int v53;      // [esp+2Ch] [ebp-3Ch]
  _BYTE v54[4]; // [esp+34h] [ebp-34h]
  char *v55;    // [esp+38h] [ebp-30h]
  char *v56;    // [esp+3Ch] [ebp-2Ch]
  char *v57;    // [esp+40h] [ebp-28h]
  float v58;    // [esp+44h] [ebp-24h]
  float v59;    // [esp+48h] [ebp-20h] BYREF
  float v60;    // [esp+4Ch] [ebp-1Ch]

  v14 = *a5 + 3 * a14 * (1 << a5[1]);
  v53 = a2 + speex_bits_unpack_unsigned(a9, a5[2]);
  v15 = 3 * speex_bits_unpack_unsigned(a9, a5[1]);
  v16 = (double)*(char *)(v14 + v15) * 0.015625 + 0.5;
  v58 = v16;
  v17 = v15 + v14;
  v18 = (double)*(char *)(v17 + 1) * 0.015625 + 0.5;
  v59 = v18;
  v19 = (double)*(char *)(v17 + 2) * 0.015625 + 0.5;
  v60 = v19;
  if (!a11) {
  LABEL_4:
    v20 = v53;
    goto LABEL_5;
  }
  if (v53 > a12) {
    if (a11 > 3)
      v38 = a13 * 0.4;
    else
      v38 = a13;
    if (v38 > 0.95)
      v38 = 0.94999999;
    v18 = v59;
    v39 = v59;
    if (v59 < 0.0)
      v39 = -v59;
    v40 = v39;
    v16 = v58;
    if (v58 <= 0.0)
      v41 = v58 * -0.5;
    else
      v41 = v58;
    v42 = v40 + v41;
    if (v19 <= 0.0)
      v43 = v19 * -0.5;
    else
      v43 = v19;
    v44 = v43 + v42;
    if (v44 > v38) {
      v45 = 1;
      v46 = &v59;
      do {
        *(v46 - 1) = (float)(v38 / v44) * *(v46 - 1);
        ++v45;
        ++v46;
      } while (v45 != 4);
      v18 = v59;
      v16 = v58;
      v20 = v53;
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  v20 = v53;
LABEL_5:
  *a7 = v20;
  *a8 = v16;
  a8[1] = v18;
  v21 = v60;
  a8[2] = v60;
  v55 = &a10[-(int)a10 & 3];
  v56 = &v55[4 * a6];
  v48 = &v55[8 * a6];
  v57 = v48;
  v50 = v53 + 1;
  v51 = 2 * v53 + 1;
  v52 = &a1[-v53 - 1];
  v49 = 1;
  v47 = 4;
  do {
    v22 = v50;
    if (a6 <= v50)
      v22 = a6;
    if (v22 > 0) {
      v23 = *(_DWORD *)&v54[v47];
      v24 = v52;
      for (i = 0; i != v22; ++i)
        *(float *)(v23 + 4 * i) = *v24++;
    }
    v26 = a6;
    if (a6 > v51)
      v26 = v51;
    if (v22 < v26) {
      v27 = &a1[v22 - v50 - v53];
      v28 = (_DWORD *)(*(_DWORD *)&v54[v47] + 4 * v22);
      v29 = 0;
      v30 = v26 - v22;
      do {
        *v28 = *(_DWORD *)v27;
        ++v29;
        ++v27;
        ++v28;
      } while (v29 != v30);
    }
    if (v26 < a6) {
      v31 = (_DWORD *)(*(_DWORD *)&v54[v47] + 4 * v26);
      v32 = 0;
      do {
        *v31 = 0;
        ++v32;
        ++v31;
      } while (v32 != a6 - v26);
    }
    ++v49;
    v47 += 4;
    --v50;
    --v51;
    ++v52;
  } while (v49 != 4);
  result = a6;
  if (a6 > 0) {
    v34 = v56;
    v35 = v55;
    for (j = 0; j != a6; ++j) {
      result = 4 * j;
      v37 = (float)(v16 * *(float *)&v48[4 * j]) + 1.0e-15 +
            (float)(v18 * *(float *)&v34[4 * j]) +
            (float)(v21 * *(float *)&v35[4 * j]);
      a1[j] = v37;
    }
  }
  return result;
}

int __cdecl forced_pitch_quant(float *a1, float *a2, float *a3, float *a4,
                               float *a5, float *a6, const void *a7, int a8,
                               int a9, float a10, int a11, int a12) {
  float v12;  // xmm1_4
  float *v13; // eax
  int i;      // edx

  v12 = a10;
  if (a10 > 0.99)
    v12 = 0.99000001;
  if (a12 > 0) {
    v13 = &a6[-a8];
    for (i = 0; i != a12; ++i)
      a6[i] = v12 * *v13++;
  }
  return a8;
}

int __cdecl forced_pitch_unquant(float *a1, int a2, int a3, float a4,
                                 const void *a5, int a6, int *a7, float *a8) {
  float v8;   // xmm1_4
  float *v9;  // eax
  int i;      // edx
  int result; // eax

  if (a4 <= 0.99)
    v8 = a4;
  else
    v8 = 0.99000001;
  if (a6 > 0) {
    v9 = &a1[-a2];
    for (i = 0; i != a6; ++i)
      a1[i] = v8 * *v9++;
  }
  *a7 = a2;
  result = 0;
  a8[2] = 0.0;
  *a8 = 0.0;
  a8[1] = a4;
  return result;
}

float *__cdecl open_loop_nbest_pitch(float *a1, int a2, int a3, int a4, int *a5,
                                     float *a6, int a7, char *a8) {
  char *v8;      // edx
  int v9;        // ecx
  int v10;       // edx
  int v11;       // esi
  int v12;       // eax
  int i;         // eax
  float *v14;    // edx
  float *v15;    // eax
  float v16;     // xmm2_4
  int v17;       // ecx
  float v18;     // xmm1_4
  float *v19;    // edx
  float *v20;    // eax
  float v21;     // xmm6_4
  int v22;       // ecx
  float v23;     // xmm1_4
  float *v24;    // edx
  float *v25;    // ebx
  float *v26;    // ecx
  int v27;       // eax
  float *result; // eax
  int v29;       // edi
  float *v30;    // ecx
  float *v31;    // edx
  float v32;     // xmm2_4
  int v33;       // ebx
  float v34;     // xmm1_4
  int v35;       // edx
  int v36;       // ecx
  float *v37;    // ebx
  float v38;     // xmm1_4
  float v39;     // xmm0_4
  float *j;      // edx
  float v41;     // xmm0_4
  int v42;       // esi
  int v43;       // ebx
  float *v44;    // ecx
  int *v45;      // edx
  int v46;       // edx
  float v47;     // xmm2_4
  int v48;       // eax
  float v49;     // xmm0_4
  int v50;       // [esp+0h] [ebp-40h]
  int v51;       // [esp+8h] [ebp-38h]
  int v52;       // [esp+Ch] [ebp-34h]
  float *v53;    // [esp+10h] [ebp-30h]
  int v54;       // [esp+14h] [ebp-2Ch]
  float *v55;    // [esp+18h] [ebp-28h]
  int v56;       // [esp+1Ch] [ebp-24h]
  int v57;       // [esp+20h] [ebp-20h]
  int v58;       // [esp+24h] [ebp-1Ch]
  float *v59;    // [esp+2Ch] [ebp-14h]

  v8 = &a8[4 * a7 + ((4 - (_BYTE)a8) & 3)];
  v53 = (float *)&a8[(4 - (_BYTE)a8) & 3];
  v51 = a3 - a2;
  v9 = 4 * (a3 - a2);
  v10 = (int)&v8[((4 - (_BYTE)v8) & 3) + 4 + v9];
  v11 = -4 * (a3 - a2);
  v54 = v10 - v9 - 4;
  v12 = v9 + ((4 - (_BYTE)v10) & 3) + v10 + 8;
  v55 = (float *)(v11 + v9 + ((4 - (_BYTE)v10) & 3) + v10);
  v56 = v11 + v9 + ((4 - (_BYTE)v12) & 3) + v12;
  if (a7 > 0) {
    for (i = 0; i != a7; ++i) {
      v53[i] = -1.0;
      a5[i] = a2;
    }
  }
  v14 = &a1[-a2];
  v15 = v14;
  if (a4 >> 2) {
    v16 = 0.0;
    v17 = 0;
    do {
      v18 = (float)((float)((float)((float)(*v14 * *v15) + 0.0) +
                            (float)(v14[1] * v15[1])) +
                    (float)(v14[2] * v15[2])) +
            (float)(v14[3] * v15[3]);
      v14 += 4;
      v15 += 4;
      v16 = v16 + v18;
      ++v17;
    } while (v17 != a4 >> 2);
  } else {
    v16 = 0.0;
  }
  *v55 = v16;
  v19 = a1;
  v20 = a1;
  if (a4 >> 2) {
    v21 = 0.0;
    v22 = 0;
    do {
      v23 = (float)((float)((float)((float)(*v19 * *v20) + 0.0) +
                            (float)(v19[1] * v20[1])) +
                    (float)(v19[2] * v20[2])) +
            (float)(v19[3] * v20[3]);
      v19 += 4;
      v20 += 4;
      v21 = v21 + v23;
      ++v22;
    } while (v22 != a4 >> 2);
  } else {
    v21 = 0.0;
  }
  if (a3 >= a2) {
    v24 = v55;
    v25 = &a1[-a2];
    v26 = &a1[a4 - a2];
    v27 = a2;
    do {
      v24[1] = (float)((float)(*(v25 - 1) * *(v25 - 1)) + *v24) -
               (float)(*(v26 - 1) * *(v26 - 1));
      ++v27;
      ++v24;
      --v25;
      --v26;
    } while (a3 >= v27);
  }
  v57 = v51 + 1;
  result = (float *)(4 * a3);
  if (v51 + 1 > 0) {
    v29 = v54 + 4 * (v51 + 1);
    v30 = &a1[-a3];
    v58 = 0;
    result = (float *)((a4 >> 2) - 1);
    do {
      while (1) {
        v31 = v30;
        if (a4 >> 2)
          break;
        *(_DWORD *)(v29 - 4) = 0;
        ++v58;
        v29 -= 4;
        ++v30;
        if (v57 == v58)
          goto LABEL_19;
      }
      result = a1;
      v32 = 0.0;
      v33 = 0;
      do {
        v34 = (float)((float)((float)((float)(*result * *v31) + 0.0) +
                              (float)(result[1] * v31[1])) +
                      (float)(result[2] * v31[2])) +
              (float)(result[3] * v31[3]);
        result += 4;
        v31 += 4;
        v32 = v32 + v34;
        ++v33;
      } while (v33 != a4 >> 2);
      *(float *)(v29 - 4) = v32;
      ++v58;
      v29 -= 4;
      ++v30;
    } while (v57 != v58);
  }
LABEL_19:
  if (a3 >= a2) {
    v35 = a2;
    v36 = 0;
    do {
      while (1) {
        v38 = *(float *)(v54 + 4 * v36);
        v39 = v38 / (float)(v55[v36] + 1.0);
        if (v39 <= 16.0)
          break;
        v37 = (float *)v56;
        *(float *)(v56 + 4 * v36) = 16.0 * v38;
        ++v35;
        ++v36;
        if (a3 < v35)
          goto LABEL_24;
      }
      v37 = (float *)v56;
      *(float *)(v56 + 4 * v36) = fmaxf(-16.0, v39) * v38;
      ++v35;
      ++v36;
    } while (a3 >= v35);
  LABEL_24:
    v59 = v37;
    v50 = a2;
    result = v37;
    for (j = &v53[a7 - 1];; j = &v53[a7 - 1]) {
      v41 = *result;
      if (*result > *j && a7 > 0) {
        if (v41 <= *v53) {
          v42 = 0;
          while (a7 != ++v42) {
            v52 = v42;
            if (v41 > v53[v42]) {
              v43 = a7 - 1;
              if (a7 - 1 <= v42)
                goto LABEL_29;
              goto LABEL_41;
            }
          }
        } else {
          v42 = 0;
          v52 = 0;
          v43 = a7 - 1;
          if (a7 - 1 > 0) {
          LABEL_41:
            v44 = &v53[v43 - 1];
            v45 = &a5[v43 - 1];
            do {
              v44[1] = *v44;
              v45[1] = *v45;
              --v43;
              --v44;
              --v45;
            } while (v42 < v43);
            v41 = *v59;
          }
        LABEL_29:
          result = (float *)(4 * v52);
          *(float *)((char *)result + (_DWORD)v53) = v41;
          *(_DWORD *)((char *)result + (_DWORD)a5) = v50;
        }
      }
      ++v50;
      ++v59;
      if (a3 < v50)
        break;
      result = v59;
    }
  }
  if (a6 && a7 > 0) {
    v46 = 0;
    v47 = fsqrt(v21);
    do {
      v48 = a5[v46] - a2;
      v49 = *(float *)(v54 + v48 * 4) /
            (float)((float)(fsqrt(v55[v48]) * v47) + 10.0);
      result = a6;
      a6[v46++] = fmaxf(0.0, v49);
    } while (a7 != v46);
  }
  return result;
}

int __cdecl pitch_search_3tap(float *a1, float *a2, float *a3, float *a4,
                              float *a5, float *a6, char **a7, int a8, int a9,
                              float a10, int a11, int a12, SpeexBits *a13,
                              char *a14, float *a15, float *a16, int a17,
                              int a18, int a19) {
  int v19;          // ecx
  int v20;          // edx
  char *v21;        // edx
  int v22;          // ebx
  int v23;          // eax
  int v24;          // eax
  int v25;          // edx
  char *v26;        // esi
  int v27;          // eax
  int j;            // eax
  int k;            // eax
  int v30;          // ebx
  float *v31;       // edi
  float *v32;       // esi
  int v33;          // ecx
  int i;            // eax
  int nn;           // ecx
  int i1;           // ecx
  int v38;          // esi
  float *v39;       // ebx
  int m;            // ecx
  float *v41;       // eax
  float *v42;       // ecx
  int n;            // edx
  int ii;           // ebx
  float *v45;       // edx
  float *v46;       // eax
  float v47;        // xmm2_4
  int v48;          // ecx
  float v49;        // xmm1_4
  float *v50;       // edi
  float *v51;       // esi
  float *v52;       // edx
  float *v53;       // eax
  float v54;        // xmm2_4
  int v55;          // ecx
  float v56;        // xmm1_4
  int v57;          // edx
  double v58;       // xmm2_8
  double v59;       // xmm1_8
  float v60;        // xmm0_4
  float v61;        // xmm0_4
  float v62;        // xmm0_4
  double v63;       // xmm1_8
  float v64;        // xmm0_4
  float v65;        // xmm0_4
  float v66;        // xmm0_4
  unsigned int v67; // esi
  int v68;          // edx
  float v69;        // xmm4_4
  int v70;          // edx
  float v71;        // xmm3_4
  float v72;        // xmm2_4
  float v73;        // xmm5_4
  int kk;           // ecx
  int mm;           // ecx
  int v76;          // ebx
  int v77;          // ecx
  int jj;           // edx
  float *v79;       // ebx
  char *v80;        // ecx
  int v81;          // edx
  float v82;        // xmm0_4
  char *v83;        // edx
  unsigned int v84; // ecx
  float v85;        // xmm3_4
  float v86;        // xmm4_4
  float v87;        // xmm6_4
  float v88;        // xmm5_4
  float v89;        // xmm0_4
  float v90;        // xmm0_4
  double v91;       // xmm0_8
  float v92;        // xmm3_4
  int v93;          // [esp+30h] [ebp-118h]
  int v94;          // [esp+34h] [ebp-114h]
  unsigned int v95; // [esp+38h] [ebp-110h]
  char *v96;        // [esp+3Ch] [ebp-10Ch]
  int v97;          // [esp+40h] [ebp-108h]
  int v98;          // [esp+44h] [ebp-104h]
  int v99;          // [esp+48h] [ebp-100h]
  float v100;       // [esp+4Ch] [ebp-FCh]
  int *v101;        // [esp+50h] [ebp-F8h]
  char *v102;       // [esp+54h] [ebp-F4h]
  float *v103;      // [esp+58h] [ebp-F0h]
  int v104;         // [esp+5Ch] [ebp-ECh]
  float *v105;      // [esp+60h] [ebp-E8h]
  int v106;         // [esp+64h] [ebp-E4h]
  int v107;         // [esp+70h] [ebp-D8h]
  char *v108;       // [esp+74h] [ebp-D4h]
  int v109;         // [esp+78h] [ebp-D0h]
  int v110;         // [esp+7Ch] [ebp-CCh]
  int v111;         // [esp+80h] [ebp-C8h]
  float v112;       // [esp+84h] [ebp-C4h]
  int v113;         // [esp+9Ch] [ebp-ACh]
  int v114;         // [esp+A0h] [ebp-A8h]
  int v115;         // [esp+A4h] [ebp-A4h]
  float *v116;      // [esp+A8h] [ebp-A0h]
  int v117;         // [esp+ACh] [ebp-9Ch]
  float *v118;      // [esp+B0h] [ebp-98h]
  float *v119;      // [esp+B4h] [ebp-94h]
  int v120;         // [esp+B8h] [ebp-90h]
  float v121;       // [esp+BCh] [ebp-8Ch]
  float v122;       // [esp+C0h] [ebp-88h]
  float v123;       // [esp+C4h] [ebp-84h]
  float v124;       // [esp+C8h] [ebp-80h]
  float v125;       // [esp+CCh] [ebp-7Ch]
  float v126;       // [esp+D0h] [ebp-78h]
  char *v127;       // [esp+D4h] [ebp-74h]
  int v128;         // [esp+D8h] [ebp-70h]
  int v129;         // [esp+DCh] [ebp-6Ch]
  float v130;       // [esp+E8h] [ebp-60h] BYREF
  float v131;       // [esp+ECh] [ebp-5Ch]
  float v132;       // [esp+F0h] [ebp-58h]
  float v133;       // [esp+F8h] [ebp-50h]
  float v134;       // [esp+FCh] [ebp-4Ch]
  float v135[3];    // [esp+108h] [ebp-40h]
  float v136;       // [esp+114h] [ebp-34h]
  int v137;         // [esp+118h] [ebp-30h]
  int v138;         // [esp+11Ch] [ebp-2Ch]
  int v139;         // [esp+120h] [ebp-28h]
  float *v140;      // [esp+124h] [ebp-24h]
  char *v141;       // [esp+128h] [ebp-20h]
  char *v142;       // [esp+12Ch] [ebp-1Ch]

  if (a17 <= 10) {
    if (a17 > 0) {
      v19 = a17;
      v21 = &a14[4 * a17 + ((4 - (_BYTE)a14) & 3)];
      v101 = (int *)&a14[(4 - (_BYTE)a14) & 3];
      if (a9 >= a8)
        goto LABEL_4;
    LABEL_21:
      speex_bits_pack(a13, 0, a7[2]);
      speex_bits_pack(a13, 0, a7[1]);
      if (a12 > 0) {
        for (i = 0; i != a12; ++i)
          a6[i] = 0.0;
      }
      return a8;
    }
    v19 = 1;
    v20 = 1;
  } else {
    v19 = 10;
    v20 = 10;
  }
  v21 = &a14[4 * v20 + ((4 - (_BYTE)a14) & 3)];
  v101 = (int *)&a14[(4 - (_BYTE)a14) & 3];
  if (a9 < a8)
    goto LABEL_21;
LABEL_4:
  v22 = 4 * a12;
  v23 = (int)&v21[4 * a12 + ((4 - (_BYTE)v21) & 3)];
  v96 = &v21[(4 - (_BYTE)v21) & 3];
  v24 = 4 * a12 + ((4 - (_BYTE)v23) & 3) + v23;
  v97 = v24 - 4 * a12;
  v25 = (4 - (_BYTE)v24) & 3;
  v26 = (char *)(4 * a12 + v25 + v24);
  v98 = v25 + v24;
  if (v19 > a9 - a8 + 1)
    v19 = a9 - a8 + 1;
  v129 = v19;
  open_loop_nbest_pitch(a2, a8, a9, a12, v101, 0, v19, v26);
  if (v129 > 0) {
    v27 = (int)&v26[12 * a12 + ((4 - (_BYTE)v26) & 3)];
    v108 = &v26[(4 - (_BYTE)v26) & 3];
    v127 = (char *)(12 * a12 + ((4 - (_BYTE)v27) & 3) + v27);
    v109 = ((4 - (_BYTE)v27) & 3) + v27;
    v102 = &v108[v22];
    v103 = (float *)&v108[8 * a12];
    v104 = v109 + v22;
    v105 = (float *)(v109 + 8 * a12);
    v106 = a12 - 1;
    v100 = -1.0;
    v128 = 0;
    v95 = 0;
    v99 = 0;
    for (j = 0;; j = v128) {
      v94 = v101[j];
      if (a12 > 0) {
        for (k = 0; k != a12; ++k)
          a6[k] = 0.0;
      }
      v110 = 1 << (char)a7[1];
      v111 = (int)&(*a7)[3 * v110 * a18];
      v140 = (float *)v108;
      v141 = v102;
      v142 = &v108[8 * a12];
      v137 = v109;
      v138 = v104;
      v139 = v109 + 8 * a12;
      v117 = -v94 - v94;
      v116 = &a15[v117 + 1];
      v118 = &a15[-v94 + 1];
      v115 = 1;
      v93 = 12;
      do {
        if (a12 > 0) {
          v30 = v115 - v94;
          v31 = v118;
          v32 = v116;
          v33 = v117 + v115;
          v107 = 0;
          v114 = 0;
          do {
            if (v30 >= 0) {
              if (v33 < 0)
                *(float *)(*(_DWORD *)((char *)&v136 + v93) + v114) = *v32;
              else
                *(_DWORD *)(*(_DWORD *)((char *)&v136 + v93) + v114) = 0;
            } else {
              *(float *)(*(_DWORD *)((char *)&v136 + v93) + v114) = *v31;
            }
            ++v107;
            ++v30;
            v114 += 4;
            ++v31;
            ++v32;
            ++v33;
          } while (a12 != v107);
        }
        if (v115 == 1) {
          syn_percep_zero(v105, a3, a4, a5, v103, a12, a11, v127);
        } else {
          if (v106 > 0) {
            v38 = *(int *)((char *)&v139 + v93);
            v39 = (&v140)[v93 / 4u];
            for (m = 0; m != v106; ++m)
              *(float *)(v38 + 4 * m + 4) = v39[m];
          }
          v41 = *(float **)((char *)&v139 + v93);
          *v41 = 0.0;
          if (a12 > 0) {
            v42 = *(float **)((char *)&v136 + v93);
            for (n = 0; n != a12; ++n) {
              *v41 = (float)(a16[n] * *v42) + *v41;
              ++v41;
            }
          }
        }
        --v115;
        v93 -= 4;
        --v116;
        --v118;
      } while (v115 != -2);
      for (ii = 1; ii != 4; ++ii) {
        v45 = (float *)*(&v139 + ii);
        if (a12 >> 2) {
          v46 = a1;
          v47 = 0.0;
          v48 = 0;
          do {
            v49 = (float)((float)((float)((float)(*v45 * *v46) + 0.0) +
                                  (float)(v45[1] * v46[1])) +
                          (float)(v45[2] * v46[2])) +
                  (float)(v45[3] * v46[3]);
            v45 += 4;
            v46 += 4;
            v47 = v47 + v49;
            ++v48;
          } while (v48 != a12 >> 2);
        } else {
          v47 = 0.0;
        }
        v135[ii] = v47;
      }
      v120 = 0;
      while (1) {
        v119 = (&v140)[v120];
        v50 = &v130 + v120;
        v51 = &v130 + 3 * v120;
        v113 = 1;
        v52 = v140;
        if (!(a12 >> 2)) {
        LABEL_51:
          *v50 = 0.0;
          *v51 = 0.0;
          v50 += 3;
          ++v51;
          v57 = v113;
          if (v120 < v113)
            goto LABEL_52;
          goto LABEL_50;
        }
        while (1) {
          v53 = v119;
          v54 = 0.0;
          v55 = 0;
          do {
            v56 = (float)((float)((float)((float)(*v53 * *v52) + 0.0) +
                                  (float)(v53[1] * v52[1])) +
                          (float)(v53[2] * v52[2])) +
                  (float)(v53[3] * v52[3]);
            v53 += 4;
            v52 += 4;
            v54 = v54 + v56;
            ++v55;
          } while (v55 != a12 >> 2);
          *v50 = v54;
          *v51 = v54;
          v50 += 3;
          ++v51;
          v57 = v113;
          if (v120 < v113)
            break;
        LABEL_50:
          v113 = v57 + 1;
          v52 = (float *)*(&v139 + v57 + 1);
          if (!(a12 >> 2))
            goto LABEL_51;
        }
      LABEL_52:
        if (++v120 == 3)
          break;
        while (v120 < 0) {
          if (++v120 == 3)
            goto LABEL_55;
        }
      }
    LABEL_55:
      if (a19 <= 1)
        v58 = 2.0;
      else
        v58 = (double)a19;
      v59 = v58 * -0.01 + 1.0;
      v60 = v136 * v59;
      v126 = v60;
      v61 = v135[2] * v59;
      v125 = v61;
      v62 = v135[1] * v59;
      v124 = v62;
      v63 = (v58 * 0.01 + 1.0) * 0.5;
      v64 = v135[0] * v63;
      v123 = v64;
      v65 = v133 * v63;
      v122 = v65;
      v66 = v130 * v63;
      v121 = v66;
      if (v110 > 0) {
        v83 = (char *)v111;
        v84 = 0;
        v112 = 0.0;
        v67 = 0;
        do {
          v86 = (float)*v83 + 32.0;
          v87 = (float)v83[1] + 32.0;
          v88 = (float)v83[2] + 32.0;
          if (v86 <= 0.0)
            v89 = (float)v83[1] + 32.0;
          else
            v89 = v86 + v87;
          if (v88 > 0.0)
            v89 = v89 + v88;
          if (v89 <= 64.0) {
            v85 = 64.0;
          } else {
            v90 = v89 - 64.0;
            if (v90 <= 127.0)
              v91 = v90;
            else
              v91 = 127.0;
            v92 = (v91 * (v58 * -0.001) + 1.0) * 64.0;
            v85 = fmaxf(0.0, v92);
          }
          if ((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v85 *
                                                                                                      v86) *
                                                                                              v126) +
                                                                                      0.0) +
                                                                              (float)((float)(v85 *
                                                                                              v87) *
                                                                                      v125)) +
                                                                      (float)((float)(v85 *
                                                                                      v88) *
                                                                              v124)) -
                                                              (float)((float)(v86 *
                                                                              v87) *
                                                                      v134)) -
                                                      (float)((float)(v87 *
                                                                      v88) *
                                                              v131)) -
                                              (float)((float)(v86 * v88) *
                                                      v132)) -
                                      (float)((float)(v86 * v86) * v123)) -
                              (float)((float)(v87 * v87) * v122)) -
                      (float)((float)(v88 * v88) * v121)) > v112 ||
              !v84) {
            v67 = v84;
            v112 =
                (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v85 *
                                                                                                v86) *
                                                                                        v126) +
                                                                                0.0) +
                                                                        (float)((float)(v85 *
                                                                                        v87) *
                                                                                v125)) +
                                                                (float)((float)(v85 *
                                                                                v88) *
                                                                        v124)) -
                                                        (float)((float)(v86 *
                                                                        v87) *
                                                                v134)) -
                                                (float)((float)(v87 * v88) *
                                                        v131)) -
                                        (float)((float)(v86 * v88) * v132)) -
                                (float)((float)(v86 * v86) * v123)) -
                        (float)((float)(v87 * v87) * v122)) -
                (float)((float)(v88 * v88) * v121);
          }
          ++v84;
          v83 += 3;
        } while (v110 != v84);
        v68 = 3 * v67;
      } else {
        v67 = 0;
        v68 = 0;
      }
      v69 = (double)*(char *)(v111 + v68) * 0.015625 + 0.5;
      v70 = v111 + v68;
      v71 = (double)*(char *)(v70 + 1) * 0.015625 + 0.5;
      v72 = (double)*(char *)(v70 + 2) * 0.015625 + 0.5;
      if (a12 > 0) {
        v76 = v138;
        v77 = v137;
        for (jj = 0; jj != a12; ++jj)
          a6[jj] = (float)((float)(v69 * v105[jj]) +
                           (float)(v71 * *(float *)(4 * jj + v76))) +
                   (float)(v72 * *(float *)(4 * jj + v77));
        v79 = v140;
        v80 = v141;
        v81 = 0;
        v73 = 0.0;
        do {
          v82 = a1[v81] -
                (float)((float)((float)(v72 * v79[v81]) +
                                (float)(v71 * *(float *)&v80[4 * v81])) +
                        (float)(v69 * v103[v81]));
          *(float *)(v97 + 4 * v81) = v82;
          v73 = v73 + (float)(v82 * v82);
          ++v81;
        } while (a12 != v81);
      } else {
        v73 = 0.0;
      }
      if (v100 > v73 || v100 < 0.0) {
        if (a12 > 0) {
          for (kk = 0; kk != a12; ++kk)
            *(float *)&v96[4 * kk] = a6[kk];
          for (mm = 0; mm != a12; ++mm)
            *(_DWORD *)(v98 + 4 * mm) = *(_DWORD *)(v97 + 4 * mm);
        }
        v95 = v67;
        v99 = v94;
        v100 = v73;
      }
      if (v129 == ++v128)
        goto LABEL_26;
    }
  }
  v94 = 0;
  v95 = 0;
  v99 = 0;
LABEL_26:
  speex_bits_pack(a13, v99 - a8, a7[2]);
  speex_bits_pack(a13, v95, a7[1]);
  if (a12 > 0) {
    for (nn = 0; nn != a12; ++nn)
      a6[nn] = *(float *)&v96[4 * nn];
    for (i1 = 0; i1 != a12; ++i1)
      a1[i1] = *(float *)(v98 + 4 * i1);
  }
  return v94;
}

void __cdecl bw_lpc(float a1, const float *a2, float *a3, int a4) {
  float v4; // xmm1_4
  int i;    // eax

  if (a4 > 0) {
    v4 = a1;
    for (i = 0; i != a4; ++i) {
      a3[i] = v4 * a2[i];
      v4 = v4 * a1;
    }
  }
}

void __cdecl signal_mul(const float *a1, float *a2, float a3, int a4) {
  int i; // eax

  if (a4 > 0) {
    for (i = 0; i != a4; ++i)
      a2[i] = a3 * a1[i];
  }
}

void __cdecl signal_div(const float *a1, float *a2, float a3, int a4) {
  int i; // eax

  if (a4 > 0) {
    for (i = 0; i != a4; ++i)
      a2[i] = (float)(1.0 / a3) * a1[i];
  }
}

long double __cdecl compute_rms(const float *a1, int a2) {
  float v2; // xmm1_4
  int v3;   // eax

  v2 = 0.0;
  if (a2 > 0) {
    v3 = 0;
    v2 = 0.0;
    do {
      v2 = v2 + (float)(a1[v3] * a1[v3]);
      ++v3;
    } while (a2 != v3);
  }
  return (float)sqrt((float)(v2 / (float)a2) + 0.1);
}

int __cdecl filter_mem2(const float *a1, const float *a2, const float *a3,
                        float *a4, int a5, int a6, float *a7) {
  int result; // eax
  int v8;     // esi
  int i;      // ebx
  float v10;  // xmm2_4
  float v11;  // xmm3_4
  int j;      // ecx
  int v13;    // [esp+0h] [ebp-1Ch]

  result = a6;
  if (a5 > 0) {
    v8 = a6 - 1;
    v13 = 0;
    for (i = 0;; i = result) {
      v10 = a1[i];
      v11 = v10 + *a7;
      if (v8 > 0) {
        for (j = 0; j != v8; ++j)
          a7[j] = (float)((float)(v10 * a2[j]) + a7[j + 1]) +
                  (float)((float)-v11 * a3[j]);
      }
      a7[a6 - 1] = (float)(v10 * a2[a6 - 1]) - (float)(v11 * a3[a6 - 1]);
      a4[v13] = v11;
      result = v13 + 1;
      v13 = result;
      if (a5 == result)
        break;
    }
  }
  return result;
}

int __cdecl iir_mem2(const float *a1, const float *a2, float *a3, int a4,
                     int a5, float *a6) {
  int result; // eax
  int v7;     // ebx
  float v8;   // xmm1_4
  float v9;   // xmm2_4
  int v10;    // ecx
  float *v11; // edx

  result = a5;
  if (a4 > 0) {
    v7 = a5 - 1;
    for (result = 0; result != a4; ++result) {
      v8 = a1[result] + *a6;
      v9 = -v8;
      if (v7 > 0) {
        v10 = 0;
        v11 = a6;
        do {
          *v11 = (float)(v9 * a2[v10++]) + v11[1];
          ++v11;
        } while (v10 != v7);
      }
      a6[a5 - 1] = v9 * a2[a5 - 1];
      a3[result] = v8;
    }
  }
  return result;
}

int __cdecl fir_mem2(const float *a1, const float *a2, float *a3, int a4,
                     int a5, float *a6) {
  int result; // eax
  int v7;     // ebx
  float v8;   // xmm1_4
  float v9;   // xmm2_4
  int v10;    // ecx
  float *v11; // edx

  result = a5;
  if (a4 > 0) {
    v7 = a5 - 1;
    for (result = 0; result != a4; ++result) {
      v8 = a1[result];
      v9 = v8 + *a6;
      if (v7 > 0) {
        v10 = 0;
        v11 = a6;
        do {
          *v11 = (float)(v8 * a2[v10++]) + v11[1];
          ++v11;
        } while (v10 != v7);
      }
      a6[a5 - 1] = v8 * a2[a5 - 1];
      a3[result] = v9;
    }
  }
  return result;
}

int __cdecl compute_impulse_response(const float *a1, const float *a2,
                                     const float *a3, float *a4, int a5, int a6,
                                     char *a7) {
  char *v7;   // edx
  float *v8;  // edi
  float *v9;  // esi
  int v10;    // edx
  float *v11; // eax
  int v12;    // edx
  int j;      // edx
  int v14;    // eax
  int result; // eax
  float *k;   // ebx
  float v17;  // xmm0_4
  float v18;  // xmm2_4
  float v19;  // xmm0_4
  float v20;  // xmm1_4
  int m;      // ecx
  int i;      // edx
  float *v23; // [esp+0h] [ebp-2Ch]
  int v24;    // [esp+4h] [ebp-28h]
  int v25;    // [esp+4h] [ebp-28h]
  int v26;    // [esp+18h] [ebp-14h]
  int v27;    // [esp+1Ch] [ebp-10h]

  v7 = &a7[4 * a6 + ((4 - (_BYTE)a7) & 3)];
  v8 = (float *)&a7[(4 - (_BYTE)a7) & 3];
  v9 = (float *)&v7[(4 - (_BYTE)v7) & 3];
  *a4 = 1.0;
  if (a6 > 0) {
    for (i = 0; i != a6; ++i)
      a4[i + 1] = a2[i];
    v24 = a6 + 1;
    v10 = a6 + 1;
  } else {
    v24 = 1;
    v10 = 1;
  }
  if (a5 > v10) {
    v11 = &a4[v10];
    v12 = 0;
    v25 = a5 - v24;
    do {
      *v11 = 1.0e-15;
      ++v12;
      ++v11;
    } while (v12 != v25);
  }
  if (a6 > 0) {
    for (j = 0; j != a6; ++j) {
      v14 = j;
      v9[v14] = 0.0;
      v8[v14] = 0.0;
    }
  }
  result = a5;
  if (a5 > 0) {
    v26 = a6 - 1;
    v27 = 0;
    v23 = a4;
    for (k = a4;; k = v23) {
      v17 = *k + *v8;
      v18 = -v17;
      v19 = v17 + *v9;
      *k = v19;
      v20 = -v19;
      if (v26 > 0) {
        for (m = 0; m != v26; ++m) {
          v8[m] = (float)(v18 * a3[m]) + v8[m + 1];
          v9[m] = (float)(v20 * a1[m]) + v9[m + 1];
        }
      }
      v8[a6 - 1] = v18 * a3[a6 - 1];
      v9[a6 - 1] = v20 * a1[a6 - 1];
      ++v27;
      ++v23;
      result = v27;
      if (a5 == v27)
        break;
    }
  }
  return result;
}

int __cdecl qmf_decomp(const float *a1, const float *a2, float *a3, float *a4,
                       int a5, int a6, float *a7, char *a8) {
  char *v8;         // eax
  char *v9;         // esi
  char *v10;        // edx
  int i;            // ecx
  float *v12;       // edx
  int v13;          // ecx
  char *v14;        // edx
  int j;            // ecx
  int k;            // eax
  int v17;          // eax
  float *v18;       // edi
  float *v19;       // esi
  float *v20;       // ebx
  float *v21;       // ecx
  char *m;          // eax
  int result;       // eax
  const float *v24; // edx
  int n;            // ecx
  int v26;          // [esp+0h] [ebp-3Ch]
  int v27;          // [esp+4h] [ebp-38h]
  int v28;          // [esp+Ch] [ebp-30h]
  int v29;          // [esp+10h] [ebp-2Ch]
  int v30;          // [esp+1Ch] [ebp-20h]
  int v31;          // [esp+20h] [ebp-1Ch]
  int v32;          // [esp+24h] [ebp-18h]
  float *v33;       // [esp+28h] [ebp-14h]
  float *v34;       // [esp+2Ch] [ebp-10h]

  v26 = a6;
  v8 = &a8[4 * a6 + ((4 - (_BYTE)a8) & 3)];
  v9 = &v8[(4 - (_BYTE)v8) & 3];
  v29 = a6 >> 1;
  if (a6 > 0) {
    v10 = &a8[((4 - (_BYTE)a8) & 3) + v26 * 4];
    for (i = 0; i != a6; ++i) {
      *((float *)v10 - 1) = a2[i];
      v10 -= 4;
    }
  }
  v28 = a6 - 1;
  if (a6 - 1 > 0) {
    v12 = &a7[v26];
    v13 = 0;
    do {
      *(float *)&v9[4 * v13++] = *(v12 - 2);
      --v12;
    } while (v28 != v13);
  }
  if (a5 > 0) {
    v14 = &v9[4 * a6];
    for (j = 0; j != a5; ++j) {
      *((float *)v14 - 1) = a1[j];
      v14 += 4;
    }
    v32 = (int)&v9[4 * a6 - 4];
    v33 = (float *)&v8[(4 - (_BYTE)v8) & 3];
    v31 = 2;
    for (k = 2;; k = v31) {
      v17 = 2 * k;
      v34 = (float *)((char *)a3 + v17 - 4);
      *v34 = 0.0;
      v18 = (float *)((char *)a4 + v17 - 4);
      *v18 = 0.0;
      if (v29 > 0) {
        v19 = v33;
        v20 = (float *)v32;
        v21 = v33;
        v27 = v32;
        v30 = 2;
        for (m = &a8[((4 - (_BYTE)a8) & 3) + 8];; m += 8) {
          *v34 = (float)((float)(*v19 + *v20) * *((float *)m - 2)) + *v34;
          *v18 = *v18 - (float)((float)(*v19 - *v20) * *((float *)m - 2));
          *v34 = (float)((float)(v21[1] + *(float *)(v27 - 4)) *
                         *((float *)m - 1)) +
                 *v34;
          *v18 = (float)((float)(v21[1] - *(float *)(v27 - 4)) *
                         *((float *)m - 1)) +
                 *v18;
          v19 += 2;
          v20 -= 2;
          v21 += 2;
          v27 -= 8;
          if (v29 <= v30)
            break;
          v30 += 2;
        }
      }
      v32 += 8;
      v33 += 2;
      if (a5 <= v31)
        break;
      v31 += 2;
    }
  }
  result = a6 - 1;
  if (v28 > 0) {
    v24 = &a1[a5];
    for (n = 0; n != v28; ++n) {
      result = *((_DWORD *)v24 - 1);
      LODWORD(a7[n]) = result;
      --v24;
    }
  }
  return result;
}

unsigned int __cdecl fir_mem_up(const float *a1, const float *a2, float *a3,
                                int a4, int a5, float *a6, char *a7) {
  unsigned int result; // eax
  int v8;              // ebx
  const float *v9;     // edx
  int v10;             // ecx
  int v11;             // edi
  unsigned int *v12;   // edx
  int v13;             // ecx
  char *v14;           // esi
  float v16;           // xmm4_4
  float *v17;          // edx
  int v18;             // ecx
  float v19;           // xmm5_4
  float v20;           // xmm7_4
  float v21;           // xmm6_4
  const float *v22;    // eax
  float v23;           // xmm5_4
  int j;               // ecx
  char *v25;           // [esp+0h] [ebp-18h]
  float v26;           // [esp+4h] [ebp-14h]
  float v27;           // [esp+4h] [ebp-14h]
  int i;               // [esp+8h] [ebp-10h]

  v25 = &a7[-(int)a7 & 3];
  result = (unsigned int)a4 >> 31;
  v8 = a4 / 2;
  if (a4 / 2 > 0) {
    v9 = &a1[v8];
    v10 = 0;
    do {
      result = *((_DWORD *)v9 - 1);
      *(_DWORD *)&v25[8 * v10++] = result;
      --v9;
    } while (v8 != v10);
  }
  v11 = a5 - 1;
  if (a5 - 1 > 0) {
    v12 = (unsigned int *)&v25[4 * a4];
    v13 = 0;
    do {
      result = LODWORD(a6[v13 + 1]);
      *v12 = result;
      v13 += 2;
      v12 += 2;
    } while (v11 > v13);
  }
  if (a4 > 0) {
    v14 = &v25[4 * a4];
    for (i = 0; i < a4; result = i) {
      v16 = *((float *)v14 - 4);
      if (a5 <= 0) {
        v19 = 0.0;
        v26 = 0.0;
        v20 = 0.0;
        v21 = 0.0;
      } else {
        v17 = (float *)(v14 - 8);
        v18 = 0;
        v19 = 0.0;
        v26 = 0.0;
        v20 = 0.0;
        v21 = 0.0;
        v22 = a2;
        do {
          v27 = (float)(*v22 * v16) + v26;
          v23 = v19 + (float)(v16 * v22[1]);
          v16 = v17[2];
          v21 = (float)(v21 + (float)(*v22 * *v17)) + (float)(v22[2] * v16);
          v20 = (float)(v20 + (float)(v22[1] * *v17)) + (float)(v22[3] * v16);
          v26 = (float)(v22[2] * *v17) + v27;
          v19 = v23 + (float)(*v17 * v22[3]);
          v18 += 4;
          v22 += 4;
          v17 += 4;
        } while (a5 > v18);
      }
      *a3 = v21;
      a3[1] = v20;
      a3[2] = v26;
      a3[3] = v19;
      i += 4;
      a3 += 4;
      v14 -= 16;
    }
  }
  if (v11 > 0) {
    for (j = 0; j < v11; j += 2) {
      result = *(_DWORD *)&v25[4 * j];
      LODWORD(a6[j + 1]) = result;
    }
  }
  return result;
}

int __cdecl comb_filter_mem_init(CombFilterMem *a1) {
  int result; // eax

  a1->last_pitch = 0;
  result = 0;
  a1->last_pitch_gain[2] = 0.0;
  a1->last_pitch_gain[1] = 0.0;
  a1->last_pitch_gain[0] = 0.0;
  a1->smooth_gain = 1065353216;
  return result;
}

float *__cdecl comb_filter(float *a1, float *a2, float *a3, int a4, float *a5,
                           int32_t a6, float *a7, float a8, CombFilterMem *a9) {
  float v9;      // xmm1_4
  float v10;     // xmm2_4
  float *v11;    // eax
  float v12;     // xmm0_4
  float v13;     // xmm0_4
  double v14;    // xmm3_8
  float v15;     // xmm2_4
  double v16;    // xmm3_8
  float v17;     // xmm0_4
  double v18;    // xmm3_8
  float v19;     // xmm6_4
  float v20;     // xmm0_4
  double v21;    // xmm5_8
  float v22;     // xmm4_4
  double v23;    // xmm7_8
  float v24;     // xmm5_4
  double v25;    // xmm0_8
  float v26;     // xmm7_4
  double v27;    // xmm3_8
  float v28;     // xmm0_4
  float *v29;    // ecx
  float v30;     // xmm7_4
  float *v31;    // ebx
  float v32;     // xmm0_4
  float *result; // eax
  float v34;     // xmm1_4
  float v35;     // xmm0_4
  float v36;     // xmm0_4
  double v37;    // xmm1_8
  float *v38;    // edx
  int32_t v39;   // xmm0_4
  float *v40;    // [esp+8h] [ebp-28h]
  float *v41;    // [esp+Ch] [ebp-24h]
  float v42;     // [esp+10h] [ebp-20h]
  float v43;     // [esp+14h] [ebp-1Ch]

  v9 = a8;
  v10 = 0.0;
  if ((int)a5 > 0) {
    v11 = 0;
    v10 = 0.0;
    do {
      v10 = v10 + (float)(a1[(_DWORD)v11] * a1[(_DWORD)v11]);
      v11 = (float *)((char *)v11 + 1);
    } while (a5 != v11);
  }
  v12 = sqrt((float)(v10 / (float)(int)a5) + 0.1);
  v42 = v12;
  v40 = a7 + 1;
  v13 = a7[1];
  if (v13 < 0.0) {
    v14 = (float)-v13;
    v15 = *a7;
    if (*a7 > 0.0) {
    LABEL_6:
      v16 = v14 + v15;
      v41 = a7 + 2;
      v17 = a7[2];
      if (v17 > 0.0)
        goto LABEL_7;
      goto LABEL_29;
    }
  } else {
    v14 = v13;
    v15 = *a7;
    if (*a7 > 0.0)
      goto LABEL_6;
  }
  v16 = v14 + v15 * -0.5;
  v41 = a7 + 2;
  v17 = a7[2];
  if (v17 > 0.0) {
  LABEL_7:
    v18 = v16 + v17;
    v19 = a9->last_pitch_gain[1];
    v20 = v19;
    if (v19 >= 0.0)
      goto LABEL_8;
    goto LABEL_30;
  }
LABEL_29:
  v18 = v16 + v17 * -0.5;
  v19 = a9->last_pitch_gain[1];
  v20 = v19;
  if (v19 >= 0.0) {
  LABEL_8:
    v21 = v20;
    v22 = a9->last_pitch_gain[0];
    if (v22 > 0.0)
      goto LABEL_9;
  LABEL_31:
    v23 = v22 * -0.5 + v21;
    v24 = a9->last_pitch_gain[2];
    if (v24 > 0.0)
      goto LABEL_10;
    goto LABEL_32;
  }
LABEL_30:
  v21 = (float)-v20;
  v22 = a9->last_pitch_gain[0];
  if (v22 <= 0.0)
    goto LABEL_31;
LABEL_9:
  v23 = v22 + v21;
  v24 = a9->last_pitch_gain[2];
  if (v24 > 0.0) {
  LABEL_10:
    v25 = v24;
    goto LABEL_11;
  }
LABEL_32:
  v25 = v24 * -0.5;
LABEL_11:
  v26 = (v18 + v25 + v23) * 0.5;
  v27 = v26;
  if (v26 > 1.3)
    v9 = a8 * (1.3 / v27);
  if (v26 < 0.5)
    v9 = v9 * (v27 + v27);
  v28 = 1.0 / (double)(int)a5;
  v43 = v28;
  if ((int)a5 > 0) {
    v29 = &a1[-a6 + 1];
    v30 = 0.0;
    v31 = 0;
    while (1) {
      v30 = v30 + v43;
      v32 = a1[(_DWORD)v31] +
            ((float)((float)((float)((float)(v15 * *v29) +
                                     (float)(*v40 * *(v29 - 1))) +
                             (float)(*v41 * *(v29 - 2))) *
                     v30) +
             (1.0 - v30) *
                 (float)((float)((float)(v22 *
                                         a1[(_DWORD)v31 - a9->last_pitch + 1]) +
                                 (float)(v19 *
                                         a1[(_DWORD)v31 - a9->last_pitch])) +
                         (float)(v24 * a1[(_DWORD)v31 - a9->last_pitch - 1]))) *
                v9;
      a2[(_DWORD)v31] = v32;
      v31 = (float *)((char *)v31 + 1);
      ++v29;
      if (a5 == v31)
        break;
      v15 = *a7;
      v19 = a9->last_pitch_gain[1];
      v22 = a9->last_pitch_gain[0];
      v24 = a9->last_pitch_gain[2];
    }
    v15 = *a7;
  }
  a9->last_pitch_gain[0] = v15;
  a9->last_pitch_gain[1] = *v40;
  a9->last_pitch_gain[2] = *v41;
  result = (float *)a6;
  a9->last_pitch = a6;
  v34 = 0.0;
  if ((int)a5 > 0) {
    result = 0;
    v34 = 0.0;
    do {
      v34 = v34 + (float)(a2[(_DWORD)result] * a2[(_DWORD)result]);
      result = (float *)((char *)result + 1);
    } while (a5 != result);
  }
  v35 = sqrt((float)(v34 / (float)(int)a5) + 0.1);
  v36 = fmaxf(0.5, fminf(v35, v42) / (float)(v35 + 1.0));
  if ((int)a5 > 0) {
    v37 = v36 * 0.04;
    v38 = 0;
    result = a2;
    do {
      *(float *)&v39 = *(float *)&a9->smooth_gain * 0.96 + v37;
      a9->smooth_gain = v39;
      *result = *(float *)&v39 * *result;
      v38 = (float *)((char *)v38 + 1);
      ++result;
    } while (a5 != v38);
  }
  return result;
}

int __cdecl syn_percep_zero(const float *a1, const float *a2, const float *a3,
                            const float *a4, float *a5, int a6, int a7,
                            char *a8) {
  float *v8;  // ebx
  int i;      // eax
  int result; // eax
  int v11;    // esi
  int j;      // ecx
  float v13;  // xmm1_4
  float v14;  // xmm2_4
  int v15;    // edx
  float *v16; // eax
  int v17;    // edi
  float v18;  // xmm2_4
  float v19;  // xmm3_4
  int k;      // ecx
  int v21;    // [esp+0h] [ebp-24h]

  v8 = (float *)&a8[-(int)a8 & 3];
  if (a7 > 0) {
    for (i = 0; i != a7; ++i)
      v8[i] = 0.0;
  }
  result = a6;
  if (a6 > 0) {
    v11 = a7 - 1;
    for (j = 0; j != a6; ++j) {
      v13 = a1[j] + *v8;
      v14 = -v13;
      if (v11 > 0) {
        v15 = 0;
        v16 = (float *)&a8[-(int)a8 & 3];
        do {
          *v16 = (float)(v14 * a2[v15++]) + v16[1];
          ++v16;
        } while (v15 != v11);
      }
      result = (int)&v8[a7 - 1];
      *(float *)result = v14 * a2[a7 - 1];
      a5[j] = v13;
    }
  }
  if (a7 > 0) {
    for (result = 0; result != a7; ++result)
      v8[result] = 0.0;
  }
  if (a6 > 0) {
    v17 = a7 - 1;
    v21 = 0;
    for (result = 0; result != a6; v21 = result) {
      v18 = a5[result];
      v19 = v18 + *v8;
      if (v17 > 0) {
        for (k = 0; k != v17; ++k)
          v8[k] = (float)((float)(v18 * a3[k]) + v8[k + 1]) +
                  (float)((float)-v19 * a4[k]);
      }
      v8[a7 - 1] = (float)(v18 * a3[a7 - 1]) - (float)(v19 * a4[a7 - 1]);
      a5[v21] = v19;
      result = v21 + 1;
    }
  }
  return result;
}

int __cdecl residue_percep_zero(const float *a1, const float *a2,
                                const float *a3, const float *a4, float *a5,
                                int a6, int a7, char *a8) {
  float *v8;  // ebx
  int i;      // eax
  int v10;    // edi
  int j;      // esi
  float v12;  // xmm2_4
  float v13;  // xmm3_4
  int k;      // ecx
  int v15;    // eax
  int m;      // eax
  int result; // eax
  int v18;    // esi
  float v19;  // xmm1_4
  float v20;  // xmm2_4
  int v21;    // ecx
  float *v22; // edx
  int v23;    // [esp+0h] [ebp-24h]

  v8 = (float *)&a8[-(int)a8 & 3];
  if (a7 > 0) {
    for (i = 0; i != a7; ++i)
      v8[i] = 0.0;
  }
  if (a6 > 0) {
    v10 = a7 - 1;
    v23 = 0;
    for (j = 0;; j = v15) {
      v12 = a1[j];
      v13 = v12 + *v8;
      if (v10 > 0) {
        for (k = 0; k != v10; ++k)
          v8[k] = (float)((float)(v12 * a2[k]) + v8[k + 1]) +
                  (float)((float)-v13 * a3[k]);
      }
      v8[a7 - 1] = (float)(v12 * a2[a7 - 1]) - (float)(v13 * a3[a7 - 1]);
      a5[v23] = v13;
      v15 = v23 + 1;
      v23 = v15;
      if (a6 == v15)
        break;
    }
  }
  if (a7 > 0) {
    for (m = 0; m != a7; ++m)
      v8[m] = 0.0;
  }
  result = a6;
  if (a6 > 0) {
    v18 = a7 - 1;
    for (result = 0; result != a6; ++result) {
      v19 = a5[result];
      v20 = v19 + *v8;
      if (v18 > 0) {
        v21 = 0;
        v22 = (float *)&a8[-(int)a8 & 3];
        do {
          *v22 = (float)(v19 * a4[v21++]) + v22[1];
          ++v22;
        } while (v21 != v18);
      }
      v8[a7 - 1] = v19 * a4[a7 - 1];
      a5[result] = v20;
    }
  }
  return result;
}

int __cdecl lsp_unquant_nb(float *a1, int a2, SpeexBits *a3) {
  int i;      // eax
  float v4;   // xmm0_4
  char *v5;   // ecx
  int v6;     // ebx
  float *v7;  // edx
  float v8;   // xmm0_4
  char *v9;   // ecx
  float *v10; // edx
  float v11;  // xmm0_4
  char *v12;  // ecx
  float *v13; // edx
  float v14;  // xmm0_4
  char *v15;  // ecx
  float *v16; // edx
  float v17;  // xmm0_4
  char *v18;  // ecx
  float *v19; // edx
  int result; // eax
  float v21;  // xmm0_4

  if (a2 > 0) {
    for (i = 0; i != a2; ++i) {
      v4 = (double)i * 0.25 + 0.25;
      a1[i] = v4;
    }
  }
  v5 = &cdbk_nb[10 * speex_bits_unpack_unsigned(a3, 6)];
  v6 = 1;
  v7 = a1 + 1;
  do {
    v8 = *(v7 - 1) + (double)*v5 * 0.0039062;
    *(v7 - 1) = v8;
    ++v6;
    ++v7;
    ++v5;
  } while (v6 != 11);
  v9 = (char *)&cdbk_nb_low1 + 5 * speex_bits_unpack_unsigned(a3, 6);
  LOBYTE(v6) = 1;
  v10 = a1 + 1;
  do {
    v11 = *(v10 - 1) + (double)*v9 * 0.0019531;
    *(v10 - 1) = v11;
    ++v6;
    ++v10;
    ++v9;
  } while (v6 != 6);
  v12 = (char *)&cdbk_nb_low2 + 5 * speex_bits_unpack_unsigned(a3, 6);
  LOBYTE(v6) = 1;
  v13 = a1 + 1;
  do {
    v14 = *(v13 - 1) + (double)*v12 * 0.00097656;
    *(v13 - 1) = v14;
    ++v6;
    ++v13;
    ++v12;
  } while (v6 != 6);
  v15 = (char *)&cdbk_nb_high1 + 5 * speex_bits_unpack_unsigned(a3, 6);
  LOBYTE(v6) = 0;
  v16 = a1;
  do {
    v17 = v16[5] + (double)*v15 * 0.0019531;
    v16[5] = v17;
    ++v6;
    ++v16;
    ++v15;
  } while (v6 != 5);
  v18 = (char *)&cdbk_nb_high2 + 5 * speex_bits_unpack_unsigned(a3, 6);
  LOBYTE(v6) = 0;
  v19 = a1;
  do {
    result = *v18;
    v21 = v19[5] + (double)result * 0.00097656;
    v19[5] = v21;
    ++v6;
    ++v19;
    ++v18;
  } while (v6 != 5);
  return result;
}

int __cdecl lsp_unquant_lbr(float *a1, int a2, SpeexBits *a3) {
  int i;      // eax
  float v4;   // xmm0_4
  char *v5;   // ecx
  int v6;     // ebx
  float *v7;  // edx
  float v8;   // xmm0_4
  char *v9;   // ecx
  float *v10; // edx
  float v11;  // xmm0_4
  char *v12;  // ecx
  float *v13; // edx
  int result; // eax
  float v15;  // xmm0_4

  if (a2 > 0) {
    for (i = 0; i != a2; ++i) {
      v4 = (double)i * 0.25 + 0.25;
      a1[i] = v4;
    }
  }
  v5 = &cdbk_nb[10 * speex_bits_unpack_unsigned(a3, 6)];
  v6 = 1;
  v7 = a1 + 1;
  do {
    v8 = *(v7 - 1) + (double)*v5 * 0.0039062;
    *(v7 - 1) = v8;
    ++v6;
    ++v7;
    ++v5;
  } while (v6 != 11);
  v9 = (char *)&cdbk_nb_low1 + 5 * speex_bits_unpack_unsigned(a3, 6);
  LOBYTE(v6) = 1;
  v10 = a1 + 1;
  do {
    v11 = *(v10 - 1) + (double)*v9 * 0.0019531;
    *(v10 - 1) = v11;
    ++v6;
    ++v10;
    ++v9;
  } while (v6 != 6);
  v12 = (char *)&cdbk_nb_high1 + 5 * speex_bits_unpack_unsigned(a3, 6);
  LOBYTE(v6) = 0;
  v13 = a1;
  do {
    result = *v12;
    v15 = v13[5] + (double)result * 0.0019531;
    v13[5] = v15;
    ++v6;
    ++v13;
    ++v12;
  } while (v6 != 5);
  return result;
}

char *__cdecl lsp_quant_high(float *a1, float *a2, int a3, SpeexBits *a4) {
  int i;            // ecx
  float v5;         // xmm5_4
  float *v6;        // eax
  float v7;         // xmm2_4
  float *v8;        // ecx
  int v9;           // ebx
  int v10;          // edx
  float v11;        // xmm0_4
  float v12;        // xmm0_4
  int v13;          // edx
  float *v14;       // eax
  float v15;        // xmm1_4
  int v16;          // edx
  float *v17;       // eax
  __int128 v18;     // xmm3
  char *v19;        // ecx
  unsigned int v20; // ebx
  __int128 v21;     // xmm2
  int v22;          // edx
  float v23;        // xmm1_4
  int j;            // ecx
  int v25;          // edx
  float *v26;       // eax
  __int128 v27;     // xmm3
  char *v28;        // ecx
  unsigned int v29; // ebx
  __int128 v30;     // xmm2
  int v31;          // edx
  float v32;        // xmm1_4
  int k;            // ecx
  char *result;     // eax
  int v35;          // edx
  float *v36;       // eax
  float v37;        // xmm0_4
  int m;            // ecx
  unsigned int v39; // [esp+14h] [ebp-54h]
  unsigned int v40; // [esp+1Ch] [ebp-4Ch]
  float v41[16];    // [esp+28h] [ebp-40h]

  if (a3 > 0) {
    for (i = 0; i != a3; ++i)
      a2[i] = a1[i];
    v5 = *a2;
    v6 = a2 + 1;
  LABEL_6:
    v7 = v5;
    v8 = v6;
    v9 = 0;
    v10 = 0;
    if (a3 != 1) {
    LABEL_7:
      v11 = *v6 - *(v6 - 1);
      goto LABEL_8;
    }
    while (1) {
      v11 = 3.141592653589793 - *(v6 - 1);
    LABEL_8:
      v12 = 10.0 / (fminf(v11, v7) + 0.04);
      v41[v10] = v12;
      if (a3 <= ++v9)
        break;
      ++v8;
      ++v10;
      ++v6;
      if (!v9) {
        v6 = a2 + 1;
        goto LABEL_6;
      }
      v7 = *(v8 - 1) - *(v8 - 2);
      if (v9 != a3 - 1)
        goto LABEL_7;
    }
    v13 = 0;
    v14 = a2;
    do {
      v15 = *v14 - ((double)v13 * 0.3125 + 0.75);
      *v14 = v15;
      ++v13;
      ++v14;
    } while (a3 != v13);
    v16 = 0;
    v17 = a2;
    do {
      *v17 = *v17 * 256.0;
      ++v16;
      ++v17;
    } while (a3 != v16);
  }
  v18 = 0;
  v39 = 0;
  v19 = high_lsp_cdbk;
  v20 = 0;
  while (a3 <= 0) {
    v21 = 0;
    if (*(float *)&v18 > 0.0)
      goto LABEL_25;
  LABEL_18:
    if (!v20)
      goto LABEL_25;
    v21 = v18;
    if (++v20 == 64)
      goto LABEL_26;
  LABEL_20:
    v18 = v21;
  }
  v22 = 0;
  v21 = 0;
  do {
    v23 = (float)*v19++;
    *(float *)&v21 = *(float *)&v21 +
                     (float)((float)(a2[v22] - v23) * (float)(a2[v22] - v23));
    ++v22;
  } while (a3 != v22);
  if (*(float *)&v18 <= *(float *)&v21)
    goto LABEL_18;
LABEL_25:
  v39 = v20++;
  if (v20 != 64)
    goto LABEL_20;
LABEL_26:
  if (a3 > 0) {
    for (j = 0; j != a3; ++j)
      a2[j] = a2[j] - (float)high_lsp_cdbk[j + a3 * v39];
  }
  speex_bits_pack(a4, v39, (char *)6);
  if (a3 > 0) {
    v25 = 0;
    v26 = a2;
    do {
      *v26 = *v26 + *v26;
      ++v25;
      ++v26;
    } while (a3 != v25);
  }
  v27 = 0;
  v40 = 0;
  v28 = high_lsp_cdbk2;
  v29 = 0;
  while (2) {
    if (a3 <= 0) {
      v30 = 0;
      if (*(float *)&v27 > 0.0)
        break;
      goto LABEL_34;
    }
    v31 = 0;
    v30 = 0;
    do {
      v32 = (float)*v28++;
      *(float *)&v30 =
          *(float *)&v30 +
          (float)((float)((float)(a2[v31] - v32) * (float)(a2[v31] - v32)) *
                  v41[v31]);
      ++v31;
    } while (a3 != v31);
    if (*(float *)&v27 <= *(float *)&v30) {
    LABEL_34:
      if (!v29)
        break;
      v30 = v27;
      if (++v29 == 64)
        goto LABEL_42;
    LABEL_36:
      v27 = v30;
      continue;
    }
    break;
  }
  v40 = v29++;
  if (v29 != 64)
    goto LABEL_36;
LABEL_42:
  if (a3 > 0) {
    for (k = 0; k != a3; ++k)
      a2[k] = a2[k] - (float)high_lsp_cdbk2[k + a3 * v40];
  }
  result = speex_bits_pack(a4, v40, (char *)6);
  if (a3 > 0) {
    v35 = 0;
    v36 = a2;
    do {
      v37 = *v36 * 0.0019531;
      *v36 = v37;
      ++v35;
      ++v36;
    } while (a3 != v35);
    for (m = 0; m != a3; ++m) {
      result = (char *)(4 * m);
      a2[m] = a1[m] - a2[m];
    }
  }
  return result;
}

int __cdecl lsp_unquant_high(float *a1, int a2, SpeexBits *a3) {
  int i;      // eax
  float v4;   // xmm0_4
  int v5;     // eax
  char *v6;   // ecx
  int v7;     // ebx
  float *v8;  // edx
  float v9;   // xmm0_4
  int result; // eax
  char *v11;  // ecx
  int v12;    // ebx
  float *v13; // edx
  float v14;  // xmm0_4

  if (a2 > 0) {
    for (i = 0; i != a2; ++i) {
      v4 = (double)i * 0.3125 + 0.75;
      a1[i] = v4;
    }
  }
  v5 = speex_bits_unpack_unsigned(a3, 6);
  if (a2 > 0) {
    v6 = &high_lsp_cdbk[a2 * v5];
    v7 = 0;
    v8 = a1;
    do {
      v9 = *v8 + (double)*v6 * 0.0039062;
      *v8 = v9;
      ++v7;
      ++v8;
      ++v6;
    } while (a2 != v7);
  }
  result = speex_bits_unpack_unsigned(a3, 6);
  if (a2 > 0) {
    v11 = &high_lsp_cdbk2[a2 * result];
    v12 = 0;
    v13 = a1;
    do {
      result = *v11;
      v14 = *v13 + (double)result * 0.0019531;
      *v13 = v14;
      ++v12;
      ++v13;
      ++v11;
    } while (a2 != v12);
  }
  return result;
}

char *__cdecl lsp_quant_nb(float *a1, float *a2, int a3, SpeexBits *a4) {
  int i;            // ecx
  float v5;         // xmm5_4
  float v6;         // xmm2_4
  float *v7;        // eax
  float *v8;        // ecx
  int v9;           // ebx
  int v10;          // edx
  float v11;        // xmm0_4
  float v12;        // xmm0_4
  int v13;          // edx
  float *v14;       // eax
  float v15;        // xmm1_4
  int v16;          // edx
  float *v17;       // eax
  __int128 v18;     // xmm3
  unsigned int v19; // esi
  char *v20;        // ecx
  unsigned int v21; // ebx
  __int128 v22;     // xmm2
  int v23;          // edx
  float v24;        // xmm1_4
  int j;            // ecx
  int v26;          // edx
  float *v27;       // eax
  float v28;        // xmm3_4
  unsigned int v29; // edi
  unsigned int v30; // ebx
  char *v31;        // esi
  char *v32;        // edx
  float v33;        // xmm2_4
  int k;            // ecx
  float v35;        // xmm1_4
  int v36;          // ecx
  float *v37;       // edx
  int v38;          // edx
  float *v39;       // eax
  __int128 v40;     // xmm3
  unsigned int v41; // edi
  unsigned int v42; // ebx
  char *v43;        // esi
  char *v44;        // edx
  __int128 v45;     // xmm2
  int m;            // ecx
  float v47;        // xmm1_4
  int v48;          // ecx
  float *v49;       // edx
  float *v50;       // esi
  __int128 v51;     // xmm3
  unsigned int v52; // edi
  char *v53;        // ecx
  __int128 v54;     // xmm2
  int v55;          // ebx
  float *v56;       // edx
  float v57;        // xmm1_4
  int v58;          // ecx
  float *v59;       // edx
  int v60;          // edx
  float *v61;       // eax
  __int128 v62;     // xmm3
  unsigned int v63; // edi
  char *v64;        // ecx
  __int128 v65;     // xmm2
  int v66;          // ebx
  float *v67;       // edx
  float v68;        // xmm1_4
  int v69;          // ecx
  float *v70;       // edx
  char *result;     // eax
  int v72;          // edx
  float *v73;       // eax
  float v74;        // xmm0_4
  int n;            // ecx
  unsigned int v76; // [esp+10h] [ebp-58h]
  char *v77;        // [esp+14h] [ebp-54h]
  char *v78;        // [esp+18h] [ebp-50h]
  unsigned int v79; // [esp+1Ch] [ebp-4Ch]
  _DWORD v80[6];    // [esp+24h] [ebp-44h]
  _BYTE v81[44];    // [esp+3Ch] [ebp-2Ch] BYREF

  if (a3 > 0) {
    for (i = 0; i != a3; ++i)
      a2[i] = a1[i];
    v5 = *a2;
  LABEL_5:
    v6 = v5;
    v7 = a2 + 1;
    v8 = a2 + 1;
    v9 = 0;
    v10 = 0;
    if (a3 != 1) {
    LABEL_6:
      v11 = *v7 - *(v7 - 1);
      goto LABEL_7;
    }
    while (1) {
      v11 = 3.141592653589793 - *(v7 - 1);
    LABEL_7:
      v12 = 10.0 / (fminf(v11, v6) + 0.04);
      *(float *)&v80[v10 + 1] = v12;
      if (a3 <= ++v9)
        break;
      ++v8;
      ++v10;
      ++v7;
      if (!v9)
        goto LABEL_5;
      v6 = *(v8 - 1) - *(v8 - 2);
      if (a3 - 1 != v9)
        goto LABEL_6;
    }
    v13 = 0;
    v14 = a2;
    do {
      v15 = *v14 - ((double)v13 * 0.25 + 0.25);
      *v14 = v15;
      ++v13;
      ++v14;
    } while (a3 != v13);
    v16 = 0;
    v17 = a2;
    do {
      *v17 = *v17 * 256.0;
      ++v16;
      ++v17;
    } while (a3 != v16);
  }
  v18 = 0;
  v19 = 0;
  v20 = cdbk_nb;
  v21 = 0;
  while (a3 <= 0) {
    v22 = 0;
    if (*(float *)&v18 > 0.0)
      goto LABEL_24;
  LABEL_17:
    if (!v21)
      goto LABEL_24;
    v22 = v18;
    if (++v21 == 64)
      goto LABEL_25;
  LABEL_19:
    v18 = v22;
  }
  v23 = 0;
  v22 = 0;
  do {
    v24 = (float)*v20++;
    *(float *)&v22 = *(float *)&v22 +
                     (float)((float)(a2[v23] - v24) * (float)(a2[v23] - v24));
    ++v23;
  } while (a3 != v23);
  if (*(float *)&v18 <= *(float *)&v22)
    goto LABEL_17;
LABEL_24:
  v19 = v21++;
  if (v21 != 64)
    goto LABEL_19;
LABEL_25:
  if (a3 > 0) {
    for (j = 0; j != a3; ++j)
      a2[j] = a2[j] - (float)cdbk_nb[j + v19 * a3];
  }
  speex_bits_pack(a4, v19, (char *)6);
  if (a3 > 0) {
    v26 = 0;
    v27 = a2;
    do {
      *v27 = *v27 + *v27;
      ++v26;
      ++v27;
    } while (a3 != v26);
  }
  v28 = 0.0;
  v29 = 0;
  v30 = 0;
  v31 = (char *)&cdbk_nb_low1;
  do {
    while (1) {
      v32 = v31;
      v33 = 0.0;
      for (k = 1; k != 6; ++k) {
        v35 = (float)*v32++;
        v33 = v33 + (float)((float)((float)(a2[k - 1] - v35) *
                                    (float)(a2[k - 1] - v35)) *
                            *(float *)&v80[k]);
      }
      if (v28 > v33 || !v30)
        break;
      ++v30;
      v31 += 5;
      if (v30 == 64)
        goto LABEL_37;
    }
    v28 = v33;
    v29 = v30++;
    v31 += 5;
  } while (v30 != 64);
LABEL_37:
  v36 = 1;
  v37 = a2 + 1;
  do {
    *(v37 - 1) = *(v37 - 1) - (float)byte_305C5F[5 * v29 + v36++];
    ++v37;
  } while (v36 != 6);
  speex_bits_pack(a4, v29, (char *)6);
  v38 = 1;
  v39 = a2 + 1;
  do {
    *(v39 - 1) = *(v39 - 1) + *(v39 - 1);
    ++v38;
    ++v39;
  } while (v38 != 6);
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = (char *)&cdbk_nb_low2;
  while (2) {
    v44 = v43;
    v45 = 0;
    for (m = 1; m != 6; ++m) {
      v47 = (float)*v44++;
      *(float *)&v45 =
          *(float *)&v45 +
          (float)((float)((float)(a2[m - 1] - v47) * (float)(a2[m - 1] - v47)) *
                  *(float *)&v80[m]);
    }
    if (*(float *)&v40 <= *(float *)&v45 && v42) {
      v45 = v40;
      ++v42;
      v43 += 5;
      if (v42 == 64)
        break;
      goto LABEL_47;
    }
    v41 = v42++;
    v43 += 5;
    if (v42 != 64) {
    LABEL_47:
      v40 = v45;
      continue;
    }
    break;
  }
  v48 = 1;
  v49 = a2 + 1;
  do {
    *(v49 - 1) = *(v49 - 1) - (float)byte_305B1F[5 * v41 + v48++];
    ++v49;
  } while (v48 != 6);
  speex_bits_pack(a4, v41, (char *)6);
  v50 = a2 + 5;
  v51 = 0;
  v79 = 0;
  v52 = 0;
  v78 = (char *)&cdbk_nb_high1;
  while (2) {
    v53 = v78;
    v54 = 0;
    v55 = 1;
    v56 = (float *)v81;
    do {
      v57 = (float)*v53++;
      *(float *)&v54 =
          *(float *)&v54 + (float)((float)((float)(v50[v55 - 1] - v57) *
                                           (float)(v50[v55 - 1] - v57)) *
                                   *v56);
      ++v55;
      ++v56;
    } while (v55 != 6);
    if (*(float *)&v51 <= *(float *)&v54 && v52) {
      v54 = v51;
      ++v52;
      v78 += 5;
      if (v52 == 64)
        break;
      goto LABEL_59;
    }
    v79 = v52++;
    v78 += 5;
    if (v52 != 64) {
    LABEL_59:
      v51 = v54;
      continue;
    }
    break;
  }
  v58 = 1;
  v59 = a2 + 6;
  do {
    *(v59 - 1) = *(v59 - 1) - (float)byte_3059DF[5 * v79 + v58++];
    ++v59;
  } while (v58 != 6);
  speex_bits_pack(a4, v79, (char *)6);
  v60 = 0;
  v61 = a2;
  do {
    v61[5] = v61[5] + v61[5];
    ++v60;
    ++v61;
  } while (v60 != 5);
  v62 = 0;
  v76 = 0;
  v63 = 0;
  v77 = (char *)&cdbk_nb_high2;
  while (2) {
    v64 = v77;
    v65 = 0;
    v66 = 1;
    v67 = (float *)v81;
    do {
      v68 = (float)*v64++;
      *(float *)&v65 =
          *(float *)&v65 + (float)((float)((float)(v50[v66 - 1] - v68) *
                                           (float)(v50[v66 - 1] - v68)) *
                                   *v67);
      ++v66;
      ++v67;
    } while (v66 != 6);
    if (*(float *)&v62 <= *(float *)&v65 && v63) {
      v65 = v62;
      ++v63;
      v77 += 5;
      if (v63 == 64)
        break;
      goto LABEL_71;
    }
    v76 = v63++;
    v77 += 5;
    if (v63 != 64) {
    LABEL_71:
      v62 = v65;
      continue;
    }
    break;
  }
  v69 = 1;
  v70 = a2 + 6;
  do {
    *(v70 - 1) = *(v70 - 1) - (float)byte_30589F[5 * v76 + v69++];
    ++v70;
  } while (v69 != 6);
  result = speex_bits_pack(a4, v76, (char *)6);
  if (a3 > 0) {
    v72 = 0;
    v73 = a2;
    do {
      v74 = *v73 * 0.00097656;
      *v73 = v74;
      ++v72;
      ++v73;
    } while (a3 != v72);
    for (n = 0; n != a3; ++n) {
      result = (char *)(4 * n);
      a2[n] = a1[n] - a2[n];
    }
  }
  return result;
}

int __cdecl lsp_quant_lbr(float *a1, float *a2, int a3, SpeexBits *a4) {
  int i;            // ecx
  float v5;         // xmm5_4
  float v6;         // xmm2_4
  float *v7;        // eax
  float *v8;        // ecx
  int v9;           // ebx
  int v10;          // edx
  float v11;        // xmm0_4
  float v12;        // xmm0_4
  int v13;          // edx
  float *v14;       // eax
  float v15;        // xmm1_4
  int v16;          // edx
  float *v17;       // eax
  __int128 v18;     // xmm3
  unsigned int v19; // esi
  char *v20;        // ecx
  unsigned int v21; // ebx
  __int128 v22;     // xmm2
  int v23;          // edx
  float v24;        // xmm1_4
  int j;            // ecx
  int v26;          // edx
  float *v27;       // eax
  __int128 v28;     // xmm3
  unsigned int v29; // edi
  unsigned int v30; // ebx
  char *v31;        // esi
  char *v32;        // edx
  __int128 v33;     // xmm2
  int k;            // ecx
  float v35;        // xmm1_4
  int v36;          // ecx
  float *v37;       // edx
  __int128 v38;     // xmm3
  unsigned int v39; // esi
  char *v40;        // ecx
  __int128 v41;     // xmm2
  int v42;          // ebx
  float *v43;       // edx
  float v44;        // xmm1_4
  int v45;          // ecx
  float *v46;       // edx
  int result;       // eax
  int v48;          // edx
  float *v49;       // eax
  float v50;        // xmm0_4
  int m;            // ecx
  char *v52;        // [esp+18h] [ebp-50h]
  unsigned int v53; // [esp+1Ch] [ebp-4Ch]
  _DWORD v54[6];    // [esp+24h] [ebp-44h]
  int v55;          // [esp+3Ch] [ebp-2Ch] BYREF

  if (a3 > 0) {
    for (i = 0; i != a3; ++i)
      a2[i] = a1[i];
    v5 = *a2;
  LABEL_5:
    v6 = v5;
    v7 = a2 + 1;
    v8 = a2 + 1;
    v9 = 0;
    v10 = 0;
    if (a3 != 1) {
    LABEL_6:
      v11 = *v7 - *(v7 - 1);
      goto LABEL_7;
    }
    while (1) {
      v11 = 3.141592653589793 - *(v7 - 1);
    LABEL_7:
      v12 = 10.0 / (fminf(v11, v6) + 0.04);
      *(float *)&v54[v10 + 1] = v12;
      if (a3 <= ++v9)
        break;
      ++v8;
      ++v10;
      ++v7;
      if (!v9)
        goto LABEL_5;
      v6 = *(v8 - 1) - *(v8 - 2);
      if (a3 - 1 != v9)
        goto LABEL_6;
    }
    v13 = 0;
    v14 = a2;
    do {
      v15 = *v14 - ((double)v13 * 0.25 + 0.25);
      *v14 = v15;
      ++v13;
      ++v14;
    } while (a3 != v13);
    v16 = 0;
    v17 = a2;
    do {
      *v17 = *v17 * 256.0;
      ++v16;
      ++v17;
    } while (a3 != v16);
  }
  v18 = 0;
  v19 = 0;
  v20 = cdbk_nb;
  v21 = 0;
  while (a3 <= 0) {
    v22 = 0;
    if (*(float *)&v18 > 0.0)
      goto LABEL_24;
  LABEL_17:
    if (!v21)
      goto LABEL_24;
    v22 = v18;
    if (++v21 == 64)
      goto LABEL_25;
  LABEL_19:
    v18 = v22;
  }
  v23 = 0;
  v22 = 0;
  do {
    v24 = (float)*v20++;
    *(float *)&v22 = *(float *)&v22 +
                     (float)((float)(a2[v23] - v24) * (float)(a2[v23] - v24));
    ++v23;
  } while (a3 != v23);
  if (*(float *)&v18 <= *(float *)&v22)
    goto LABEL_17;
LABEL_24:
  v19 = v21++;
  if (v21 != 64)
    goto LABEL_19;
LABEL_25:
  if (a3 > 0) {
    for (j = 0; j != a3; ++j)
      a2[j] = a2[j] - (float)cdbk_nb[j + v19 * a3];
  }
  speex_bits_pack(a4, v19, (char *)6);
  if (a3 > 0) {
    v26 = 0;
    v27 = a2;
    do {
      *v27 = *v27 + *v27;
      ++v26;
      ++v27;
    } while (a3 != v26);
  }
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = (char *)&cdbk_nb_low1;
  while (2) {
    v32 = v31;
    v33 = 0;
    for (k = 1; k != 6; ++k) {
      v35 = (float)*v32++;
      *(float *)&v33 =
          *(float *)&v33 +
          (float)((float)((float)(a2[k - 1] - v35) * (float)(a2[k - 1] - v35)) *
                  *(float *)&v54[k]);
    }
    if (*(float *)&v28 <= *(float *)&v33 && v30) {
      v33 = v28;
      ++v30;
      v31 += 5;
      if (v30 == 64)
        break;
      goto LABEL_37;
    }
    v29 = v30++;
    v31 += 5;
    if (v30 != 64) {
    LABEL_37:
      v28 = v33;
      continue;
    }
    break;
  }
  v36 = 1;
  v37 = a2 + 1;
  do {
    *(v37 - 1) = *(v37 - 1) - (float)byte_305C5F[5 * v29 + v36++];
    ++v37;
  } while (v36 != 6);
  speex_bits_pack(a4, v29, (char *)6);
  v38 = 0;
  v53 = 0;
  v39 = 0;
  v52 = (char *)&cdbk_nb_high1;
  while (2) {
    v40 = v52;
    v41 = 0;
    v42 = 1;
    v43 = (float *)&v55;
    do {
      v44 = (float)*v40++;
      *(float *)&v41 =
          *(float *)&v41 + (float)((float)((float)(a2[v42 + 4] - v44) *
                                           (float)(a2[v42 + 4] - v44)) *
                                   *v43);
      ++v42;
      ++v43;
    } while (v42 != 6);
    if (*(float *)&v38 <= *(float *)&v41 && v39) {
      v41 = v38;
      ++v39;
      v52 += 5;
      if (v39 == 64)
        break;
      goto LABEL_47;
    }
    v53 = v39++;
    v52 += 5;
    if (v39 != 64) {
    LABEL_47:
      v38 = v41;
      continue;
    }
    break;
  }
  v45 = 1;
  v46 = a2 + 6;
  do {
    *(v46 - 1) = *(v46 - 1) - (float)byte_3059DF[5 * v53 + v45++];
    ++v46;
  } while (v45 != 6);
  speex_bits_pack(a4, v53, (char *)6);
  result = a3;
  if (a3 > 0) {
    v48 = 0;
    v49 = a2;
    do {
      v50 = *v49 * 0.0019531;
      *v49 = v50;
      ++v48;
      ++v49;
    } while (a3 != v48);
    for (m = 0; m != a3; ++m) {
      result = 4 * m;
      a2[m] = a1[m] - a2[m];
    }
  }
  return result;
}

float *__cdecl nb_encoder_init(const SpeexMode *a1) {
  float *mode;     // ebx
  float *v2;       // eax
  float *v3;       // esi
  float v4;        // eax
  int v5;          // edi
  int v6;          // eax
  void *v7;        // eax
  char *v8;        // eax
  char *v9;        // eax
  int v10;         // eax
  int v11;         // edx
  int v12;         // ecx
  VBRState *v13;   // eax
  int v15;         // ebx
  float *v16;      // edx
  float v17;       // xmm0_4
  int v18;         // edi
  double v19;      // xmm0_8
  int v20;         // ebx
  int v21;         // edi
  int v22;         // ebx
  float v23;       // xmm0_4
  int i;           // edi
  int v25;         // ebx
  float v26;       // xmm0_4
  long double v27; // [esp+0h] [ebp-58h]
  int v28;         // [esp+20h] [ebp-38h]
  int v29;         // [esp+24h] [ebp-34h]
  int j;           // [esp+3Ch] [ebp-1Ch]

  mode = (float *)a1->mode;
  v2 = (float *)speex_alloc(0x7DFCu);
  v3 = v2;
  if (!v2)
    return 0;
  *((_DWORD *)v2 + 18) = v2 + 63;
  *(_DWORD *)v2 = a1;
  v4 = *mode;
  v3[2] = *mode;
  v5 = 3 * LODWORD(v4) / 2;
  *((_DWORD *)v3 + 5) = v5;
  *((_DWORD *)v3 + 4) = *(_DWORD *)mode / *((_DWORD *)mode + 1);
  v3[3] = mode[1];
  v3[6] = mode[2];
  v3[14] = mode[5];
  v3[15] = mode[6];
  v3[7] = mode[3];
  v3[8] = mode[4];
  v3[16] = mode[7];
  v3[17] = mode[8];
  *((_DWORD *)v3 + 60) = mode + 9;
  v6 = *((_DWORD *)mode + 25);
  *((_DWORD *)v3 + 62) = v6;
  *((_DWORD *)v3 + 61) = v6;
  *((_DWORD *)v3 + 10) = 1;
  *((_DWORD *)v3 + 59) = 1;
  v7 = speex_alloc(4 * v5);
  *((_DWORD *)v3 + 19) = v7;
  *((_DWORD *)v3 + 20) = v7;
  v8 = (char *)speex_alloc(4 * (*((_DWORD *)mode + 4) + *(_DWORD *)mode) + 4);
  *((_DWORD *)v3 + 21) = v8;
  *((_DWORD *)v3 + 22) = &v8[4 * *((_DWORD *)mode + 4) + 4];
  v9 = (char *)speex_alloc(4 * (*((_DWORD *)mode + 4) + *(_DWORD *)mode) + 4);
  *((_DWORD *)v3 + 23) = v9;
  *((_DWORD *)v3 + 24) = &v9[4 * *((_DWORD *)mode + 4) + 4];
  *((_DWORD *)v3 + 25) = speex_alloc(4 * *((_DWORD *)v3 + 2));
  v10 = *((int *)v3 + 3) >> 1;
  v28 = *((_DWORD *)v3 + 2) - v10;
  v29 = v10 + (*((int *)v3 + 2) >> 1);
  *((_DWORD *)v3 + 26) = speex_alloc(4 * *((_DWORD *)v3 + 5));
  if (v28 > 0) {
    for (i = 0; i != v28; ++i) {
      v25 = *((_DWORD *)v3 + 26);
      *(double *)&v27 = (double)i * 3.141592653589793 / (double)v28;
      v26 = (double)cos(v27) * -0.46 + 0.54;
      *(float *)(v25 + 4 * i) = v26;
    }
  }
  if (v29 > 0) {
    v21 = 4 * v28;
    for (j = 0; j != v29; ++j) {
      v22 = *((_DWORD *)v3 + 26);
      *(double *)&v27 = (double)j * 3.141592653589793 / (double)v29;
      v23 = (double)cos(v27) * 0.46 + 0.54;
      *(float *)(v22 + v21) = v23;
      v21 += 4;
    }
  }
  *((_DWORD *)v3 + 28) = speex_alloc(4 * *((_DWORD *)v3 + 6) + 4);
  v11 = *((_DWORD *)v3 + 6);
  if (v11 + 1 > 0) {
    v18 = 0;
    do {
      v19 = v3[16] * 6.283185307179586 * (double)v18;
      v20 = *((_DWORD *)v3 + 28);
      *(double *)&v27 = v19 * v19 * -0.5;
      *(float *)&v19 = (double)exp(v27) * 16384.0;
      *(_DWORD *)(v20 + 4 * v18++) = LODWORD(v19);
      v11 = *((_DWORD *)v3 + 6);
    } while (v11 + 1 > v18);
  }
  *((_DWORD *)v3 + 27) = speex_alloc(4 * v11 + 4);
  *((_DWORD *)v3 + 29) = speex_alloc(4 * *((_DWORD *)v3 + 6));
  *((_DWORD *)v3 + 36) = speex_alloc(4 * *((_DWORD *)v3 + 6));
  *((_DWORD *)v3 + 37) = speex_alloc(4 * *((_DWORD *)v3 + 6));
  *((_DWORD *)v3 + 38) = speex_alloc(4 * *((_DWORD *)v3 + 6));
  *((_DWORD *)v3 + 39) = speex_alloc(4 * *((_DWORD *)v3 + 6));
  *((_DWORD *)v3 + 30) = speex_alloc(4 * *((_DWORD *)v3 + 6));
  *((_DWORD *)v3 + 31) = speex_alloc(4 * *((_DWORD *)v3 + 6));
  *((_DWORD *)v3 + 32) = speex_alloc(4 * *((_DWORD *)v3 + 6));
  *((_DWORD *)v3 + 33) = speex_alloc(4 * *((_DWORD *)v3 + 6));
  *((_DWORD *)v3 + 34) = speex_alloc(4 * *((_DWORD *)v3 + 6));
  *((_DWORD *)v3 + 35) = speex_alloc(4 * *((_DWORD *)v3 + 6));
  *((_DWORD *)v3 + 1) = 1;
  v12 = *((_DWORD *)v3 + 6);
  if (v12 > 0) {
    v15 = 0;
    do {
      v16 = (float *)(*((_DWORD *)v3 + 30) + 4 * v15++);
      v17 = (float)v15 * 3.141592653589793 / (double)(v12 + 1);
      *v16 = v17;
      v12 = *((_DWORD *)v3 + 6);
    } while (v15 < v12);
  }
  *((_DWORD *)v3 + 40) = speex_alloc(4 * v12);
  *((_DWORD *)v3 + 41) = speex_alloc(4 * *((_DWORD *)v3 + 6));
  *((_DWORD *)v3 + 42) = speex_alloc(4 * *((_DWORD *)v3 + 6));
  *((_DWORD *)v3 + 43) = speex_alloc(4 * *((_DWORD *)v3 + 6));
  *((_DWORD *)v3 + 44) = speex_alloc(4 * *((_DWORD *)v3 + 4));
  *((_DWORD *)v3 + 13) = speex_alloc(4 * *((_DWORD *)v3 + 4));
  v13 = (VBRState *)speex_alloc(0x40u);
  *((_DWORD *)v3 + 45) = v13;
  vbr_init(v13);
  v3[46] = 8.0;
  v3[48] = 0.0;
  v3[49] = 0.0;
  v3[50] = 0.0;
  v3[52] = 0.0;
  v3[53] = 0.0;
  *((_DWORD *)v3 + 58) = 2;
  *((_DWORD *)v3 + 56) = 2;
  *((_DWORD *)v3 + 57) = 8000;
  v3[51] = 0.0;
  return v3;
}

void __cdecl nb_encoder_destroy(void **a1) {
  speex_free(a1[19]);
  speex_free(a1[21]);
  speex_free(a1[25]);
  speex_free(a1[37]);
  speex_free(a1[31]);
  speex_free(a1[33]);
  speex_free(a1[35]);
  speex_free(a1[23]);
  speex_free(a1[26]);
  speex_free(a1[28]);
  speex_free(a1[27]);
  speex_free(a1[29]);
  speex_free(a1[30]);
  speex_free(a1[36]);
  speex_free(a1[38]);
  speex_free(a1[39]);
  speex_free(a1[32]);
  speex_free(a1[34]);
  speex_free(a1[40]);
  speex_free(a1[41]);
  speex_free(a1[42]);
  speex_free(a1[43]);
  speex_free(a1[44]);
  speex_free(a1[13]);
  vbr_destroy();
  speex_free(a1[45]);
  speex_free(a1);
}

int __cdecl nb_encode(void *a1, float *a2, SpeexBits *a3) {
  int v3;          // ecx
  int i;           // ebx
  int v5;          // edx
  const float *v6; // edi
  int j;           // ebx
  int v8;          // edx
  int v9;          // ebx
  int v10;         // eax
  int v11;         // edx
  _DWORD *v12;     // eax
  int v13;         // ecx
  double v14;      // xmm1_8
  int v15;         // ebx
  int v16;         // eax
  int v17;         // edx
  int k;           // eax
  int v19;         // ebx
  int v20;         // edx
  int v21;         // ebx
  _DWORD *v22;     // eax
  signed int v23;  // ebx
  double v24;      // xmm0_8
  float v25;       // xmm0_4
  int v26;         // ebx
  int v27;         // eax
  int v28;         // eax
  int v29;         // eax
  int v30;         // eax
  float *v31;      // eax
  int v32;         // ecx
  int v33;         // edx
  int v34;         // ebx
  int v35;         // ebx
  int v36;         // ecx
  int v38;         // edx
  int v39;         // ecx
  float v40;       // xmm0_4
  float v41;       // xmm0_4
  int v42;         // eax
  int v43;         // eax
  int v44;         // ebx
  int v45;         // eax
  int v46;         // ebx
  int v47;         // ebx
  float *v48;      // edi
  float *v49;      // edx
  float v50;       // xmm4_4
  float v51;       // xmm1_4
  int v52;         // eax
  float v53;       // xmm1_4
  float v54;       // xmm1_4
  int v55;         // ebx
  _DWORD *v56;     // ecx
  int v57;         // edx
  signed int v58;  // eax
  double v59;      // xmm0_8
  int m;           // edi
  int v61;         // eax
  int v62;         // ecx
  int v63;         // edx
  float v64;       // xmm1_4
  float *v65;      // eax
  float v66;       // xmm0_4
  int v67;         // ecx
  int v68;         // eax
  float *v69;      // edx
  int v70;         // eax
  int v71;         // eax
  int v72;         // eax
  int n;           // ecx
  int v74;         // eax
  int ii;          // ecx
  int v76;         // eax
  int jj;          // ecx
  int v78;         // ebx
  int v79;         // ecx
  int v80;         // edx
  int v81;         // eax
  int kk;          // eax
  int *v83;        // ebx
  int v84;         // edx
  int v85;         // edi
  int v86;         // edx
  int v87;         // ecx
  float *v88;      // edi
  int v89;         // eax
  int v90;         // ebx
  int v91;         // eax
  int v92;         // eax
  float v93;       // xmm0_4
  _DWORD *v94;     // edx
  void(__cdecl * v95)(float *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD,
                      float *, float *, SpeexBits *, char *, _DWORD,
                      _DWORD); // ecx
  int v96;                     // ecx
  int v97;                     // eax
  int v98;                     // ebx
  int v99;                     // edx
  int v100;                    // ecx
  float *v101;                 // edi
  int v102;                    // eax
  int v103;                    // ebx
  float *v104;                 // edx
  float v105;                  // xmm0_4
  int v106;                    // eax
  float v107;                  // xmm0_4
  int v108;                    // ecx
  int v109;                    // eax
  unsigned int v110;           // ebx
  int v111;                    // edx
  int v112;                    // eax
  unsigned int v113;           // ebx
  int v114;                    // eax
  float v115;                  // xmm0_4
  long double v116;            // [esp+0h] [ebp-178h]
  long double v117;            // [esp+0h] [ebp-178h]
  long double v118;            // [esp+0h] [ebp-178h]
  int v119;                    // [esp+5Ch] [ebp-11Ch]
  float v120;                  // [esp+6Ch] [ebp-10Ch]
  float v121;                  // [esp+6Ch] [ebp-10Ch]
  int v122;                    // [esp+A8h] [ebp-D0h]
  int v123;                    // [esp+A8h] [ebp-D0h]
  float v124;                  // [esp+ACh] [ebp-CCh]
  float v125;                  // [esp+C8h] [ebp-B0h]
  int(__cdecl * v126)(float *, float *, _DWORD, _DWORD, _DWORD, float *, int,
                      int, int, _DWORD, _DWORD, int, SpeexBits *, char *,
                      float *, float *, _DWORD, _DWORD,
                      _DWORD); // [esp+CCh] [ebp-ACh]
  int v127;                    // [esp+D0h] [ebp-A8h]
  float v128;                  // [esp+D4h] [ebp-A4h]
  float v129;                  // [esp+D8h] [ebp-A0h]
  float *v130;                 // [esp+DCh] [ebp-9Ch]
  float *v131;                 // [esp+E0h] [ebp-98h]
  float *v132;                 // [esp+E4h] [ebp-94h]
  float *v133;                 // [esp+E8h] [ebp-90h]
  float *v134;                 // [esp+ECh] [ebp-8Ch]
  float v135;                  // [esp+F0h] [ebp-88h]
  int v136;                    // [esp+F4h] [ebp-84h]
  int v137;                    // [esp+F8h] [ebp-80h]
  float *v138;                 // [esp+FCh] [ebp-7Ch]
  float *v139;                 // [esp+100h] [ebp-78h]
  float *v140;                 // [esp+104h] [ebp-74h]
  float v141;                  // [esp+108h] [ebp-70h]
  int v142;                    // [esp+10Ch] [ebp-6Ch]
  char *v143;                  // [esp+110h] [ebp-68h]
  char *v144;                  // [esp+114h] [ebp-64h]
  int v145;                    // [esp+118h] [ebp-60h]
  float v146;                  // [esp+11Ch] [ebp-5Ch]
  float v147[6];               // [esp+128h] [ebp-50h] BYREF
  int v148[7];                 // [esp+140h] [ebp-38h] BYREF
  int v149;                    // [esp+15Ch] [ebp-1Ch]

  v119 = *((_DWORD *)a1 + 18);
  speex_move(*((void **)a1 + 19),
             (const void *)(*((_DWORD *)a1 + 19) + 4 * *((_DWORD *)a1 + 2)),
             4 * (*((_DWORD *)a1 + 5) - *((_DWORD *)a1 + 2)));
  v3 = *((_DWORD *)a1 + 2);
  if (v3 > 0) {
    for (i = 0; i < v3; ++i) {
      *(float *)(*((_DWORD *)a1 + 19) + 4 * (i + *((_DWORD *)a1 + 5) - v3)) =
          a2[i];
      v3 = *((_DWORD *)a1 + 2);
    }
  }
  speex_move(*((void **)a1 + 21), (const void *)(*((_DWORD *)a1 + 21) + 4 * v3),
             4 * *((_DWORD *)a1 + 8) + 4);
  speex_move(*((void **)a1 + 23),
             (const void *)(*((_DWORD *)a1 + 23) + 4 * *((_DWORD *)a1 + 2)),
             4 * *((_DWORD *)a1 + 8) + 4);
  v5 = *((_DWORD *)a1 + 5);
  v143 = (char *)(v119 + (-v119 & 3) + 4 * v5);
  v6 = (const float *)(v119 + (-v119 & 3));
  if (v5 > 0) {
    for (j = 0; j < v5; ++j) {
      v6[j] = *(float *)(*((_DWORD *)a1 + 20) + 4 * j) *
              *(float *)(*((_DWORD *)a1 + 26) + 4 * j);
      v5 = *((_DWORD *)a1 + 5);
    }
  }
  _spx_autocorr(v6, *((float **)a1 + 27), *((_DWORD *)a1 + 6) + 1, v5);
  **((float **)a1 + 27) = **((float **)a1 + 27) * *((float *)a1 + 17);
  v8 = *((_DWORD *)a1 + 6);
  if (v8 + 1 > 0) {
    v9 = 0;
    do {
      *(float *)(*((_DWORD *)a1 + 27) + 4 * v9) =
          *(float *)(*((_DWORD *)a1 + 27) + 4 * v9) *
          *(float *)(*((_DWORD *)a1 + 28) + 4 * v9);
      ++v9;
      v8 = *((_DWORD *)a1 + 6);
    } while (v9 < v8 + 1);
  }
  _spx_lpc(*((float **)a1 + 29), *((float **)a1 + 27), v8);
  v10 = lpc_to_lsp(*((float **)a1 + 29), *((_DWORD *)a1 + 6),
                   *((float **)a1 + 30), 15, 0.2, v143);
  v11 = *((_DWORD *)a1 + 6);
  if (v10 == v11 ||
      *((int *)a1 + 56) > 1 &&
          *((_DWORD *)a1 + 6) == lpc_to_lsp(*((float **)a1 + 29), v11,
                                            *((float **)a1 + 30), 11,
                                            0.050000001, v143) ||
      *((int *)a1 + 6) <= 0) {
    if (*((_DWORD *)a1 + 1))
      goto LABEL_15;
  LABEL_99:
    lsp_interpolate(*((float **)a1 + 32), *((float **)a1 + 30),
                    *((float **)a1 + 34), *((_DWORD *)a1 + 6),
                    *((_DWORD *)a1 + 4), 2 * *((_DWORD *)a1 + 4));
    goto LABEL_16;
  }
  v46 = 0;
  do {
    *(_DWORD *)(*((_DWORD *)a1 + 30) + 4 * v46) =
        *(_DWORD *)(*((_DWORD *)a1 + 32) + 4 * v46);
    ++v46;
  } while (*((_DWORD *)a1 + 6) > v46);
  if (!*((_DWORD *)a1 + 1))
    goto LABEL_99;
LABEL_15:
  if (*((int *)a1 + 6) > 0) {
    v44 = 0;
    do {
      *(_DWORD *)(*((_DWORD *)a1 + 34) + 4 * v44) =
          *(_DWORD *)(*((_DWORD *)a1 + 30) + 4 * v44);
      ++v44;
    } while (*((_DWORD *)a1 + 6) > v44);
  }
LABEL_16:
  lsp_enforce_margin(*((float **)a1 + 34), *((_DWORD *)a1 + 6), 0.0020000001);
  lsp_to_lpc(*((float **)a1 + 34), *((float **)a1 + 36), *((_DWORD *)a1 + 6),
             v143);
  v12 = *(_DWORD **)(*((_DWORD *)a1 + 60) + 4 * *((_DWORD *)a1 + 61));
  if (v12 && !*((_DWORD *)a1 + 48) && !*((_DWORD *)a1 + 49) && !v12[1] &&
      *v12 == -1) {
    v142 = 0;
    v128 = 0.0;
    goto LABEL_26;
  }
  bw_lpc(*((float *)a1 + 14), *((const float **)a1 + 36), *((float **)a1 + 38),
         *((_DWORD *)a1 + 6));
  bw_lpc(*((float *)a1 + 15), *((const float **)a1 + 36), *((float **)a1 + 39),
         *((_DWORD *)a1 + 6));
  filter_mem2(*((const float **)a1 + 20), *((const float **)a1 + 38),
              *((const float **)a1 + 39), *((float **)a1 + 24),
              *((_DWORD *)a1 + 2), *((_DWORD *)a1 + 6), *((float **)a1 + 42));
  open_loop_nbest_pitch(*((float **)a1 + 24), *((_DWORD *)a1 + 7),
                        *((_DWORD *)a1 + 8), *((_DWORD *)a1 + 2), v148, v147, 6,
                        v143);
  v13 = v148[0];
  v128 = v147[0];
  v14 = v147[0] * 0.85;
  v15 = 1;
  v16 = 1;
  if (v147[1] > v14)
    goto LABEL_19;
LABEL_24:
  v142 = v13;
LABEL_25:
  for (k = v15; v15 != 5; k = v15) {
    v13 = v142;
    v15 = k + 1;
    v16 = k + 1;
    if (v147[v16] <= v14)
      goto LABEL_24;
  LABEL_19:
    v142 = v148[v16];
    v17 = 2 * v142 - v13;
    if (v17 < 0)
      v17 = v13 - 2 * v142;
    if (v17 > 2) {
      v38 = 3 * v142 - v13;
      if (v38 < 0)
        v38 = v13 - 3 * v142;
      if (v38 > 3) {
        if (4 * v142 - v13 < 0) {
          if (v13 - 4 * v142 <= 4)
            continue;
        } else if (4 * v142 - v13 <= 4) {
          continue;
        }
        if (5 * v142 - v13 < 0) {
          if (v13 - 5 * v142 > 5) {
            v142 = v13;
            goto LABEL_25;
          }
        } else if (5 * v142 - v13 > 5) {
          v142 = v13;
          goto LABEL_25;
        }
      }
    }
  }
LABEL_26:
  fir_mem2(*((const float **)a1 + 20), *((const float **)a1 + 36),
           *((float **)a1 + 22), *((_DWORD *)a1 + 2), *((_DWORD *)a1 + 6),
           *((float **)a1 + 43));
  v129 = compute_rms((const float *)*((_DWORD *)a1 + 22), *((_DWORD *)a1 + 2));
  if (!*((_DWORD *)a1 + 45) || !*((_DWORD *)a1 + 48) && !*((_DWORD *)a1 + 49)) {
    *((_DWORD *)a1 + 47) = -1082130432;
    goto LABEL_30;
  }
  v39 = *((_DWORD *)a1 + 6);
  if (v39 > 0) {
    v45 = 0;
    v135 = 0.0;
    do {
      v135 = (float)((float)(*(float *)(*((_DWORD *)a1 + 32) + 4 * v45) -
                             *(float *)(*((_DWORD *)a1 + 30) + 4 * v45)) *
                     (float)(*(float *)(*((_DWORD *)a1 + 32) + 4 * v45) -
                             *(float *)(*((_DWORD *)a1 + 30) + 4 * v45))) +
             v135;
      ++v45;
    } while (v39 != v45);
  } else {
    v135 = 0.0;
  }
  if (*((_DWORD *)a1 + 52)) {
    if ((float)(*((float *)a1 + 53) * *((float *)a1 + 54)) <= 0.0) {
      v40 = 0.0;
      goto LABEL_75;
    }
    v40 = *((float *)a1 + 53) * -0.00001 / (float)(*((float *)a1 + 55) + 1.0);
    if (v40 > 0.05) {
      v40 = 0.050000001;
      if (0.05000000074505806 >= -0.05)
        goto LABEL_75;
    } else if (v40 >= -0.05) {
    LABEL_75:
      v41 = v40 + *((float *)a1 + 46);
      *((float *)a1 + 46) = v41;
      if (v41 > 10.0)
        *((_DWORD *)a1 + 46) = 1092616192;
      if (*((float *)a1 + 46) < 0.0)
        *((_DWORD *)a1 + 46) = 0;
      goto LABEL_79;
    }
    v40 = -0.050000001;
    goto LABEL_75;
  }
LABEL_79:
  v120 = vbr_analysis((VBRState *)*((_DWORD *)a1 + 45), a2, *((_DWORD *)a1 + 2),
                      v142, SLODWORD(v128));
  *((float *)a1 + 47) = v120;
  if (!*((_DWORD *)a1 + 48)) {
    if (v120 >= 2.0) {
      *((_DWORD *)a1 + 51) = 0;
      v43 = *((_DWORD *)a1 + 62);
    } else {
      v42 = *((_DWORD *)a1 + 51);
      if (v42 && v135 <= 0.05 && *((_DWORD *)a1 + 50) && v42 <= 20) {
        *((_DWORD *)a1 + 51) = v42 + 1;
        v43 = 0;
      } else {
        *((_DWORD *)a1 + 51) = 1;
        v43 = 1;
      }
    }
    *((_DWORD *)a1 + 61) = v43;
    goto LABEL_30;
  }
  v149 = 8;
  v136 = 0;
  v47 = 8;
  v48 = (float *)&vbr_nb_thresh;
  v124 = *((float *)a1 + 46);
  v125 = floorf(v124);
  v49 = (float *)((char *)&vbr_nb_thresh + 4 * (int)v125 + 352);
  v50 = 100.0;
  if ((int)v125 == 10) {
    do {
      v54 = v48[98];
      if (v120 > v54 && v50 > (float)(v120 - v54)) {
        v136 = v47;
        v50 = v120 - v54;
      }
      v48 -= 11;
      --v47;
    } while (v47);
    v149 = v136;
    if (v136)
      goto LABEL_108;
  } else {
    do {
      v51 = (float)((float)(v124 - (float)(int)v125) * v49[1]) +
            (float)((float)((float)((int)v125 + 1) - v124) * *v49);
      if (v120 > v51 && v50 > (float)(v120 - v51)) {
        v136 = v47;
        v50 = v120 - v51;
      }
      v49 -= 11;
      --v47;
    } while (v47);
    v149 = v136;
    if (v136) {
    LABEL_108:
      *((_DWORD *)a1 + 51) = 0;
      goto LABEL_109;
    }
  }
  v114 = *((_DWORD *)a1 + 51);
  if (v114 && v135 <= 0.05 && *((_DWORD *)a1 + 50) && v114 <= 20) {
    v149 = 0;
    *((_DWORD *)a1 + 51) = v114 + 1;
  } else {
    v149 = 1;
    *((_DWORD *)a1 + 51) = 1;
  }
LABEL_109:
  speex_encoder_ctl(a1);
  if (*((_DWORD *)a1 + 52)) {
    speex_encoder_ctl(a1);
    v52 = v148[6] - *((_DWORD *)a1 + 52);
    *((float *)a1 + 53) = (float)v52 + *((float *)a1 + 53);
    v53 = *((float *)a1 + 54) * 0.95 + (double)v52 * 0.05;
    *((float *)a1 + 54) = v53;
    *((float *)a1 + 55) = *((float *)a1 + 55) + 1.0;
  }
LABEL_30:
  if (*((_DWORD *)a1 + 59)) {
    speex_bits_pack(a3, 0, (char *)1);
    speex_bits_pack(a3, *((_DWORD *)a1 + 61), (char *)4);
    v19 = *((_DWORD *)a1 + 61);
    v20 = *((_DWORD *)a1 + 60);
    if (*(_DWORD *)(v20 + 4 * v19)) {
    LABEL_32:
      if (*((_DWORD *)a1 + 1) && *((int *)a1 + 6) > 0) {
        v21 = 0;
        do {
          *(_DWORD *)(4 * v21 + *((_DWORD *)a1 + 32)) =
              *(_DWORD *)(4 * v21 + *((_DWORD *)a1 + 30));
          ++v21;
        } while (*((_DWORD *)a1 + 6) > v21);
        v19 = *((_DWORD *)a1 + 61);
        v20 = *((_DWORD *)a1 + 60);
      }
      HIDWORD(v116) = a3;
      DWORD2(v116) = *((_DWORD *)a1 + 6);
      (*(void(__cdecl **)(_DWORD, _DWORD))(*(_DWORD *)(v20 + 4 * v19) + 16))(
          *((_DWORD *)a1 + 30), *((_DWORD *)a1 + 31));
      v22 = *(_DWORD **)(*((_DWORD *)a1 + 60) + 4 * *((_DWORD *)a1 + 61));
      if (*v22 != -1) {
        speex_bits_pack(a3, v142 - *((_DWORD *)a1 + 7), (char *)7);
        v22 = *(_DWORD **)(*((_DWORD *)a1 + 60) + 4 * *((_DWORD *)a1 + 61));
      }
      if (v22[1]) {
        *(double *)&v116 = (float)(v128 * 15.0) + 0.5;
        v58 = (int)(double)floor(v116);
        if (v58 > 15) {
          v58 = 15;
          v59 = 15.0;
        } else if (v58 < 0) {
          v58 = 0;
          v59 = 0.0;
        } else {
          v59 = (double)v58;
        }
        speex_bits_pack(a3, v58, (char *)4);
        v115 = v59 * 0.066667;
        v128 = v115;
      }
      *(double *)&v116 = v129;
      *(double *)&v117 = (double)log(v116) * 3.5 + 0.5;
      v23 = (int)(double)floor(v117);
      if (v23 < 0) {
        v23 = 0;
        v24 = 0.0;
      } else if (v23 <= 31) {
        v24 = (double)v23;
      } else {
        v23 = 31;
        v24 = 31.0;
      }
      *(double *)&v118 = v24 / 3.5;
      v25 = exp(v118);
      v146 = v25;
      speex_bits_pack(a3, v23, (char *)5);
      if (*((_DWORD *)a1 + 1) && *((int *)a1 + 6) > 0) {
        v26 = 0;
        do {
          *(_DWORD *)(4 * v26 + *((_DWORD *)a1 + 33)) =
              *(_DWORD *)(4 * v26 + *((_DWORD *)a1 + 31));
          ++v26;
        } while (*((_DWORD *)a1 + 6) > v26);
      }
      v122 = *((_DWORD *)a1 + 3);
      v27 = (int)&v143[4 * v122 + ((4 - (_BYTE)v143) & 3)];
      v130 = (float *)&v143[(4 - (_BYTE)v143) & 3];
      v28 = 4 * v122 + ((4 - (_BYTE)v27) & 3) + v27;
      v131 = (float *)(v28 - 4 * v122);
      v29 = 4 * v122 + ((4 - (_BYTE)v28) & 3) + v28;
      v133 = (float *)(v29 - 4 * v122);
      v30 = 4 * v122 + ((4 - (_BYTE)v29) & 3) + v29;
      v134 = (float *)(v30 - 4 * v122);
      v31 = (float *)(((4 - (_BYTE)v30) & 3) + v30);
      v32 = *((_DWORD *)a1 + 6);
      v144 = (char *)&v31[v32];
      v132 = v31;
      v33 = *((_DWORD *)a1 + 4);
      if (v33 > 0) {
        v127 = 0;
        for (m = *((_DWORD *)a1 + 3);; v122 = m) {
          v137 = m * v127;
          v61 = 4 * m * v127;
          v138 = (float *)(v61 + *((_DWORD *)a1 + 20));
          v140 = (float *)(v61 + *((_DWORD *)a1 + 22));
          v139 = (float *)(*((_DWORD *)a1 + 24) + v61);
          lsp_interpolate(*((float **)a1 + 32), *((float **)a1 + 30),
                          *((float **)a1 + 34), v32, v127, v33);
          lsp_interpolate(*((float **)a1 + 33), *((float **)a1 + 31),
                          *((float **)a1 + 35), *((_DWORD *)a1 + 6), v127,
                          *((_DWORD *)a1 + 4));
          lsp_enforce_margin(*((float **)a1 + 34), *((_DWORD *)a1 + 6),
                             0.0020000001);
          lsp_enforce_margin(*((float **)a1 + 35), *((_DWORD *)a1 + 6),
                             0.0020000001);
          lsp_to_lpc(*((float **)a1 + 34), *((float **)a1 + 36),
                     *((_DWORD *)a1 + 6), v144);
          lsp_to_lpc(*((float **)a1 + 35), *((float **)a1 + 37),
                     *((_DWORD *)a1 + 6), v144);
          v62 = *((_DWORD *)a1 + 6);
          if (v62 <= 0) {
            v64 = 1.0;
          } else {
            v63 = 0;
            v64 = 1.0;
            v65 = (float *)*((_DWORD *)a1 + 37);
            do {
              v64 = v64 + (float)(v65[1] - *v65);
              v63 += 2;
              v65 += 2;
            } while (v62 > v63);
          }
          *(float *)(*((_DWORD *)a1 + 44) + 4 * v127) = v64;
          bw_lpc(*((float *)a1 + 14), *((const float **)a1 + 36),
                 *((float **)a1 + 38), *((_DWORD *)a1 + 6));
          v66 = *((float *)a1 + 15);
          if (v66 < 0.0) {
            **((_DWORD **)a1 + 39) = 1065353216;
            if (*((int *)a1 + 6) > 0) {
              v111 = 1;
              do
                *(_DWORD *)(*((_DWORD *)a1 + 39) + 4 * v111++) = 0;
              while (*((_DWORD *)a1 + 6) >= v111);
            }
          } else {
            bw_lpc(v66, *((const float **)a1 + 36), *((float **)a1 + 39),
                   *((_DWORD *)a1 + 6));
          }
          if (*((int *)a1 + 3) > 0) {
            v67 = 1;
            do {
              v134[v67 - 1] = v140[v67 - 1];
              v68 = v67++;
            } while (*((_DWORD *)a1 + 3) > v68);
          }
          v123 = v122 >> 1;
          if (!*((_DWORD *)a1 + 56))
            m = v123;
          compute_impulse_response(
              *((const float **)a1 + 37), *((const float **)a1 + 38),
              *((const float **)a1 + 39), v133, m, *((_DWORD *)a1 + 6), v144);
          if (m < *((_DWORD *)a1 + 3)) {
            v69 = &v133[m];
            v70 = m;
            do {
              *v69 = 1.0e-15;
              ++v70;
              ++v69;
            } while (*((_DWORD *)a1 + 3) > v70);
          }
          if (*((int *)a1 + 3) > 0) {
            v71 = 0;
            do
              v140[v71++] = 1.0e-15;
            while (*((_DWORD *)a1 + 3) > v71);
          }
          v72 = *((_DWORD *)a1 + 6);
          if (v72 > 0) {
            for (n = 0; n < v72; ++n) {
              v132[n] = *(float *)(*((_DWORD *)a1 + 40) + 4 * n);
              v72 = *((_DWORD *)a1 + 6);
            }
          }
          iir_mem2(v140, *((const float **)a1 + 37), v140, *((_DWORD *)a1 + 3),
                   v72, v132);
          v74 = *((_DWORD *)a1 + 6);
          if (v74 > 0) {
            for (ii = 0; ii < v74; ++ii) {
              v132[ii] = *(float *)(*((_DWORD *)a1 + 41) + 4 * ii);
              v74 = *((_DWORD *)a1 + 6);
            }
          }
          filter_mem2(v140, *((const float **)a1 + 38),
                      *((const float **)a1 + 39), v130, *((_DWORD *)a1 + 3),
                      v74, v132);
          v76 = *((_DWORD *)a1 + 6);
          if (v76 > 0) {
            for (jj = 0; jj < v76; ++jj) {
              v132[jj] = *(float *)(*((_DWORD *)a1 + 41) + 4 * jj);
              v76 = *((_DWORD *)a1 + 6);
            }
          }
          filter_mem2(v138, *((const float **)a1 + 38),
                      *((const float **)a1 + 39), v139, *((_DWORD *)a1 + 3),
                      v76, v132);
          if (!*((_DWORD *)a1 + 56) && *((int *)a1 + 6) > 0) {
            v78 = 0;
            do {
              *(float *)(*((_DWORD *)a1 + 41) + 4 * v78) = v132[v78];
              ++v78;
            } while (*((_DWORD *)a1 + 6) > v78);
          }
          v79 = *((_DWORD *)a1 + 3);
          if (v79 > 0) {
            v80 = 1;
            do {
              v131[v80 - 1] = v139[v80 - 1] - v130[v80 - 1];
              v81 = v80++;
            } while (*((_DWORD *)a1 + 3) > v81);
            v79 = *((_DWORD *)a1 + 3);
            if (v79 > 0) {
              for (kk = 0; kk < v79; ++kk) {
                v140[kk] = 0.0;
                v79 = *((_DWORD *)a1 + 3);
              }
            }
          }
          v83 = *(int **)(*((_DWORD *)a1 + 60) + 4 * *((_DWORD *)a1 + 61));
          v126 = (int(__cdecl *)(float *, float *, _DWORD, _DWORD, _DWORD,
                                 float *, int, int, int, _DWORD, _DWORD, int,
                                 SpeexBits *, char *, float *, float *, _DWORD,
                                 _DWORD, _DWORD))v83[6];
          if (!v126)
            speex_error("No pitch prediction, what's wrong");
          v84 = *v83;
          if (*v83 == -1) {
            v85 = *((_DWORD *)a1 + 7);
            v86 = *((_DWORD *)a1 + 8);
          } else if (v84) {
            v112 = *((_DWORD *)a1 + 7) + v84 - 1;
            if (v142 >= v112)
              v112 = v142;
            if (v112 > *((_DWORD *)a1 + 8) - v84)
              v112 = *((_DWORD *)a1 + 8) - v84;
            v142 = v112;
            v85 = v112 - v84 + 1;
            v86 = v112 + v84;
          } else {
            v85 = v142;
            v86 = v142;
          }
          if (*((_DWORD *)a1 + 10) && v86 > v137)
            v86 = v137;
          *(_DWORD *)(*((_DWORD *)a1 + 13) + 4 * v127) =
              v126(v131, v139, *((_DWORD *)a1 + 37), *((_DWORD *)a1 + 38),
                   *((_DWORD *)a1 + 39), v140, v83[8], v85, v86, LODWORD(v128),
                   *((_DWORD *)a1 + 6), v79, a3, v144, v140, v133,
                   *((_DWORD *)a1 + 56), 0, *((_DWORD *)a1 + 58));
          v87 = *((_DWORD *)a1 + 3);
          v88 = (float *)(*((_DWORD *)a1 + 25) + 4 * v87 * v127);
          if (v87 > 0) {
            v89 = 0;
            do
              v88[v89++] = 0.0;
            while (*((_DWORD *)a1 + 3) > v89);
            v87 = *((_DWORD *)a1 + 3);
            if (v87 > 0) {
              v90 = 1;
              do {
                v134[v90 - 1] = v134[v90 - 1] - v140[v90 - 1];
                v91 = v90;
                v87 = *((_DWORD *)a1 + 3);
                ++v90;
              } while (v91 < v87);
            }
          }
          v121 = compute_rms(v134, v87);
          v92 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)a1 + 60) +
                                        4 * *((_DWORD *)a1 + 61)) +
                            8);
          if (v92) {
            if (v92 == 3) {
              v113 = scal_quant(v121 / v146, &exc_gain_quant_scal3_bound, 8);
              speex_bits_pack(a3, v113, (char *)3);
              v93 = v146 * exc_gain_quant_scal3[v113];
            } else {
              v110 = scal_quant(v121 / v146, &exc_gain_quant_scal1_bound, 2);
              speex_bits_pack(a3, v110, (char *)1);
              v93 = v146 * exc_gain_quant_scal1[v110];
            }
            v141 = v93;
          } else {
            v93 = v146;
            v141 = v146;
          }
          signal_div(v131, v131, v93, *((_DWORD *)a1 + 3));
          v94 = *(_DWORD **)(*((_DWORD *)a1 + 60) + 4 * *((_DWORD *)a1 + 61));
          v95 = (void(__cdecl *)(float *, _DWORD, _DWORD, _DWORD, _DWORD,
                                 _DWORD, _DWORD, float *, float *, SpeexBits *,
                                 char *, _DWORD, _DWORD))v94[9];
          if (!v95)
            speex_error("No fixed codebook");
          v95(v131, *((_DWORD *)a1 + 37), *((_DWORD *)a1 + 38),
              *((_DWORD *)a1 + 39), v94[11], *((_DWORD *)a1 + 6),
              *((_DWORD *)a1 + 3), v88, v133, a3, v144, *((_DWORD *)a1 + 56),
              v94[3]);
          signal_mul(v88, v88, v141, *((_DWORD *)a1 + 3));
          if (*((int *)a1 + 3) > 0) {
            v96 = 1;
            do {
              v140[v96 - 1] = v140[v96 - 1] + v88[v96 - 1];
              v97 = v96++;
            } while (*((_DWORD *)a1 + 3) > v97);
          }
          v98 = *((_DWORD *)a1 + 61);
          v99 = *((_DWORD *)a1 + 60);
          if (*(_DWORD *)(*(_DWORD *)(v99 + 4 * v98) + 12)) {
            v100 = *((_DWORD *)a1 + 3);
            v145 = (int)&v144[4 * v100 + (-(int)v144 & 3)];
            v101 = (float *)&v144[-(int)v144 & 3];
            if (v100 > 0) {
              v102 = 0;
              do
                v101[v102++] = 0.0;
              while (v102 < *((_DWORD *)a1 + 3));
              v100 = *((_DWORD *)a1 + 3);
              if (v100 > 0) {
                v103 = 1;
                v104 = v131 + 1;
                do {
                  v105 = *(v104 - 1) * 2.2;
                  *(v104 - 1) = v105;
                  v106 = v103;
                  v100 = *((_DWORD *)a1 + 3);
                  ++v103;
                  ++v104;
                } while (v106 < v100);
              }
              v98 = *((_DWORD *)a1 + 61);
              v99 = *((_DWORD *)a1 + 60);
            }
            (*(void(__cdecl **)(float *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD,
                                int, float *, float *, SpeexBits *, int, _DWORD,
                                _DWORD))(*(_DWORD *)(v99 + 4 * v98) + 36))(
                v131, *((_DWORD *)a1 + 37), *((_DWORD *)a1 + 38),
                *((_DWORD *)a1 + 39),
                *(_DWORD *)(*(_DWORD *)(v99 + 4 * v98) + 44),
                *((_DWORD *)a1 + 6), v100, v101, v133, a3, v145,
                *((_DWORD *)a1 + 56), 0);
            v107 = v141 * 0.4545454545454545;
            signal_mul(v101, v101, v107, *((_DWORD *)a1 + 3));
            if (*((int *)a1 + 3) > 0) {
              v108 = 1;
              do {
                v140[v108 - 1] = v140[v108 - 1] + v101[v108 - 1];
                v109 = v108++;
              } while (v109 < *((_DWORD *)a1 + 3));
            }
          }
          iir_mem2(v140, *((const float **)a1 + 37), v138, *((_DWORD *)a1 + 3),
                   *((_DWORD *)a1 + 6), *((float **)a1 + 40));
          if (*((_DWORD *)a1 + 56))
            filter_mem2(v138, *((const float **)a1 + 38),
                        *((const float **)a1 + 39), v139, *((_DWORD *)a1 + 3),
                        *((_DWORD *)a1 + 6), *((float **)a1 + 41));
          ++v127;
          v33 = *((_DWORD *)a1 + 4);
          if (v127 >= v33)
            break;
          v32 = *((_DWORD *)a1 + 6);
          m = *((_DWORD *)a1 + 3);
        }
      }
      if (*((int *)a1 + 61) > 0 && *((int *)a1 + 6) > 0) {
        v34 = 0;
        do {
          *(_DWORD *)(*((_DWORD *)a1 + 32) + 4 * v34) =
              *(_DWORD *)(*((_DWORD *)a1 + 30) + 4 * v34);
          ++v34;
        } while (v34 < *((_DWORD *)a1 + 6));
        if (*((int *)a1 + 6) > 0) {
          v35 = 0;
          do {
            *(_DWORD *)(*((_DWORD *)a1 + 33) + 4 * v35) =
                *(_DWORD *)(*((_DWORD *)a1 + 31) + 4 * v35);
            ++v35;
          } while (v35 < *((_DWORD *)a1 + 6));
        }
      }
      if (*((_DWORD *)a1 + 61) == 1) {
        if (*((_DWORD *)a1 + 51))
          speex_bits_pack(a3, 0xFu, (char *)4);
        else
          speex_bits_pack(a3, 0, (char *)4);
      }
      *((_DWORD *)a1 + 1) = 0;
      v36 = *((_DWORD *)a1 + 61);
      *((_DWORD *)a1 + 10) =
          *(int(__cdecl **)(float *, float *, float *, float *, const void *,
                            int, int, float *, float *, SpeexBits *, char *))(
              *(_DWORD *)(*((_DWORD *)a1 + 60) + 4 * v36) + 36) ==
              noise_codebook_quant ||
          !v36;
      return 1;
    }
  } else {
    v19 = *((_DWORD *)a1 + 61);
    v20 = *((_DWORD *)a1 + 60);
    if (*(_DWORD *)(v20 + 4 * v19))
      goto LABEL_32;
  }
  if (*((int *)a1 + 2) > 0) {
    v55 = 0;
    do {
      v56 = (_DWORD *)(*((_DWORD *)a1 + 22) + 4 * v55);
      *(_DWORD *)(*((_DWORD *)a1 + 24) + 4 * v55) = 646978941;
      *v56 = 646978941;
      ++v55;
    } while (v55 < *((_DWORD *)a1 + 2));
  }
  if (*((int *)a1 + 6) > 0) {
    v57 = 0;
    do
      *(_DWORD *)(*((_DWORD *)a1 + 41) + 4 * v57++) = 0;
    while (v57 < *((_DWORD *)a1 + 6));
  }
  *((_DWORD *)a1 + 1) = 1;
  *((_DWORD *)a1 + 10) = 1;
  iir_mem2(*((const float **)a1 + 22), *((const float **)a1 + 37),
           *((float **)a1 + 20), *((_DWORD *)a1 + 2), *((_DWORD *)a1 + 6),
           *((float **)a1 + 40));
  return 0;
}

_DWORD *__cdecl nb_decoder_init(const SpeexMode *a1) {
  int *mode;          // esi
  _DWORD *v2;         // eax
  _DWORD *v3;         // ebx
  int v4;             // edi
  void *v5;           // eax
  char *v6;           // eax
  int v7;             // ecx
  int v8;             // edx
  int v9;             // edx
  CombFilterMem *v10; // eax
  _DWORD *v11;        // eax
  int v12;            // edx
  int v14;            // ecx

  mode = (int *)a1->mode;
  v2 = speex_alloc(0x4070u);
  v3 = v2;
  if (!v2)
    return 0;
  v2[11] = v2 + 124;
  *v2 = a1;
  v2[29] = 1;
  v2[1] = 1;
  v4 = *mode;
  v2[3] = *mode;
  v2[5] = *mode / mode[1];
  v2[4] = mode[1];
  v2[6] = mode[2];
  v2[7] = mode[3];
  v2[8] = mode[4];
  v2[30] = mode + 9;
  v2[31] = mode[25];
  v2[32] = 0;
  v5 = speex_alloc(4 * v4);
  v3[12] = v5;
  v3[13] = v5;
  v6 = (char *)speex_alloc(4 * (v3[8] + v3[3]) + 4);
  v3[14] = v6;
  v7 = v3[8];
  v3[15] = &v6[4 * v7 + 4];
  if ((int)v3[3] > 0) {
    v8 = 0;
    do
      *(_DWORD *)(v3[12] + 4 * v8++) = 0;
    while (v8 < v3[3]);
    v7 = v3[8];
  }
  v9 = v3[3];
  if (v9 + v7 + 1 > 0) {
    v14 = 0;
    do {
      *(_DWORD *)(v3[14] + 4 * v14++) = 0;
      v9 = v3[3];
    } while (v14 < v3[8] + v9 + 1);
  }
  v3[16] = speex_alloc(4 * v9);
  v3[20] = speex_alloc(4 * v3[6]);
  v3[17] = speex_alloc(4 * v3[6]);
  v3[18] = speex_alloc(4 * v3[6]);
  v3[19] = speex_alloc(4 * v3[6]);
  v3[21] = speex_alloc(20 * v3[6]);
  v10 = (CombFilterMem *)speex_alloc(0x14u);
  v3[33] = v10;
  comb_filter_mem_init(v10);
  v3[22] = speex_alloc(4 * v3[5]);
  v3[23] = 40;
  v3[2] = 0;
  v3[27] = 0;
  v3[26] = 0;
  v3[25] = 0;
  v3[28] = 0;
  v3[9] = 8000;
  v3[10] = 0;
  v3[115] = speex_default_user_handler;
  v3[116] = 0;
  v11 = v3;
  v12 = 16;
  do {
    v11[35] = 0;
    v11 += 5;
    --v12;
  } while (v12);
  v3[121] = 0;
  v3[120] = 0;
  v3[119] = 0;
  v3[122] = 0;
  v3[123] = 0;
  return v3;
}

void __cdecl nb_decoder_destroy(void **a1) {
  speex_free(a1[12]);
  speex_free(a1[14]);
  speex_free(a1[16]);
  speex_free(a1[20]);
  speex_free(a1[17]);
  speex_free(a1[18]);
  speex_free(a1[19]);
  speex_free(a1[21]);
  speex_free(a1[33]);
  speex_free(a1[22]);
  speex_free(a1);
}

int __cdecl nb_decode(char *a1, SpeexBits *a2, _DWORD *a3) {
  int v3;                                                            // edx
  int v4;                                                            // ebx
  double v5;                                                         // xmm0_8
  int v6;                                                            // eax
  float v7;                                                          // xmm1_4
  float v8;                                                          // xmm1_4
  int v9;                                                            // edx
  int v10;                                                           // ebx
  int v11;                                                           // esi
  int v12;                                                           // edx
  float v13;                                                         // xmm0_4
  int v14;                                                           // ecx
  int v15;                                                           // ebx
  int v16;                                                           // eax
  int v17;                                                           // edx
  int v18;                                                           // ecx
  float v19;                                                         // xmm0_4
  int v20;                                                           // ebx
  int v21;                                                           // edx
  int v22;                                                           // edx
  int v23;                                                           // eax
  int result;                                                        // eax
  int v25;                                                           // eax
  int v26;                                                           // ebx
  float v27;                                                         // xmm0_4
  float v28;                                                         // xmm0_4
  float v29;                                                         // xmm1_4
  float v30;                                                         // xmm0_4
  float v31;                                                         // xmm2_4
  float v32;                                                         // xmm0_4
  float v33;                                                         // xmm1_4
  float v34;                                                         // xmm0_4
  int v35;                                                           // ebx
  int v36;                                                           // esi
  int i;                                                             // eax
  int v38;                                                           // eax
  int v39;                                                           // esi
  float *v40;                                                        // eax
  float v41;                                                         // edx
  float v42;                                                         // ebx
  int v43;                                                           // ebx
  int v44;                                                           // edx
  int j;                                                             // ecx
  int v46;                                                           // ebx
  float v47;                                                         // xmm0_4
  int v48;                                                           // ecx
  int v49;                                                           // eax
  int v50;                                                           // ecx
  float v51;                                                         // xmm0_4
  float v52;                                                         // xmm0_4
  int v53;                                                           // eax
  float v54;                                                         // xmm0_4
  int v55;                                                           // ecx
  int v56;                                                           // edx
  float v57;                                                         // xmm1_4
  float *v58;                                                        // eax
  int v59;                                                           // ecx
  int m;                                                             // eax
  int *v61;                                                          // ebx
  int v62;                                                           // edx
  int v63;                                                           // esi
  int v64;                                                           // edx
  float v65;                                                         // xmm0_4
  int v66;                                                           // ecx
  float *v67;                                                        // edx
  int v68;                                                           // eax
  double v69;                                                        // xmm0_8
  double v70;                                                        // xmm1_8
  double v71;                                                        // xmm0_8
  double v72;                                                        // xmm1_8
  float v73;                                                         // xmm0_4
  int v74;                                                           // ecx
  int v75;                                                           // eax
  int v76;                                                           // esi
  int v77;                                                           // edx
  int v78;                                                           // eax
  int v79;                                                           // edx
  void(__cdecl * v80)(float *, _DWORD, _DWORD, SpeexBits *, char *); // ecx
  int v81;                                                           // ecx
  int v82;                                                           // eax
  int v83;                                                           // ebx
  int v84;                                                           // esi
  int v85;                                                           // edx
  int v86;                                                           // ecx
  float *v87;                                                        // ebx
  int n;                                                             // eax
  float v89;                                                         // xmm0_4
  int v90;                                                           // ecx
  int v91;                                                           // eax
  int v92;                                                           // ecx
  int v93;                                                           // eax
  float v94;                                                         // xmm0_4
  int v95;                                                           // edx
  int ii;                                                            // ecx
  int v97;                                                           // eax
  int v98;                                                           // eax
  int v99;                                                           // edx
  float v100;                                                        // xmm0_4
  float v101;                                                        // xmm1_4
  double v102;                                                       // xmm7_8
  double v103;                                                       // xmm6_8
  double v104;                                                       // xmm5_8
  double v105;                                                       // xmm4_8
  int v106;                                                          // ecx
  float *v107;                                                       // edx
  float v108;                                                        // xmm3_4
  float *v109;                                                       // eax
  float v110;                                                        // xmm1_4
  float v111;                                                        // xmm1_4
  int v112;                                                          // eax
  long double v113;                                                  // fst7
  int v114;                                                          // eax
  int k;                                                             // edx
  int v116;                                                          // ecx
  float v117;                                                        // xmm0_4
  float v118;                                                        // xmm0_4
  float v119;                                                        // xmm2_4
  long double v120; // [esp+0h] [ebp-148h]
  float v121;       // [esp+0h] [ebp-148h]
  double v122;      // [esp+50h] [ebp-F8h]
  double v123;      // [esp+60h] [ebp-E8h]
  double v124;      // [esp+68h] [ebp-E0h]
  void(__cdecl * v125)(float *, int, int, _DWORD, int, int, int *, float *,
                       SpeexBits *, char *, _DWORD, int, _DWORD,
                       _DWORD); // [esp+90h] [ebp-B8h]
  int v126;                     // [esp+94h] [ebp-B4h]
  float v127;                   // [esp+98h] [ebp-B0h]
  int v128;                     // [esp+9Ch] [ebp-ACh]
  float v129;                   // [esp+A0h] [ebp-A8h]
  int v130;                     // [esp+A4h] [ebp-A4h]
  float v131;                   // [esp+A8h] [ebp-A0h]
  int v132;                     // [esp+ACh] [ebp-9Ch]
  float *v133;                  // [esp+B0h] [ebp-98h]
  float *v134;                  // [esp+B4h] [ebp-94h]
  float *v135;                  // [esp+B8h] [ebp-90h]
  float v136;                   // [esp+BCh] [ebp-8Ch]
  float v137;                   // [esp+C0h] [ebp-88h]
  int v138;                     // [esp+C4h] [ebp-84h]
  float *v139;                  // [esp+C8h] [ebp-80h]
  float *v140;                  // [esp+CCh] [ebp-7Ch]
  float *v141;                  // [esp+D0h] [ebp-78h]
  float v142;                   // [esp+D4h] [ebp-74h]
  float *v143;                  // [esp+D8h] [ebp-70h]
  float v144;                   // [esp+DCh] [ebp-6Ch]
  float v145;                   // [esp+E0h] [ebp-68h]
  int v146;                     // [esp+E4h] [ebp-64h]
  float *v147;                  // [esp+E8h] [ebp-60h]
  float *v148;                  // [esp+ECh] [ebp-5Ch]
  float v149;                   // [esp+F0h] [ebp-58h]
  float *v150;                  // [esp+F4h] [ebp-54h]
  float v151;                   // [esp+FCh] [ebp-4Ch]
  float v152;                   // [esp+100h] [ebp-48h]
  char *v153;                   // [esp+104h] [ebp-44h]
  float *v154;                  // [esp+108h] [ebp-40h]
  float v155;                   // [esp+10Ch] [ebp-3Ch]
  float v156[2];                // [esp+11Ch] [ebp-2Ch] BYREF
  float v157;                   // [esp+124h] [ebp-24h]
  int v158;                     // [esp+128h] [ebp-20h]
  int v159[7];                  // [esp+12Ch] [ebp-1Ch] BYREF

  v132 = *((_DWORD *)a1 + 11);
  if (*((_DWORD *)a1 + 29)) {
    if (!a2) {
      if (*((_DWORD *)a1 + 123)) {
        *((_DWORD *)a1 + 31) = 0;
        goto LABEL_5;
      }
      *(double *)&v120 =
          (double)*((int *)a1 + 2) * ((double)*((int *)a1 + 2) * -0.04);
      v28 = exp(v120);
      v142 = v28;
      v29 = *((float *)a1 + 25);
      v30 = *((float *)a1 + 26);
      if (v30 <= v29) {
        v119 = *((float *)a1 + 27);
        if (v30 <= v119) {
          if (v29 > v119)
            v29 = *((float *)a1 + 27);
          goto LABEL_61;
        }
      } else {
        v31 = *((float *)a1 + 27);
        if (v31 <= v30) {
          if (v31 > v29)
            v29 = *((float *)a1 + 27);
          goto LABEL_61;
        }
      }
      v29 = *((float *)a1 + 26);
    LABEL_61:
      v32 = *((float *)a1 + 24);
      if (v32 > v29) {
        v32 = v29;
        *((float *)a1 + 24) = v29;
      }
      v33 = v32;
      if (v32 > 0.95)
        v33 = 0.94999999;
      v34 = (float)(v33 * v142) + 1.0e-15;
      v152 = v34;
      speex_move(*((void **)a1 + 14),
                 (const void *)(*((_DWORD *)a1 + 14) + 4 * *((_DWORD *)a1 + 3)),
                 4 * *((_DWORD *)a1 + 8) + 4);
      v35 = 4 * *((_DWORD *)a1 + 6);
      v36 = -4 * *((_DWORD *)a1 + 6);
      v139 = (float *)(v132 + ((4 - (_BYTE)v132) & 3));
      v140 =
          (float *)((char *)&v139[v35 / 4u + 1] +
                    (-(char)(v132 + ((4 - v132) & 3) + v35) & 3) + v35 + v36);
      v141 = (float *)((char *)&v139[v35 / 4u + 2] +
                       (-(char)(v132 + ((4 - v132) & 3) + v35) & 3) + v35 +
                       (-(char)(v35 +
                                (-(char)(v132 + ((4 - v132) & 3) + v35) & 3) +
                                v132 + ((4 - v132) & 3) + v35 + 4) &
                        3) +
                       v35 + v36);
      if (*((int *)a1 + 5) > 0) {
        v138 = 0;
        v124 = v34;
        v123 = v142 * sqrt((float)(1.0 - v34));
        for (i = 0;; i = v138) {
          v38 = 4 * *((_DWORD *)a1 + 4) * i;
          v143 = (float *)(v38 + *((_DWORD *)a1 + 13));
          v39 = *((_DWORD *)a1 + 15) + v38;
          if (*((_DWORD *)a1 + 32)) {
            v40 = *(float **)(*((_DWORD *)a1 + 30) + 4 * *((_DWORD *)a1 + 31));
            if (v40) {
              v41 = v40[12];
              v42 = v40[13];
              v144 = v40[14];
            } else {
              v42 = 0.69999999;
              v41 = 0.69999999;
              v144 = 0.0;
            }
            bw_lpc(v41, *((const float **)a1 + 20), v139, *((_DWORD *)a1 + 6));
            bw_lpc(v42, *((const float **)a1 + 20), v140, *((_DWORD *)a1 + 6));
            bw_lpc(v144, *((const float **)a1 + 20), v141, *((_DWORD *)a1 + 6));
          }
          v145 = compute_rms((const float *)*((_DWORD *)a1 + 16),
                             *((_DWORD *)a1 + 3));
          v43 = *((_DWORD *)a1 + 4);
          if (v43 > 0) {
            v46 = 0;
            do {
              v122 = (*(float *)(v39 + 4 * (v46 - *((_DWORD *)a1 + 23))) +
                      1.0e-15) *
                     v124;
              v137 = speex_rand(v145);
              v47 = v122 + v137 * v123;
              *(float *)(v39 + 4 * v46++) = v47;
            } while (v46 < *((_DWORD *)a1 + 4));
            v43 = *((_DWORD *)a1 + 4);
            if (v43 > 0) {
              v48 = 1;
              do {
                v143[v48 - 1] = *(float *)(4 * v48 + v39 - 4);
                v49 = v48;
                v43 = *((_DWORD *)a1 + 4);
                ++v48;
              } while (v49 < v43);
            }
          }
          if (*((_DWORD *)a1 + 32)) {
            filter_mem2(
                v143, v140, v139, v143, v43, *((_DWORD *)a1 + 6),
                (float *)(*((_DWORD *)a1 + 21) + 4 * *((_DWORD *)a1 + 6)));
            filter_mem2(v143, v141, *((const float **)a1 + 20), v143,
                        *((_DWORD *)a1 + 4), *((_DWORD *)a1 + 6),
                        *((float **)a1 + 21));
          } else {
            v44 = *((_DWORD *)a1 + 6);
            if (v44 > 0) {
              for (j = 0; j < v44; ++j) {
                *(_DWORD *)(*((_DWORD *)a1 + 21) + 4 * (j + v44)) = 0;
                v44 = *((_DWORD *)a1 + 6);
              }
              v43 = *((_DWORD *)a1 + 4);
            }
            iir_mem2(v143, *((const float **)a1 + 20), v143, v43, v44,
                     *((float **)a1 + 21));
          }
          if (++v138 >= *((_DWORD *)a1 + 5))
            break;
        }
      }
      if (*((int *)a1 + 3) > 0) {
        v50 = 0;
        do {
          v52 = *(float *)(4 * v50 + *((_DWORD *)a1 + 13));
          if (v52 <= 32767.0)
            v51 = fmaxf(-32767.0, v52);
          else
            v51 = 32767.0;
          *(float *)&a3[v50++] = v51;
        } while (v50 < *((_DWORD *)a1 + 3));
      }
      *((_DWORD *)a1 + 1) = 0;
      ++*((_DWORD *)a1 + 2);
      v53 = *((_DWORD *)a1 + 28);
      *(float *)&a1[4 * v53++ + 100] = v152;
      *((_DWORD *)a1 + 28) = v53;
      if (v53 > 2)
        *((_DWORD *)a1 + 28) = 0;
      return 0;
    }
    while (1) {
      while (1) {
        if ((int)speex_bits_remaining(a2) <= 4)
          return -1;
        if (speex_bits_unpack_unsigned(a2, 1)) {
          v158 = speex_bits_unpack_unsigned(a2, 3);
          speex_mode_query(&speex_wb_mode);
          if (v158 < 0) {
            speex_warning(
                "Invalid wideband mode encountered. Corrupted stream?");
            return -2;
          }
          v158 -= 4;
          speex_bits_advance(a2, v158);
          if ((int)speex_bits_remaining(a2) <= 4)
            return -1;
          if (speex_bits_unpack_unsigned(a2, 1)) {
            v158 = speex_bits_unpack_unsigned(a2, 3);
            speex_mode_query(&speex_wb_mode);
            if (v158 < 0) {
              speex_warning(
                  "Invalid wideband mode encountered: corrupted stream?");
              return -2;
            }
            v158 -= 4;
            speex_bits_advance(a2, v158);
            if (speex_bits_unpack_unsigned(a2, 1)) {
              speex_warning(
                  "More than two wideband layers found: corrupted stream?");
              return -2;
            }
          }
        }
        if ((int)speex_bits_remaining(a2) <= 3)
          return -1;
        v25 = speex_bits_unpack_unsigned(a2, 4);
        if (v25 == 15)
          return -1;
        if (v25 != 14)
          break;
        result = speex_inband_handler(a2, (SpeexCallback *)(a1 + 136), a1);
        if (result)
          return result;
      }
      if (v25 != 13)
        break;
      result = (*((int(__cdecl **)(SpeexBits *, char *, _DWORD))a1 + 115))(
          a2, a1, *((_DWORD *)a1 + 116));
      if (result)
        return result;
    }
    if (v25 > 8) {
      speex_warning("Invalid mode encountered: corrupted stream?");
      return -2;
    }
    *((_DWORD *)a1 + 31) = v25;
  }
LABEL_5:
  speex_move(*((void **)a1 + 14),
             (const void *)(*((_DWORD *)a1 + 14) + 4 * *((_DWORD *)a1 + 3)),
             4 * *((_DWORD *)a1 + 8) + 4);
  v3 = *(_DWORD *)(*((_DWORD *)a1 + 30) + 4 * *((_DWORD *)a1 + 31));
  if (!v3) {
    bw_lpc(0.93000001, *((const float **)a1 + 20),
           (float *)((-v132 & 3) + v132), 10);
    v113 =
        compute_rms((const float *)*((_DWORD *)a1 + 16), *((_DWORD *)a1 + 3));
    v114 = *((_DWORD *)a1 + 3);
    if (v114 > 0) {
      for (k = 0; k < v114; ++k) {
        *(_DWORD *)(*((_DWORD *)a1 + 15) + 4 * k) = 646978941;
        v114 = *((_DWORD *)a1 + 3);
      }
    }
    v121 = v113;
    speex_rand_vec(v121, *((float **)a1 + 15), v114);
    *((_DWORD *)a1 + 1) = 1;
    iir_mem2(*((const float **)a1 + 15), (const float *)((-v132 & 3) + v132),
             *((float **)a1 + 13), *((_DWORD *)a1 + 3), *((_DWORD *)a1 + 6),
             *((float **)a1 + 21));
    if (*((int *)a1 + 3) > 0) {
      v116 = 0;
      do {
        v118 = *(float *)(*((_DWORD *)a1 + 13) + 4 * v116);
        if (v118 <= 32767.0)
          v117 = fmaxf(-32767.0, v118);
        else
          v117 = 32767.0;
        *(float *)&a3[v116++] = v117;
      } while (*((_DWORD *)a1 + 3) > v116);
    }
    *((_DWORD *)a1 + 2) = 0;
    return 0;
  }
  DWORD2(v120) = a2;
  (*(void(__cdecl **)(_DWORD, _DWORD))(v3 + 20))(*((_DWORD *)a1 + 17),
                                                 *((_DWORD *)a1 + 6));
  if (*((_DWORD *)a1 + 2)) {
    v4 = *((_DWORD *)a1 + 6);
    v5 = 0.0;
    if (v4 > 0) {
      v6 = 0;
      v7 = 0.0;
      do {
        v7 = v7 + fabs(*(float *)(*((_DWORD *)a1 + 18) + 4 * v6) -
                       *(float *)(*((_DWORD *)a1 + 17) + 4 * v6));
        ++v6;
      } while (v4 != v6);
      v5 = v7;
    }
    *(double *)&v120 = v5 * -0.2;
    v8 = (double)exp(v120) * 0.6;
    if (2 * v4 > 0) {
      v9 = 0;
      do {
        *(float *)(*((_DWORD *)a1 + 21) + 4 * v9) =
            v8 * *(float *)(*((_DWORD *)a1 + 21) + 4 * v9);
        ++v9;
      } while (2 * *((_DWORD *)a1 + 6) > v9);
    }
  }
  if (*((_DWORD *)a1 + 1) || *((_DWORD *)a1 + 2)) {
    if (*((int *)a1 + 6) > 0) {
      v10 = 0;
      do {
        *(_DWORD *)(*((_DWORD *)a1 + 18) + 4 * v10) =
            *(_DWORD *)(*((_DWORD *)a1 + 17) + 4 * v10);
        ++v10;
      } while (*((_DWORD *)a1 + 6) > v10);
    }
    v11 = *((_DWORD *)a1 + 31);
    v12 = *((_DWORD *)a1 + 30);
    if (**(_DWORD **)(v12 + 4 * v11) != -1) {
    LABEL_53:
      v26 = *((_DWORD *)a1 + 7);
      v128 = speex_bits_unpack_unsigned(a2, 7) + v26;
      if (*(_DWORD *)(*(_DWORD *)(*((_DWORD *)a1 + 30) +
                                  4 * *((_DWORD *)a1 + 31)) +
                      4))
        goto LABEL_54;
    LABEL_20:
      v129 = 0.0;
      goto LABEL_21;
    }
  } else {
    v11 = *((_DWORD *)a1 + 31);
    v12 = *((_DWORD *)a1 + 30);
    if (**(_DWORD **)(v12 + 4 * v11) != -1)
      goto LABEL_53;
  }
  v128 = 0;
  if (!*(_DWORD *)(*(_DWORD *)(v12 + 4 * v11) + 4))
    goto LABEL_20;
LABEL_54:
  v27 = (double)speex_bits_unpack_unsigned(a2, 4) * 0.066667;
  v129 = v27;
LABEL_21:
  *(double *)&v120 = (double)speex_bits_unpack_unsigned(a2, 5) / 3.5;
  v13 = exp(v120);
  v127 = v13;
  v14 = 4 * *((_DWORD *)a1 + 6);
  v15 = -4 * *((_DWORD *)a1 + 6);
  v133 = (float *)(v132 + ((4 - (_BYTE)v132) & 3));
  v134 = (float *)((char *)&v133[v14 / 4u + 1] +
                   (-(char)(v132 + ((4 - v132) & 3) + v14) & 3) + v14 + v15);
  v16 = -(char)(v14 + (-(char)(v132 + ((4 - v132) & 3) + v14) & 3) + v132 +
                ((4 - v132) & 3) + v14 + 4) &
        3;
  v153 = (char *)&v133[v14 / 4u + 3] +
         (-(char)(v132 + ((4 - v132) & 3) + v14) & 3) + v14 + v16 + v14;
  v135 = (float *)((char *)&v133[v14 / 4u + 2] +
                   (-(char)(v132 + ((4 - v132) & 3) + v14) & 3) + v14 + v16 +
                   v14 + v15);
  if (*((_DWORD *)a1 + 31) == 1)
    *((_DWORD *)a1 + 123) = speex_bits_unpack_unsigned(a2, 4) == 15;
  if (*((int *)a1 + 31) > 1)
    *((_DWORD *)a1 + 123) = 0;
  v17 = *((_DWORD *)a1 + 5);
  if (v17 > 0) {
    v54 = v129 - 0.6 + v129 - 0.6 + 0.5;
    v155 = v54;
    v131 = 0.0;
    v126 = 0;
    v130 = 40;
    v136 = 0.0;
    v154 = (float *)&v153[(4 - (_BYTE)v153) & 3];
    while (1) {
      v146 = *((_DWORD *)a1 + 4) * v126;
      v147 = (float *)(4 * v146 + *((_DWORD *)a1 + 13));
      v148 = (float *)(*((_DWORD *)a1 + 15) + 4 * v146);
      lsp_interpolate(*((float **)a1 + 18), *((float **)a1 + 17),
                      *((float **)a1 + 19), *((_DWORD *)a1 + 6), v126, v17);
      lsp_enforce_margin(*((float **)a1 + 19), *((_DWORD *)a1 + 6),
                         0.0020000001);
      lsp_to_lpc(*((float **)a1 + 19), *((float **)a1 + 20),
                 *((_DWORD *)a1 + 6), v153);
      if (*((_DWORD *)a1 + 32)) {
        bw_lpc(*(float *)(*(_DWORD *)(*((_DWORD *)a1 + 30) +
                                      4 * *((_DWORD *)a1 + 31)) +
                          48),
               *((const float **)a1 + 20), v133, *((_DWORD *)a1 + 6));
        bw_lpc(*(float *)(*(_DWORD *)(*((_DWORD *)a1 + 30) +
                                      4 * *((_DWORD *)a1 + 31)) +
                          52),
               *((const float **)a1 + 20), v134, *((_DWORD *)a1 + 6));
        bw_lpc(*(float *)(*(_DWORD *)(*((_DWORD *)a1 + 30) +
                                      4 * *((_DWORD *)a1 + 31)) +
                          56),
               *((const float **)a1 + 20), v135, *((_DWORD *)a1 + 6));
      }
      v55 = *((_DWORD *)a1 + 6);
      if (v55 <= 0) {
        v57 = 1.0;
      } else {
        v56 = 0;
        v57 = 1.0;
        v58 = (float *)*((_DWORD *)a1 + 20);
        do {
          v57 = v57 + (float)(v58[1] - *v58);
          v56 += 2;
          v58 += 2;
        } while (v55 > v56);
      }
      *(float *)(*((_DWORD *)a1 + 22) + 4 * v126) = v57;
      v59 = *((_DWORD *)a1 + 4);
      if (v59 > 0) {
        for (m = 0; m < v59; ++m) {
          v148[m] = 0.0;
          v59 = *((_DWORD *)a1 + 4);
        }
      }
      v61 = *(int **)(*((_DWORD *)a1 + 30) + 4 * *((_DWORD *)a1 + 31));
      v125 = (void(__cdecl *)(float *, int, int, _DWORD, int, int, int *,
                              float *, SpeexBits *, char *, _DWORD, int, _DWORD,
                              _DWORD))v61[7];
      if (!v125)
        speex_error("No pitch prediction, what's wrong");
      v62 = *v61;
      if (*v61 == -1) {
        v63 = *((_DWORD *)a1 + 7);
        v64 = *((_DWORD *)a1 + 8);
      } else if (v62) {
        v63 = v128 - v62 + 1;
        if (v63 < *((_DWORD *)a1 + 7))
          v63 = *((_DWORD *)a1 + 7);
        v64 = v128 + v62;
        if (v64 > *((_DWORD *)a1 + 8))
          v64 = *((_DWORD *)a1 + 8);
      } else {
        v63 = v128;
        v64 = v128;
      }
      v125(v148, v63, v64, LODWORD(v129), v61[8], v59, v159, v156, a2, v153,
           *((_DWORD *)a1 + 2), v146, *((_DWORD *)a1 + 24), 0);
      if (*((_DWORD *)a1 + 2)) {
        v65 = *((float *)a1 + 10);
        if (v65 > v127 && *((int *)a1 + 4) > 0) {
          v66 = 1;
          v67 = v148 + 1;
          do {
            *(v67 - 1) = (float)(v127 / (float)(v65 + 1.0)) * *(v67 - 1);
            v68 = v66++;
            ++v67;
          } while (*((_DWORD *)a1 + 4) > v68);
        }
      }
      v69 = fabs(v156[1]);
      if (v156[0] <= 0.0)
        v70 = v156[0] * -0.5;
      else
        v70 = v156[0];
      v71 = v69 + v70;
      if (v157 <= 0.0)
        v72 = v157 * -0.5;
      else
        v72 = v157;
      v73 = v72 + v71;
      v136 = v136 + v73;
      if (v73 > v131) {
        v130 = v159[0];
        v131 = v73;
      }
      v74 = *((_DWORD *)a1 + 4);
      v150 = (float *)(*((_DWORD *)a1 + 16) + 4 * v74 * v126);
      if (v74 > 0) {
        v75 = 0;
        do
          v150[v75++] = 0.0;
        while (v75 < *((_DWORD *)a1 + 4));
      }
      v76 = *((_DWORD *)a1 + 31);
      v77 = *((_DWORD *)a1 + 30);
      v78 = *(_DWORD *)(*(_DWORD *)(v77 + 4 * v76) + 8);
      if (v78 == 3) {
        v149 = v127 * exc_gain_quant_scal3[speex_bits_unpack_unsigned(a2, 3)];
        v76 = *((_DWORD *)a1 + 31);
        v77 = *((_DWORD *)a1 + 30);
      } else if (v78 == 1) {
        v149 = v127 * exc_gain_quant_scal1[speex_bits_unpack_unsigned(a2, 1)];
        v76 = *((_DWORD *)a1 + 31);
        v77 = *((_DWORD *)a1 + 30);
      } else {
        v149 = v127;
      }
      v79 = *(_DWORD *)(v77 + 4 * v76);
      v80 = *(void(__cdecl **)(float *, _DWORD, _DWORD, SpeexBits *, char *))(
          v79 + 40);
      if (!v80)
        speex_error("No fixed codebook");
      v80(v150, *(_DWORD *)(v79 + 44), *((_DWORD *)a1 + 4), a2, v153);
      signal_mul(v150, v150, v149, *((_DWORD *)a1 + 4));
      if (*((_DWORD *)a1 + 31) != 1)
        break;
      if (*((int *)a1 + 4) > 0) {
        v97 = 0;
        do
          v148[v97++] = 0.0;
        while (v97 < *((_DWORD *)a1 + 4));
      }
      v98 = *((_DWORD *)a1 + 122);
      v99 = v98;
      v83 = *((_DWORD *)a1 + 4);
      if (v98 < v83) {
        v100 = sqrt((double)v128);
        do {
          if (v99 >= 0) {
            v148[v99] = v100;
            v83 = *((_DWORD *)a1 + 4);
            v98 = *((_DWORD *)a1 + 122);
          }
          v99 = v98 + v128;
          v98 = v99;
          *((_DWORD *)a1 + 122) = v99;
        } while (v99 < v83);
      }
      *((_DWORD *)a1 + 122) = v99 - v83;
      if (v155 < 0.0)
        v101 = 0.0;
      else
        v101 = fminf(1.0, v155);
      if (*((int *)a1 + 4) > 0) {
        v102 = v101 * 0.8;
        v103 = v101 * 0.6;
        v104 = v101 * 0.5;
        v105 = v101 * -0.5;
        v151 = 1.0 - v101;
        v106 = 1;
        do {
          v107 = &v148[v106];
          v108 = *(v107 - 1);
          v109 = &v150[v106];
          v110 = v108 * v102 * v127 + *((float *)a1 + 119) * v103 * v127 +
                 *(v109 - 1) * v104 + *((float *)a1 + 120) * v105 +
                 (float)(*(v109 - 1) * v151);
          *(v107 - 1) = v110;
          *((float *)a1 + 119) = v108;
          *((float *)a1 + 120) = *(v109 - 1);
          v111 = *((float *)a1 + 121) * 0.95 + *(v107 - 1) * 0.05;
          *((float *)a1 + 121) = v111;
          *(v107 - 1) = *(v107 - 1) - v111;
          v112 = v106++;
        } while (*((_DWORD *)a1 + 4) > v112);
      LABEL_131:
        v83 = *((_DWORD *)a1 + 4);
      }
      v84 = *((_DWORD *)a1 + 31);
      v85 = *((_DWORD *)a1 + 30);
      if (!*(_DWORD *)(*(_DWORD *)(v85 + 4 * v84) + 12))
        goto LABEL_141;
      v86 = v83;
      v87 = &v154[v83];
      if (v86 > 0) {
        for (n = 0; n < v86; ++n) {
          v154[n] = 0.0;
          v86 = *((_DWORD *)a1 + 4);
        }
        v84 = *((_DWORD *)a1 + 31);
        v85 = *((_DWORD *)a1 + 30);
      }
      (*(void(__cdecl **)(float *, _DWORD, int, SpeexBits *, float *))(
          *(_DWORD *)(v85 + 4 * v84) + 40))(
          v154, *(_DWORD *)(*(_DWORD *)(v85 + 4 * v84) + 44), v86, a2, v87);
      v89 = v149 * 0.4545454545454545;
      signal_mul(v154, v154, v89, *((_DWORD *)a1 + 4));
      v83 = *((_DWORD *)a1 + 4);
      if (v83 > 0) {
        v90 = 1;
        do {
          v148[v90 - 1] = v148[v90 - 1] + v154[v90 - 1];
          v91 = v90++;
        } while (v91 < *((_DWORD *)a1 + 4));
        v83 = *((_DWORD *)a1 + 4);
      LABEL_141:
        if (v83 > 0) {
          v92 = 1;
          do {
            v147[v92 - 1] = v148[v92 - 1];
            v93 = v92;
            v83 = *((_DWORD *)a1 + 4);
            ++v92;
          } while (v93 < v83);
        }
      }
      if (!*((_DWORD *)a1 + 32))
        goto LABEL_151;
      v94 = *(float *)(*(_DWORD *)(*((_DWORD *)a1 + 30) +
                                   4 * *((_DWORD *)a1 + 31)) +
                       60);
      if (v94 > 0.0) {
        comb_filter(v148, v147, *((float **)a1 + 20), *((_DWORD *)a1 + 6),
                    (float *)v83, v159[0], v156, v94,
                    *((CombFilterMem **)a1 + 33));
        if (!*((_DWORD *)a1 + 32)) {
        LABEL_151:
          v95 = *((_DWORD *)a1 + 6);
          if (v95 > 0) {
            for (ii = 0; ii < v95; ++ii) {
              *(_DWORD *)(*((_DWORD *)a1 + 21) + 4 * (ii + v95)) = 0;
              v95 = *((_DWORD *)a1 + 6);
            }
          }
          iir_mem2(v147, *((const float **)a1 + 20), v147, *((_DWORD *)a1 + 4),
                   v95, *((float **)a1 + 21));
          goto LABEL_149;
        }
        v83 = *((_DWORD *)a1 + 4);
      }
      filter_mem2(v147, v134, v133, v147, v83, *((_DWORD *)a1 + 6),
                  (float *)(*((_DWORD *)a1 + 21) + 4 * *((_DWORD *)a1 + 6)));
      filter_mem2(v147, v135, *((const float **)a1 + 20), v147,
                  *((_DWORD *)a1 + 4), *((_DWORD *)a1 + 6),
                  *((float **)a1 + 21));
    LABEL_149:
      ++v126;
      v17 = *((_DWORD *)a1 + 5);
      if (v126 >= v17)
        goto LABEL_27;
    }
    if (*((int *)a1 + 4) > 0) {
      v81 = 1;
      do {
        v148[v81 - 1] = v148[v81 - 1] + v150[v81 - 1];
        v82 = v81++;
      } while (*((_DWORD *)a1 + 4) > v82);
    }
    goto LABEL_131;
  }
  v130 = 40;
  v136 = 0.0;
LABEL_27:
  if (*((int *)a1 + 3) > 0) {
    v18 = 0;
    do {
      while (1) {
        v19 = *(float *)(*((_DWORD *)a1 + 13) + 4 * v18);
        if (v19 > 32767.0)
          break;
        *(float *)&a3[v18++] = fmaxf(-32767.0, v19);
        if (v18 >= *((_DWORD *)a1 + 3))
          goto LABEL_32;
      }
      a3[v18++] = 1191181824;
    } while (v18 < *((_DWORD *)a1 + 3));
  }
LABEL_32:
  if (*((int *)a1 + 6) > 0) {
    v20 = 0;
    do {
      *(_DWORD *)(*((_DWORD *)a1 + 18) + 4 * v20) =
          *(_DWORD *)(*((_DWORD *)a1 + 17) + 4 * v20);
      ++v20;
    } while (v20 < *((_DWORD *)a1 + 6));
  }
  *((_DWORD *)a1 + 1) = 0;
  *((_DWORD *)a1 + 2) = 0;
  *((_DWORD *)a1 + 23) = v130;
  *((float *)a1 + 24) = v136 * 0.25;
  v21 = *((_DWORD *)a1 + 28);
  *(float *)&a1[4 * v21 + 100] = v136 * 0.25;
  v22 = v21 + 1;
  v23 = 0;
  if (v22 < 3)
    v23 = v22;
  *((_DWORD *)a1 + 28) = v23;
  *((float *)a1 + 10) = v127;
  return 0;
}

int __cdecl nb_encoder_ctl(_DWORD *a1, int a2, int *a3) {
  int v4;      // edx
  int v5;      // eax
  int v6;      // eax
  int v7;      // eax
  int v8;      // ebx
  int v9;      // edx
  int v10;     // eax
  int v11;     // ecx
  int v12;     // ebx
  float *v13;  // edx
  float v14;   // xmm0_4
  int i;       // eax
  int v16;     // eax
  _DWORD *v17; // esi
  _DWORD *v18; // ebx
  _DWORD *v19; // ecx
  int v20;     // ebx
  _DWORD *v21; // ecx
  int v22;     // edx
  int v23;     // eax
  int v24;     // ecx
  int v25;     // ecx
  int v26;     // ecx
  int v27;     // ebx
  int v28;     // [esp+28h] [ebp-30h]
  int v29;     // [esp+2Ch] [ebp-2Ch]
  int v30;     // [esp+34h] [ebp-24h]
  int v31;     // [esp+38h] [ebp-20h]
  int v32;     // [esp+3Ch] [ebp-1Ch]

  switch (a2) {
  case 3:
    *a3 = a1[2];
    return 0;
  case 4:
    v4 = *a3;
    if (*a3 < 0) {
      v4 = 0;
    } else if (v4 >= 11) {
      v4 = 10;
    }
    v5 = *(_DWORD *)(*(_DWORD *)*a1 + 4 * v4 + 104);
    a1[61] = v5;
    a1[62] = v5;
    return 0;
  case 6:
  case 8:
    v6 = *a3;
    a1[61] = *a3;
    a1[62] = v6;
    return 0;
  case 7:
  case 9:
    *a3 = a1[61];
    return 0;
  case 12:
    a1[48] = *a3;
    return 0;
  case 13:
    *a3 = a1[48];
    return 0;
  case 14:
    a1[46] = *a3;
    return 0;
  case 15:
    *a3 = a1[46];
    return 0;
  case 16:
    v7 = *a3;
    a1[56] = *a3;
    if (v7 >= 0)
      goto LABEL_16;
    a1[56] = 0;
    return 0;
  case 17:
    *a3 = a1[56];
    return 0;
  case 18:
    v31 = 10;
    v8 = *a3;
    do {
      speex_encoder_ctl(a1);
      speex_encoder_ctl(a1);
      if (v8 >= v30)
        break;
      --v31;
    } while (v31 >= 0);
    goto LABEL_16;
  case 19:
    v9 = *(_DWORD *)(a1[60] + 4 * a1[61]);
    if (v9)
      v10 = *(_DWORD *)(v9 + 64) * a1[57] / a1[2];
    else
      v10 = 5 * a1[57] / a1[2];
    *a3 = v10;
    return 0;
  case 24:
    a1[57] = *a3;
    return 0;
  case 25:
    *a3 = a1[57];
    return 0;
  case 26:
    a1[10] = 1;
    a1[1] = 1;
    v11 = a1[6];
    if (v11 > 0) {
      v12 = 0;
      do {
        v13 = (float *)(a1[30] + 4 * v12++);
        v14 = (float)v12 * 3.141592653589793 / (double)(v11 + 1);
        *v13 = v14;
        v11 = a1[6];
      } while (v11 > v12);
      if (v11 > 0) {
        v29 = 0;
        for (i = 0;; i = v29) {
          v16 = 4 * i;
          v17 = (_DWORD *)(a1[41] + v16);
          v18 = (_DWORD *)(a1[42] + v16);
          v19 = (_DWORD *)(a1[40] + v16);
          *(_DWORD *)(a1[43] + v16) = 0;
          *v19 = 0;
          *v18 = 0;
          *v17 = 0;
          if (a1[6] <= ++v29)
            break;
        }
      }
    }
    if (a1[2] + a1[8] + 1 > 0) {
      v20 = 0;
      do {
        v21 = (_DWORD *)(a1[21] + 4 * v20);
        *(_DWORD *)(a1[23] + 4 * v20) = 0;
        *v21 = 0;
        ++v20;
      } while (v20 < a1[2] + a1[8] + 1);
    }
    if ((int)a1[5] > 0) {
      v22 = 0;
      do
        *(_DWORD *)(a1[19] + 4 * v22++) = 0;
      while (v22 < a1[5]);
    }
    goto LABEL_16;
  case 29:
    *a3 = a1[47];
    return 0;
  case 30:
    a1[49] = *a3;
    return 0;
  case 31:
    *a3 = a1[49];
    return 0;
  case 32:
    a1[52] = *a3;
    a1[48] = 1;
    v32 = 10;
    v27 = *a3;
    do {
      speex_encoder_ctl(a1);
      speex_encoder_ctl(a1);
      if (v27 >= v30)
        break;
      --v32;
    } while (v32 >= 0);
    speex_encoder_ctl(a1);
    a1[55] = 0;
    a1[53] = 0;
    a1[54] = 0;
    return 0;
  case 33:
    *a3 = a1[52];
    return 0;
  case 34:
    a1[50] = *a3;
    return 0;
  case 35:
    *a3 = a1[50];
    return 0;
  case 36:
    a1[59] = *a3;
    return 0;
  case 37:
    *a3 = a1[59];
    return 0;
  case 39:
    *a3 = a1[5] - a1[2];
    return 0;
  case 40:
    v23 = *a3;
    a1[58] = *a3;
    if (v23 <= 100)
      goto LABEL_16;
    a1[58] = 100;
    v28 = 0;
    break;
  case 41:
    *a3 = a1[58];
    return 0;
  case 100:
    if ((int)a1[4] > 0) {
      v24 = 0;
      do {
        a3[v24] = *(_DWORD *)(a1[44] + 4 * v24);
        ++v24;
      } while (v24 < a1[4]);
    }
    goto LABEL_16;
  case 101:
    if ((int)a1[2] > 0) {
      v25 = 0;
      do {
        a3[v25] = *(_DWORD *)(a1[22] + 4 * v25);
        ++v25;
      } while (v25 < a1[2]);
    }
    goto LABEL_16;
  case 102:
    if ((int)a1[2] > 0) {
      v26 = 0;
      do {
        a3[v26] = *(_DWORD *)(a1[25] + 4 * v26);
        ++v26;
      } while (v26 < a1[2]);
    }
  LABEL_16:
    v28 = 0;
    break;
  default:
    speex_warning_int("Unknown nb_ctl request: ", a2);
    v28 = -1;
    break;
  }
  return v28;
}

int __cdecl nb_decoder_ctl(_DWORD *a1, int a2, int *a3) {
  int result; // eax
  int v4;     // edx
  int v5;     // ecx
  _DWORD *v6; // eax
  int v7;     // edx
  int v8;     // edx
  int v9;     // edx
  int v10;    // ecx
  int v11;    // ecx
  int v12;    // ecx

  switch (a2) {
  case 0:
    a1[32] = *a3;
    return 0;
  case 1:
    *a3 = a1[32];
    return 0;
  case 3:
    *a3 = a1[3];
    return 0;
  case 6:
  case 8:
    a1[31] = *a3;
    return 0;
  case 7:
  case 9:
    *a3 = a1[31];
    return 0;
  case 19:
    v4 = *(_DWORD *)(a1[30] + 4 * a1[31]);
    if (v4)
      *a3 = *(_DWORD *)(v4 + 64) * a1[9] / a1[3];
    else
      *a3 = 5 * a1[9] / a1[3];
    return 0;
  case 20:
    v5 = *a3;
    v6 = &a1[5 * *a3];
    v6[35] = a3[1];
    v6[36] = a3[2];
    v6[34] = v5;
    return 0;
  case 22:
    a1[115] = a3[1];
    a1[116] = a3[2];
    a1[114] = *a3;
    return 0;
  case 24:
    a1[9] = *a3;
    return 0;
  case 25:
    *a3 = a1[9];
    return 0;
  case 26:
    if (2 * a1[6] > 0) {
      v7 = 0;
      do
        *(_DWORD *)(a1[21] + 4 * v7++) = 0;
      while (v7 < 2 * a1[6]);
    }
    if (a1[8] + a1[3] + 1 > 0) {
      v8 = 0;
      do
        *(_DWORD *)(a1[14] + 4 * v8++) = 0;
      while (v8 < a1[8] + a1[3] + 1);
    }
    if ((int)a1[3] > 0) {
      v9 = 0;
      do
        *(_DWORD *)(a1[12] + 4 * v9++) = 0;
      while (v9 < a1[3]);
    }
    goto LABEL_25;
  case 36:
    a1[29] = *a3;
    return 0;
  case 37:
    *a3 = a1[29];
    return 0;
  case 100:
    if ((int)a1[5] <= 0)
      goto LABEL_25;
    v10 = 0;
    do {
      a3[v10] = *(_DWORD *)(a1[22] + 4 * v10);
      ++v10;
    } while (v10 < a1[5]);
    result = 0;
    break;
  case 101:
    if ((int)a1[3] <= 0)
      goto LABEL_25;
    v11 = 0;
    do {
      a3[v11] = *(_DWORD *)(a1[15] + 4 * v11);
      ++v11;
    } while (a1[3] > v11);
    result = 0;
    break;
  case 102:
    if ((int)a1[3] <= 0) {
    LABEL_25:
      result = 0;
    } else {
      v12 = 0;
      do {
        a3[v12] = *(_DWORD *)(a1[16] + 4 * v12);
        ++v12;
      } while (v12 < a1[3]);
      result = 0;
    }
    break;
  case 103:
    *a3 = a1[123];
    result = 0;
    break;
  default:
    speex_warning_int("Unknown nb_ctl request: ", a2);
    result = -1;
    break;
  }
  return result;
}

void __cdecl vbr_init(VBRState *a1) {
  VBRState *v1;   // ebx
  int32_t v2;     // xmm0_4
  int v3;         // esi
  long double v4; // [esp+0h] [ebp-28h]
  int v5;         // [esp+10h] [ebp-18h]

  v1 = a1;
  a1->average_energy = 0;
  a1->last_energy = 1065353216;
  a1->accum_sum = 0;
  a1->energy_alpha = 1036831949;
  a1->soft_pitch = 0;
  a1->last_pitch_coef = 0;
  a1->last_quality = 0;
  *((_QWORD *)&v4 + 1) = 0x3FD3333333333333LL;
  *(_QWORD *)&v4 = 0x40B7700000000000LL;
  *(float *)&v2 = (double)pow(v4, v5) * 0.05;
  a1->noise_accum = v2;
  a1->noise_accum_count = 1028443341;
  *(float *)&a1->noise_level = *(float *)&v2 / 0.050000001;
  a1->consec_noise = 0;
  v3 = 5;
  do {
    *(float *)v1->last_log_energy = logf(6000.0);
    v1 = (VBRState *)((char *)v1 + 4);
    --v3;
  } while (v3);
}

long double __cdecl vbr_analysis(VBRState *a1, float *a2, int a3, int a4,
                                 int32_t a5) {
  int v5;          // ecx
  float v6;        // xmm0_4
  VBRState *v7;    // eax
  float v8;        // xmm1_4
  int i;           // edx
  float v10;       // xmm0_4
  float v11;       // xmm6_4
  double v12;      // xmm5_8
  float v13;       // xmm4_4
  int32_t v14;     // esi
  float v15;       // xmm4_4
  float v16;       // xmm0_4
  int32_t v17;     // xmm1_4
  uint32_t v18;    // xmm5_4
  float v19;       // xmm0_4
  double v20;      // xmm1_8
  int32_t v21;     // xmm0_4
  __m128 v22;      // xmm2
  float v23;       // xmm1_4
  double v24;      // xmm0_8
  float v25;       // xmm2_4
  float v26;       // xmm0_4
  float v27;       // xmm2_4
  double v28;      // xmm1_8
  float v29;       // xmm2_4
  VBRState *v30;   // edx
  int v31;         // ecx
  float v33;       // xmm1_4
  double v34;      // xmm0_8
  double v35;      // xmm1_8
  float v36;       // xmm2_4
  double v37;      // xmm1_8
  float *v38;      // eax
  int v39;         // edx
  int v40;         // eax
  float v41;       // xmm0_4
  int32_t v42;     // xmm0_4
  int32_t v43;     // xmm1_4
  uint32_t v44;    // xmm0_4
  __m128 v45;      // xmm0
  double v46;      // xmm0_8
  long double v47; // [esp+0h] [ebp-C8h]
  long double v48; // [esp+0h] [ebp-C8h]
  long double v49; // [esp+0h] [ebp-C8h]
  long double v50; // [esp+0h] [ebp-C8h]
  long double v51; // [esp+0h] [ebp-C8h]
  int v52;         // [esp+10h] [ebp-B8h]
  double v53;      // [esp+10h] [ebp-B8h]
  double v54;      // [esp+10h] [ebp-B8h]
  float v55;       // [esp+1Ch] [ebp-ACh]
  double v56;      // [esp+78h] [ebp-50h]
  double v57;      // [esp+88h] [ebp-40h]
  float v58;       // [esp+A0h] [ebp-28h]
  float v59;       // [esp+A4h] [ebp-24h]
  float v60;       // [esp+A8h] [ebp-20h]
  float v61;       // [esp+ACh] [ebp-1Ch]
  float v62;       // [esp+B0h] [ebp-18h]
  float v63;       // [esp+B4h] [ebp-14h]
  double v64;      // [esp+B8h] [ebp-10h]

  v5 = a3 >> 1;
  if (a3 >> 1 > 0) {
    v40 = 0;
    v59 = 0.0;
    do {
      v59 = (float)(a2[v40] * a2[v40]) + v59;
      ++v40;
    } while (v5 != v40);
  } else {
    v59 = 0.0;
  }
  if (v5 < a3) {
    v38 = &a2[v5];
    v60 = 0.0;
    v39 = 0;
    do {
      v6 = (float)(*v38 * *v38) + v60;
      v60 = v6;
      ++v39;
      ++v38;
    } while (v39 != a3 - v5);
  } else {
    v60 = 0.0;
    v6 = 0.0;
  }
  v58 = v6 + v59;
  v61 = logf((float)(v6 + v59) + 6000.0);
  v7 = a1;
  v8 = 0.0;
  for (i = 0; i != 5; ++i) {
    v8 = v8 + (float)((float)(v61 - *(float *)v7->last_log_energy) *
                      (float)(v61 - *(float *)v7->last_log_energy));
    v7 = (VBRState *)((char *)v7 + 4);
  }
  v57 = *(float *)&a5;
  v10 = (*(float *)&a5 - 0.4) * 3.0 * fabs(*(float *)&a5 - 0.4);
  v62 = v10;
  *(float *)&a1->average_energy =
      (float)((float)(1.0 - *(float *)&a1->energy_alpha) *
              *(float *)&a1->average_energy) +
      (float)(*(float *)&a1->energy_alpha * v58);
  *(float *)&a1->noise_level =
      *(float *)&a1->noise_accum / *(float *)&a1->noise_accum_count;
  *((_QWORD *)&v47 + 1) = 0x3FD3333333333333LL;
  *(double *)&v47 = v58;
  v11 = pow(v47, v52);
  v12 = *(float *)&a1->noise_accum_count;
  v13 = fminf(1.0, v8 / 150.0);
  if (v12 < 0.06 && v58 > 6000.0) {
    *(float *)&v42 = v11 * 0.05;
    a1->noise_accum = v42;
  }
  if ((v62 >= 0.3 ||
       (v13 >= 0.2 || *(float *)&a1->noise_level * 1.2 <= v11) &&
           (v13 >= 0.05 || *(float *)&a1->noise_level * 1.5 <= v11)) &&
      (v62 >= 0.4 || v13 >= 0.05 || *(float *)&a1->noise_level * 1.2 <= v11) &&
      (v62 >= 0.0 || v13 >= 0.05)) {
    v14 = 0;
    a1->consec_noise = 0;
    v15 = *(float *)&a1->noise_level;
  LABEL_42:
    if (v15 <= v11)
      goto LABEL_15;
    goto LABEL_43;
  }
  v14 = a1->consec_noise + 1;
  a1->consec_noise = v14;
  v15 = *(float *)&a1->noise_level;
  v16 = fminf(v15 * 3.0, v11);
  if (v14 <= 3)
    goto LABEL_42;
  *(float *)&v17 = *(float *)&a1->noise_accum * 0.95 + v16 * 0.05;
  a1->noise_accum = v17;
  *(float *)&v18 = v12 * 0.95 + 0.05;
  a1->noise_accum_count = v18;
  if (v15 <= v11)
    goto LABEL_15;
LABEL_43:
  if (v58 <= 6000.0) {
    v19 = v58;
    if (v58 < 30000.0)
      goto LABEL_16;
  LABEL_45:
    v63 = logf((float)(v19 + 1.0) / (float)(*(float *)&a1->last_energy + 1.0));
    v55 =
        logf((float)(v19 + 1.0) / (float)(*(float *)&a1->average_energy + 1.0));
    v33 = v55;
    if (v55 < -5.0) {
      v34 = 7.0;
      v35 = -5.0;
      goto LABEL_47;
    }
    if (v55 <= 2.0) {
      if (v55 <= 0.0) {
        v36 = 7.0;
        goto LABEL_74;
      }
      v46 = v55;
    } else {
      v33 = 2.0;
      v46 = 2.0;
    }
    v36 = v46 * 0.6 + 7.0;
  LABEL_74:
    if (v33 >= 0.0)
      goto LABEL_48;
    v34 = v36;
    v35 = v33;
  LABEL_47:
    v36 = v34 + v35 * 0.5;
  LABEL_48:
    if (v63 > 0.0) {
      if (v63 <= 5.0)
        v37 = v63;
      else
        v37 = 5.0;
      v36 = v36 + v37 * 0.5;
    }
    if (v60 > v59 * 1.6)
      v36 = v36 + 0.5;
    v20 = v36;
    goto LABEL_18;
  }
  *(float *)&v43 = *(float *)&a1->noise_accum * 0.95 + v11 * 0.05;
  a1->noise_accum = v43;
  *(float *)&v44 = *(float *)&a1->noise_accum_count * 0.95 + 0.05;
  a1->noise_accum_count = v44;
LABEL_15:
  v19 = v58;
  if (v58 >= 30000.0)
    goto LABEL_45;
LABEL_16:
  if (v19 >= 10000.0) {
    v20 = 6.300000190734863;
    if (v58 >= 3000.0)
      goto LABEL_18;
  } else {
    v20 = 5.600000381469727;
    if (v58 >= 3000.0)
      goto LABEL_18;
  }
  v41 = v20 - 0.7;
  v20 = v41;
LABEL_18:
  *(float *)&a1->last_energy = v58;
  v22 = (__m128)0x3FD999999999999AuLL;
  *(double *)v22.i64 = 0.4 * v57;
  *(float *)&v21 = *(float *)&a1->soft_pitch * 0.6 + 0.4 * v57;
  a1->soft_pitch = v21;
  v22.f32[0] = v20 + (*(float *)&v21 - 0.4 + *(float *)&a5 - 0.4) * 2.2;
  v23 = *(float *)&a1->last_quality;
  if (v23 > v22.f32[0]) {
    v24 = v22.f32[0];
    v22 = (__m128)0x3FE0000000000000uLL;
    v22.f32[0] = v24 * 0.5 + v23 * 0.5;
  }
  if (v22.f32[0] >= 4.0) {
    v45 = _mm_cmplt_ss((__m128)0x41200000u, v22);
    LODWORD(v25) = _mm_andnot_ps(v45, v22).u32[0] | v45.i32[0] & 0x41200000;
    if (v14 <= 2)
      goto LABEL_22;
  LABEL_70:
    v64 = 4.0;
    goto LABEL_24;
  }
  v25 = 4.0;
  if (v14 > 2)
    goto LABEL_70;
LABEL_22:
  if (!v14)
    goto LABEL_25;
  v64 = v25;
LABEL_24:
  *(double *)&v48 = (double)v14 + 3.0;
  v56 = log(v48);
  *(_QWORD *)&v49 = 0x4008000000000000LL;
  v25 = v64 - (v56 - (double)log(v49));
LABEL_25:
  v26 = fmaxf(0.0, v25);
  v27 = v26;
  if (v58 < 60000.0) {
    if (v14 > 2) {
      *(double *)&v48 = (double)v14 + 3.0;
      v54 = log(v48);
      *(_QWORD *)&v51 = 0x4008000000000000LL;
      v27 = (v54 - (double)log(v51)) * -0.5 + v26;
    }
    if (v58 < 10000.0 && v14 > 2) {
      *(double *)&v48 = (double)v14 + 3.0;
      v53 = log(v48);
      *(_QWORD *)&v50 = 0x4008000000000000LL;
      v27 = (v53 - (double)log(v50)) * -0.5 + v27;
    }
    if (v27 < 0.0)
      v28 = 0.0;
    else
      v28 = v27;
    *(double *)&v48 = v58 / 60000.0;
    v27 = v28 + (double)log(v48) * 0.3;
  }
  v29 = fmaxf(-1.0, v27);
  a1->last_pitch_coef = a5;
  *(float *)&a1->last_quality = v29;
  v30 = a1;
  v31 = 4;
  do {
    *(_DWORD *)&v30->last_log_energy[16] = *(_DWORD *)&v30->last_log_energy[12];
    v30 = (VBRState *)((char *)v30 - 4);
    --v31;
  } while (v31);
  *(float *)a1->last_log_energy = v61;
  return v29;
}

void vbr_destroy() { ; }

int __cdecl speex_inband_handler(SpeexBits *a1, SpeexCallback *a2, void *a3) {
  int v3;                                            // edx
  SpeexCallback *v4;                                 // eax
  int(__cdecl * func)(SpeexBits *, void *, int32_t); // ecx
  int v7;                                            // ecx

  v3 = speex_bits_unpack_unsigned(a1, 4);
  v4 = &a2[v3];
  func = (int(__cdecl *)(SpeexBits *, void *, int32_t))v4->func;
  if (func)
    return func(a1, a3, v4->data);
  if (v3 <= 1) {
    v7 = 1;
  } else if (v3 <= 7) {
    v7 = 4;
  } else if (v3 > 9) {
    if (v3 <= 11) {
      v7 = 16;
    } else {
      v7 = 32;
      if (v3 > 13)
        v7 = 64;
    }
  } else {
    v7 = 8;
  }
  speex_bits_advance(a1, v7);
  return 0;
}

int __cdecl speex_default_user_handler(SpeexBits *a1) {
  int v1; // eax

  v1 = speex_bits_unpack_unsigned(a1, 4);
  speex_bits_advance(a1, 8 * v1 + 5);
  return 0;
}

int __cdecl scal_quant(float a1, const float *a2, int a3) {
  int result; // eax

  if (a3 - 1 <= 0 || a1 <= *a2)
    return 0;
  result = 0;
  do
    ++result;
  while (result != a3 - 1 && a1 > a2[result]);
  return result;
}

void __cdecl vq_nbest(float *a1, const float *a2, int a3, int a4, float *a5,
                      int a6, int *a7, float *a8) {
  float v8;         // xmm1_4
  float v9;         // xmm2_4
  float *v10;       // ebx
  int v11;          // edx
  int v12;          // ecx
  int v13;          // edi
  int v14;          // eax
  int v15;          // eax
  const float *v16; // esi
  float *v17;       // [esp+0h] [ebp-28h]
  int i;            // [esp+Ch] [ebp-1Ch]
  int v19;          // [esp+10h] [ebp-18h]
  int v20;          // [esp+14h] [ebp-14h]
  int v21;          // [esp+18h] [ebp-10h]

  if (a4 > 0) {
    v19 = a6 - 1;
    v21 = a6 - 1;
    v20 = 0;
    for (i = 0; i != a4; ++i) {
      if (a3 > 0) {
        v15 = 0;
        v8 = 0.0;
        v16 = a2;
        do {
          v8 = v8 + (float)(a1[v15] * *v16++);
          a2 = v16;
          ++v15;
        } while (a3 != v15);
      } else {
        v8 = 0.0;
      }
      v9 = (float)(a5[i] * 0.5) - v8;
      if (i < a6 || a8[a6 - 1] > v9) {
        if (v19 <= 0) {
          v14 = 4 * (a6 - 1);
        } else {
          v10 = &a8[v21 - 1];
          v17 = &a8[v21];
          v11 = a6 - 1;
          v12 = a6 - 1;
          v13 = 0;
          while (1) {
            if (v20 >= v12) {
              v14 = v11 * 4;
              if (*(v17 - 1) <= v9)
                break;
            }
            a8[v11] = *v10;
            a7[v11] = a7[v11 - 1];
            --v12;
            ++v13;
            --v10;
            --v17;
            --v11;
            if (v13 == v19) {
              v14 = 4 * v12;
              break;
            }
          }
        }
        *(float *)((char *)a8 + v14) = v9;
        *(int *)((char *)a7 + v14) = i;
        ++v20;
      }
    }
  }
}

int __cdecl vq_nbest_sign(float *a1, const float *a2, int a3, int a4, float *a5,
                          int a6, int *a7, float *a8) {
  int result;       // eax
  float v9;         // xmm1_4
  float v10;        // xmm2_4
  float *v11;       // ebx
  int v12;          // edx
  int v13;          // ecx
  int v14;          // edi
  int v15;          // eax
  int v16;          // eax
  const float *v17; // esi
  float *v18;       // [esp+0h] [ebp-2Ch]
  int v19;          // [esp+Ch] [ebp-20h]
  int v20;          // [esp+10h] [ebp-1Ch]
  int v21;          // [esp+14h] [ebp-18h]
  int v22;          // [esp+18h] [ebp-14h]
  int v23;          // [esp+1Ch] [ebp-10h]

  result = a4;
  if (a4 > 0) {
    v23 = a6 - 1;
    v22 = a6 - 1;
    v21 = 0;
    v19 = 0;
    while (a3 > 0) {
      v16 = 0;
      v9 = 0.0;
      v17 = a2;
      do {
        v9 = v9 + (float)(a1[v16] * *v17++);
        a2 = v17;
        ++v16;
      } while (a3 != v16);
      if (v9 <= 0.0)
        goto LABEL_5;
      v9 = -v9;
      v20 = 0;
    LABEL_6:
      v10 = (float)(a5[v19] * 0.5) + v9;
      if (v19 < a6 || a8[a6 - 1] > v10) {
        if (v23 <= 0) {
          v15 = 4 * (a6 - 1);
        } else {
          v11 = &a8[v22 - 1];
          v18 = &a8[v22];
          v12 = a6 - 1;
          v13 = a6 - 1;
          v14 = 0;
          while (1) {
            if (v21 >= v13) {
              v15 = v12 * 4;
              if (*(v18 - 1) <= v10)
                break;
            }
            a8[v12] = *v11;
            a7[v12] = a7[v12 - 1];
            --v13;
            ++v14;
            --v11;
            --v18;
            --v12;
            if (v23 == v14) {
              v15 = 4 * v13;
              break;
            }
          }
        }
        *(float *)((char *)a8 + v15) = v10;
        *(int *)((char *)a7 + v15) = v19;
        ++v21;
        if (v20)
          *(int *)((char *)a7 + v15) = v19 + a4;
      }
      result = ++v19;
      if (a4 == v19)
        return result;
    }
    v9 = 0.0;
  LABEL_5:
    v20 = 1;
    goto LABEL_6;
  }
  return result;
}

int __cdecl lsp_to_lpc(float *a1, float *a2, int a3, char *a4) {
  int v4;     // ebx
  char *v5;   // eax
  int v6;     // esi
  int v7;     // ecx
  int i;      // edx
  int result; // eax
  int v10;    // edi
  int j;      // edx
  float v12;  // xmm0_4
  float v13;  // xmm0_4
  float v14;  // xmm3_4
  float v15;  // xmm4_4
  int v16;    // esi
  float *v17; // edx
  int v18;    // ecx
  float *v19; // eax
  float v20;  // xmm1_4
  float v21;  // xmm0_4

  v4 = a3 >> 1;
  v5 = &a4[-(int)a4 & 3];
  v6 = (int)&v5[16 * (a3 >> 1) + 8];
  v7 = 4 * (a3 >> 1) + 1;
  if (v7 >= 0) {
    for (i = 0; i <= v7; ++i) {
      *(_DWORD *)v5 = 0;
      v5 += 4;
    }
  }
  result = -v6 & 3;
  v10 = v6 + result;
  if (a3 <= 0) {
    if (a3)
      return result;
  } else {
    for (j = 0; j != a3; ++j) {
      while (1) {
        v12 = a1[j];
        if (v12 >= 1.5707963268)
          break;
        *(float *)(v10 + 4 * j++) =
            (float)((float)((float)((float)((float)((float)(v12 * v12) *
                                                    -0.0012712094) +
                                            0.041487746) *
                                    (float)(v12 * v12)) -
                            0.49991244) *
                    (float)(v12 * v12)) +
            0.99999332;
        if (a3 == j)
          goto LABEL_9;
      }
      v13 = 3.141592653589793 - v12;
      *(float *)(v10 + 4 * j) =
          -(float)((float)((float)((float)((float)((float)((float)(v13 * v13) *
                                                           -0.0012712094) +
                                                   0.041487746) *
                                           (float)(v13 * v13)) -
                                   0.49991244) *
                           (float)(v13 * v13)) +
                   0.99999332);
    }
  }
LABEL_9:
  result = 0;
  v14 = 1.0;
  v15 = 1.0;
  v16 = 0;
  while (1) {
    if (v4 > 0) {
      v17 = (float *)&a4[-(int)a4 & 3];
      v18 = 0;
      do {
        v19 = (float *)(v10 + 8 * v18);
        v20 = (float)((float)((float)(*v19 * -2.0) * *v17) + v14) + v17[1];
        v21 = (float)((float)((float)(v19[1] * -2.0) * v17[2]) + v15) + v17[3];
        v17[1] = *v17;
        v17[3] = v17[2];
        *v17 = v14;
        v17[2] = v15;
        ++v18;
        v17 += 4;
        v15 = v21;
        v14 = v20;
      } while (v4 != v18);
      result = (int)(v17 - 1);
    }
    if (v16 > 0)
      a2[v16 - 1] = (float)((float)(v14 + *(float *)(result + 4)) +
                            (float)(v15 - *(float *)(result + 8))) *
                    0.5;
    *(float *)(result + 4) = v14;
    *(float *)(result + 8) = v15;
    if (a3 < ++v16)
      break;
    v14 = 0.0;
    v15 = 0.0;
  }
  return result;
}

float *__cdecl lsp_enforce_margin(float *a1, int a2, float a3) {
  float *result; // eax
  double v4;     // xmm4_8
  double v5;     // xmm1_8
  float v6;      // xmm1_4
  int v7;        // edx
  float v8;      // xmm2_4
  float v9;      // xmm3_4
  float v10;     // xmm0_4
  float v11;     // xmm2_4

  if (a3 > *a1)
    *a1 = a3;
  result = &a1[a2];
  v4 = a3;
  v5 = 3.141592653589793 - a3;
  if (*(result - 1) > v5) {
    v6 = v5;
    *(result - 1) = v6;
  }
  if (a2 - 1 > 1) {
    v7 = 1;
    result = a1 + 1;
    do {
      v11 = *(result - 1);
      if (v11 + v4 > *result) {
        v8 = v11 + a3;
        *result = v8;
      } else {
        v8 = *result;
      }
      v9 = result[1];
      if (v8 > v9 - v4) {
        v10 = ((float)(v8 + v9) - v4) * 0.5;
        *result = v10;
      }
      ++v7;
      ++result;
    } while (v7 != a2 - 1);
  }
  return result;
}

void __cdecl lsp_interpolate(float *a1, float *a2, float *a3, int a4, int a5,
                             int a6) {
  int i; // edx

  if (a4 > 0) {
    for (i = 0; i != a4; ++i)
      a3[i] =
          (float)((float)(1.0 - (float)((float)((float)a5 + 1.0) / (float)a6)) *
                  a1[i]) +
          (float)((float)((float)((float)a5 + 1.0) / (float)a6) * a2[i]);
  }
}

int __cdecl lpc_to_lsp(float *a1, int a2, float *a3, int a4, float a5,
                       char *a6) {
  int v6;       // edi
  int v7;       // ebx
  float *v8;    // ecx
  int v9;       // ebx
  float *i;     // esi
  int v11;      // eax
  float *v12;   // edx
  float *v13;   // edx
  float *v14;   // eax
  int v15;      // ecx
  int v16;      // esi
  __int128 v17; // xmm4
  __int128 v18; // xmm5
  __int128 v19; // xmm6
  char *j;      // edx
  char *v21;    // eax
  float *v22;   // eax
  float v23;    // xmm3_4
  float *v24;   // ecx
  int v25;      // ebx
  float *v26;   // edx
  float v27;    // xmm0_4
  float v28;    // xmm1_4
  float v29;    // xmm1_4
  float *v30;   // ecx
  int v31;      // ebx
  float *v32;   // edx
  float v33;    // xmm0_4
  int k;        // edi
  float v35;    // xmm1_4
  float *v36;   // ecx
  int v37;      // ebx
  float *v38;   // edx
  float v39;    // xmm0_4
  char *v41;    // [esp+1Ch] [ebp-6Ch]
  float *v42;   // [esp+48h] [ebp-40h]
  char *v43;    // [esp+4Ch] [ebp-3Ch]
  int v44;      // [esp+50h] [ebp-38h]
  int v45;      // [esp+5Ch] [ebp-2Ch]
  float *v46;   // [esp+60h] [ebp-28h]
  char *v47;    // [esp+68h] [ebp-20h]
  int v48;      // [esp+6Ch] [ebp-1Ch]

  v6 = a2 / 2;
  v7 = 4 * (a2 / 2);
  v48 = (int)&a6[((4 - (_BYTE)a6) & 3) + 8 + v7 +
                 (-(char)(((4 - (_BYTE)a6) & 3) + (_BYTE)a6 + v7) & 3) + v7];
  v41 = (char *)(v48 - v7);
  *(_DWORD *)(v48 - v7 - 4) = 1065353216;
  *(_DWORD *)&a6[(4 - (_BYTE)a6) & 3] = 1065353216;
  if (a2 / 2 > 0) {
    v8 = &a1[a2];
    v9 = 0;
    for (i = a1;; i = a1) {
      v11 = 4 * v9;
      v12 = &i[v9];
      *(float *)&v41[v11] =
          (float)(*v12 + *(v8 - 1)) - *(float *)&v41[4 * v9 - 4];
      v43 = &a6[((4 - (_BYTE)a6) & 3) + 4];
      *(float *)&v43[v11] =
          (float)(*v12 - *--v8) + *(float *)&v43[4 * v9++ - 4];
      if (v6 == v9)
        break;
    }
    v13 = (float *)(v41 - 4);
    v14 = (float *)&a6[(4 - (_BYTE)a6) & 3];
    v15 = 0;
    do {
      *v13 = *v13 + *v13;
      *v14 = *v14 + *v14;
      ++v13;
      ++v14;
      ++v15;
    } while (v6 != v15);
  }
  if (a2 <= 0)
    return 0;
  v16 = a2 >> 1;
  v42 = (float *)(v48 + (-v48 & 3) + 4);
  v47 = (char *)(v48 + (-v48 & 3));
  LODWORD(v17) = 0;
  LODWORD(v18) = 0;
  v19 = 0x3F800000u;
  v44 = 0;
  v45 = 0;
  for (j = v47;; j = (char *)(v48 + (-v48 & 3))) {
    v21 = &a6[(4 - (_BYTE)a6) & 3];
    if ((v44 & 1) == 0)
      v21 = v41 - 4;
    *(_DWORD *)j = 1065353216;
    *(_DWORD *)v42 = v19;
    v22 = (float *)&v21[4 * (a2 >> 1)];
    v46 = v22 - 1;
    v23 = (float)(*(float *)&v19 * *(v22 - 1)) + *v22;
    if (v16 > 1) {
      v24 = v22;
      v25 = 2;
      v26 = (float *)(v47 + 8);
      do {
        v27 = (float)((float)(*(float *)&v19 + *(float *)&v19) * *(v26 - 1)) -
              *(v26 - 2);
        *v26 = v27;
        v23 = v23 + (float)(v27 * *(v24 - 2));
        ++v25;
        ++v26;
        --v24;
      } while (v25 <= v16);
    }
    if (*(float *)&v17 >= -1.0)
      break;
  LABEL_32:
    if (a2 == ++v44)
      return v45;
  LABEL_33:;
  }
  while (1) {
    v28 = (*(float *)&v19 * (*(float *)&v19 * -0.9) + 1.0) * a5;
    if (fabs(v23) < 0.2)
      v28 = v28 * 0.5;
    v17 = v19;
    *(float *)&v17 = *(float *)&v19 - v28;
    *(_DWORD *)v47 = 1065353216;
    *v42 = *(float *)&v19 - v28;
    v29 = (float)((float)(*(float *)&v19 - v28) * *v46) + *v22;
    if (v16 > 1) {
      v30 = v22;
      v31 = 2;
      v32 = (float *)(v47 + 8);
      do {
        v33 = (float)((float)(*(float *)&v17 + *(float *)&v17) * *(v32 - 1)) -
              *(v32 - 2);
        *v32 = v33;
        v29 = v29 + (float)(v33 * *(v30 - 2));
        ++v31;
        ++v32;
        --v30;
      } while (v31 <= v16);
    }
    if ((float)(v29 * v23) < 0.0) {
      ++v45;
      if (a4 >= 0) {
        for (k = 0; k <= a4; ++k) {
          v18 = v19;
          *(float *)&v18 = (float)(*(float *)&v19 + *(float *)&v17) * 0.5;
          *(_DWORD *)v47 = 1065353216;
          *(_DWORD *)v42 = v18;
          v35 = (float)(*(float *)&v18 * *v46) + *v22;
          if (v16 > 1) {
            v36 = v22;
            v37 = 2;
            v38 = (float *)(v47 + 8);
            do {
              v39 = (float)((float)(*(float *)&v18 + *(float *)&v18) *
                            *(v38 - 1)) -
                    *(v38 - 2);
              *v38 = v39;
              v35 = v35 + (float)(v39 * *(v36 - 2));
              ++v37;
              ++v38;
              --v36;
            } while (v37 <= v16);
          }
          if ((float)(v35 * v23) < 0.0) {
            *(float *)&v17 = (float)(*(float *)&v19 + *(float *)&v17) * 0.5;
          } else {
            v19 = v18;
            v23 = v35;
          }
        }
      }
      a3[v44] = acosf(*(float *)&v18);
      v19 = (unsigned int)v18;
      goto LABEL_32;
    }
    if (*(float *)&v17 < -1.0)
      break;
    v19 = v17;
    v23 = v29;
  }
  v19 = v17;
  if (a2 != ++v44)
    goto LABEL_33;
  return v45;
}

long double __cdecl _spx_lpc(float *a1, float *a2, int a3) {
  float v3;         // xmm3_4
  int i;            // eax
  const float *v6;  // ecx
  float *v7;        // edi
  int v8;           // esi
  float v9;         // xmm2_4
  float *v10;       // eax
  int j;            // edx
  float v12;        // xmm2_4
  int v13;          // ebx
  float *v14;       // eax
  int v15;          // ecx
  float *v16;       // edx
  float v17;        // xmm1_4
  const float *v18; // [esp+4h] [ebp-10h]

  v3 = *a2;
  if (*a2 == 0.0) {
    if (a3 > 0) {
      for (i = 0; i != a3; ++i)
        a1[i] = 0.0;
    }
    return 0.0;
  } else if (a3 > 0) {
    v6 = a2;
    v18 = a2;
    v7 = a1;
    v8 = 0;
    while (1) {
      v9 = -v6[1];
      if (v8 > 0) {
        v10 = (float *)v6;
        for (j = 0; j != v8; ++j)
          v9 = v9 - (float)(a1[j] * *v10--);
      }
      v12 = v9 / (v3 + *a2 * 0.003);
      *v7 = v12;
      v13 = v8 >> 1;
      if (v8 >> 1 > 0) {
        v14 = v7;
        v15 = 0;
        v16 = a1;
        do {
          v17 = *v16;
          *v16 = (float)(v12 * *(v14 - 1)) + *v16;
          *(v14 - 1) = (float)(v17 * v12) + *(v14 - 1);
          ++v15;
          ++v16;
          --v14;
        } while (v13 != v15);
      } else {
        v13 = 0;
      }
      if ((v8 & 1) != 0)
        a1[v13] = a1[v13] + (float)(v12 * a1[v13]);
      v3 = v3 - (float)(v12 * (float)(v3 * v12));
      ++v8;
      ++v18;
      ++v7;
      if (a3 == v8)
        break;
      v6 = v18;
    }
  }
  return v3;
}

float *__cdecl _spx_autocorr(const float *a1, float *a2, int a3, int a4) {
  int v4;           // ebx
  float *v5;        // esi
  int v6;           // ecx
  float *v7;        // edx
  float v8;         // xmm1_4
  int v9;           // eax
  float *result;    // eax
  const float *v11; // [esp+0h] [ebp-14h]

  v4 = a3 - 1;
  if (a3) {
    v5 = &a2[v4];
    v11 = &a1[v4];
    v6 = a4 - v4;
    do {
      while (v4 >= a4) {
        *v5 = 0.0;
        --v4;
        --v5;
        --v11;
        ++v6;
        if (v4 == -1)
          goto LABEL_8;
      }
      v7 = (float *)v11;
      v8 = 0.0;
      v9 = 0;
      do
        v8 = v8 + (float)(*v7++ * a1[v9++]);
      while (v9 != v6);
      *v5 = v8;
      --v4;
      --v5;
      --v11;
      ++v6;
    } while (v4 != -1);
  }
LABEL_8:
  result = a2;
  *a2 = *a2 + 10.0;
  return result;
}

int __cdecl DSOUNDRecord_Start(dsound_sample_t *a1) {
  if (!g_recording_initialized || !sAudioRecorder)
    return -1;
  if ((unsigned __int8)CAudioRecorder::Start(sAudioRecorder)) {
    g_current_sample = (int)a1;
    g_currently_recording = 1;
    return 0;
  } else {
    Com_Printf("error: Unable to Read to Buffer\n");
    return -1;
  }
}

int DSOUNDRecord_Stop() {
  if (!g_recording_initialized || !sAudioRecorder)
    return -1;
  CAudioRecorder::Stop(sAudioRecorder);
  g_current_sample = 0;
  g_currently_recording = 0;
  return 0;
}

int DSOUNDRecord_NewSample(void) {
  int v1; // edx

  if (!g_recording_initialized)
    return 0;
  v1 = s_recordingSamplePtr;
  s_recordingSamplePtr += 36;
  memset((void *)v1, 0, 0x24u);
  *(_DWORD *)(v1 + 8) = g_sound_recordFrequency;
  *(_DWORD *)(v1 + 12) = g_sound_recordVolume;
  *(_DWORD *)(v1 + 16) = 128;
  *(_DWORD *)(v1 + 20) = g_sound_channels;
  *(_BYTE *)(v1 + 32) = 2;
  return v1;
}

_BOOL4 DSOUNDRecord_DestroySample() { return g_recording_initialized != 0; }

int DSOUNDRecord_Init() {
  CAudioRecorder *v0; // esi
  CAudioRecorder *v1; // ebx

  s_recordingSamplePtr = (int)&s_recordingSamples;
  g_recording_initialized = 0;
  v0 = (CAudioRecorder *)operator new(0x78u);
  CAudioRecorder::CAudioRecorder(
      v0, COERCE_UINT64_T((double)(int)g_sound_recordFrequency),
      g_sound_channels, 16);
  sAudioRecorder = v0;
  if ((unsigned __int8)CAudioRecorder::Initialize(v0)) {
    g_recording_initialized = 1;
    return 1;
  } else {
    v1 = sAudioRecorder;
    if (sAudioRecorder) {
      CAudioRecorder::~CAudioRecorder(sAudioRecorder);
      operator delete(v1);
    }
    sAudioRecorder = 0;
    return 0;
  }
}

void DSOUNDRecord_Shutdown(void) {
  CAudioRecorder *v0; // ebx

  if (sAudioRecorder) {
    CAudioRecorder::Shutdown(sAudioRecorder);
    v0 = sAudioRecorder;
    if (sAudioRecorder) {
      CAudioRecorder::~CAudioRecorder(sAudioRecorder);
      operator delete(v0);
    }
    sAudioRecorder = 0;
  }
  g_recording_initialized = 0;
}

void DSOUNDRecord_Frame(void) {
  void *Buffer;       // eax
  _DWORD v1[5];       // [esp+1Ch] [ebp-2Ch] BYREF
  bool v2;            // [esp+30h] [ebp-18h]
  unsigned int v3;    // [esp+34h] [ebp-14h]
  int v4;             // [esp+38h] [ebp-10h]
  unsigned int v5[3]; // [esp+3Ch] [ebp-Ch] BYREF

  if (g_recording_initialized) {
    if (g_currently_recording) {
      if (g_current_sample) {
        Buffer = CAudioRecorder::GetBuffer(sAudioRecorder, v5);
        if (Buffer) {
          if (v5[0]) {
            v2 = (int)g_sound_channels > 1;
            v1[3] = 2;
            v1[4] = g_sound_recordFrequency;
            v4 = 0;
            v3 = g_sound_channels;
            v1[2] = v5[0] / (2 * g_sound_channels);
            v1[1] = v5[0];
            v1[0] = Buffer;
            current_audioCallback(v1);
          }
        }
      }
    }
  }
}

int __cdecl mixerSetRecordLevel(char *a1, unsigned __int16 a2) {
  if (sAudioRecorder)
    CAudioRecorder::SetRecordLevel(sAudioRecorder, (float)a2 / 65535.0);
  return 0;
}

__int16 mixerGetRecordLevel() {
  int v0;            // eax
  float RecordLevel; // [esp+1Ch] [ebp-Ch]

  if (sAudioRecorder) {
    RecordLevel = CAudioRecorder::GetRecordLevel(sAudioRecorder);
    return (int)(RecordLevel * 65535.0);
  } else {
    LOWORD(v0) = -1;
  }
  return v0;
}

int __cdecl mixerGetRecordSource(char *a1) {
  *(_DWORD *)a1 = &unk_63614D;
  return 1;
}

int mixerSetRecordSource() { return 1; }

int __cdecl mixerSetMicrophoneMute(char a1) {
  if (sAudioRecorder)
    CAudioRecorder::Mute(sAudioRecorder, a1 == 0);
  return 0;
}

int __cdecl DSound_UpdateSample(dsound_sample_t *a1, char *__src,
                                unsigned int a3) {
  unsigned int v4[3]; // [esp+1Ch] [ebp-Ch] BYREF

  if (!dsoundplay_initialized)
    return -1;
  if (!a3)
    return 0;
  v4[0] = a3;
  CCircularBuffer::Write((CCircularBuffer *)a1->mssBuffer, __src, v4);
  return a3;
}

int DSound_Init() {
  char v0; // al

  v0 = 1;
  if (dsoundplay_initialized)
    v0 = dsoundplay_initialized;
  dsoundplay_initialized = v0;
  return 1;
}

void DSound_Shutdown(void) { dsoundplay_initialized = 0; }

void DSound_Frame(void) { ; }

const void *__cdecl DSound_SampleFrame(dsound_sample_t *a1) {
  const void *result; // eax
  unsigned int v2[3]; // [esp+1Ch] [ebp-Ch] BYREF

  result = (const void *)AIL_sample_status(a1->mssSample);
  if (result == (const void *)2) {
    result = (const void *)CCircularBuffer::ReadPtrSize(
        (CCircularBuffer *)a1->mssBuffer);
    v2[0] = (unsigned int)result;
    if (result) {
      result = CCircularBuffer::ReadPtr((CCircularBuffer *)a1->mssBuffer, v2);
      if (result) {
        AIL_set_sample_address(a1->mssSample, result, v2[0]);
        return (const void *)AIL_resume_sample(a1->mssSample);
      }
    }
  }
  return result;
}

int __cdecl inflateEnd(z_streamp strm) {
  int32_t state; // eax
  _DWORD *v3;    // edx

  if (!strm)
    return -2;
  state = strm->state;
  if (!state || !strm->zfree)
    return -2;
  v3 = *(_DWORD **)(state + 20);
  if (v3) {
    inflate_blocks_free(v3, (int)strm);
    state = strm->state;
  }
  ((void(__cdecl *)(int32_t, int32_t))strm->zfree)(strm->opaque, state);
  strm->state = 0;
  return 0;
}

int __cdecl inflate(z_streamp strm, int flush) {
  int v2;           // edx
  int32_t state;    // ecx
  int32_t v5;       // eax
  int32_t v6;       // edx
  int32_t v7;       // eax
  int32_t v8;       // edx
  int32_t v9;       // eax
  int32_t v10;      // edx
  int32_t v11;      // eax
  int32_t v12;      // eax
  _DWORD *v13;      // edx
  int32_t v14;      // eax
  int32_t v15;      // edx
  int32_t v16;      // eax
  int32_t v17;      // edx
  int32_t v18;      // eax
  int32_t v19;      // edx
  int32_t v20;      // eax
  int32_t v21;      // eax
  _DWORD *v22;      // edx
  int v23;          // eax
  _DWORD *v24;      // eax
  int32_t avail_in; // eax
  int32_t next_in;  // eax
  int v27;          // edx
  int32_t v28;      // eax
  int v29;          // edx
  _DWORD *v30;      // edi
  _DWORD *v31;      // edx
  char v32;         // [esp+18h] [ebp-20h]

  if (!strm || !strm->state || !strm->next_in)
    return -2;
  v2 = -5;
  while (2) {
    state = strm->state;
    switch (*(_DWORD *)state) {
    case 0:
      avail_in = strm->avail_in;
      if (!avail_in)
        return v2;
      strm->avail_in = avail_in - 1;
      ++strm->total_in;
      next_in = strm->next_in;
      v27 = *(unsigned __int8 *)strm->next_in;
      *(_DWORD *)(state + 4) = v27;
      strm->next_in = next_in + 1;
      if ((v27 & 0xF) != 8) {
        *(_DWORD *)strm->state = 13;
        strm->msg = (int32_t) "unknown compression method";
        *(_DWORD *)(strm->state + 4) = 5;
        v2 = 5 * (flush != 4) - 5;
        continue;
      }
      v31 = (_DWORD *)strm->state;
      if ((unsigned int)((v31[1] >> 4) + 8) > v31[4]) {
        *v31 = 13;
        strm->msg = (int32_t) "invalid window size";
        *(_DWORD *)(strm->state + 4) = 5;
        v2 = 5 * (flush != 4) - 5;
        continue;
      }
      *v31 = 1;
      v2 = 5 * (flush != 4) - 5;
    LABEL_38:
      v28 = strm->avail_in;
      if (!v28)
        return v2;
      strm->avail_in = v28 - 1;
      ++strm->total_in;
      v29 = *(unsigned __int8 *)strm->next_in;
      v32 = *(_BYTE *)strm->next_in++;
      v30 = (_DWORD *)strm->state;
      if (v29 + (v30[1] << 8) != 31 * ((v29 + (v30[1] << 8)) / 0x1Fu)) {
        *v30 = 13;
        strm->msg = (int32_t) "incorrect header check";
        *(_DWORD *)(strm->state + 4) = 5;
        v2 = 5 * (flush != 4) - 5;
        continue;
      }
      if ((v32 & 0x20) == 0) {
        *v30 = 7;
        v2 = 5 * (flush != 4) - 5;
        continue;
      }
      *v30 = 2;
      v2 = 5 * (flush != 4) - 5;
    LABEL_19:
      v14 = strm->avail_in;
      if (v14) {
        strm->avail_in = v14 - 1;
        ++strm->total_in;
        v15 = strm->next_in;
        *(_DWORD *)(strm->state + 8) = *(unsigned __int8 *)strm->next_in << 24;
        strm->next_in = v15 + 1;
        *(_DWORD *)strm->state = 3;
        v2 = 5 * (flush != 4) - 5;
      LABEL_21:
        v16 = strm->avail_in;
        if (v16) {
          strm->avail_in = v16 - 1;
          ++strm->total_in;
          v17 = strm->next_in;
          *(_DWORD *)(strm->state + 8) += *(unsigned __int8 *)strm->next_in
                                          << 16;
          strm->next_in = v17 + 1;
          *(_DWORD *)strm->state = 4;
          v2 = 5 * (flush != 4) - 5;
        LABEL_23:
          v18 = strm->avail_in;
          if (v18) {
            strm->avail_in = v18 - 1;
            ++strm->total_in;
            v19 = strm->next_in;
            *(_DWORD *)(strm->state + 8) += *(unsigned __int8 *)strm->next_in
                                            << 8;
            strm->next_in = v19 + 1;
            *(_DWORD *)strm->state = 5;
            v2 = 5 * (flush != 4) - 5;
          LABEL_25:
            v20 = strm->avail_in;
            if (v20) {
              strm->avail_in = v20 - 1;
              ++strm->total_in;
              v21 = strm->next_in;
              *(_DWORD *)(strm->state + 8) += *(unsigned __int8 *)strm->next_in;
              strm->next_in = v21 + 1;
              v22 = (_DWORD *)strm->state;
              strm->adler = v22[2];
              *v22 = 6;
              return 2;
            }
          }
        }
      }
      return v2;
    case 1:
      goto LABEL_38;
    case 2:
      goto LABEL_19;
    case 3:
      goto LABEL_21;
    case 4:
      goto LABEL_23;
    case 5:
      goto LABEL_25;
    case 6:
      *(_DWORD *)state = 13;
      strm->msg = (int32_t) "need dictionary";
      *(_DWORD *)(strm->state + 4) = 0;
      return -2;
    case 7:
      v23 = inflate_blocks(*(int **)(state + 20), (int)strm, v2);
      v2 = v23;
      if (v23 == -3) {
        *(_DWORD *)strm->state = 13;
        *(_DWORD *)(strm->state + 4) = 0;
      } else {
        if (!v23)
          v2 = 5 * (flush != 4) - 5;
        if (v2 != 1)
          return v2;
        inflate_blocks_reset(*(_DWORD **)(strm->state + 20), (int)strm,
                             (_DWORD *)(strm->state + 4));
        v24 = (_DWORD *)strm->state;
        if (v24[3]) {
          *v24 = 12;
          v2 = 5 * (flush != 4) - 5;
        } else {
          *v24 = 8;
          v2 = 5 * (flush != 4) - 5;
        LABEL_9:
          v5 = strm->avail_in;
          if (!v5)
            return v2;
          strm->avail_in = v5 - 1;
          ++strm->total_in;
          v6 = strm->next_in;
          *(_DWORD *)(strm->state + 8) = *(unsigned __int8 *)strm->next_in
                                         << 24;
          strm->next_in = v6 + 1;
          *(_DWORD *)strm->state = 9;
          v2 = 5 * (flush != 4) - 5;
        LABEL_11:
          v7 = strm->avail_in;
          if (!v7)
            return v2;
          strm->avail_in = v7 - 1;
          ++strm->total_in;
          v8 = strm->next_in;
          *(_DWORD *)(strm->state + 8) += *(unsigned __int8 *)strm->next_in
                                          << 16;
          strm->next_in = v8 + 1;
          *(_DWORD *)strm->state = 10;
          v2 = 5 * (flush != 4) - 5;
        LABEL_13:
          v9 = strm->avail_in;
          if (!v9)
            return v2;
          strm->avail_in = v9 - 1;
          ++strm->total_in;
          v10 = strm->next_in;
          *(_DWORD *)(strm->state + 8) += *(unsigned __int8 *)strm->next_in
                                          << 8;
          strm->next_in = v10 + 1;
          *(_DWORD *)strm->state = 11;
          v2 = 5 * (flush != 4) - 5;
        LABEL_15:
          v11 = strm->avail_in;
          if (!v11)
            return v2;
          strm->avail_in = v11 - 1;
          ++strm->total_in;
          v12 = strm->next_in;
          *(_DWORD *)(strm->state + 8) += *(unsigned __int8 *)strm->next_in;
          strm->next_in = v12 + 1;
          v13 = (_DWORD *)strm->state;
          if (v13[1] == v13[2]) {
            *v13 = 12;
            return 1;
          }
          *v13 = 13;
          strm->msg = (int32_t) "incorrect data check";
          *(_DWORD *)(strm->state + 4) = 5;
          v2 = 5 * (flush != 4) - 5;
        }
      }
      continue;
    case 8:
      goto LABEL_9;
    case 9:
      goto LABEL_11;
    case 0xA:
      goto LABEL_13;
    case 0xB:
      goto LABEL_15;
    case 0xC:
      return 1;
    case 0xD:
      return -3;
    default:
      return -2;
    }
  }
}

int __cdecl inflateInit2_(z_streamp strm, int windowBits, const char *version,
                          int stream_size) {
  int32_t v5;                                      // eax
  int32_t state;                                   // esi
  uLong(__cdecl * v7)(uLong, const Bytef *, uInt); // edx
  _DWORD *v8;                                      // eax
  int32_t v9;                                      // eax
  _DWORD *v10;                                     // edx
  int32_t v11;                                     // eax
  _DWORD *v12;                                     // edx

  if (!version || *version != 49 || stream_size != 56)
    return -6;
  if (!strm)
    return -2;
  strm->msg = 0;
  if (!strm->zalloc) {
    strm->zalloc = (int32_t)zcalloc;
    strm->opaque = 0;
  }
  if (!strm->zfree)
    strm->zfree = (int32_t)zcfree;
  v5 = ((int(__cdecl *)(int32_t, int, int))strm->zalloc)(strm->opaque, 1, 24);
  strm->state = v5;
  if (!v5)
    return -4;
  *(_DWORD *)(v5 + 20) = 0;
  *(_DWORD *)(strm->state + 12) = 0;
  if (windowBits < 0) {
    windowBits = -windowBits;
    *(_DWORD *)(strm->state + 12) = 1;
  }
  if ((unsigned int)(windowBits - 8) <= 7) {
    *(_DWORD *)(strm->state + 16) = windowBits;
    state = strm->state;
    if (*(_DWORD *)(state + 12))
      v7 = 0;
    else
      v7 = adler32;
    v8 = inflate_blocks_new(
        (int)strm, (int(__cdecl *)(_DWORD, _DWORD, _DWORD))v7, 1 << windowBits);
    *(_DWORD *)(state + 20) = v8;
    if (v8) {
      if (strm->state) {
        strm->total_out = 0;
        strm->total_in = 0;
        strm->msg = 0;
        *(_DWORD *)strm->state = *(_DWORD *)(strm->state + 12) != 0 ? 7 : 0;
        inflate_blocks_reset(*(_DWORD **)(strm->state + 20), (int)strm, 0);
      }
      return 0;
    }
    v9 = strm->state;
    if (v9 && strm->zfree) {
      v10 = *(_DWORD **)(v9 + 20);
      if (v10) {
        inflate_blocks_free(v10, (int)strm);
        v9 = strm->state;
      }
      ((void(__cdecl *)(int32_t, int32_t))strm->zfree)(strm->opaque, v9);
      strm->state = 0;
      return -4;
    }
    return -4;
  }
  v11 = strm->state;
  if (!v11 || !strm->zfree)
    return -2;
  v12 = *(_DWORD **)(v11 + 20);
  if (v12) {
    inflate_blocks_free(v12, (int)strm);
    v11 = strm->state;
  }
  ((void(__cdecl *)(int32_t, int32_t))strm->zfree)(strm->opaque, v11);
  strm->state = 0;
  return -2;
}

_DWORD *__cdecl jpeg_CreateCompress(_DWORD *__b, int a2, int a3) {
  int v3;         // esi
  int v4;         // edi
  _DWORD *v5;     // eax
  int v6;         // edx
  _DWORD *result; // eax
  int v8;         // edx
  int v9;         // [esp+18h] [ebp-20h]
  int v10;        // [esp+1Ch] [ebp-1Ch]

  __b[1] = 0;
  if (a2 != 62) {
    *(_DWORD *)(*__b + 20) = 12;
    *(_DWORD *)(*__b + 24) = 62;
    *(_DWORD *)(*__b + 28) = a2;
    (*(void(__cdecl **)(_DWORD *)) * __b)(__b);
  }
  if (a3 != 364) {
    *(_DWORD *)(*__b + 20) = 21;
    *(_DWORD *)(*__b + 24) = 364;
    *(_DWORD *)(*__b + 28) = a3;
    (*(void(__cdecl **)(_DWORD *)) * __b)(__b);
  }
  v3 = *__b;
  v4 = __b[3];
  v9 = __b[6];
  v10 = __b[7];
  memset(__b, 0, 0x16Cu);
  *__b = v3;
  __b[3] = v4;
  __b[6] = v9;
  __b[7] = v10;
  *((_BYTE *)__b + 16) = 0;
  jinit_memory_mgr(__b);
  __b[2] = 0;
  __b[8] = 0;
  __b[18] = 0;
  v5 = __b;
  v6 = 4;
  do {
    v5[19] = 0;
    ++v5;
    --v6;
  } while (v6);
  result = __b;
  v8 = 4;
  do {
    result[23] = 0;
    result[27] = 0;
    ++result;
    --v8;
  } while (v8);
  __b[89] = 0;
  __b[13] = 0;
  __b[14] = 1072693248;
  __b[5] = 100;
  return result;
}

int __cdecl jpeg_destroy_compress(int a1) { return jpeg_destroy(a1); }

int __cdecl jpeg_suppress_tables(int a1, unsigned __int8 a2) {
  int v2;     // edx
  int v3;     // ecx
  int result; // eax
  int v5;     // edx
  int i;      // ecx
  int v7;     // edi
  int v8;     // edi

  v2 = a1;
  v3 = 4;
  do {
    result = *(_DWORD *)(v2 + 76);
    if (result) {
      result = a2;
      *(_BYTE *)(*(_DWORD *)(v2 + 76) + 128) = a2;
    }
    v2 += 4;
    --v3;
  } while (v3);
  v5 = a1;
  for (i = 0; i != 4; ++i) {
    v7 = *(_DWORD *)(v5 + 92);
    if (v7) {
      result = a2;
      *(_BYTE *)(v7 + 273) = a2;
    }
    v8 = *(_DWORD *)(v5 + 108);
    if (v8) {
      result = a2;
      *(_BYTE *)(v8 + 273) = a2;
    }
    v5 += 4;
  }
  return result;
}

int __cdecl jpeg_finish_compress(_DWORD *a1) {
  int v1;          // edx
  int i;           // eax
  unsigned int v3; // edi
  int v4;          // eax

  v1 = a1[5];
  if ((unsigned int)(v1 - 101) <= 1) {
    if (a1[53] < a1[10]) {
      *(_DWORD *)(*a1 + 20) = 67;
      (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
    }
    goto LABEL_12;
  }
  if (v1 != 103) {
    *(_DWORD *)(*a1 + 20) = 20;
    *(_DWORD *)(*a1 + 24) = a1[5];
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  for (i = a1[80]; !*(_BYTE *)(i + 13); i = a1[80]) {
    (*(void(__cdecl **)(_DWORD *))i)(a1);
    if (a1[57]) {
      v3 = 0;
      do {
        while (1) {
          v4 = a1[2];
          if (v4) {
            *(_DWORD *)(v4 + 4) = v3;
            *(_DWORD *)(a1[2] + 8) = a1[57];
            (*(void(__cdecl **)(_DWORD *))a1[2])(a1);
          }
          if (!(*(unsigned __int8(__cdecl **)(_DWORD *, _DWORD))(a1[83] + 4))(
                  a1, 0))
            break;
          if (++v3 >= a1[57])
            goto LABEL_12;
        }
        *(_DWORD *)(*a1 + 20) = 24;
        (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
        ++v3;
      } while (v3 < a1[57]);
    }
  LABEL_12:
    (*(void(__cdecl **)(_DWORD *))(a1[80] + 8))(a1);
  }
  (*(void(__cdecl **)(_DWORD *))(a1[84] + 12))(a1);
  (*(void(__cdecl **)(_DWORD *))(a1[8] + 16))(a1);
  return jpeg_abort((int)a1);
}

_DWORD *__cdecl jpeg_CreateDecompress(_DWORD *__b, int a2, int a3) {
  int v3;         // esi
  int v4;         // edi
  _DWORD *v5;     // eax
  int v6;         // edx
  _DWORD *v7;     // eax
  int v8;         // edx
  _DWORD *result; // eax
  int v10;        // [esp+18h] [ebp-10h]
  int v11;        // [esp+1Ch] [ebp-Ch]

  __b[1] = 0;
  if (a2 != 62) {
    *(_DWORD *)(*__b + 20) = 12;
    *(_DWORD *)(*__b + 24) = 62;
    *(_DWORD *)(*__b + 28) = a2;
    (*(void(__cdecl **)(_DWORD *)) * __b)(__b);
  }
  if (a3 != 436) {
    *(_DWORD *)(*__b + 20) = 21;
    *(_DWORD *)(*__b + 24) = 436;
    *(_DWORD *)(*__b + 28) = a3;
    (*(void(__cdecl **)(_DWORD *)) * __b)(__b);
  }
  v3 = *__b;
  v4 = __b[3];
  v10 = __b[6];
  v11 = __b[7];
  memset(__b, 0, 0x1B4u);
  *__b = v3;
  __b[3] = v4;
  __b[6] = v10;
  __b[7] = v11;
  *((_BYTE *)__b + 16) = 1;
  jinit_memory_mgr(__b);
  __b[2] = 0;
  __b[8] = 0;
  v5 = __b;
  v6 = 4;
  do {
    v5[38] = 0;
    ++v5;
    --v6;
  } while (v6);
  v7 = __b;
  v8 = 4;
  do {
    v7[42] = 0;
    v7[46] = 0;
    ++v7;
    --v8;
  } while (v8);
  __b[69] = 0;
  jinit_marker_reader((int)__b);
  jinit_input_controller((int)__b);
  result = __b;
  __b[5] = 200;
  return result;
}

int __cdecl jpeg_destroy_decompress(int a1) { return jpeg_destroy(a1); }

int __cdecl jpeg_consume_input(int a1) {
  int result; // eax
  int v2;     // eax
  char v3;    // al
  char v4;    // al
  int *v5;    // eax
  int v6;     // ecx
  int v7;     // edi
  _DWORD *v8; // edx
  int v9;     // [esp+1Ch] [ebp-1Ch]

  switch (*(_DWORD *)(a1 + 20)) {
  case 0xC8:
    (*(void(__cdecl **)(int))(*(_DWORD *)(a1 + 408) + 4))(a1);
    (*(void(__cdecl **)(int))(*(_DWORD *)(a1 + 32) + 8))(a1);
    *(_DWORD *)(a1 + 20) = 201;
    goto LABEL_5;
  case 0xC9:
  LABEL_5:
    result = (**(int(__cdecl ***)(int))(a1 + 408))(a1);
    if (result != 1)
      return result;
    v2 = *(_DWORD *)(a1 + 44);
    switch (v2) {
    case 3:
      if (*(_BYTE *)(a1 + 264))
        goto LABEL_28;
      if (*(_BYTE *)(a1 + 272)) {
        v4 = *(_BYTE *)(a1 + 273);
        if (v4) {
          if (v4 != 1) {
            *(_DWORD *)(*(_DWORD *)a1 + 20) = 114;
            *(_DWORD *)(*(_DWORD *)a1 + 24) = *(unsigned __int8 *)(a1 + 273);
            (*(void(__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, -1);
            *(_DWORD *)(a1 + 48) = 3;
          LABEL_24:
            *(_DWORD *)(a1 + 52) = 2;
            break;
          }
        LABEL_28:
          *(_DWORD *)(a1 + 48) = 3;
          goto LABEL_24;
        }
      LABEL_33:
        *(_DWORD *)(a1 + 48) = 2;
        goto LABEL_24;
      }
      v5 = *(int **)(a1 + 204);
      v6 = *v5;
      v9 = v5[21];
      v7 = v5[42];
      if (*v5 == 1) {
        if (v5[21] == 2 && v7 == 3)
          goto LABEL_28;
      } else if (v6 == 82 && v9 == 71 && v7 == 66) {
        goto LABEL_33;
      }
      v8 = (_DWORD *)(*(_DWORD *)a1 + 24);
      *v8 = v6;
      v8[1] = v9;
      v8[2] = v7;
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 111;
      (*(void(__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
      goto LABEL_28;
    case 4:
      if (*(_BYTE *)(a1 + 272) && (v3 = *(_BYTE *)(a1 + 273)) != 0) {
        if (v3 != 2) {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 114;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = *(unsigned __int8 *)(a1 + 273);
          (*(void(__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, -1);
        }
        *(_DWORD *)(a1 + 48) = 5;
      } else {
        *(_DWORD *)(a1 + 48) = 4;
      }
      *(_DWORD *)(a1 + 52) = 4;
      break;
    case 1:
      *(_DWORD *)(a1 + 48) = 1;
      *(_DWORD *)(a1 + 52) = 1;
      break;
    default:
      *(_DWORD *)(a1 + 48) = 0;
      *(_DWORD *)(a1 + 52) = 0;
      break;
    }
    *(_DWORD *)(a1 + 56) = 1;
    *(_DWORD *)(a1 + 60) = 1;
    *(_DWORD *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 68) = 1072693248;
    *(_BYTE *)(a1 + 72) = 0;
    *(_BYTE *)(a1 + 73) = 0;
    *(_DWORD *)(a1 + 76) = 0;
    *(_BYTE *)(a1 + 80) = 1;
    *(_BYTE *)(a1 + 81) = 1;
    *(_BYTE *)(a1 + 82) = 0;
    *(_DWORD *)(a1 + 84) = 2;
    *(_BYTE *)(a1 + 88) = 1;
    *(_DWORD *)(a1 + 92) = 256;
    *(_DWORD *)(a1 + 124) = 0;
    *(_BYTE *)(a1 + 96) = 0;
    *(_BYTE *)(a1 + 97) = 0;
    *(_BYTE *)(a1 + 98) = 0;
    *(_DWORD *)(a1 + 20) = 202;
    return 1;
  case 0xCA:
    return 1;
  case 0xCB:
  case 0xCC:
  case 0xCD:
  case 0xCE:
  case 0xCF:
  case 0xD0:
  case 0xD2:
    return (**(int (***)(void))(a1 + 408))();
  default:
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 20);
    (**(void(__cdecl ***)(int))a1)(a1);
    return 0;
  }
}

int __cdecl jpeg_read_header(_DWORD *a1, char a2) {
  int result; // eax

  if ((unsigned int)(a1[5] - 200) > 1) {
    *(_DWORD *)(*a1 + 20) = 20;
    *(_DWORD *)(*a1 + 24) = a1[5];
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  result = jpeg_consume_input((int)a1);
  if (result == 2) {
    if (a2) {
      *(_DWORD *)(*a1 + 20) = 51;
      (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
    }
    jpeg_abort((int)a1);
    return 2;
  }
  return result;
}

int __cdecl jpeg_finish_decompress(int a1) {
  int v1; // edx
  int v2; // eax

  v1 = *(_DWORD *)(a1 + 20);
  if ((unsigned int)(v1 - 205) > 1 || *(_BYTE *)(a1 + 72)) {
    if (v1 == 207) {
      *(_DWORD *)(a1 + 20) = 210;
    } else if (v1 != 210) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 20);
      (**(void(__cdecl ***)(int))a1)(a1);
    }
  } else {
    if (*(_DWORD *)(a1 + 128) < *(_DWORD *)(a1 + 104)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 67;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    (*(void(__cdecl **)(int))(*(_DWORD *)(a1 + 392) + 4))(a1);
    *(_DWORD *)(a1 + 20) = 210;
  }
  while (1) {
    v2 = *(_DWORD *)(a1 + 408);
    if (*(_BYTE *)(v2 + 17))
      break;
    if (!(*(int(__cdecl **)(int))v2)(a1))
      return 0;
  }
  (*(void(__cdecl **)(int))(*(_DWORD *)(a1 + 32) + 24))(a1);
  jpeg_abort(a1);
  return 1;
}

int __cdecl init_source(int a1) {
  int result; // eax

  result = *(_DWORD *)(a1 + 32);
  *(_BYTE *)(result + 28) = 1;
  return result;
}

_DWORD *__cdecl skip_input_data(int a1, int a2) {
  _DWORD *result; // eax

  result = *(_DWORD **)(a1 + 32);
  if (a2 > 0) {
    *result += a2;
    result[1] -= a2;
  }
  return result;
}

void term_source() { ; }

int __cdecl jpeg_memory_src(int a1, int a2, int a3) {
  _DWORD *v3; // edx
  int result; // eax
  int v5;     // eax

  if (*(_DWORD *)(a1 + 32)) {
    v3 = *(_DWORD **)(a1 + 32);
  } else {
    v5 = (**(int(__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 32);
    *(_DWORD *)(a1 + 32) = v5;
    v3 = (_DWORD *)v5;
  }
  v3[2] = init_source;
  v3[3] = 0;
  v3[4] = skip_input_data;
  v3[5] = jpeg_resync_to_restart;
  v3[6] = term_source;
  v3[1] = a3;
  result = a2;
  *v3 = a2;
  return result;
}

int __cdecl jpeg_start_decompress(int a1) {
  int v1; // eax
  int v3; // edx
  int v4; // eax
  int v5; // eax
  int v6; // ecx

  if (*(_DWORD *)(a1 + 20) == 202) {
    jinit_master_decompress(a1);
    if (*(_BYTE *)(a1 + 72)) {
      *(_DWORD *)(a1 + 20) = 207;
      return 1;
    }
    *(_DWORD *)(a1 + 20) = 203;
  }
  v1 = *(_DWORD *)(a1 + 20);
  if (v1 != 203) {
    if (v1 != 204) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 20);
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    return (unsigned __int8)output_pass_setup(a1);
  }
  if (!*(_BYTE *)(*(_DWORD *)(a1 + 408) + 16)) {
  LABEL_17:
    *(_DWORD *)(a1 + 140) = *(_DWORD *)(a1 + 132);
    return (unsigned __int8)output_pass_setup(a1);
  }
  v3 = *(_DWORD *)(a1 + 8);
LABEL_8:
  if (v3)
    (*(void(__cdecl **)(int))v3)(a1);
  while (1) {
    v4 = (**(int(__cdecl ***)(int))(a1 + 408))(a1);
    if (!v4)
      return 0;
    if (v4 == 2)
      goto LABEL_17;
    v3 = *(_DWORD *)(a1 + 8);
    if (v3) {
      if (v4 == 3 || v4 == 1) {
        v5 = *(_DWORD *)(v3 + 4) + 1;
        *(_DWORD *)(v3 + 4) = v5;
        v3 = *(_DWORD *)(a1 + 8);
        v6 = *(_DWORD *)(v3 + 8);
        if (v5 >= v6) {
          *(_DWORD *)(v3 + 8) = *(_DWORD *)(a1 + 292) + v6;
          v3 = *(_DWORD *)(a1 + 8);
        }
      }
      goto LABEL_8;
    }
  }
}

int __cdecl jpeg_read_scanlines(_DWORD *a1, int a2, int a3) {
  unsigned int v3; // edx
  int v4;          // eax
  int result;      // eax
  _DWORD v6[3];    // [esp+1Ch] [ebp-Ch] BYREF

  if (a1[5] != 205) {
    *(_DWORD *)(*a1 + 20) = 20;
    *(_DWORD *)(*a1 + 24) = a1[5];
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  v3 = a1[32];
  if (v3 >= a1[26]) {
    *(_DWORD *)(*a1 + 20) = 123;
    (*(void(__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
    return 0;
  } else {
    v4 = a1[2];
    if (v4) {
      *(_DWORD *)(v4 + 4) = v3;
      *(_DWORD *)(a1[2] + 8) = a1[26];
      (*(void(__cdecl **)(_DWORD *))a1[2])(a1);
    }
    v6[0] = 0;
    (*(void(__cdecl **)(_DWORD *, int, _DWORD *, int))(a1[99] + 4))(a1, a2, v6,
                                                                    a3);
    result = v6[0];
    a1[32] += v6[0];
  }
  return result;
}

int __cdecl jpeg_add_quant_table(_DWORD *a1, unsigned int a2, int a3, int a4,
                                 char a5) {
  int v5;     // esi
  int j;      // ecx
  int v7;     // edx
  int result; // eax
  int i;      // ecx
  int v10;    // edx

  if (a1[5] != 100) {
    *(_DWORD *)(*a1 + 20) = 20;
    *(_DWORD *)(*a1 + 24) = a1[5];
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  if (a2 > 3) {
    *(_DWORD *)(*a1 + 20) = 31;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  v5 = (int)&a1[a2 + 19];
  if (!*(_DWORD *)v5)
    *(_DWORD *)v5 = jpeg_alloc_quant_table((int)a1);
  if (a5) {
    for (i = 0; i != 64; ++i) {
      v10 = (*(_DWORD *)(a3 + 4 * i) * a4 + 50) / 100;
      if (v10 <= 0) {
        LOWORD(v10) = 1;
      } else if (v10 >= 256) {
        LOWORD(v10) = 255;
      }
      *(_WORD *)(*(_DWORD *)v5 + 2 * i) = v10;
    }
  } else {
    for (j = 0; j != 64; ++j) {
      while (1) {
        v7 = (*(_DWORD *)(a3 + 4 * j) * a4 + 50) / 100;
        if (v7 > 0)
          break;
        *(_WORD *)(*(_DWORD *)v5 + 2 * j++) = 1;
        if (j == 64)
          goto LABEL_14;
      }
      if (v7 > 0x7FFF)
        LOWORD(v7) = 0x7FFF;
      *(_WORD *)(*(_DWORD *)v5 + 2 * j) = v7;
    }
  }
LABEL_14:
  result = *(_DWORD *)v5;
  *(_BYTE *)(*(_DWORD *)v5 + 128) = 0;
  return result;
}

_DWORD *__cdecl jpeg_set_colorspace(int a1, int a2) {
  _DWORD *result; // eax
  int v3;         // eax
  int v4;         // edx
  int v5;         // ecx
  _DWORD *v6;     // eax
  _DWORD *v7;     // eax
  _DWORD *v8;     // eax
  _DWORD *v9;     // edx
  _DWORD *v10;    // eax
  _DWORD *v11;    // eax
  _DWORD *v12;    // eax
  _DWORD *v13;    // eax
  _DWORD *v14;    // eax
  _DWORD *v15;    // edx
  _DWORD *v16;    // eax
  _DWORD *v17;    // eax

  if (*(_DWORD *)(a1 + 20) != 100) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 20);
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  *(_DWORD *)(a1 + 68) = a2;
  *(_BYTE *)(a1 + 200) = 0;
  *(_BYTE *)(a1 + 208) = 0;
  switch (a2) {
  case 0:
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 64) = v3;
    result = (_DWORD *)(v3 - 1);
    if ((unsigned int)result > 9) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 26;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(*(_DWORD *)a1 + 28) = 10;
      result = (_DWORD *)(**(int(__cdecl ***)(int))a1)(a1);
    }
    if (*(int *)(a1 + 64) > 0) {
      v4 = 0;
      v5 = 0;
      do {
        result = (_DWORD *)(*(_DWORD *)(a1 + 72) + v5);
        *result = v4;
        result[2] = 1;
        result[3] = 1;
        result[4] = 0;
        result[5] = 0;
        result[6] = 0;
        ++v4;
        v5 += 84;
      } while (*(_DWORD *)(a1 + 64) > v4);
    }
    return result;
  case 1:
    *(_BYTE *)(a1 + 200) = 1;
    *(_DWORD *)(a1 + 64) = 1;
    result = *(_DWORD **)(a1 + 72);
    *result = 1;
    goto LABEL_14;
  case 2:
    *(_BYTE *)(a1 + 208) = 1;
    *(_DWORD *)(a1 + 64) = 3;
    v16 = *(_DWORD **)(a1 + 72);
    *v16 = 82;
    v16[2] = 1;
    v16[3] = 1;
    v16[4] = 0;
    v16[5] = 0;
    v16[6] = 0;
    v17 = (_DWORD *)(*(_DWORD *)(a1 + 72) + 84);
    *v17 = 71;
    v17[2] = 1;
    v17[3] = 1;
    v17[4] = 0;
    v17[5] = 0;
    v17[6] = 0;
    result = (_DWORD *)(*(_DWORD *)(a1 + 72) + 168);
    *result = 66;
    goto LABEL_14;
  case 3:
    *(_BYTE *)(a1 + 200) = 1;
    *(_DWORD *)(a1 + 64) = 3;
    v13 = *(_DWORD **)(a1 + 72);
    *v13 = 1;
    v13[2] = 2;
    v13[3] = 2;
    v13[4] = 0;
    v13[5] = 0;
    v13[6] = 0;
    v14 = (_DWORD *)(*(_DWORD *)(a1 + 72) + 84);
    *v14 = 2;
    v14[2] = 1;
    v14[3] = 1;
    v14[4] = 1;
    v14[5] = 1;
    v14[6] = 1;
    v15 = *(_DWORD **)(a1 + 72);
    result = v15 + 42;
    v15[42] = 3;
    v15[44] = 1;
    v15[45] = 1;
    v15[46] = 1;
    v15[47] = 1;
    v15[48] = 1;
    return result;
  case 4:
    *(_BYTE *)(a1 + 208) = 1;
    *(_DWORD *)(a1 + 64) = 4;
    v10 = *(_DWORD **)(a1 + 72);
    *v10 = 67;
    v10[2] = 1;
    v10[3] = 1;
    v10[4] = 0;
    v10[5] = 0;
    v10[6] = 0;
    v11 = (_DWORD *)(*(_DWORD *)(a1 + 72) + 84);
    *v11 = 77;
    v11[2] = 1;
    v11[3] = 1;
    v11[4] = 0;
    v11[5] = 0;
    v11[6] = 0;
    v12 = (_DWORD *)(*(_DWORD *)(a1 + 72) + 168);
    *v12 = 89;
    v12[2] = 1;
    v12[3] = 1;
    v12[4] = 0;
    v12[5] = 0;
    v12[6] = 0;
    result = (_DWORD *)(*(_DWORD *)(a1 + 72) + 252);
    *result = 75;
  LABEL_14:
    result[2] = 1;
    result[3] = 1;
    result[4] = 0;
    result[5] = 0;
    result[6] = 0;
    break;
  case 5:
    *(_BYTE *)(a1 + 208) = 1;
    *(_DWORD *)(a1 + 64) = 4;
    v6 = *(_DWORD **)(a1 + 72);
    *v6 = 1;
    v6[2] = 2;
    v6[3] = 2;
    v6[4] = 0;
    v6[5] = 0;
    v6[6] = 0;
    v7 = (_DWORD *)(*(_DWORD *)(a1 + 72) + 84);
    *v7 = 2;
    v7[2] = 1;
    v7[3] = 1;
    v7[4] = 1;
    v7[5] = 1;
    v7[6] = 1;
    v8 = (_DWORD *)(*(_DWORD *)(a1 + 72) + 168);
    *v8 = 3;
    v8[2] = 1;
    v8[3] = 1;
    v8[4] = 1;
    v8[5] = 1;
    v8[6] = 1;
    v9 = *(_DWORD **)(a1 + 72);
    result = v9 + 63;
    v9[63] = 4;
    v9[65] = 2;
    v9[66] = 2;
    v9[67] = 0;
    v9[68] = 0;
    v9[69] = 0;
    break;
  default:
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 10;
    result = (_DWORD *)(**(int(__cdecl ***)(int))a1)(a1);
    break;
  }
  return result;
}

_DWORD *__cdecl jpeg_default_colorspace(_DWORD *a1) {
  _DWORD *result; // eax

  switch (a1[12]) {
  case 0:
    result = jpeg_set_colorspace((int)a1, 0);
    break;
  case 1:
    result = jpeg_set_colorspace((int)a1, 1);
    break;
  case 2:
  case 3:
    result = jpeg_set_colorspace((int)a1, 3);
    break;
  case 4:
    result = jpeg_set_colorspace((int)a1, 4);
    break;
  case 5:
    result = jpeg_set_colorspace((int)a1, 5);
    break;
  default:
    *(_DWORD *)(*a1 + 20) = 9;
    result = (_DWORD *)(*(int(__cdecl **)(_DWORD *)) * a1)(a1);
    break;
  }
  return result;
}

int __cdecl jpeg_set_quality(_DWORD *a1, int a2, char a3) {
  int v3; // eax
  int v4; // edi

  if (a2 <= 0) {
    v4 = 5000;
  } else {
    if (a2 > 100) {
      v3 = 200;
    } else {
      if (a2 <= 49) {
        v4 = 5000 / a2;
        goto LABEL_6;
      }
      v3 = 2 * a2;
    }
    v4 = 200 - v3;
  }
LABEL_6:
  jpeg_add_quant_table(a1, 0, (int)&std_luminance_quant_tbl_3644, v4, a3);
  return jpeg_add_quant_table(a1, 1u, (int)&std_chrominance_quant_tbl_3645, v4,
                              a3);
}

_DWORD *__cdecl jpeg_set_defaults(int a1) {
  int v1;     // edx
  size_t v2;  // esi
  char *v3;   // edx
  int v4;     // edx
  size_t v5;  // esi
  char *v6;   // edx
  int v7;     // edx
  size_t v8;  // esi
  char *v9;   // edx
  int v10;    // edx
  size_t v11; // esi
  char *v12;  // edx
  _BYTE *v13; // eax
  int v14;    // edx
  int v16;    // eax
  int v17;    // eax
  int v18;    // [esp+20h] [ebp-28h]
  int v19;    // [esp+24h] [ebp-24h]
  int v20;    // [esp+28h] [ebp-20h]
  int v21;    // [esp+2Ch] [ebp-1Ch]

  if (*(_DWORD *)(a1 + 20) != 100) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 20);
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  if (!*(_DWORD *)(a1 + 72))
    *(_DWORD *)(a1 + 72) =
        (**(int(__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 840);
  *(_DWORD *)(a1 + 60) = 8;
  jpeg_add_quant_table((_DWORD *)a1, 0, (int)&std_luminance_quant_tbl_3644, 50,
                       1);
  jpeg_add_quant_table((_DWORD *)a1, 1u, (int)&std_chrominance_quant_tbl_3645,
                       50, 1);
  v18 = a1 + 92;
  if (*(_DWORD *)(a1 + 92)) {
    v1 = *(_DWORD *)(a1 + 92);
  } else {
    v17 = jpeg_alloc_huff_table(a1);
    *(_DWORD *)(a1 + 92) = v17;
    v1 = v17;
  }
  *(_DWORD *)v1 = bits_dc_luminance_3688;
  *(_DWORD *)(v1 + 4) = &unk_1010101;
  *(_DWORD *)(v1 + 8) = 257;
  *(_DWORD *)(v1 + 12) = 0;
  *(_BYTE *)(v1 + 16) = 0;
  v2 = 0;
  v3 = (char *)&bits_dc_luminance_3688;
  do
    v2 += (unsigned __int8)*++v3;
  while (v3 != &byte_306EAC);
  if (v2 - 1 > 0xFF) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 8;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  memcpy((void *)(*(_DWORD *)v18 + 17), &val_dc_luminance_3689, v2);
  *(_BYTE *)(*(_DWORD *)v18 + 273) = 0;
  v19 = a1 + 108;
  if (*(_DWORD *)(a1 + 108)) {
    v4 = *(_DWORD *)(a1 + 108);
  } else {
    v16 = jpeg_alloc_huff_table(a1);
    *(_DWORD *)(a1 + 108) = v16;
    v4 = v16;
  }
  *(_DWORD *)v4 = bits_ac_luminance_3692;
  *(_DWORD *)(v4 + 4) = 67240707;
  *(_DWORD *)(v4 + 8) = 67437827;
  *(_DWORD *)(v4 + 12) = &unk_1000004;
  *(_BYTE *)(v4 + 16) = 125;
  v5 = 0;
  v6 = (char *)&bits_ac_luminance_3692;
  do
    v5 += (unsigned __int8)*++v6;
  while (v6 != &byte_306E72);
  if (v5 - 1 > 0xFF) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 8;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  memcpy((void *)(*(_DWORD *)v19 + 17), &val_ac_luminance_3693, v5);
  *(_BYTE *)(*(_DWORD *)v19 + 273) = 0;
  v20 = a1 + 96;
  if (!*(_DWORD *)(a1 + 96))
    *(_DWORD *)(a1 + 96) = jpeg_alloc_huff_table(a1);
  v7 = *(_DWORD *)(a1 + 96);
  *(_DWORD *)v7 = bits_dc_chrominance_3690;
  *(_DWORD *)(v7 + 4) = &unk_1010101;
  *(_DWORD *)(v7 + 8) = &unk_1010101;
  *(_DWORD *)(v7 + 12) = 0;
  *(_BYTE *)(v7 + 16) = 0;
  v8 = 0;
  v9 = (char *)&bits_dc_chrominance_3690;
  do
    v8 += (unsigned __int8)*++v9;
  while (v9 != &byte_306E8F);
  if (v8 - 1 > 0xFF) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 8;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  memcpy((void *)(*(_DWORD *)v20 + 17), &val_dc_chrominance_3691, v8);
  *(_BYTE *)(*(_DWORD *)v20 + 273) = 0;
  v21 = a1 + 112;
  if (!*(_DWORD *)(a1 + 112))
    *(_DWORD *)(a1 + 112) = jpeg_alloc_huff_table(a1);
  v10 = *(_DWORD *)(a1 + 112);
  *(_DWORD *)v10 = bits_ac_chrominance_3694;
  *(_DWORD *)(v10 + 4) = 50594818;
  *(_DWORD *)(v10 + 8) = 67438340;
  *(_DWORD *)(v10 + 12) = 33619972;
  *(_BYTE *)(v10 + 16) = 119;
  v11 = 0;
  v12 = (char *)&bits_ac_chrominance_3694;
  do
    v11 += (unsigned __int8)*++v12;
  while (v12 != &byte_306DB2);
  if (v11 - 1 > 0xFF) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 8;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  memcpy((void *)(*(_DWORD *)v21 + 17), &val_ac_chrominance_3695, v11);
  *(_BYTE *)(*(_DWORD *)v21 + 273) = 0;
  v13 = (_BYTE *)a1;
  v14 = 16;
  do {
    v13[124] = 0;
    v13[140] = 1;
    v13[156] = 5;
    ++v13;
    --v14;
  } while (v14);
  *(_DWORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 172) = 0;
  *(_BYTE *)(a1 + 180) = 0;
  *(_BYTE *)(a1 + 181) = 0;
  *(_BYTE *)(a1 + 182) = 0;
  if (*(int *)(a1 + 60) > 8)
    *(_BYTE *)(a1 + 182) = 1;
  *(_BYTE *)(a1 + 183) = 0;
  *(_DWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 188) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 196) = 0;
  *(_BYTE *)(a1 + 201) = 1;
  *(_BYTE *)(a1 + 202) = 1;
  *(_BYTE *)(a1 + 203) = 0;
  *(_WORD *)(a1 + 204) = 1;
  *(_WORD *)(a1 + 206) = 1;
  return jpeg_default_colorspace((_DWORD *)a1);
}

int __cdecl jpeg_start_compress(_DWORD *a1, char a2) {
  int result; // eax

  if (a1[5] != 100) {
    *(_DWORD *)(*a1 + 20) = 20;
    *(_DWORD *)(*a1 + 24) = a1[5];
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  if (a2)
    jpeg_suppress_tables((int)a1, 0);
  (*(void(__cdecl **)(_DWORD *))(*a1 + 16))(a1);
  (*(void(__cdecl **)(_DWORD *))(a1[8] + 8))(a1);
  jinit_compress_master((int)a1);
  (*(void(__cdecl **)(_DWORD *))a1[80])(a1);
  a1[53] = 0;
  result = 102 - (*((_BYTE *)a1 + 180) == 0);
  a1[5] = result;
  return result;
}

int __cdecl jpeg_write_scanlines(_DWORD *a1, int a2, unsigned int a3) {
  int v3;       // edi
  int v4;       // edx
  int v5;       // eax
  int result;   // eax
  _DWORD v7[3]; // [esp+1Ch] [ebp-Ch] BYREF

  v3 = a3;
  if (a1[5] != 101) {
    *(_DWORD *)(*a1 + 20) = 20;
    *(_DWORD *)(*a1 + 24) = a1[5];
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  if (a1[53] >= a1[10]) {
    *(_DWORD *)(*a1 + 20) = 123;
    (*(void(__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
  }
  v4 = a1[2];
  if (v4) {
    *(_DWORD *)(v4 + 4) = a1[53];
    *(_DWORD *)(a1[2] + 8) = a1[10];
    (*(void(__cdecl **)(_DWORD *))a1[2])(a1);
  }
  v5 = a1[80];
  if (*(_BYTE *)(v5 + 12))
    (*(void(__cdecl **)(_DWORD *))(v5 + 4))(a1);
  if (a1[10] - a1[53] < a3)
    v3 = a1[10] - a1[53];
  v7[0] = 0;
  (*(void(__cdecl **)(_DWORD *, int, _DWORD *, int))(a1[81] + 4))(a1, a2, v7,
                                                                  v3);
  result = v7[0];
  a1[53] += v7[0];
  return result;
}

int __cdecl error_exit(int a1) {
  (*(void(__cdecl **)(int))(*(_DWORD *)a1 + 8))(a1);
  jpeg_destroy(a1);
  return (*(int (**)(void))(*(_DWORD *)a1 + 132))();
}

int __cdecl output_message(int a1) {
  _BYTE v2[208]; // [esp+18h] [ebp-D0h] BYREF

  (*(void(__cdecl **)(int, _BYTE *))(*(_DWORD *)a1 + 12))(a1, v2);
  return (*(int(__cdecl **)(_BYTE *))(*(_DWORD *)a1 + 136))(v2);
}

int __cdecl emit_message(int *a1, int a2) {
  int result; // eax
  int v3;     // esi

  result = a2;
  v3 = *a1;
  if (a2 < 0) {
    result = *(_DWORD *)(v3 + 108);
    if (!result || *(int *)(v3 + 104) > 2)
      result = (*(int(__cdecl **)(int *))(v3 + 8))(a1);
    ++*(_DWORD *)(v3 + 108);
  } else if (a2 <= *(_DWORD *)(v3 + 104)) {
    return (*(int (**)(void))(v3 + 8))();
  }
  return result;
}

int __cdecl format_message(int a1, char *a2) {
  _DWORD *v2;     // ecx
  int v3;         // edx
  const char *v4; // esi
  const char *v5; // eax
  char v6;        // dl
  int v8;         // esi
  int v9;         // eax

  v2 = *(_DWORD **)a1;
  v3 = *(_DWORD *)(*(_DWORD *)a1 + 20);
  if (v3 <= 0 || v3 > v2[29]) {
    v8 = v2[30];
    if (!v8)
      goto LABEL_13;
    v9 = v2[31];
    if (v3 < v9 || v3 > v2[32])
      goto LABEL_13;
    v4 = *(const char **)(v8 + 4 * (v3 - v9));
  } else {
    v4 = *(const char **)(v2[28] + 4 * v3);
  }
  if (!v4) {
  LABEL_13:
    v2[6] = v3;
    v4 = *(const char **)v2[28];
  }
  v5 = v4;
  do {
    v6 = *v5++;
    if (!v6)
      return sprintf(a2, v4, v2[6], v2[7], v2[8], v2[9], v2[10], v2[11], v2[12],
                     v2[13]);
  } while (v6 != 37);
  if (*v5 != 115)
    return sprintf(a2, v4, v2[6], v2[7], v2[8], v2[9], v2[10], v2[11], v2[12],
                   v2[13]);
  return sprintf(a2, v4, v2 + 6);
}

int __cdecl reset_error_mgr(int *a1) {
  int result; // eax

  *(_DWORD *)(*a1 + 108) = 0;
  result = *a1;
  *(_DWORD *)(*a1 + 20) = 0;
  return result;
}

uLong __cdecl adler32(uLong adler, const Bytef *buf, uInt len) {
  const Bytef *v3;  // esi
  unsigned int v4;  // edi
  signed int v5;    // eax
  uLong i;          // ecx
  int v7;           // eax
  uLong v8;         // edx
  int v9;           // eax
  int v10;          // edx
  int v11;          // eax
  int v12;          // edx
  int v13;          // eax
  int v14;          // edx
  int v15;          // eax
  int v16;          // edx
  int v17;          // eax
  int v18;          // edx
  int v19;          // eax
  int v20;          // edx
  int v21;          // eax
  int v22;          // edx
  int v23;          // eax
  int v24;          // edx
  int v25;          // eax
  int v26;          // edx
  int v27;          // eax
  int v28;          // edx
  int v29;          // eax
  int v30;          // edx
  int v31;          // eax
  int v32;          // edx
  int v33;          // eax
  int v34;          // edx
  int v35;          // eax
  int v36;          // ecx
  int v37;          // edx
  const Bytef *v38; // edx
  int v40;          // [esp+0h] [ebp-10h]
  uLong v41;        // [esp+4h] [ebp-Ch]

  v3 = buf;
  v4 = (unsigned __int16)adler;
  v41 = HIWORD(adler);
  if (!buf)
    return 1;
  for (; len; v41 %= 0xFFF1u) {
    v5 = 5552;
    if (len < 0x15B1)
      v5 = len;
    v40 = v5;
    len -= v5;
    if (v5 > 15) {
      for (i = v41;; i = v37) {
        v7 = v4 + *v3;
        v8 = v7 + i;
        v9 = v3[1] + v7;
        v10 = v9 + v8;
        v11 = v3[2] + v9;
        v12 = v11 + v10;
        v13 = v3[3] + v11;
        v14 = v13 + v12;
        v15 = v3[4] + v13;
        v16 = v15 + v14;
        v17 = v3[5] + v15;
        v18 = v17 + v16;
        v19 = v3[6] + v17;
        v20 = v19 + v18;
        v21 = v3[7] + v19;
        v22 = v21 + v20;
        v23 = v3[8] + v21;
        v24 = v23 + v22;
        v25 = v3[9] + v23;
        v26 = v25 + v24;
        v27 = v3[10] + v25;
        v28 = v27 + v26;
        v29 = v3[11] + v27;
        v30 = v29 + v28;
        v31 = v3[12] + v29;
        v32 = v31 + v30;
        v33 = v3[13] + v31;
        v34 = v33 + v32;
        v35 = v3[14] + v33;
        v36 = v3[15];
        v4 = v35 + v36;
        v37 = v35 + v36 + v35 + v34;
        v41 = v37;
        v3 += 16;
        v40 -= 16;
        if (v40 <= 15)
          break;
      }
    }
    if (v40) {
      v38 = v3;
      do {
        v4 += *v38++;
        v41 += v4;
      } while (&v3[v40] != v38);
      v3 += v40;
    }
    v4 %= 0xFFF1u;
  }
  return v4 | (v41 << 16);
}

int __cdecl inflate_blocks(int *a1, int a2, int a3) {
  unsigned int v3;        // edi
  unsigned int v4;        // eax
  int v5;                 // edx
  unsigned int v7;        // eax
  unsigned int v8;        // edx
  unsigned int v9;        // eax
  int v10;                // eax
  int *v11;               // edx
  char *v12;              // ecx
  unsigned int v13;       // edx
  unsigned __int8 *v14;   // edx
  size_t v15;             // esi
  unsigned __int8 *v16;   // ecx
  int v17;                // eax
  char *v18;              // ecx
  unsigned int v19;       // eax
  char *v20;              // ecx
  int *v21;               // edx
  int v22;                // esi
  unsigned int v23;       // edx
  _BYTE *v24;             // ecx
  _DWORD *v25;            // ecx
  unsigned __int8 *v26;   // eax
  size_t v27;             // esi
  unsigned __int8 *v28;   // ecx
  int *v29;               // edx
  _DWORD *v30;            // ecx
  unsigned __int8 *v31;   // esi
  int v32;                // eax
  int v33;                // ecx
  int v34;                // edx
  unsigned int v35;       // esi
  int v36;                // eax
  int v37;                // esi
  unsigned int v38;       // esi
  size_t v39;             // esi
  size_t v40;             // eax
  unsigned __int8 *v41;   // edx
  size_t v42;             // esi
  unsigned __int8 *v43;   // edx
  int v44;                // eax
  int v45;                // edx
  int v46;                // ecx
  unsigned int v47;       // edx
  int v48;                // eax
  unsigned __int8 *i;     // ecx
  unsigned __int8 *v50;   // edx
  unsigned __int8 *v51;   // edx
  size_t v52;             // esi
  _DWORD *v53;            // ecx
  char *v54;              // eax
  int v55;                // ecx
  int v56;                // eax
  unsigned int v57;       // eax
  unsigned int v58;       // edx
  int v59;                // eax
  unsigned __int8 *v60;   // [esp+48h] [ebp-80h]
  int v61;                // [esp+4Ch] [ebp-7Ch]
  unsigned int v62;       // [esp+58h] [ebp-70h]
  unsigned int v63;       // [esp+60h] [ebp-68h]
  unsigned __int8 *__src; // [esp+64h] [ebp-64h]
  size_t v65;             // [esp+68h] [ebp-60h]
  char *__dst;            // [esp+6Ch] [ebp-5Ch]
  size_t __n;             // [esp+70h] [ebp-58h]
  unsigned int v68;       // [esp+74h] [ebp-54h]
  int v69;                // [esp+78h] [ebp-50h]
  int v70;                // [esp+7Ch] [ebp-4Ch]
  _DWORD *v71;            // [esp+80h] [ebp-48h]
  int v72;                // [esp+84h] [ebp-44h]
  unsigned __int8 *v73;   // [esp+88h] [ebp-40h]
  size_t v74;             // [esp+8Ch] [ebp-3Ch]
  size_t v75;             // [esp+90h] [ebp-38h]
  unsigned int v76;       // [esp+94h] [ebp-34h]
  int v77;                // [esp+98h] [ebp-30h]
  unsigned int v78;       // [esp+9Ch] [ebp-2Ch]
  int v79;                // [esp+A0h] [ebp-28h] BYREF
  int v80;                // [esp+A4h] [ebp-24h] BYREF
  int v81;                // [esp+A8h] [ebp-20h] BYREF
  int v82[7];             // [esp+ACh] [ebp-1Ch] BYREF

  __src = *(unsigned __int8 **)a2;
  v65 = *(_DWORD *)(a2 + 4);
  v76 = a1[8];
  v3 = a1[7];
  __dst = (char *)a1[13];
  v4 = a1[12];
  if ((unsigned int)__dst >= v4)
    __n = a1[11] - (_DWORD)__dst;
  else
    __n = v4 - (_DWORD)__dst - 1;
LABEL_3:
  while (2) {
    switch (*a1) {
    case 0:
      if (v3 > 2)
        goto LABEL_53;
      if (!v65)
        goto LABEL_118;
      v51 = __src;
      v52 = v65;
      while (1) {
        --v52;
        v76 |= *v51++ << v3;
        v3 += 8;
        if (v3 > 2)
          break;
        if (&__src[v65] == v51) {
          __src = v51;
          a3 = 0;
        LABEL_118:
          v29 = a1;
          a1[8] = v76;
          a1[7] = v3;
          v30 = (_DWORD *)a2;
          *(_DWORD *)(a2 + 4) = 0;
          *(_DWORD *)(a2 + 8) += &__src[-*(_DWORD *)a2];
          v31 = __src;
          goto LABEL_51;
        }
      }
      __src = v51;
      v65 = v52;
      a3 = 0;
    LABEL_53:
      a1[6] = v76 & 1;
      v32 = (unsigned __int8)(v76 & 7) >> 1;
      if (v32 == 1) {
        inflate_trees_fixed(&v79, v82, &v80, &v81);
        v56 = inflate_codes_new(v79, v82[0], v80, v81, a2);
        a1[1] = v56;
        if (!v56) {
          a1[8] = v76;
          a1[7] = v3;
          *(_DWORD *)(a2 + 4) = v65;
          *(_DWORD *)(a2 + 8) += &__src[-*(_DWORD *)a2];
          *(_DWORD *)a2 = __src;
          a1[13] = (int)__dst;
          return inflate_flush(a1, (_DWORD *)a2, -4);
        }
        v76 >>= 3;
        v3 -= 3;
        *a1 = 6;
      } else if (v32) {
        if (v32 != 2) {
          if (v32 != 3)
            continue;
          *a1 = 9;
          *(_DWORD *)(a2 + 24) = "invalid block type";
          a1[8] = v76 >> 3;
          a1[7] = v3 - 3;
          *(_DWORD *)(a2 + 4) = v65;
          *(_DWORD *)(a2 + 8) += &__src[-*(_DWORD *)a2];
          *(_DWORD *)a2 = __src;
          a1[13] = (int)__dst;
          return inflate_flush(a1, (_DWORD *)a2, -3);
        }
        v76 >>= 3;
        v3 -= 3;
        *a1 = 3;
      } else {
        v55 = ((_BYTE)v3 - 3) & 7;
        v76 = v76 >> 3 >> v55;
        v3 = v3 - 3 - v55;
        *a1 = 1;
      }
      continue;
    case 1:
      if (v3 > 0x1F) {
        v60 = __src;
        v27 = v65;
        goto LABEL_102;
      }
      if (!v65) {
        v60 = __src;
        goto LABEL_50;
      }
      v27 = v65;
      v60 = __src;
      v28 = __src;
      break;
    case 2:
      if (!v65) {
        a1[8] = v76;
        a1[7] = v3;
        *(_DWORD *)(a2 + 4) = 0;
        *(_DWORD *)(a2 + 8) += &__src[-*(_DWORD *)a2];
        *(_DWORD *)a2 = __src;
        a1[13] = (int)__dst;
        return inflate_flush(a1, (_DWORD *)a2, a3);
      }
      if (__n)
        goto LABEL_71;
      v20 = __dst;
      v21 = a1;
      if (__dst != (char *)a1[11])
        goto LABEL_36;
      v57 = a1[12];
      v58 = a1[10];
      if (v57 == v58) {
        v20 = __dst;
        v21 = a1;
      } else {
        if (v57 <= v58)
          __n = (size_t)&__dst[-v58];
        else
          __n = v57 - v58 - 1;
        if (__n) {
          __dst = (char *)a1[10];
          goto LABEL_71;
        }
        v20 = (char *)a1[10];
        v21 = a1;
      }
    LABEL_36:
      v21[13] = (int)v20;
      v22 = inflate_flush(v21, (_DWORD *)a2, a3);
      v23 = a1[13];
      v24 = (_BYTE *)a1[12];
      if (v23 >= (unsigned int)v24)
        __n = a1[11] - v23;
      else
        __n = (size_t)&v24[-v23 - 1];
      if (v23 != a1[11] || (v54 = (char *)a1[10], __dst = v54, v24 == v54)) {
        __dst = (char *)a1[13];
      } else if (v24 <= v54) {
        __n = v23 - (_DWORD)v54;
      } else {
        __n = v24 - v54 - 1;
      }
      if (!__n) {
        a1[8] = v76;
        a1[7] = v3;
        *(_DWORD *)(a2 + 4) = v65;
        v25 = (_DWORD *)a2;
        *(_DWORD *)(a2 + 8) += &__src[-*(_DWORD *)a2];
        v26 = __src;
      LABEL_42:
        *v25 = v26;
        a1[13] = (int)__dst;
        return inflate_flush(a1, (_DWORD *)a2, v22);
      }
    LABEL_71:
      v39 = a1[1];
      if (v65 < v39)
        v39 = v65;
      if (__n >= v39) {
        __n -= v39;
      } else {
        v39 = __n;
        __n = 0;
      }
      memcpy(__dst, __src, v39);
      __src += v39;
      v65 -= v39;
      __dst += v39;
      v40 = a1[1] - v39;
      a1[1] = v40;
      if (!v40)
        *a1 = a1[6] != 0 ? 7 : 0;
      a3 = 0;
      continue;
    case 3:
      if (v3 <= 0xD) {
        if (!v65) {
          v50 = __src;
          goto LABEL_112;
        }
        v73 = __src;
        v74 = v65;
        for (i = __src;; i = v73) {
          --v74;
          v76 |= *i << v3;
          ++v73;
          v3 += 8;
          if (v3 > 0xD)
            break;
          v50 = &__src[v65];
          if (&__src[v65] == v73) {
            a3 = 0;
          LABEL_112:
            a1[8] = v76;
            a1[7] = v3;
            *(_DWORD *)(a2 + 4) = 0;
            *(_DWORD *)(a2 + 8) += &v50[-*(_DWORD *)a2];
            *(_DWORD *)a2 = v50;
            a1[13] = (int)__dst;
            return inflate_flush(a1, (_DWORD *)a2, a3);
          }
        }
        a3 = 0;
      } else {
        v73 = __src;
        v74 = v65;
      }
      v7 = v76 & 0x3FFF;
      a1[1] = v7;
      v8 = v76 & 0x1F;
      if (v8 > 0x1D || (v9 = (v7 >> 5) & 0x1F, v9 > 0x1D)) {
        *a1 = 9;
        *(_DWORD *)(a2 + 24) = "too many length or distance symbols";
        a1[8] = v76;
        a1[7] = v3;
        *(_DWORD *)(a2 + 4) = v74;
        *(_DWORD *)(a2 + 8) += &v73[-*(_DWORD *)a2];
        *(_DWORD *)a2 = v73;
        a1[13] = (int)__dst;
        return inflate_flush(a1, (_DWORD *)a2, -3);
      }
      v10 = (*(int(__cdecl **)(_DWORD, unsigned int, int))(a2 + 32))(
          *(_DWORD *)(a2 + 40), v8 + v9 + 258, 4);
      a1[3] = v10;
      if (!v10)
        goto LABEL_159;
      v76 >>= 14;
      v3 -= 14;
      a1[2] = 0;
      *a1 = 4;
    LABEL_18:
      v13 = a1[2];
      v62 = v13;
      if (((unsigned int)a1[1] >> 10) + 4 > v13) {
        v71 = (_DWORD *)((char *)border + 4 * v13);
        do {
          if (v3 <= 2) {
            if (!v74) {
            LABEL_144:
              v16 = v73;
              goto LABEL_26;
            }
            v14 = v73;
            v15 = v74;
            while (1) {
              --v15;
              v76 |= *v14++ << v3;
              v3 += 8;
              if (v3 > 2)
                break;
              v16 = &v73[v74];
              if (&v73[v74] == v14) {
              LABEL_25:
                a3 = 0;
              LABEL_26:
                a1[8] = v76;
                a1[7] = v3;
                *(_DWORD *)(a2 + 4) = 0;
                *(_DWORD *)(a2 + 8) += &v16[-*(_DWORD *)a2];
                *(_DWORD *)a2 = v16;
                a1[13] = (int)__dst;
                return inflate_flush(a1, (_DWORD *)a2, a3);
              }
            }
            v73 = v14;
            v74 = v15;
            a3 = 0;
          }
          *(_DWORD *)(a1[3] + 4 * *v71) = v76 & 7;
          v13 = ++v62;
          a1[2] = v62;
          v76 >>= 3;
          v3 -= 3;
          ++v71;
        } while (v62 < ((unsigned int)a1[1] >> 10) + 4);
      }
      v38 = v13;
      if (v13 <= 0x12) {
        v53 = (_DWORD *)((char *)border + 4 * v13);
        do {
          *(_DWORD *)(a1[3] + 4 * *v53) = 0;
          a1[2] = ++v38;
          ++v53;
        } while (v38 != 19);
      }
      a1[4] = 7;
      v22 = inflate_trees_bits((_DWORD *)a1[3], (unsigned int *)a1 + 4, a1 + 5,
                               a1[9], a2);
      if (v22)
        goto LABEL_154;
      a1[2] = 0;
      *a1 = 5;
    LABEL_59:
      while (1) {
        v68 = a1[2];
        v33 = a1[1] & 0x1F;
        v34 = ((unsigned int)a1[1] >> 5) & 0x1F;
        v63 = v33 + v34 + 258;
        if (v68 >= v63)
          break;
        v35 = a1[4];
        if (v35 > v3) {
          if (!v74)
            goto LABEL_144;
          v75 = v74;
          v41 = v73;
          while (1) {
            --v75;
            v76 |= *v41++ << v3;
            v3 += 8;
            if (v35 <= v3)
              break;
            v16 = &v73[v74];
            if (&v73[v74] == v41)
              goto LABEL_25;
          }
          v73 = v41;
          a3 = 0;
        } else {
          v75 = v74;
        }
        v36 = a1[5] + 8 * (inflate_mask[v35] & v76);
        v37 = *(unsigned __int8 *)(v36 + 1);
        v72 = v37;
        v78 = *(_DWORD *)(v36 + 4);
        if (v78 > 0xF) {
          if (v78 == 18) {
            v69 = 11;
            v77 = 7;
          } else {
            v77 = v78 - 14;
            v69 = 3;
          }
          if (v77 + v37 > v3) {
            if (!v75)
              goto LABEL_144;
            v42 = v75;
            v43 = v73;
            while (1) {
              --v42;
              v76 |= *v43++ << v3;
              v3 += 8;
              if (v77 + v72 <= v3)
                break;
              v16 = &v73[v75];
              if (&v73[v75] == v43)
                goto LABEL_25;
            }
            v73 = v43;
            v75 = v42;
            a3 = 0;
          }
          v61 = v69 + (inflate_mask[v77] & (v76 >> v72));
          v76 = v76 >> v72 >> v77;
          v3 = v3 - v72 - v77;
          if (v63 < v61 + v68) {
          LABEL_152:
            (*(void(__cdecl **)(_DWORD, int))(a2 + 36))(*(_DWORD *)(a2 + 40),
                                                        a1[3]);
            *a1 = 9;
            *(_DWORD *)(a2 + 24) = "invalid bit length repeat";
            a1[8] = v76;
            a1[7] = v3;
            *(_DWORD *)(a2 + 4) = v75;
            *(_DWORD *)(a2 + 8) += &v73[-*(_DWORD *)a2];
            *(_DWORD *)a2 = v73;
            v12 = __dst;
            v11 = a1;
          LABEL_16:
            v11[13] = (int)v12;
            return inflate_flush(v11, (_DWORD *)a2, -3);
          }
          if (v78 == 16) {
            if (!v68)
              goto LABEL_152;
            v44 = a1[3];
            v70 = *(_DWORD *)(v44 + 4 * v68 - 4);
          } else {
            v70 = 0;
            v44 = a1[3];
          }
          v45 = 4 * v68;
          v46 = 0;
          while (1) {
            *(_DWORD *)(v44 + v45) = v70;
            ++v68;
            ++v46;
            v45 += 4;
            if (v61 == v46)
              break;
            v44 = a1[3];
          }
          a1[2] = v68;
        } else {
          v76 >>= v37;
          v3 -= v37;
          *(_DWORD *)(a1[3] + 4 * v68) = v78;
          a1[2] = v68 + 1;
        }
        v74 = v75;
      }
      a1[5] = 0;
      v81 = 9;
      v80 = 6;
      v22 = inflate_trees_dynamic(v33 + 257, v34 + 1, (_DWORD *)a1[3],
                                  (unsigned int *)&v81, (unsigned int *)&v80,
                                  &v79, v82, a1[9], a2);
      if (v22) {
      LABEL_154:
        if (v22 == -3) {
          (*(void(__cdecl **)(_DWORD, int))(a2 + 36))(*(_DWORD *)(a2 + 40),
                                                      a1[3]);
          *a1 = 9;
        }
        a1[8] = v76;
        a1[7] = v3;
        *(_DWORD *)(a2 + 4) = v74;
        v25 = (_DWORD *)a2;
        *(_DWORD *)(a2 + 8) += &v73[-*(_DWORD *)a2];
        v26 = v73;
        goto LABEL_42;
      }
      (*(void(__cdecl **)(_DWORD, int))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[3]);
      v59 = inflate_codes_new(v81, v80, v79, v82[0], a2);
      if (!v59) {
      LABEL_159:
        a1[8] = v76;
        a1[7] = v3;
        *(_DWORD *)(a2 + 4) = v74;
        *(_DWORD *)(a2 + 8) += &v73[-*(_DWORD *)a2];
        *(_DWORD *)a2 = v73;
        a1[13] = (int)__dst;
        return inflate_flush(a1, (_DWORD *)a2, -4);
      }
      a1[1] = v59;
      *a1 = 6;
    LABEL_28:
      a1[8] = v76;
      a1[7] = v3;
      *(_DWORD *)(a2 + 4) = v74;
      *(_DWORD *)(a2 + 8) += &v73[-*(_DWORD *)a2];
      *(_DWORD *)a2 = v73;
      a1[13] = (int)__dst;
      v17 = inflate_codes(a1, a2, a3);
      if (v17 != 1)
        return inflate_flush(a1, (_DWORD *)a2, v17);
      inflate_codes_free(a1[1], a2);
      __src = *(unsigned __int8 **)a2;
      v65 = *(_DWORD *)(a2 + 4);
      v76 = a1[8];
      v3 = a1[7];
      v18 = (char *)a1[13];
      __dst = v18;
      v19 = a1[12];
      if (v19 <= (unsigned int)v18)
        __n = a1[11] - (_DWORD)v18;
      else
        __n = v19 - (_DWORD)v18 - 1;
      if (a1[6]) {
        *a1 = 7;
        a3 = 0;
      LABEL_6:
        a1[13] = (int)__dst;
        v5 = inflate_flush(a1, (_DWORD *)a2, a3);
        __dst = (char *)a1[13];
        if (__dst == (char *)a1[12]) {
          *a1 = 8;
        LABEL_8:
          a1[8] = v76;
          a1[7] = v3;
          *(_DWORD *)(a2 + 4) = v65;
          *(_DWORD *)(a2 + 8) += &__src[-*(_DWORD *)a2];
          *(_DWORD *)a2 = __src;
          a1[13] = (int)__dst;
          return inflate_flush(a1, (_DWORD *)a2, 1);
        } else {
          a1[8] = v76;
          a1[7] = v3;
          *(_DWORD *)(a2 + 4) = v65;
          *(_DWORD *)(a2 + 8) += &__src[-*(_DWORD *)a2];
          *(_DWORD *)a2 = __src;
          a1[13] = (int)__dst;
          return inflate_flush(a1, (_DWORD *)a2, v5);
        }
      }
      *a1 = 0;
      a3 = 0;
      continue;
    case 4:
      v73 = __src;
      v74 = v65;
      goto LABEL_18;
    case 5:
      v73 = __src;
      v74 = v65;
      goto LABEL_59;
    case 6:
      v73 = __src;
      v74 = v65;
      goto LABEL_28;
    case 7:
      goto LABEL_6;
    case 8:
      goto LABEL_8;
    case 9:
      v11 = a1;
      a1[8] = v76;
      a1[7] = v3;
      *(_DWORD *)(a2 + 4) = v65;
      *(_DWORD *)(a2 + 8) += &__src[-*(_DWORD *)a2];
      *(_DWORD *)a2 = __src;
      v12 = __dst;
      goto LABEL_16;
    default:
      a1[8] = v76;
      a1[7] = v3;
      *(_DWORD *)(a2 + 4) = v65;
      *(_DWORD *)(a2 + 8) += &__src[-*(_DWORD *)a2];
      *(_DWORD *)a2 = __src;
      a1[13] = (int)__dst;
      return inflate_flush(a1, (_DWORD *)a2, -2);
    }
    break;
  }
  while (1) {
    --v27;
    v76 |= *v28 << v3;
    ++v60;
    v3 += 8;
    if (v3 > 0x1F) {
      a3 = 0;
    LABEL_102:
      v47 = ~v76 >> 16;
      if (v47 != (unsigned __int16)v76) {
        *a1 = 9;
        *(_DWORD *)(a2 + 24) = "invalid stored block lengths";
        a1[8] = v76;
        a1[7] = v3;
        *(_DWORD *)(a2 + 4) = v27;
        *(_DWORD *)(a2 + 8) += &v60[-*(_DWORD *)a2];
        *(_DWORD *)a2 = v60;
        a1[13] = (int)__dst;
        return inflate_flush(a1, (_DWORD *)a2, -3);
      }
      a1[1] = v47;
      if (v47)
        v48 = 2;
      else
        v48 = a1[6] != 0 ? 7 : 0;
      *a1 = v48;
      __src = v60;
      v65 = v27;
      v76 = 0;
      v3 = 0;
      goto LABEL_3;
    }
    if (v60 == &__src[v65])
      break;
    v28 = v60;
  }
  a3 = 0;
LABEL_50:
  v29 = a1;
  a1[8] = v76;
  a1[7] = v3;
  v30 = (_DWORD *)a2;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) += &v60[-*(_DWORD *)a2];
  v31 = v60;
LABEL_51:
  *v30 = v31;
  v29[13] = (int)__dst;
  return inflate_flush(a1, v30, a3);
}

int __cdecl inflate_blocks_free(_DWORD *a1, int a2) {
  int v2;                                    // eax
  int(__cdecl * v3)(_DWORD, _DWORD, _DWORD); // edx
  int v4;                                    // eax

  if ((unsigned int)(*a1 - 4) <= 1)
    (*(void(__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[3]);
  if (*a1 == 6)
    inflate_codes_free(a1[1], a2);
  *a1 = 0;
  a1[7] = 0;
  a1[8] = 0;
  v2 = a1[10];
  a1[13] = v2;
  a1[12] = v2;
  v3 = (int(__cdecl *)(_DWORD, _DWORD, _DWORD))a1[14];
  if (v3) {
    v4 = v3(0, 0, 0);
    a1[15] = v4;
    *(_DWORD *)(a2 + 48) = v4;
    v2 = a1[10];
  }
  (*(void(__cdecl **)(_DWORD, int))(a2 + 36))(*(_DWORD *)(a2 + 40), v2);
  (*(void(__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[9]);
  (*(void(__cdecl **)(_DWORD, _DWORD *))(a2 + 36))(*(_DWORD *)(a2 + 40), a1);
  return 0;
}

int __cdecl write_marker_byte(_DWORD *a1, char a2) {
  int v2;     // ecx
  _BYTE *v3;  // eax
  int result; // eax

  v2 = a1[8];
  v3 = *(_BYTE **)v2;
  *v3 = a2;
  *(_DWORD *)v2 = v3 + 1;
  result = *(_DWORD *)(v2 + 4) - 1;
  *(_DWORD *)(v2 + 4) = result;
  if (!result) {
    result = (*(int(__cdecl **)(_DWORD *))(v2 + 12))(a1);
    if (!(_BYTE)result) {
      *(_DWORD *)(*a1 + 20) = 24;
      return (*(int(__cdecl **)(_DWORD *)) * a1)(a1);
    }
  }
  return result;
}

int __cdecl write_file_trailer(_DWORD *a1) {
  int v1;     // edx
  _BYTE *v2;  // eax
  int v3;     // eax
  int v4;     // edx
  _BYTE *v5;  // eax
  int result; // eax

  v1 = a1[8];
  v2 = *(_BYTE **)v1;
  *v2 = -1;
  *(_DWORD *)v1 = v2 + 1;
  v3 = *(_DWORD *)(v1 + 4) - 1;
  *(_DWORD *)(v1 + 4) = v3;
  if (!v3 && !(*(unsigned __int8(__cdecl **)(_DWORD *))(v1 + 12))(a1)) {
    *(_DWORD *)(*a1 + 20) = 24;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  v4 = a1[8];
  v5 = *(_BYTE **)v4;
  *v5 = -39;
  *(_DWORD *)v4 = v5 + 1;
  result = *(_DWORD *)(v4 + 4) - 1;
  *(_DWORD *)(v4 + 4) = result;
  if (!result) {
    result = (*(int(__cdecl **)(_DWORD *))(v4 + 12))(a1);
    if (!(_BYTE)result) {
      *(_DWORD *)(*a1 + 20) = 24;
      return (*(int(__cdecl **)(_DWORD *)) * a1)(a1);
    }
  }
  return result;
}

int __cdecl write_file_header(int a1) {
  int v1;      // edi
  int v2;      // edx
  _BYTE *v3;   // eax
  int v4;      // eax
  int v5;      // edx
  _BYTE *v6;   // eax
  int result;  // eax
  int v8;      // edx
  _BYTE *v9;   // eax
  int v10;     // eax
  int v11;     // edx
  _BYTE *v12;  // eax
  int v13;     // eax
  int v14;     // edx
  _BYTE *v15;  // eax
  int v16;     // eax
  int v17;     // edx
  _BYTE *v18;  // eax
  int v19;     // eax
  int v20;     // edx
  _BYTE *v21;  // eax
  int v22;     // eax
  int v23;     // edx
  _BYTE *v24;  // eax
  int v25;     // eax
  int v26;     // edx
  _BYTE *v27;  // eax
  int v28;     // eax
  int v29;     // edx
  _BYTE *v30;  // eax
  int v31;     // eax
  int v32;     // edx
  _BYTE *v33;  // eax
  int v34;     // eax
  int v35;     // ecx
  _BYTE *v36;  // eax
  int v37;     // eax
  int v38;     // ecx
  _BYTE *v39;  // eax
  int v40;     // eax
  int v41;     // ecx
  _BYTE *v42;  // eax
  int v43;     // eax
  __int16 v44; // di
  int v45;     // ecx
  _BYTE *v46;  // eax
  int v47;     // eax
  int v48;     // edx
  _BYTE *v49;  // eax
  int v50;     // eax
  __int16 v51; // di
  int v52;     // ecx
  _BYTE *v53;  // eax
  int v54;     // eax
  int v55;     // edx
  _BYTE *v56;  // eax
  int v57;     // eax
  int v58;     // edx
  _BYTE *v59;  // eax
  int v60;     // eax
  int v61;     // edx
  _BYTE *v62;  // eax
  int v63;     // edx
  _BYTE *v64;  // eax
  int v65;     // eax
  int v66;     // edx
  _BYTE *v67;  // eax
  int v68;     // eax
  int v69;     // edx
  _BYTE *v70;  // eax
  int v71;     // eax
  int v72;     // edx
  _BYTE *v73;  // eax
  int v74;     // eax
  int v75;     // edx
  _BYTE *v76;  // eax
  int v77;     // eax
  int v78;     // edx
  _BYTE *v79;  // eax
  int v80;     // eax
  int v81;     // edx
  _BYTE *v82;  // eax
  int v83;     // eax
  int v84;     // edx
  _BYTE *v85;  // eax
  int v86;     // eax
  int v87;     // edx
  _BYTE *v88;  // eax
  int v89;     // eax
  int v90;     // edx
  _BYTE *v91;  // eax
  int v92;     // eax
  int v93;     // edx
  _BYTE *v94;  // eax
  int v95;     // eax
  int v96;     // edx
  _BYTE *v97;  // eax
  int v98;     // eax
  int v99;     // edx
  _BYTE *v100; // eax
  int v101;    // eax
  int v102;    // edx
  _BYTE *v103; // eax
  int v104;    // eax
  int v105;    // edx
  _BYTE *v106; // eax
  int v107;    // eax
  int v108;    // eax
  int v109;    // edx
  _BYTE *v110; // eax

  v1 = *(_DWORD *)(a1 + 336);
  v2 = *(_DWORD *)(a1 + 32);
  v3 = *(_BYTE **)v2;
  *v3 = -1;
  *(_DWORD *)v2 = v3 + 1;
  v4 = *(_DWORD *)(v2 + 4) - 1;
  *(_DWORD *)(v2 + 4) = v4;
  if (!v4 && !(*(unsigned __int8(__cdecl **)(int))(v2 + 12))(a1)) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  v5 = *(_DWORD *)(a1 + 32);
  v6 = *(_BYTE **)v5;
  *v6 = -40;
  *(_DWORD *)v5 = v6 + 1;
  result = *(_DWORD *)(v5 + 4) - 1;
  *(_DWORD *)(v5 + 4) = result;
  if (!result) {
    result = (*(int(__cdecl **)(int))(v5 + 12))(a1);
    if (!(_BYTE)result) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      result = (**(int(__cdecl ***)(int))a1)(a1);
    }
  }
  *(_DWORD *)(v1 + 28) = 0;
  if (*(_BYTE *)(a1 + 200)) {
    v8 = *(_DWORD *)(a1 + 32);
    v9 = *(_BYTE **)v8;
    *v9 = -1;
    *(_DWORD *)v8 = v9 + 1;
    v10 = *(_DWORD *)(v8 + 4) - 1;
    *(_DWORD *)(v8 + 4) = v10;
    if (!v10 && !(*(unsigned __int8(__cdecl **)(int))(v8 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v11 = *(_DWORD *)(a1 + 32);
    v12 = *(_BYTE **)v11;
    *v12 = -32;
    *(_DWORD *)v11 = v12 + 1;
    v13 = *(_DWORD *)(v11 + 4) - 1;
    *(_DWORD *)(v11 + 4) = v13;
    if (!v13 && !(*(unsigned __int8(__cdecl **)(int))(v11 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v14 = *(_DWORD *)(a1 + 32);
    v15 = *(_BYTE **)v14;
    *v15 = 0;
    *(_DWORD *)v14 = v15 + 1;
    v16 = *(_DWORD *)(v14 + 4) - 1;
    *(_DWORD *)(v14 + 4) = v16;
    if (!v16 && !(*(unsigned __int8(__cdecl **)(int))(v14 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v17 = *(_DWORD *)(a1 + 32);
    v18 = *(_BYTE **)v17;
    *v18 = 16;
    *(_DWORD *)v17 = v18 + 1;
    v19 = *(_DWORD *)(v17 + 4) - 1;
    *(_DWORD *)(v17 + 4) = v19;
    if (!v19 && !(*(unsigned __int8(__cdecl **)(int))(v17 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v20 = *(_DWORD *)(a1 + 32);
    v21 = *(_BYTE **)v20;
    *v21 = 74;
    *(_DWORD *)v20 = v21 + 1;
    v22 = *(_DWORD *)(v20 + 4) - 1;
    *(_DWORD *)(v20 + 4) = v22;
    if (!v22 && !(*(unsigned __int8(__cdecl **)(int))(v20 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v23 = *(_DWORD *)(a1 + 32);
    v24 = *(_BYTE **)v23;
    *v24 = 70;
    *(_DWORD *)v23 = v24 + 1;
    v25 = *(_DWORD *)(v23 + 4) - 1;
    *(_DWORD *)(v23 + 4) = v25;
    if (!v25 && !(*(unsigned __int8(__cdecl **)(int))(v23 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v26 = *(_DWORD *)(a1 + 32);
    v27 = *(_BYTE **)v26;
    *v27 = 73;
    *(_DWORD *)v26 = v27 + 1;
    v28 = *(_DWORD *)(v26 + 4) - 1;
    *(_DWORD *)(v26 + 4) = v28;
    if (!v28 && !(*(unsigned __int8(__cdecl **)(int))(v26 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v29 = *(_DWORD *)(a1 + 32);
    v30 = *(_BYTE **)v29;
    *v30 = 70;
    *(_DWORD *)v29 = v30 + 1;
    v31 = *(_DWORD *)(v29 + 4) - 1;
    *(_DWORD *)(v29 + 4) = v31;
    if (!v31 && !(*(unsigned __int8(__cdecl **)(int))(v29 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v32 = *(_DWORD *)(a1 + 32);
    v33 = *(_BYTE **)v32;
    *v33 = 0;
    *(_DWORD *)v32 = v33 + 1;
    v34 = *(_DWORD *)(v32 + 4) - 1;
    *(_DWORD *)(v32 + 4) = v34;
    if (!v34 && !(*(unsigned __int8(__cdecl **)(int))(v32 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v35 = *(_DWORD *)(a1 + 32);
    v36 = *(_BYTE **)v35;
    *v36 = *(_BYTE *)(a1 + 201);
    *(_DWORD *)v35 = v36 + 1;
    v37 = *(_DWORD *)(v35 + 4) - 1;
    *(_DWORD *)(v35 + 4) = v37;
    if (!v37 && !(*(unsigned __int8(__cdecl **)(int))(v35 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v38 = *(_DWORD *)(a1 + 32);
    v39 = *(_BYTE **)v38;
    *v39 = *(_BYTE *)(a1 + 202);
    *(_DWORD *)v38 = v39 + 1;
    v40 = *(_DWORD *)(v38 + 4) - 1;
    *(_DWORD *)(v38 + 4) = v40;
    if (!v40 && !(*(unsigned __int8(__cdecl **)(int))(v38 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v41 = *(_DWORD *)(a1 + 32);
    v42 = *(_BYTE **)v41;
    *v42 = *(_BYTE *)(a1 + 203);
    *(_DWORD *)v41 = v42 + 1;
    v43 = *(_DWORD *)(v41 + 4) - 1;
    *(_DWORD *)(v41 + 4) = v43;
    if (!v43 && !(*(unsigned __int8(__cdecl **)(int))(v41 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v44 = *(_WORD *)(a1 + 204);
    v45 = *(_DWORD *)(a1 + 32);
    v46 = *(_BYTE **)v45;
    *v46 = HIBYTE(v44);
    *(_DWORD *)v45 = v46 + 1;
    v47 = *(_DWORD *)(v45 + 4) - 1;
    *(_DWORD *)(v45 + 4) = v47;
    if (!v47 && !(*(unsigned __int8(__cdecl **)(int))(v45 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v48 = *(_DWORD *)(a1 + 32);
    v49 = *(_BYTE **)v48;
    *v49 = v44;
    *(_DWORD *)v48 = v49 + 1;
    v50 = *(_DWORD *)(v48 + 4) - 1;
    *(_DWORD *)(v48 + 4) = v50;
    if (!v50 && !(*(unsigned __int8(__cdecl **)(int))(v48 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v51 = *(_WORD *)(a1 + 206);
    v52 = *(_DWORD *)(a1 + 32);
    v53 = *(_BYTE **)v52;
    *v53 = HIBYTE(v51);
    *(_DWORD *)v52 = v53 + 1;
    v54 = *(_DWORD *)(v52 + 4) - 1;
    *(_DWORD *)(v52 + 4) = v54;
    if (!v54 && !(*(unsigned __int8(__cdecl **)(int))(v52 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v55 = *(_DWORD *)(a1 + 32);
    v56 = *(_BYTE **)v55;
    *v56 = v51;
    *(_DWORD *)v55 = v56 + 1;
    v57 = *(_DWORD *)(v55 + 4) - 1;
    *(_DWORD *)(v55 + 4) = v57;
    if (!v57 && !(*(unsigned __int8(__cdecl **)(int))(v55 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v58 = *(_DWORD *)(a1 + 32);
    v59 = *(_BYTE **)v58;
    *v59 = 0;
    *(_DWORD *)v58 = v59 + 1;
    v60 = *(_DWORD *)(v58 + 4) - 1;
    *(_DWORD *)(v58 + 4) = v60;
    if (!v60 && !(*(unsigned __int8(__cdecl **)(int))(v58 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v61 = *(_DWORD *)(a1 + 32);
    v62 = *(_BYTE **)v61;
    *v62 = 0;
    *(_DWORD *)v61 = v62 + 1;
    result = *(_DWORD *)(v61 + 4) - 1;
    *(_DWORD *)(v61 + 4) = result;
    if (!result) {
      result = (*(int(__cdecl **)(int))(v61 + 12))(a1);
      if (!(_BYTE)result) {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
        result = (**(int(__cdecl ***)(int))a1)(a1);
      }
    }
  }
  if (*(_BYTE *)(a1 + 208)) {
    v63 = *(_DWORD *)(a1 + 32);
    v64 = *(_BYTE **)v63;
    *v64 = -1;
    *(_DWORD *)v63 = v64 + 1;
    v65 = *(_DWORD *)(v63 + 4) - 1;
    *(_DWORD *)(v63 + 4) = v65;
    if (!v65 && !(*(unsigned __int8(__cdecl **)(int))(v63 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v66 = *(_DWORD *)(a1 + 32);
    v67 = *(_BYTE **)v66;
    *v67 = -18;
    *(_DWORD *)v66 = v67 + 1;
    v68 = *(_DWORD *)(v66 + 4) - 1;
    *(_DWORD *)(v66 + 4) = v68;
    if (!v68 && !(*(unsigned __int8(__cdecl **)(int))(v66 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v69 = *(_DWORD *)(a1 + 32);
    v70 = *(_BYTE **)v69;
    *v70 = 0;
    *(_DWORD *)v69 = v70 + 1;
    v71 = *(_DWORD *)(v69 + 4) - 1;
    *(_DWORD *)(v69 + 4) = v71;
    if (!v71 && !(*(unsigned __int8(__cdecl **)(int))(v69 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v72 = *(_DWORD *)(a1 + 32);
    v73 = *(_BYTE **)v72;
    *v73 = 14;
    *(_DWORD *)v72 = v73 + 1;
    v74 = *(_DWORD *)(v72 + 4) - 1;
    *(_DWORD *)(v72 + 4) = v74;
    if (!v74 && !(*(unsigned __int8(__cdecl **)(int))(v72 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v75 = *(_DWORD *)(a1 + 32);
    v76 = *(_BYTE **)v75;
    *v76 = 65;
    *(_DWORD *)v75 = v76 + 1;
    v77 = *(_DWORD *)(v75 + 4) - 1;
    *(_DWORD *)(v75 + 4) = v77;
    if (!v77 && !(*(unsigned __int8(__cdecl **)(int))(v75 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v78 = *(_DWORD *)(a1 + 32);
    v79 = *(_BYTE **)v78;
    *v79 = 100;
    *(_DWORD *)v78 = v79 + 1;
    v80 = *(_DWORD *)(v78 + 4) - 1;
    *(_DWORD *)(v78 + 4) = v80;
    if (!v80 && !(*(unsigned __int8(__cdecl **)(int))(v78 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v81 = *(_DWORD *)(a1 + 32);
    v82 = *(_BYTE **)v81;
    *v82 = 111;
    *(_DWORD *)v81 = v82 + 1;
    v83 = *(_DWORD *)(v81 + 4) - 1;
    *(_DWORD *)(v81 + 4) = v83;
    if (!v83 && !(*(unsigned __int8(__cdecl **)(int))(v81 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v84 = *(_DWORD *)(a1 + 32);
    v85 = *(_BYTE **)v84;
    *v85 = 98;
    *(_DWORD *)v84 = v85 + 1;
    v86 = *(_DWORD *)(v84 + 4) - 1;
    *(_DWORD *)(v84 + 4) = v86;
    if (!v86 && !(*(unsigned __int8(__cdecl **)(int))(v84 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v87 = *(_DWORD *)(a1 + 32);
    v88 = *(_BYTE **)v87;
    *v88 = 101;
    *(_DWORD *)v87 = v88 + 1;
    v89 = *(_DWORD *)(v87 + 4) - 1;
    *(_DWORD *)(v87 + 4) = v89;
    if (!v89 && !(*(unsigned __int8(__cdecl **)(int))(v87 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v90 = *(_DWORD *)(a1 + 32);
    v91 = *(_BYTE **)v90;
    *v91 = 0;
    *(_DWORD *)v90 = v91 + 1;
    v92 = *(_DWORD *)(v90 + 4) - 1;
    *(_DWORD *)(v90 + 4) = v92;
    if (!v92 && !(*(unsigned __int8(__cdecl **)(int))(v90 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v93 = *(_DWORD *)(a1 + 32);
    v94 = *(_BYTE **)v93;
    *v94 = 100;
    *(_DWORD *)v93 = v94 + 1;
    v95 = *(_DWORD *)(v93 + 4) - 1;
    *(_DWORD *)(v93 + 4) = v95;
    if (!v95 && !(*(unsigned __int8(__cdecl **)(int))(v93 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v96 = *(_DWORD *)(a1 + 32);
    v97 = *(_BYTE **)v96;
    *v97 = 0;
    *(_DWORD *)v96 = v97 + 1;
    v98 = *(_DWORD *)(v96 + 4) - 1;
    *(_DWORD *)(v96 + 4) = v98;
    if (!v98 && !(*(unsigned __int8(__cdecl **)(int))(v96 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v99 = *(_DWORD *)(a1 + 32);
    v100 = *(_BYTE **)v99;
    *v100 = 0;
    *(_DWORD *)v99 = v100 + 1;
    v101 = *(_DWORD *)(v99 + 4) - 1;
    *(_DWORD *)(v99 + 4) = v101;
    if (!v101 && !(*(unsigned __int8(__cdecl **)(int))(v99 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v102 = *(_DWORD *)(a1 + 32);
    v103 = *(_BYTE **)v102;
    *v103 = 0;
    *(_DWORD *)v102 = v103 + 1;
    v104 = *(_DWORD *)(v102 + 4) - 1;
    *(_DWORD *)(v102 + 4) = v104;
    if (!v104 && !(*(unsigned __int8(__cdecl **)(int))(v102 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v105 = *(_DWORD *)(a1 + 32);
    v106 = *(_BYTE **)v105;
    *v106 = 0;
    *(_DWORD *)v105 = v106 + 1;
    v107 = *(_DWORD *)(v105 + 4) - 1;
    *(_DWORD *)(v105 + 4) = v107;
    if (!v107 && !(*(unsigned __int8(__cdecl **)(int))(v105 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v108 = *(_DWORD *)(a1 + 68);
    if (v108 == 3) {
      v109 = *(_DWORD *)(a1 + 32);
      v110 = *(_BYTE **)v109;
      **(_BYTE **)v109 = 1;
    } else {
      v109 = *(_DWORD *)(a1 + 32);
      if (v108 == 5) {
        v110 = *(_BYTE **)v109;
        **(_BYTE **)v109 = 2;
      } else {
        v110 = *(_BYTE **)v109;
        **(_BYTE **)v109 = 0;
      }
    }
    *(_DWORD *)v109 = v110 + 1;
    result = *(_DWORD *)(v109 + 4) - 1;
    *(_DWORD *)(v109 + 4) = result;
    if (!result) {
      result = (*(int(__cdecl **)(int))(v109 + 12))(a1);
      if (!(_BYTE)result) {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
        return (**(int(__cdecl ***)(int))a1)(a1);
      }
    }
  }
  return result;
}

int __cdecl write_scan_header(int a1) {
  int v1;      // edx
  int v2;      // edx
  _BYTE *v3;   // eax
  int v4;      // eax
  int v5;      // edx
  _BYTE *v6;   // eax
  int v7;      // eax
  int v8;      // edx
  _BYTE *v9;   // eax
  int v10;     // eax
  int v11;     // edx
  _BYTE *v12;  // eax
  int v13;     // eax
  int v14;     // esi
  int v15;     // ecx
  _BYTE *v16;  // eax
  int v17;     // eax
  int v18;     // edx
  _BYTE *v19;  // eax
  int v20;     // eax
  int v21;     // edx
  _BYTE *v22;  // eax
  int v23;     // eax
  int v24;     // edx
  _BYTE *v25;  // eax
  int v26;     // eax
  int v27;     // esi
  int v28;     // ecx
  _BYTE *v29;  // eax
  int v30;     // eax
  int v31;     // edx
  _BYTE *v32;  // eax
  int v33;     // eax
  int v34;     // ecx
  _BYTE *v35;  // eax
  int v36;     // eax
  int j;       // eax
  char v38;    // dl
  int v39;     // ecx
  _BYTE *v40;  // eax
  int v41;     // eax
  _DWORD *v42; // esi
  int v43;     // ecx
  _BYTE *v44;  // eax
  int v45;     // eax
  int v46;     // eax
  int v47;     // esi
  char v48;    // dl
  _BYTE *v49;  // eax
  int v50;     // eax
  int v51;     // ecx
  _BYTE *v52;  // eax
  int v53;     // eax
  int v54;     // ecx
  _BYTE *v55;  // eax
  int v56;     // eax
  int v57;     // ecx
  _BYTE *v58;  // eax
  int result;  // eax
  int i;       // edx
  int v61;     // esi
  int v62;     // [esp+2Ch] [ebp-1Ch]
  int v63;     // [esp+30h] [ebp-18h]
  int v64;     // [esp+34h] [ebp-14h]
  int v65;     // [esp+38h] [ebp-10h]
  int v66;     // [esp+3Ch] [ebp-Ch]

  v62 = *(_DWORD *)(a1 + 336);
  if (*(_BYTE *)(a1 + 181)) {
    v1 = *(_DWORD *)(a1 + 336);
    goto LABEL_3;
  }
  if (*(int *)(a1 + 232) > 0) {
    v66 = a1;
    v63 = 0;
    for (i = a1;; i = v66) {
      v61 = *(_DWORD *)(i + 236);
      if (!*(_BYTE *)(a1 + 216))
        break;
      if (*(_DWORD *)(a1 + 304))
        goto LABEL_47;
      if (!*(_DWORD *)(a1 + 312))
        emit_dht((_DWORD *)a1, *(_DWORD *)(v61 + 20), 0);
      ++v63;
      v66 += 4;
      if (*(_DWORD *)(a1 + 232) <= v63)
        goto LABEL_48;
    LABEL_44:;
    }
    emit_dht((_DWORD *)a1, *(_DWORD *)(v61 + 20), 0);
  LABEL_47:
    emit_dht((_DWORD *)a1, *(_DWORD *)(v61 + 24), 1);
    ++v63;
    v66 += 4;
    if (*(_DWORD *)(a1 + 232) <= v63)
      goto LABEL_48;
    goto LABEL_44;
  }
LABEL_48:
  v1 = v62;
LABEL_3:
  if (*(_DWORD *)(a1 + 192) != *(_DWORD *)(v1 + 28)) {
    v2 = *(_DWORD *)(a1 + 32);
    v3 = *(_BYTE **)v2;
    *v3 = -1;
    *(_DWORD *)v2 = v3 + 1;
    v4 = *(_DWORD *)(v2 + 4) - 1;
    *(_DWORD *)(v2 + 4) = v4;
    if (!v4 && !(*(unsigned __int8(__cdecl **)(int))(v2 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v5 = *(_DWORD *)(a1 + 32);
    v6 = *(_BYTE **)v5;
    *v6 = -35;
    *(_DWORD *)v5 = v6 + 1;
    v7 = *(_DWORD *)(v5 + 4) - 1;
    *(_DWORD *)(v5 + 4) = v7;
    if (!v7 && !(*(unsigned __int8(__cdecl **)(int))(v5 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v8 = *(_DWORD *)(a1 + 32);
    v9 = *(_BYTE **)v8;
    *v9 = 0;
    *(_DWORD *)v8 = v9 + 1;
    v10 = *(_DWORD *)(v8 + 4) - 1;
    *(_DWORD *)(v8 + 4) = v10;
    if (!v10 && !(*(unsigned __int8(__cdecl **)(int))(v8 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v11 = *(_DWORD *)(a1 + 32);
    v12 = *(_BYTE **)v11;
    *v12 = 4;
    *(_DWORD *)v11 = v12 + 1;
    v13 = *(_DWORD *)(v11 + 4) - 1;
    *(_DWORD *)(v11 + 4) = v13;
    if (!v13 && !(*(unsigned __int8(__cdecl **)(int))(v11 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v14 = *(_DWORD *)(a1 + 192);
    v15 = *(_DWORD *)(a1 + 32);
    v16 = *(_BYTE **)v15;
    *v16 = BYTE1(v14);
    *(_DWORD *)v15 = v16 + 1;
    v17 = *(_DWORD *)(v15 + 4) - 1;
    *(_DWORD *)(v15 + 4) = v17;
    if (!v17 && !(*(unsigned __int8(__cdecl **)(int))(v15 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v18 = *(_DWORD *)(a1 + 32);
    v19 = *(_BYTE **)v18;
    *v19 = v14;
    *(_DWORD *)v18 = v19 + 1;
    v20 = *(_DWORD *)(v18 + 4) - 1;
    *(_DWORD *)(v18 + 4) = v20;
    if (!v20 && !(*(unsigned __int8(__cdecl **)(int))(v18 + 12))(a1)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    *(_DWORD *)(v62 + 28) = *(_DWORD *)(a1 + 192);
  }
  v21 = *(_DWORD *)(a1 + 32);
  v22 = *(_BYTE **)v21;
  *v22 = -1;
  *(_DWORD *)v21 = v22 + 1;
  v23 = *(_DWORD *)(v21 + 4) - 1;
  *(_DWORD *)(v21 + 4) = v23;
  if (!v23 && !(*(unsigned __int8(__cdecl **)(int))(v21 + 12))(a1)) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  v24 = *(_DWORD *)(a1 + 32);
  v25 = *(_BYTE **)v24;
  *v25 = -38;
  *(_DWORD *)v24 = v25 + 1;
  v26 = *(_DWORD *)(v24 + 4) - 1;
  *(_DWORD *)(v24 + 4) = v26;
  if (!v26 && !(*(unsigned __int8(__cdecl **)(int))(v24 + 12))(a1)) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  v27 = 2 * *(_DWORD *)(a1 + 232) + 6;
  v28 = *(_DWORD *)(a1 + 32);
  v29 = *(_BYTE **)v28;
  *v29 = (unsigned __int16)(2 * *(_WORD *)(a1 + 232) + 6) >> 8;
  *(_DWORD *)v28 = v29 + 1;
  v30 = *(_DWORD *)(v28 + 4) - 1;
  *(_DWORD *)(v28 + 4) = v30;
  if (!v30 && !(*(unsigned __int8(__cdecl **)(int))(v28 + 12))(a1)) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  v31 = *(_DWORD *)(a1 + 32);
  v32 = *(_BYTE **)v31;
  *v32 = v27;
  *(_DWORD *)v31 = v32 + 1;
  v33 = *(_DWORD *)(v31 + 4) - 1;
  *(_DWORD *)(v31 + 4) = v33;
  if (!v33 && !(*(unsigned __int8(__cdecl **)(int))(v31 + 12))(a1)) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  v34 = *(_DWORD *)(a1 + 32);
  v35 = *(_BYTE **)v34;
  *v35 = *(_DWORD *)(a1 + 232);
  *(_DWORD *)v34 = v35 + 1;
  v36 = *(_DWORD *)(v34 + 4) - 1;
  *(_DWORD *)(v34 + 4) = v36;
  if (!v36 && !(*(unsigned __int8(__cdecl **)(int))(v34 + 12))(a1)) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  if (*(int *)(a1 + 232) > 0) {
    v65 = a1;
    v64 = 0;
    for (j = a1;; j = v65) {
      v42 = *(_DWORD **)(j + 236);
      v43 = *(_DWORD *)(a1 + 32);
      v44 = *(_BYTE **)v43;
      *v44 = *v42;
      *(_DWORD *)v43 = v44 + 1;
      v45 = *(_DWORD *)(v43 + 4) - 1;
      *(_DWORD *)(v43 + 4) = v45;
      if (!v45 && !(*(unsigned __int8(__cdecl **)(int))(v43 + 12))(a1)) {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
        (**(void(__cdecl ***)(int))a1)(a1);
      }
      v46 = v42[5];
      v47 = v42[6];
      if (!*(_BYTE *)(a1 + 216))
        break;
      if (*(_DWORD *)(a1 + 304))
        goto LABEL_35;
      if (*(_DWORD *)(a1 + 312) && !*(_BYTE *)(a1 + 181)) {
        LOBYTE(v47) = 0;
      LABEL_35:
        v38 = 0;
      LABEL_19:
        v39 = *(_DWORD *)(a1 + 32);
        v40 = *(_BYTE **)v39;
        *v40 = v47 + v38;
        *(_DWORD *)v39 = v40 + 1;
        v41 = *(_DWORD *)(v39 + 4) - 1;
        *(_DWORD *)(v39 + 4) = v41;
        if (v41)
          goto LABEL_20;
        goto LABEL_28;
      }
      v48 = 16 * v46;
      v39 = *(_DWORD *)(a1 + 32);
      v49 = *(_BYTE **)v39;
      *v49 = v48;
      *(_DWORD *)v39 = v49 + 1;
      v50 = *(_DWORD *)(v39 + 4) - 1;
      *(_DWORD *)(v39 + 4) = v50;
      if (v50)
        goto LABEL_20;
    LABEL_28:
      if ((*(unsigned __int8(__cdecl **)(int))(v39 + 12))(a1)) {
      LABEL_20:
        ++v64;
        v65 += 4;
        if (*(_DWORD *)(a1 + 232) <= v64)
          goto LABEL_30;
        continue;
      }
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      (**(void(__cdecl ***)(int))a1)(a1);
      ++v64;
      v65 += 4;
      if (*(_DWORD *)(a1 + 232) <= v64)
        goto LABEL_30;
    }
    v38 = 16 * v46;
    goto LABEL_19;
  }
LABEL_30:
  v51 = *(_DWORD *)(a1 + 32);
  v52 = *(_BYTE **)v51;
  *v52 = *(_DWORD *)(a1 + 304);
  *(_DWORD *)v51 = v52 + 1;
  v53 = *(_DWORD *)(v51 + 4) - 1;
  *(_DWORD *)(v51 + 4) = v53;
  if (!v53 && !(*(unsigned __int8(__cdecl **)(int))(v51 + 12))(a1)) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  v54 = *(_DWORD *)(a1 + 32);
  v55 = *(_BYTE **)v54;
  *v55 = *(_DWORD *)(a1 + 308);
  *(_DWORD *)v54 = v55 + 1;
  v56 = *(_DWORD *)(v54 + 4) - 1;
  *(_DWORD *)(v54 + 4) = v56;
  if (!v56 && !(*(unsigned __int8(__cdecl **)(int))(v54 + 12))(a1)) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  v57 = *(_DWORD *)(a1 + 32);
  v58 = *(_BYTE **)v57;
  *v58 = *(_BYTE *)(a1 + 316) + 16 * *(_BYTE *)(a1 + 312);
  *(_DWORD *)v57 = v58 + 1;
  result = *(_DWORD *)(v57 + 4) - 1;
  *(_DWORD *)(v57 + 4) = result;
  if (!result) {
    result = (*(int(__cdecl **)(int))(v57 + 12))(a1);
    if (!(_BYTE)result) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      return (**(int(__cdecl ***)(int))a1)(a1);
    }
  }
  return result;
}

int __cdecl write_tables_only(_DWORD *a1) {
  int v1;      // edx
  _BYTE *v2;   // eax
  int v3;      // eax
  int v4;      // edx
  _BYTE *v5;   // eax
  int v6;      // eax
  _DWORD *v7;  // esi
  int i;       // edi
  _DWORD *v9;  // eax
  _DWORD *v10; // esi
  int v11;     // edx
  _BYTE *v12;  // eax
  int v13;     // eax
  int v14;     // edx
  _BYTE *v15;  // eax
  int result;  // eax

  v1 = a1[8];
  v2 = *(_BYTE **)v1;
  *v2 = -1;
  *(_DWORD *)v1 = v2 + 1;
  v3 = *(_DWORD *)(v1 + 4) - 1;
  *(_DWORD *)(v1 + 4) = v3;
  if (!v3 && !(*(unsigned __int8(__cdecl **)(_DWORD *))(v1 + 12))(a1)) {
    *(_DWORD *)(*a1 + 20) = 24;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  v4 = a1[8];
  v5 = *(_BYTE **)v4;
  *v5 = -40;
  *(_DWORD *)v4 = v5 + 1;
  v6 = *(_DWORD *)(v4 + 4) - 1;
  *(_DWORD *)(v4 + 4) = v6;
  if (!v6 && !(*(unsigned __int8(__cdecl **)(_DWORD *))(v4 + 12))(a1)) {
    *(_DWORD *)(*a1 + 20) = 24;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  v7 = a1;
  for (i = 0; i != 4; ++i) {
    if (v7[19])
      emit_dqt(a1, i);
    ++v7;
  }
  v9 = a1;
  if (!*((_BYTE *)a1 + 181)) {
    v10 = a1;
    LOWORD(i) = 0;
    do {
      if (v10[23])
        emit_dht(a1, i, 0);
      if (v10[27])
        emit_dht(a1, i, 1);
      ++i;
      ++v10;
    } while (i != 4);
    v9 = a1;
  }
  v11 = v9[8];
  v12 = *(_BYTE **)v11;
  *v12 = -1;
  *(_DWORD *)v11 = v12 + 1;
  v13 = *(_DWORD *)(v11 + 4) - 1;
  *(_DWORD *)(v11 + 4) = v13;
  if (!v13 && !(*(unsigned __int8(__cdecl **)(_DWORD *))(v11 + 12))(a1)) {
    *(_DWORD *)(*a1 + 20) = 24;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  v14 = a1[8];
  v15 = *(_BYTE **)v14;
  *v15 = -39;
  *(_DWORD *)v14 = v15 + 1;
  result = *(_DWORD *)(v14 + 4) - 1;
  *(_DWORD *)(v14 + 4) = result;
  if (!result) {
    result = (*(int(__cdecl **)(_DWORD *))(v14 + 12))(a1);
    if (!(_BYTE)result) {
      *(_DWORD *)(*a1 + 20) = 24;
      return (*(int(__cdecl **)(_DWORD *)) * a1)(a1);
    }
  }
  return result;
}

int __cdecl write_frame_header(int a1) {
  int v1;  // esi
  int v2;  // eax
  char v3; // si
  int v5;  // edx
  int v6;  // ecx
  int v7;  // [esp+18h] [ebp-10h]
  int v8;  // [esp+1Ch] [ebp-Ch]

  v1 = *(_DWORD *)(a1 + 72);
  v2 = *(_DWORD *)(a1 + 64);
  if (v2 > 0) {
    v7 = 0;
    v8 = 0;
    do {
      v8 += emit_dqt((_DWORD *)a1, *(_DWORD *)(v1 + 16));
      ++v7;
      v1 += 84;
      v2 = *(_DWORD *)(a1 + 64);
    } while (v7 < v2);
  } else {
    v8 = 0;
  }
  if (*(_BYTE *)(a1 + 181))
    return emit_sof((_DWORD *)a1, 201);
  if (*(_BYTE *)(a1 + 216) || *(_DWORD *)(a1 + 60) != 8) {
    v3 = 0;
  } else {
    v5 = *(_DWORD *)(a1 + 72);
    if (v2 > 0) {
      v6 = 0;
      v3 = 1;
      do {
        if (*(int *)(v5 + 20) > 1 || *(int *)(v5 + 24) > 1)
          v3 = 0;
        ++v6;
        v5 += 84;
      } while (v2 != v6);
    } else {
      v3 = 1;
    }
    if (v8 && v3) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 75;
      (*(void(__cdecl **)(int, _DWORD))(*(_DWORD *)a1 + 4))(a1, 0);
      v3 = 0;
    }
  }
  if (*(_BYTE *)(a1 + 181))
    return emit_sof((_DWORD *)a1, 201);
  if (*(_BYTE *)(a1 + 216))
    return emit_sof((_DWORD *)a1, 194);
  if (v3)
    return emit_sof((_DWORD *)a1, 192);
  return emit_sof((_DWORD *)a1, 193);
}

int __cdecl write_marker_header(_DWORD *a1, char a2, unsigned int a3) {
  int v3;     // edx
  _BYTE *v4;  // eax
  int v5;     // eax
  int v6;     // edx
  _BYTE *v7;  // eax
  int v8;     // eax
  int v9;     // ecx
  _BYTE *v10; // eax
  int v11;    // eax
  int v12;    // edx
  _BYTE *v13; // eax
  int result; // eax

  if (a3 > 0xFFFD) {
    *(_DWORD *)(*a1 + 20) = 11;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  v3 = a1[8];
  v4 = *(_BYTE **)v3;
  *v4 = -1;
  *(_DWORD *)v3 = v4 + 1;
  v5 = *(_DWORD *)(v3 + 4) - 1;
  *(_DWORD *)(v3 + 4) = v5;
  if (!v5 && !(*(unsigned __int8(__cdecl **)(_DWORD *))(v3 + 12))(a1)) {
    *(_DWORD *)(*a1 + 20) = 24;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  v6 = a1[8];
  v7 = *(_BYTE **)v6;
  *v7 = a2;
  *(_DWORD *)v6 = v7 + 1;
  v8 = *(_DWORD *)(v6 + 4) - 1;
  *(_DWORD *)(v6 + 4) = v8;
  if (!v8 && !(*(unsigned __int8(__cdecl **)(_DWORD *))(v6 + 12))(a1)) {
    *(_DWORD *)(*a1 + 20) = 24;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  v9 = a1[8];
  v10 = *(_BYTE **)v9;
  *v10 = (unsigned __int16)(a3 + 2) >> 8;
  *(_DWORD *)v9 = v10 + 1;
  v11 = *(_DWORD *)(v9 + 4) - 1;
  *(_DWORD *)(v9 + 4) = v11;
  if (!v11 && !(*(unsigned __int8(__cdecl **)(_DWORD *))(v9 + 12))(a1)) {
    *(_DWORD *)(*a1 + 20) = 24;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  v12 = a1[8];
  v13 = *(_BYTE **)v12;
  *v13 = a3 + 2;
  *(_DWORD *)v12 = v13 + 1;
  result = *(_DWORD *)(v12 + 4) - 1;
  *(_DWORD *)(v12 + 4) = result;
  if (!result) {
    result = (*(int(__cdecl **)(_DWORD *))(v12 + 12))(a1);
    if (!(_BYTE)result) {
      *(_DWORD *)(*a1 + 20) = 24;
      return (*(int(__cdecl **)(_DWORD *)) * a1)(a1);
    }
  }
  return result;
}

_DWORD *__cdecl free_pool(_DWORD *a1, unsigned int a2) {
  _DWORD *v2;     // eax
  _DWORD *v3;     // edi
  int v4;         // esi
  _DWORD *result; // eax
  _DWORD *v6;     // edi
  int v7;         // esi
  int v8;         // esi
  int i;          // esi
  _DWORD *v10;    // ecx
  _DWORD *v11;    // [esp+1Ch] [ebp-Ch]

  v11 = (_DWORD *)a1[1];
  if (a2 > 1) {
    *(_DWORD *)(*a1 + 20) = 14;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  if (a2 == 1) {
    v8 = v11[17];
    if (v8) {
      do {
        while (!*(_BYTE *)(v8 + 34)) {
          v8 = *(_DWORD *)(v8 + 36);
          if (!v8)
            goto LABEL_18;
        }
        *(_BYTE *)(v8 + 34) = 0;
        (*(void(__cdecl **)(_DWORD *, int))(v8 + 48))(a1, v8 + 40);
        v8 = *(_DWORD *)(v8 + 36);
      } while (v8);
    LABEL_18:
      v10 = v11;
    } else {
      v10 = v11;
    }
    v10[17] = 0;
    for (i = v10[18]; i; i = *(_DWORD *)(i + 36)) {
      while (!*(_BYTE *)(i + 34)) {
        i = *(_DWORD *)(i + 36);
        if (!i)
          goto LABEL_24;
      }
      *(_BYTE *)(i + 34) = 0;
      (*(void(__cdecl **)(_DWORD *, int))(i + 48))(a1, i + 40);
    }
  LABEL_24:
    v11[18] = 0;
  }
  v2 = (_DWORD *)v11[a2 + 15];
  v11[a2 + 15] = 0;
  if (v2) {
    while (1) {
      v3 = (_DWORD *)*v2;
      v4 = v2[2] + v2[1] + 12;
      jpeg_free_large((int)a1, (int)v2, v4);
      v11[19] -= v4;
      if (!v3)
        break;
      v2 = v3;
    }
  }
  result = (_DWORD *)v11[a2 + 13];
  v11[a2 + 13] = 0;
  if (result) {
    while (1) {
      v6 = (_DWORD *)*result;
      v7 = result[2] + result[1] + 12;
      result = (_DWORD *)jpeg_free_small((int)a1, (int)result, v7);
      v11[19] -= v7;
      if (!v6)
        break;
      result = v6;
    }
  }
  return result;
}

void __cdecl self_destruct(_DWORD *a1) {
  unsigned int i; // esi

  for (i = 1; i != -1; --i)
    free_pool(a1, i);
  jpeg_free_small((int)a1, a1[1], 84);
  a1[1] = 0;
  jpeg_mem_term();
}

_DWORD *__cdecl jinit_memory_mgr(_DWORD *a1) {
  _DWORD *small;  // esi
  _DWORD *result; // eax
  int v3;         // edx
  int v4;         // [esp+1Ch] [ebp-1Ch]

  a1[1] = 0;
  v4 = jpeg_mem_init();
  small = (_DWORD *)jpeg_get_small((int)a1, 84);
  if (!small) {
    jpeg_mem_term();
    *(_DWORD *)(*a1 + 20) = 54;
    *(_DWORD *)(*a1 + 24) = 0;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  *small = alloc_small;
  small[1] = alloc_large;
  small[2] = alloc_sarray;
  small[3] = alloc_barray;
  small[4] = request_virt_sarray;
  small[5] = request_virt_barray;
  small[6] = realize_virt_arrays;
  small[7] = access_virt_sarray;
  small[8] = access_virt_barray;
  small[9] = free_pool;
  small[10] = self_destruct;
  small[12] = 1000000000;
  small[11] = v4;
  result = small;
  v3 = 2;
  do {
    result[14] = 0;
    result[16] = 0;
    --result;
    --v3;
  } while (v3);
  small[17] = 0;
  small[18] = 0;
  small[19] = 84;
  a1[1] = small;
  return result;
}

int __cdecl alloc_small(_DWORD *a1, unsigned int a2, unsigned int a3) {
  _DWORD *v3;       // eax
  _DWORD *small;    // ecx
  unsigned int v5;  // edx
  int v6;           // eax
  _DWORD *v8;       // ecx
  int v9;           // eax
  unsigned int v10; // eax
  unsigned int v11; // edi
  unsigned int v12; // esi
  int v13;          // eax
  int v14;          // [esp+14h] [ebp-24h]
  _DWORD *v15;      // [esp+18h] [ebp-20h]
  unsigned int v16; // [esp+1Ch] [ebp-1Ch]

  v14 = a1[1];
  if (a3 > 0x3B9AC9F4) {
    *(_DWORD *)(*a1 + 20) = 54;
    *(_DWORD *)(*a1 + 24) = 1;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  if ((a3 & 7) != 0)
    a3 = a3 - (a3 & 7) + 8;
  if (a2 > 1) {
    *(_DWORD *)(*a1 + 20) = 14;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  v3 = *(_DWORD **)(v14 + 4 * a2 + 52);
  if (v3) {
    if (a3 <= v3[2]) {
      small = *(_DWORD **)(v14 + 4 * a2 + 52);
      v5 = a3;
    LABEL_10:
      v6 = small[1];
      small[1] = v6 + v5;
      small[2] -= a3;
      return (int)small + v6 + 12;
    }
    while (1) {
      v8 = (_DWORD *)*v3;
      if (!*v3)
        break;
      if (a3 <= v8[2]) {
        v9 = v8[1];
        v8[1] = v9 + a3;
        v8[2] -= a3;
        return (int)v8 + v9 + 12;
      }
      v3 = (_DWORD *)*v3;
    }
    v15 = v3;
  } else {
    v15 = 0;
  }
  v16 = a3 + 12;
  if (v15)
    v10 = extra_pool_slop[a2];
  else
    v10 = first_pool_slop[a2];
  v11 = 1000000000 - v16;
  if (v10 <= 1000000000 - v16)
    v11 = v10;
  while (1) {
    v12 = v11 + v16;
    small = (_DWORD *)jpeg_get_small((int)a1, v11 + v16);
    if (small)
      break;
    while (1) {
      v11 >>= 1;
      if (v11 > 0x31)
        break;
      *(_DWORD *)(*a1 + 20) = 54;
      *(_DWORD *)(*a1 + 24) = 2;
      (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
      v12 = v11 + v16;
      small = (_DWORD *)jpeg_get_small((int)a1, v11 + v16);
      if (small)
        goto LABEL_23;
    }
  }
LABEL_23:
  *(_DWORD *)(v14 + 76) += v12;
  *small = 0;
  small[1] = 0;
  small[2] = v11 + a3;
  if (!v15) {
    *(_DWORD *)(v14 + 4 * a2 + 52) = small;
    v5 = a3;
    goto LABEL_10;
  }
  *v15 = small;
  v13 = small[1];
  small[1] = v13 + a3;
  small[2] -= a3;
  return (int)small + v13 + 12;
}

int __cdecl request_virt_barray(_DWORD *a1, unsigned int a2, char a3, int a4,
                                int a5, int a6) {
  int result; // eax
  int v7;     // [esp+1Ch] [ebp-Ch]

  v7 = a1[1];
  if (a2 != 1) {
    *(_DWORD *)(*a1 + 20) = 14;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  result = alloc_small(a1, a2, 0x78u);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = a5;
  *(_DWORD *)(result + 8) = a4;
  *(_DWORD *)(result + 12) = a6;
  *(_BYTE *)(result + 32) = a3;
  *(_BYTE *)(result + 34) = 0;
  *(_DWORD *)(result + 36) = *(_DWORD *)(v7 + 72);
  *(_DWORD *)(v7 + 72) = result;
  return result;
}

int __cdecl request_virt_sarray(_DWORD *a1, unsigned int a2, char a3, int a4,
                                int a5, int a6) {
  int result; // eax
  int v7;     // [esp+1Ch] [ebp-Ch]

  v7 = a1[1];
  if (a2 != 1) {
    *(_DWORD *)(*a1 + 20) = 14;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  result = alloc_small(a1, a2, 0x78u);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = a5;
  *(_DWORD *)(result + 8) = a4;
  *(_DWORD *)(result + 12) = a6;
  *(_BYTE *)(result + 32) = a3;
  *(_BYTE *)(result + 34) = 0;
  *(_DWORD *)(result + 36) = *(_DWORD *)(v7 + 68);
  *(_DWORD *)(v7 + 68) = result;
  return result;
}

_DWORD *__cdecl alloc_large(_DWORD *a1, unsigned int a2, unsigned int a3) {
  int v3;        // edi
  _DWORD *large; // esi
  int v6;        // [esp+1Ch] [ebp-Ch]

  v3 = a3;
  v6 = a1[1];
  if (a3 > 0x3B9AC9F4) {
    *(_DWORD *)(*a1 + 20) = 54;
    *(_DWORD *)(*a1 + 24) = 3;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  if ((a3 & 7) != 0)
    v3 = a3 - (a3 & 7) + 8;
  if (a2 > 1) {
    *(_DWORD *)(*a1 + 20) = 14;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  large = (_DWORD *)jpeg_get_large((int)a1, v3 + 12);
  if (!large) {
    *(_DWORD *)(*a1 + 20) = 54;
    *(_DWORD *)(*a1 + 24) = 4;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  *(_DWORD *)(v6 + 76) += v3 + 12;
  *large = *(_DWORD *)(v6 + 4 * a2 + 60);
  large[1] = v3;
  large[2] = 0;
  *(_DWORD *)(v6 + 4 * a2 + 60) = large;
  return large + 3;
}

int __cdecl alloc_barray(_DWORD *a1, unsigned int a2, int a3, signed int a4) {
  signed int v4;   // esi
  int result;      // eax
  unsigned int v6; // edi
  _DWORD *v7;      // eax
  _DWORD *v8;      // edx
  int i;           // ecx
  int v10;         // [esp+14h] [ebp-14h]
  int v11;         // [esp+18h] [ebp-10h]

  v10 = a1[1];
  v4 = 0x3B9AC9F4u / (a3 << 7);
  if (v4 <= 0) {
    *(_DWORD *)(*a1 + 20) = 70;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  if (v4 >= a4)
    v4 = a4;
  *(_DWORD *)(v10 + 80) = v4;
  result = alloc_small(a1, a2, 4 * a4);
  v11 = result;
  if (a4) {
    v6 = 0;
    do {
      if (v4 > a4 - v6)
        v4 = a4 - v6;
      v7 = alloc_large(a1, a2, (v4 * a3) << 7);
      if (v4) {
        v8 = (_DWORD *)(v11 + 4 * v6);
        for (i = 0; i != v4; ++i) {
          *v8 = v7;
          ++v6;
          v7 += 32 * a3;
          ++v8;
        }
      }
    } while (a4 > v6);
    return v11;
  }
  return result;
}

int __cdecl alloc_sarray(_DWORD *a1, unsigned int a2, unsigned int a3,
                         unsigned int a4) {
  int v4;          // edi
  unsigned int v5; // esi
  int result;      // eax
  unsigned int v7; // edi
  _DWORD *v8;      // eax
  _DWORD *v9;      // edx
  int i;           // ecx
  int v11;         // [esp+1Ch] [ebp-Ch]

  v4 = a1[1];
  v5 = 0x3B9AC9F4 / a3;
  if ((int)(0x3B9AC9F4 / a3) <= 0) {
    *(_DWORD *)(*a1 + 20) = 70;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  if ((int)v5 >= (int)a4)
    v5 = a4;
  *(_DWORD *)(v4 + 80) = v5;
  result = alloc_small(a1, a2, 4 * a4);
  v11 = result;
  if (a4) {
    v7 = 0;
    do {
      if (v5 > a4 - v7)
        v5 = a4 - v7;
      v8 = alloc_large(a1, a2, v5 * a3);
      if (v5) {
        v9 = (_DWORD *)(v11 + 4 * v7);
        for (i = 0; i != v5; ++i) {
          *v9 = v8;
          ++v7;
          v8 = (_DWORD *)((char *)v8 + a3);
          ++v9;
        }
      }
    } while (a4 > v7);
    return v11;
  }
  return result;
}

int __cdecl access_virt_sarray(int a1, int a2, unsigned int a3, unsigned int a4,
                               char a5) {
  unsigned int v5;  // ecx
  unsigned int v6;  // esi
  unsigned int v7;  // eax
  int v8;           // edx
  int v9;           // ecx
  _DWORD *v10;      // edx
  int v12;          // eax
  int v13;          // ecx
  int v14;          // eax
  int v15;          // edi
  int v16;          // ecx
  int v17;          // eax
  int v18;          // edx
  int v19;          // edi
  int v20;          // esi
  int v21;          // edx
  int v22;          // eax
  int v23;          // eax
  int v24;          // eax
  int v25;          // ecx
  int v26;          // eax
  int v27;          // edx
  int v28;          // esi
  int v29;          // edx
  int v30;          // eax
  unsigned int v31; // eax
  unsigned int v32; // eax
  int v33;          // esi
  int v34;          // edi
  int v35;          // [esp+28h] [ebp-40h]
  int v36;          // [esp+28h] [ebp-40h]
  int v37;          // [esp+3Ch] [ebp-2Ch]
  unsigned int v38; // [esp+44h] [ebp-24h]
  unsigned int v39; // [esp+4Ch] [ebp-1Ch]
  int v40;          // [esp+50h] [ebp-18h]
  int v41;          // [esp+54h] [ebp-14h]
  int v42;          // [esp+58h] [ebp-10h]
  size_t __len;     // [esp+5Ch] [ebp-Ch]

  v39 = a4 + a3;
  if (a4 + a3 > *(_DWORD *)(a2 + 4) || a4 > *(_DWORD *)(a2 + 12) ||
      !*(_DWORD *)a2) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 22;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  v5 = *(_DWORD *)(a2 + 24);
  if (a3 >= v5) {
    if (v39 <= *(_DWORD *)(a2 + 16) + v5) {
      v6 = *(_DWORD *)(a2 + 28);
      goto LABEL_7;
    }
    v12 = a2;
    if (!*(_BYTE *)(a2 + 34))
      goto LABEL_63;
  LABEL_16:
    v13 = v12;
    goto LABEL_17;
  }
  v12 = a2;
  if (*(_BYTE *)(a2 + 34))
    goto LABEL_16;
LABEL_63:
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 69;
  (**(void(__cdecl ***)(int))a1)(a1);
  v13 = a2;
LABEL_17:
  if (*(_BYTE *)(v13 + 33)) {
    v37 = *(_DWORD *)(v13 + 8);
    v24 = v13;
    v25 = *(_DWORD *)(v13 + 24);
    v40 = v25 * v37;
    v15 = *(_DWORD *)(v24 + 16);
    if (v15 <= 0) {
      v6 = *(_DWORD *)(v24 + 28);
    } else {
      v26 = *(_DWORD *)(a2 + 20);
      if (v26 > v15)
        v26 = v15;
      v6 = *(_DWORD *)(a2 + 28);
      if (v26 > (int)(v6 - v25))
        v26 = *(_DWORD *)(a2 + 28) - v25;
      v27 = v26;
      if (v26 > *(_DWORD *)(a2 + 4) - v25)
        v27 = *(_DWORD *)(a2 + 4) - v25;
      if (v27 > 0) {
        v41 = 0;
        while (1) {
          v28 = v27 * v37;
          (*(void(__cdecl **)(int, int, _DWORD, int, int))(a2 + 44))(
              a1, a2 + 40, *(_DWORD *)(*(_DWORD *)a2 + 4 * v41), v40,
              v27 * v37);
          v40 += v28;
          v29 = *(_DWORD *)(a2 + 20);
          v41 += v29;
          v15 = *(_DWORD *)(a2 + 16);
          if (v15 <= v41)
            break;
          v30 = v15 - v41;
          if (v29 <= v15 - v41)
            v30 = *(_DWORD *)(a2 + 20);
          v36 = *(_DWORD *)(a2 + 24) + v41;
          v6 = *(_DWORD *)(a2 + 28);
          v27 = v6 - v36;
          if (v30 <= (int)(v6 - v36))
            v27 = v30;
          if (v27 > *(_DWORD *)(a2 + 4) - v36)
            v27 = *(_DWORD *)(a2 + 4) - v36;
          if (v27 <= 0) {
            v37 = *(_DWORD *)(a2 + 8);
            goto LABEL_75;
          }
        }
        v37 = *(_DWORD *)(a2 + 8);
        v6 = *(_DWORD *)(a2 + 28);
      }
    }
  LABEL_75:
    *(_BYTE *)(a2 + 33) = 0;
    v14 = a2;
  } else {
    v14 = v13;
    v15 = *(_DWORD *)(v13 + 16);
    v37 = *(_DWORD *)(v13 + 8);
    v6 = *(_DWORD *)(v13 + 28);
  }
  if (a3 <= *(_DWORD *)(v14 + 24)) {
    v31 = 0;
    if ((int)(v39 - v15) >= 0)
      v31 = v39 - v15;
    *(_DWORD *)(a2 + 24) = v31;
  } else {
    *(_DWORD *)(v14 + 24) = a3;
  }
  v16 = *(_DWORD *)(a2 + 24);
  v42 = v16 * v37;
  if (v15 > 0) {
    v17 = *(_DWORD *)(a2 + 20);
    if (v15 <= v17)
      v17 = v15;
    v18 = v6 - v16;
    if (v17 <= (int)(v6 - v16))
      v18 = v17;
    if (v18 > *(_DWORD *)(a2 + 4) - v16)
      v18 = *(_DWORD *)(a2 + 4) - v16;
    if (v18 > 0) {
      v19 = 0;
      do {
        v20 = v18 * v37;
        (*(void(__cdecl **)(int, int, _DWORD, int, int))(a2 + 40))(
            a1, a2 + 40, *(_DWORD *)(*(_DWORD *)a2 + 4 * v19), v42, v18 * v37);
        v42 += v20;
        v21 = *(_DWORD *)(a2 + 20);
        v19 += v21;
        v22 = *(_DWORD *)(a2 + 16);
        if (v19 >= v22) {
          v6 = *(_DWORD *)(a2 + 28);
          goto LABEL_7;
        }
        v23 = v22 - v19;
        if (v23 > v21)
          v23 = *(_DWORD *)(a2 + 20);
        v35 = v19 + *(_DWORD *)(a2 + 24);
        v6 = *(_DWORD *)(a2 + 28);
        v18 = v6 - v35;
        if (v23 <= (int)(v6 - v35))
          v18 = v23;
        if (v18 > *(_DWORD *)(a2 + 4) - v35)
          v18 = *(_DWORD *)(a2 + 4) - v35;
      } while (v18 > 0);
      v7 = *(_DWORD *)(a2 + 28);
      if (v39 > v6)
        goto LABEL_8;
      goto LABEL_39;
    }
  }
LABEL_7:
  v7 = v6;
  if (v39 <= v6) {
  LABEL_39:
    v9 = *(_DWORD *)(a2 + 24);
  LABEL_40:
    if (a5)
      *(_BYTE *)(a2 + 33) = 1;
    goto LABEL_13;
  }
LABEL_8:
  if (a3 <= v6) {
    if (!a5)
      goto LABEL_69;
    goto LABEL_68;
  }
  if (a5) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 22;
    (**(void(__cdecl ***)(int))a1)(a1);
    v7 = a3;
  LABEL_68:
    *(_DWORD *)(a2 + 28) = v39;
  LABEL_69:
    v8 = a2;
    if (!*(_BYTE *)(a2 + 32))
      goto LABEL_11;
    goto LABEL_70;
  }
  v7 = a3;
  v8 = a2;
  if (*(_BYTE *)(a2 + 32)) {
  LABEL_70:
    __len = *(_DWORD *)(v8 + 8);
    v9 = *(_DWORD *)(v8 + 24);
    v32 = v7 - v9;
    if (v32 < v39 - v9) {
      v33 = 4 * v32;
      v34 = 0;
      v38 = v39 - v9 - v32;
      do {
        jzero_far(*(void **)(*(_DWORD *)a2 + v33), __len);
        ++v34;
        v33 += 4;
      } while (v38 != v34);
      v9 = *(_DWORD *)(a2 + 24);
    }
    goto LABEL_40;
  }
LABEL_11:
  if (!a5) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 22;
    (**(void(__cdecl ***)(int))a1)(a1);
    v9 = *(_DWORD *)(a2 + 24);
    v10 = (_DWORD *)a2;
    return *v10 + 4 * (a3 - v9);
  }
  v9 = *(_DWORD *)(a2 + 24);
  *(_BYTE *)(a2 + 33) = 1;
LABEL_13:
  v10 = (_DWORD *)a2;
  return *v10 + 4 * (a3 - v9);
}

int __cdecl access_virt_barray(int a1, int a2, unsigned int a3, unsigned int a4,
                               char a5) {
  unsigned int v5;  // ecx
  unsigned int v6;  // esi
  unsigned int v7;  // eax
  int v8;           // edx
  int v9;           // ecx
  _DWORD *v10;      // edx
  int v12;          // eax
  int v13;          // ecx
  int v14;          // eax
  int v15;          // edi
  int v16;          // ecx
  int v17;          // eax
  int v18;          // edx
  int v19;          // edi
  int v20;          // esi
  int v21;          // edx
  int v22;          // eax
  int v23;          // eax
  int v24;          // eax
  int v25;          // ecx
  int v26;          // eax
  int v27;          // edx
  int v28;          // esi
  int v29;          // edx
  int v30;          // eax
  unsigned int v31; // eax
  unsigned int v32; // eax
  int v33;          // esi
  int v34;          // edi
  int v35;          // [esp+28h] [ebp-40h]
  int v36;          // [esp+28h] [ebp-40h]
  int v37;          // [esp+34h] [ebp-34h]
  unsigned int v38; // [esp+3Ch] [ebp-2Ch]
  unsigned int v39; // [esp+44h] [ebp-24h]
  int v40;          // [esp+48h] [ebp-20h]
  int v41;          // [esp+4Ch] [ebp-1Ch]
  int v42;          // [esp+50h] [ebp-18h]
  int v43;          // [esp+54h] [ebp-14h]
  int v44;          // [esp+58h] [ebp-10h]
  size_t __len;     // [esp+5Ch] [ebp-Ch]

  v39 = a4 + a3;
  if (a4 + a3 > *(_DWORD *)(a2 + 4) || a4 > *(_DWORD *)(a2 + 12) ||
      !*(_DWORD *)a2) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 22;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  v5 = *(_DWORD *)(a2 + 24);
  if (a3 >= v5) {
    if (v39 <= *(_DWORD *)(a2 + 16) + v5) {
      v6 = *(_DWORD *)(a2 + 28);
      goto LABEL_7;
    }
    v12 = a2;
    if (!*(_BYTE *)(a2 + 34))
      goto LABEL_63;
  LABEL_16:
    v13 = v12;
    goto LABEL_17;
  }
  v12 = a2;
  if (*(_BYTE *)(a2 + 34))
    goto LABEL_16;
LABEL_63:
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 69;
  (**(void(__cdecl ***)(int))a1)(a1);
  v13 = a2;
LABEL_17:
  if (*(_BYTE *)(v13 + 33)) {
    v37 = *(_DWORD *)(v13 + 8);
    v40 = v37 << 7;
    v24 = v13;
    v25 = *(_DWORD *)(v13 + 24);
    v41 = v25 * (v37 << 7);
    v15 = *(_DWORD *)(v24 + 16);
    if (v15 <= 0) {
      v6 = *(_DWORD *)(v24 + 28);
    } else {
      v26 = *(_DWORD *)(a2 + 20);
      if (v26 > v15)
        v26 = v15;
      v6 = *(_DWORD *)(a2 + 28);
      if (v26 > (int)(v6 - v25))
        v26 = *(_DWORD *)(a2 + 28) - v25;
      v27 = v26;
      if (v26 > *(_DWORD *)(a2 + 4) - v25)
        v27 = *(_DWORD *)(a2 + 4) - v25;
      if (v27 > 0) {
        v42 = 0;
        while (1) {
          v28 = v27 * v40;
          (*(void(__cdecl **)(int, int, _DWORD, int, int))(a2 + 44))(
              a1, a2 + 40, *(_DWORD *)(*(_DWORD *)a2 + 4 * v42), v41,
              v27 * v40);
          v41 += v28;
          v29 = *(_DWORD *)(a2 + 20);
          v42 += v29;
          v15 = *(_DWORD *)(a2 + 16);
          if (v15 <= v42)
            break;
          v30 = v15 - v42;
          if (v29 <= v15 - v42)
            v30 = *(_DWORD *)(a2 + 20);
          v36 = *(_DWORD *)(a2 + 24) + v42;
          v6 = *(_DWORD *)(a2 + 28);
          v27 = v6 - v36;
          if (v30 <= (int)(v6 - v36))
            v27 = v30;
          if (v27 > *(_DWORD *)(a2 + 4) - v36)
            v27 = *(_DWORD *)(a2 + 4) - v36;
          if (v27 <= 0) {
            v37 = *(_DWORD *)(a2 + 8);
            goto LABEL_75;
          }
        }
        v37 = *(_DWORD *)(a2 + 8);
        v6 = *(_DWORD *)(a2 + 28);
      }
    }
  LABEL_75:
    *(_BYTE *)(a2 + 33) = 0;
    v14 = a2;
  } else {
    v14 = v13;
    v15 = *(_DWORD *)(v13 + 16);
    v37 = *(_DWORD *)(v13 + 8);
    v6 = *(_DWORD *)(v13 + 28);
  }
  if (a3 <= *(_DWORD *)(v14 + 24)) {
    v31 = 0;
    if ((int)(v39 - v15) >= 0)
      v31 = v39 - v15;
    *(_DWORD *)(a2 + 24) = v31;
  } else {
    *(_DWORD *)(v14 + 24) = a3;
  }
  v43 = v37 << 7;
  v16 = *(_DWORD *)(a2 + 24);
  v44 = v16 * (v37 << 7);
  if (v15 > 0) {
    v17 = *(_DWORD *)(a2 + 20);
    if (v15 <= v17)
      v17 = v15;
    v18 = v6 - v16;
    if (v17 <= (int)(v6 - v16))
      v18 = v17;
    if (v18 > *(_DWORD *)(a2 + 4) - v16)
      v18 = *(_DWORD *)(a2 + 4) - v16;
    if (v18 > 0) {
      v19 = 0;
      do {
        v20 = v18 * v43;
        (*(void(__cdecl **)(int, int, _DWORD, int, int))(a2 + 40))(
            a1, a2 + 40, *(_DWORD *)(*(_DWORD *)a2 + 4 * v19), v44, v18 * v43);
        v44 += v20;
        v21 = *(_DWORD *)(a2 + 20);
        v19 += v21;
        v22 = *(_DWORD *)(a2 + 16);
        if (v19 >= v22) {
          v6 = *(_DWORD *)(a2 + 28);
          goto LABEL_7;
        }
        v23 = v22 - v19;
        if (v23 > v21)
          v23 = *(_DWORD *)(a2 + 20);
        v35 = v19 + *(_DWORD *)(a2 + 24);
        v6 = *(_DWORD *)(a2 + 28);
        v18 = v6 - v35;
        if (v23 <= (int)(v6 - v35))
          v18 = v23;
        if (v18 > *(_DWORD *)(a2 + 4) - v35)
          v18 = *(_DWORD *)(a2 + 4) - v35;
      } while (v18 > 0);
      v7 = *(_DWORD *)(a2 + 28);
      if (v39 > v6)
        goto LABEL_8;
      goto LABEL_39;
    }
  }
LABEL_7:
  v7 = v6;
  if (v39 <= v6) {
  LABEL_39:
    v9 = *(_DWORD *)(a2 + 24);
  LABEL_40:
    if (a5)
      *(_BYTE *)(a2 + 33) = 1;
    goto LABEL_13;
  }
LABEL_8:
  if (a3 <= v6) {
    if (!a5)
      goto LABEL_69;
    goto LABEL_68;
  }
  if (a5) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 22;
    (**(void(__cdecl ***)(int))a1)(a1);
    v7 = a3;
  LABEL_68:
    *(_DWORD *)(a2 + 28) = v39;
  LABEL_69:
    v8 = a2;
    if (!*(_BYTE *)(a2 + 32))
      goto LABEL_11;
    goto LABEL_70;
  }
  v7 = a3;
  v8 = a2;
  if (*(_BYTE *)(a2 + 32)) {
  LABEL_70:
    __len = *(_DWORD *)(v8 + 8) << 7;
    v9 = *(_DWORD *)(v8 + 24);
    v32 = v7 - v9;
    if (v32 < v39 - v9) {
      v33 = 4 * v32;
      v34 = 0;
      v38 = v39 - v9 - v32;
      do {
        jzero_far(*(void **)(*(_DWORD *)a2 + v33), __len);
        ++v34;
        v33 += 4;
      } while (v38 != v34);
      v9 = *(_DWORD *)(a2 + 24);
    }
    goto LABEL_40;
  }
LABEL_11:
  if (!a5) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 22;
    (**(void(__cdecl ***)(int))a1)(a1);
    v9 = *(_DWORD *)(a2 + 24);
    v10 = (_DWORD *)a2;
    return *v10 + 4 * (a3 - v9);
  }
  v9 = *(_DWORD *)(a2 + 24);
  *(_BYTE *)(a2 + 33) = 1;
LABEL_13:
  v10 = (_DWORD *)a2;
  return *v10 + 4 * (a3 - v9);
}

int __cdecl realize_virt_arrays(_DWORD *a1) {
  int result;       // eax
  int *v2;          // ecx
  int v3;           // edi
  int v4;           // esi
  int *i;           // ecx
  _DWORD *v6;       // edx
  int v7;           // edi
  signed int v8;    // esi
  unsigned int v9;  // ecx
  signed int v10;   // esi
  int v11;          // eax
  _DWORD *v12;      // ecx
  int m;            // esi
  signed int v14;   // edi
  unsigned int v15; // ecx
  signed int v16;   // eax
  bool v17;         // cc
  signed int j;     // eax
  unsigned int v19; // eax
  _DWORD *v20;      // eax
  _DWORD *v21;      // edx
  int k;            // ecx
  int v23;          // [esp+4h] [ebp-44h]
  int v24;          // [esp+8h] [ebp-40h]
  int v25;          // [esp+Ch] [ebp-3Ch]
  unsigned int v26; // [esp+1Ch] [ebp-2Ch]
  _DWORD *v27;      // [esp+24h] [ebp-24h]
  signed int v28;   // [esp+28h] [ebp-20h]
  int v29;          // [esp+28h] [ebp-20h]
  unsigned int v30; // [esp+2Ch] [ebp-1Ch]
  int v31;          // [esp+30h] [ebp-18h]
  int v32;          // [esp+34h] [ebp-14h]
  unsigned int v33; // [esp+38h] [ebp-10h]
  signed int v34;   // [esp+3Ch] [ebp-Ch]

  result = a1[1];
  v27 = (_DWORD *)result;
  v2 = *(int **)(result + 68);
  if (v2) {
    v3 = 0;
    v4 = 0;
    do {
      while (1) {
        result = *v2;
        if (!*v2)
          break;
        v2 = (int *)v2[9];
        if (!v2)
          goto LABEL_6;
      }
      v4 += v2[3] * v2[2];
      result = v2[1] * v2[2];
      v3 += result;
      v2 = (int *)v2[9];
    } while (v2);
  } else {
    v4 = 0;
    v3 = 0;
  }
LABEL_6:
  for (i = (int *)v27[18]; i; i = (int *)i[9]) {
    while (1) {
      result = *i;
      if (!*i)
        break;
      i = (int *)i[9];
      if (!i)
        goto LABEL_11;
    }
    result = (i[3] * i[2]) << 7;
    v4 += result;
    v3 += (i[1] * i[2]) << 7;
  }
LABEL_11:
  if (v4 <= 0)
    return result;
  v25 = v27[19];
  result = jpeg_mem_available((int)a1, v4, v3);
  if (result >= v3) {
    v28 = 1000000000;
    v6 = v27;
    v7 = v27[17];
    if (v7)
      goto LABEL_16;
    goto LABEL_35;
  }
  v29 = result / v4;
  v17 = result / v4 <= 0;
  result = 1;
  if (!v17)
    result = v29;
  v28 = result;
  v6 = v27;
  v7 = v27[17];
  if (!v7) {
  LABEL_35:
    v12 = v6;
    goto LABEL_24;
  }
  do {
  LABEL_16:
    while (*(_DWORD *)v7) {
      v7 = *(_DWORD *)(v7 + 36);
      if (!v7)
        goto LABEL_23;
    }
    v8 = *(_DWORD *)(v7 + 4);
    v9 = *(_DWORD *)(v7 + 12);
    if (v28 < (int)((v8 - 1) / v9 + 1)) {
      *(_DWORD *)(v7 + 16) = v28 * v9;
      v24 = *(_DWORD *)(v7 + 8) * v8;
      v23 = v7 + 40;
      jpeg_open_backing_store((int)a1);
      *(_BYTE *)(v7 + 34) = 1;
      v34 = *(_DWORD *)(v7 + 16);
      v30 = *(_DWORD *)(v7 + 8);
      v31 = a1[1];
      v10 = 0x3B9AC9F4 / v30;
      if ((int)(0x3B9AC9F4 / v30) > 0)
        goto LABEL_19;
    } else {
      *(_DWORD *)(v7 + 16) = v8;
      v34 = v8;
      v30 = *(_DWORD *)(v7 + 8);
      v31 = a1[1];
      v10 = 0x3B9AC9F4 / v30;
      if ((int)(0x3B9AC9F4 / v30) > 0)
        goto LABEL_19;
    }
    *(_DWORD *)(*a1 + 20) = 70;
    (*(void(__cdecl **)(_DWORD *, int, int, int)) * a1)(a1, v23, v24, v25);
  LABEL_19:
    if (v10 >= v34)
      v10 = v34;
    v26 = v10;
    *(_DWORD *)(v31 + 80) = v10;
    v11 = alloc_small(a1, 1u, 4 * v34);
    v32 = v11;
    if (v34) {
      v33 = 0;
      for (j = v34;; j = v34) {
        v19 = j - v33;
        if (v26 <= v19)
          v19 = v26;
        v26 = v19;
        v20 = alloc_large(a1, 1u, v19 * v30);
        if (v26) {
          v21 = (_DWORD *)(v32 + 4 * v33);
          for (k = 0; k != v26; ++k) {
            *v21 = v20;
            ++v33;
            v20 = (_DWORD *)((char *)v20 + v30);
            ++v21;
          }
        }
        if (v33 >= v34)
          break;
      }
      v11 = v32;
    }
    *(_DWORD *)v7 = v11;
    result = v27[20];
    *(_DWORD *)(v7 + 20) = result;
    *(_DWORD *)(v7 + 24) = 0;
    *(_DWORD *)(v7 + 28) = 0;
    *(_BYTE *)(v7 + 33) = 0;
    v7 = *(_DWORD *)(v7 + 36);
  } while (v7);
LABEL_23:
  v12 = v27;
LABEL_24:
  for (m = v12[18]; m; m = *(_DWORD *)(m + 36)) {
    while (1) {
      result = *(_DWORD *)m;
      if (!*(_DWORD *)m)
        break;
      m = *(_DWORD *)(m + 36);
      if (!m)
        return result;
    }
    v14 = *(_DWORD *)(m + 4);
    v15 = *(_DWORD *)(m + 12);
    if (v28 < (int)((v14 - 1) / v15 + 1)) {
      *(_DWORD *)(m + 16) = v28 * v15;
      jpeg_open_backing_store((int)a1);
      *(_BYTE *)(m + 34) = 1;
      v16 = *(_DWORD *)(m + 16);
    } else {
      *(_DWORD *)(m + 16) = v14;
      v16 = v14;
    }
    *(_DWORD *)m = alloc_barray(a1, 1u, *(_DWORD *)(m + 8), v16);
    result = v27[20];
    *(_DWORD *)(m + 20) = result;
    *(_DWORD *)(m + 24) = 0;
    *(_DWORD *)(m + 28) = 0;
    *(_BYTE *)(m + 33) = 0;
  }
  return result;
}

int __cdecl jpeg_abort(int a1) {
  int result; // eax

  result = *(_DWORD *)(a1 + 4);
  if (result) {
    result = (*(int(__cdecl **)(int, int))(result + 36))(a1, 1);
    if (*(_BYTE *)(a1 + 16)) {
      *(_DWORD *)(a1 + 20) = 200;
      *(_DWORD *)(a1 + 276) = 0;
    } else {
      *(_DWORD *)(a1 + 20) = 100;
    }
  }
  return result;
}

int __cdecl jpeg_destroy(int a1) {
  int result; // eax

  result = *(_DWORD *)(a1 + 4);
  if (result)
    result = (*(int(__cdecl **)(int))(result + 40))(a1);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  return result;
}

int __cdecl jpeg_alloc_quant_table(int a1) {
  int result; // eax

  result = (**(int(__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 130);
  *(_BYTE *)(result + 128) = 0;
  return result;
}

int __cdecl jpeg_alloc_huff_table(int a1) {
  int result; // eax

  result = (**(int(__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 274);
  *(_BYTE *)(result + 273) = 0;
  return result;
}

int __cdecl start_input_pass(int *a1) {
  int v1;           // eax
  int *i;           // eax
  _DWORD *v3;       // ecx
  unsigned int v4;  // esi
  int v5;           // edx
  int v6;           // edi
  int v7;           // edx
  int v8;           // edx
  int v9;           // ecx
  int v10;          // edx
  int *j;           // eax
  int v12;          // esi
  int *v13;         // esi
  int *v14;         // edi
  int *v15;         // edx
  int v16;          // eax
  unsigned int v17; // edx
  int *v18;         // ecx
  void *v19;        // esi
  int result;       // eax
  _DWORD *v21;      // ecx
  unsigned int v22; // edi
  int *v23;         // esi
  int v24;          // [esp+1Ch] [ebp-1Ch]
  int v25;          // [esp+20h] [ebp-18h]
  unsigned int v26; // [esp+24h] [ebp-14h]
  int v27;          // [esp+28h] [ebp-10h]
  int *v28;         // [esp+2Ch] [ebp-Ch]

  v1 = a1[75];
  if (v1 == 1) {
    v21 = (_DWORD *)a1[76];
    a1[80] = v21[7];
    a1[81] = v21[8];
    v21[13] = 1;
    v21[14] = 1;
    v21[15] = 1;
    v21[16] = v21[9];
    v21[17] = 1;
    v22 = v21[3];
    if (v21[8] % v22)
      v22 = v21[8] % v22;
    v21[18] = v22;
    a1[82] = 1;
    a1[83] = 0;
    v13 = a1;
  } else {
    if ((unsigned int)(v1 - 1) > 3) {
      *(_DWORD *)(*a1 + 20) = 26;
      *(_DWORD *)(*a1 + 24) = a1[75];
      *(_DWORD *)(*a1 + 28) = 4;
      (*(void(__cdecl **)(int *)) * a1)(a1);
    }
    a1[80] = jdiv_round_up(a1[9], 8 * a1[70]);
    a1[81] = jdiv_round_up(a1[10], 8 * a1[71]);
    a1[82] = 0;
    if (a1[75] <= 0) {
      v13 = a1;
    } else {
      v28 = a1;
      v24 = 0;
      for (i = a1;; i = v28) {
        v3 = (_DWORD *)i[76];
        v4 = v3[2];
        v3[13] = v4;
        v5 = v3[3];
        v3[14] = v5;
        v6 = v3[13] * v5;
        v3[15] = v6;
        v3[16] = v3[9] * v4;
        v7 = v3[7] % v4;
        if (!v7)
          v7 = v4;
        v3[17] = v7;
        v8 = v3[8] % v3[3];
        if (!v8)
          v8 = v3[3];
        v3[18] = v8;
        if (a1[82] + v6 > 10) {
          *(_DWORD *)(*a1 + 20) = 13;
          (*(void(__cdecl **)(int *)) * a1)(a1);
        }
        v9 = v6 - 1;
        if (v6 > 0) {
          v10 = a1[82];
          for (j = a1;; j = a1) {
            j[v10 + 83] = v24;
            v12 = ++v10;
            if (v9-- <= 0)
              break;
          }
          a1[82] = v12;
        }
        ++v24;
        ++v28;
        if (v24 >= a1[75])
          break;
      }
      v13 = a1;
    }
  }
  if (v13[75] > 0) {
    v14 = v13;
    v25 = 0;
    while (1) {
      while (1) {
        v16 = v14[76];
        v27 = v16;
        if (!*(_DWORD *)(v16 + 76))
          break;
        ++v25;
        ++v14;
        v15 = a1;
        if (v25 >= a1[75])
          goto LABEL_27;
      }
      v17 = *(_DWORD *)(v16 + 16);
      v26 = v17;
      if (v17 > 3)
        break;
      v18 = a1;
      if (!a1[v17 + 38]) {
        v23 = a1;
        goto LABEL_34;
      }
    LABEL_26:
      v19 = (void *)(*(int(__cdecl **)(int *, int, int))v18[1])(v18, 1, 130);
      memcpy(v19, (const void *)a1[v26 + 38], 0x82u);
      *(_DWORD *)(v27 + 76) = v19;
      ++v25;
      ++v14;
      v15 = a1;
      if (v25 >= a1[75]) {
      LABEL_27:
        v13 = v15;
        goto LABEL_28;
      }
    }
    v23 = a1;
  LABEL_34:
    *(_DWORD *)(*v23 + 20) = 52;
    *(_DWORD *)(*v23 + 24) = v17;
    (*(void(__cdecl **)(int *)) * v23)(v23);
    v18 = a1;
    goto LABEL_26;
  }
LABEL_28:
  (*(void(__cdecl **)(int *))v13[104])(v13);
  (*(void(__cdecl **)(int *))v13[100])(v13);
  result = *(_DWORD *)(v13[100] + 4);
  *(_DWORD *)v13[102] = result;
  return result;
}

int __cdecl consume_markers(int *a1) {
  int v1;     // esi
  int v3;     // eax
  int v4;     // eax
  int v5;     // eax
  int v6;     // esi
  int v7;     // eax
  int v8;     // eax
  int v9;     // eax
  int v10;    // esi
  _BYTE *v11; // [esp+10h] [ebp-18h]
  int v12;    // [esp+14h] [ebp-14h]
  int *v13;   // [esp+18h] [ebp-10h]
  int v14;    // [esp+1Ch] [ebp-Ch]

  v11 = (_BYTE *)a1[102];
  if (v11[17])
    return 2;
  v3 = (*(int(__cdecl **)(int *))(a1[103] + 4))(a1);
  v1 = v3;
  if (v3 != 1) {
    if (v3 != 2)
      return v1;
    v11[17] = 1;
    if (v11[20]) {
      if (*(_BYTE *)(a1[103] + 13)) {
        *(_DWORD *)(*a1 + 20) = 59;
        (*(void(__cdecl **)(int *)) * a1)(a1);
        return v1;
      }
    } else {
      v4 = a1[33];
      if (a1[35] > v4) {
        a1[35] = v4;
        return v1;
      }
    }
    return 2;
  }
  if (v11[20]) {
    if (a1[10] > 65500 || a1[9] > 65500) {
      *(_DWORD *)(*a1 + 20) = 41;
      *(_DWORD *)(*a1 + 24) = 65500;
      (*(void(__cdecl **)(int *)) * a1)(a1);
    }
    if (a1[50] != 8) {
      *(_DWORD *)(*a1 + 20) = 15;
      *(_DWORD *)(*a1 + 24) = a1[50];
      (*(void(__cdecl **)(int *)) * a1)(a1);
    }
    if (a1[11] > 10) {
      *(_DWORD *)(*a1 + 20) = 26;
      *(_DWORD *)(*a1 + 24) = a1[11];
      *(_DWORD *)(*a1 + 28) = 10;
      (*(void(__cdecl **)(int *)) * a1)(a1);
    }
    a1[70] = 1;
    a1[71] = 1;
    v5 = a1[51];
    v6 = v5;
    if (a1[11] > 0) {
      v12 = 0;
      do {
        v13 = (int *)(v6 + 8);
        if ((unsigned int)(*(_DWORD *)(v6 + 8) - 1) > 3 ||
            (v7 = *(_DWORD *)(v6 + 12), v7 <= 0) || v7 > 4) {
          *(_DWORD *)(*a1 + 20) = 18;
          (*(void(__cdecl **)(int *)) * a1)(a1);
        }
        v8 = *v13;
        if (*v13 < a1[70])
          v8 = a1[70];
        a1[70] = v8;
        v9 = *(_DWORD *)(v6 + 12);
        if (v9 < a1[71])
          v9 = a1[71];
        a1[71] = v9;
        ++v12;
        v6 += 84;
      } while (a1[11] > v12);
      v5 = a1[51];
    }
    a1[72] = 8;
    v10 = v5;
    if (a1[11] > 0) {
      v14 = 0;
      do {
        *(_DWORD *)(v10 + 36) = 8;
        *(_DWORD *)(v10 + 28) =
            jdiv_round_up(*(_DWORD *)(v10 + 8) * a1[9], 8 * a1[70]);
        *(_DWORD *)(v10 + 32) =
            jdiv_round_up(*(_DWORD *)(v10 + 12) * a1[10], 8 * a1[71]);
        *(_DWORD *)(v10 + 40) =
            jdiv_round_up(*(_DWORD *)(v10 + 8) * a1[9], a1[70]);
        *(_DWORD *)(v10 + 44) =
            jdiv_round_up(*(_DWORD *)(v10 + 12) * a1[10], a1[71]);
        *(_BYTE *)(v10 + 48) = 1;
        *(_DWORD *)(v10 + 76) = 0;
        ++v14;
        v10 += 84;
      } while (v14 < a1[11]);
    }
    a1[73] = jdiv_round_up(a1[10], 8 * a1[71]);
    *(_BYTE *)(a1[102] + 16) = a1[75] < a1[11] || *((_BYTE *)a1 + 208);
    v11[20] = 0;
    return 1;
  } else {
    if (!v11[16]) {
      *(_DWORD *)(*a1 + 20) = 35;
      (*(void(__cdecl **)(int *)) * a1)(a1);
    }
    start_input_pass(a1);
  }
  return v1;
}

int __cdecl reset_input_controller(int a1) {
  int v1;     // eax
  int result; // eax

  v1 = *(_DWORD *)(a1 + 408);
  *(_DWORD *)v1 = consume_markers;
  *(_BYTE *)(v1 + 16) = 0;
  *(_BYTE *)(v1 + 17) = 0;
  *(_BYTE *)(v1 + 20) = 1;
  (*(void(__cdecl **)(int))(*(_DWORD *)a1 + 16))(a1);
  result = (**(int(__cdecl ***)(int))(a1 + 412))(a1);
  *(_DWORD *)(a1 + 148) = 0;
  return result;
}

int __cdecl jinit_input_controller(int a1) {
  int result; // eax

  result = (**(int(__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 24);
  *(_DWORD *)(a1 + 408) = result;
  *(_DWORD *)result = consume_markers;
  *(_DWORD *)(result + 4) = reset_input_controller;
  *(_DWORD *)(result + 8) = start_input_pass;
  *(_DWORD *)(result + 12) = finish_input_pass;
  *(_BYTE *)(result + 16) = 0;
  *(_BYTE *)(result + 17) = 0;
  *(_BYTE *)(result + 20) = 1;
  return result;
}

int __cdecl get_interesting_appn(_DWORD *a1) {
  unsigned __int8 *v1;   // edx
  unsigned __int8 *v2;   // eax
  int v3;                // esi
  unsigned __int8 *v4;   // edx
  int v5;                // eax
  unsigned __int8 *v6;   // edi
  int v7;                // esi
  int v8;                // edi
  int v9;                // eax
  int v11;               // ecx
  _DWORD *v12;           // [esp+1Ch] [ebp-3Ch]
  unsigned int v13;      // [esp+24h] [ebp-34h]
  unsigned __int8 **v14; // [esp+28h] [ebp-30h]
  unsigned __int8 v15;   // [esp+2Fh] [ebp-29h]
  int v16;               // [esp+30h] [ebp-28h]
  int v17;               // [esp+34h] [ebp-24h]
  int v18;               // [esp+38h] [ebp-20h]
  int v19;               // [esp+3Ch] [ebp-1Ch]
  _BYTE v20[22];         // [esp+42h] [ebp-16h] BYREF

  v14 = (unsigned __int8 **)a1[8];
  v1 = *v14;
  v2 = v14[1];
  if (v2) {
    v3 = *v1 << 8;
    v4 = v1 + 1;
    v5 = (int)(v2 - 1);
    if (v5)
      goto LABEL_3;
  } else {
    if (!((unsigned __int8(__cdecl *)(_DWORD *))v14[3])(a1))
      return 0;
    v3 = **v14 << 8;
    v4 = *v14 + 1;
    v5 = (int)(v14[1] - 1);
    if (v14[1] != (unsigned __int8 *)1)
      goto LABEL_3;
  }
  if (!((unsigned __int8(__cdecl *)(_DWORD *))v14[3])(a1))
    return 0;
  v4 = *v14;
  v5 = (int)v14[1];
LABEL_3:
  v17 = v5 - 1;
  v6 = v4 + 1;
  v18 = v3 + *v4 - 2;
  if (v18 > 13) {
    v13 = 14;
  LABEL_6:
    v7 = 0;
    while (1) {
      while (v17) {
        --v17;
        v20[v7] = *v6++;
        if (v13 == ++v7)
          goto LABEL_11;
      }
      if (!((unsigned __int8(__cdecl *)(_DWORD *))v14[3])(a1))
        return 0;
      v8 = (int)*v14;
      v17 = (int)(v14[1] - 1);
      v20[v7] = **v14;
      v6 = (unsigned __int8 *)(v8 + 1);
      if (v13 == ++v7)
        goto LABEL_11;
    }
  }
  if (v18 > 0) {
    v13 = v3 + *v4 - 2;
    goto LABEL_6;
  }
  v13 = 0;
LABEL_11:
  v19 = v18 - v13;
  v9 = a1[97];
  if (v9 == 224) {
    examine_app0((int)a1, v20, v13, v18 - v13);
  } else if (v9 == 238) {
    if (v13 > 0xB && v20[0] == 65 && v20[1] == 100 && v20[2] == 111 &&
        v20[3] == 98 && v20[4] == 101) {
      v16 = v20[8] + (v20[7] << 8);
      v11 = v20[10] + (v20[9] << 8);
      v15 = v20[11];
      v12 = (_DWORD *)*a1;
      v12[6] = v20[6] + (v20[5] << 8);
      v12[7] = v16;
      v12[8] = v11;
      v12[9] = v15;
      *(_DWORD *)(*a1 + 20) = 76;
      (*(void(__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      *((_BYTE *)a1 + 272) = 1;
      *((_BYTE *)a1 + 273) = v15;
    } else {
      *(_DWORD *)(*a1 + 20) = 78;
      *(_DWORD *)(*a1 + 24) = v18;
      (*(void(__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    }
  } else {
    *(_DWORD *)(*a1 + 20) = 68;
    *(_DWORD *)(*a1 + 24) = a1[97];
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  *v14 = v6;
  v14[1] = (unsigned __int8 *)v17;
  if (v19 > 0)
    (*(void(__cdecl **)(_DWORD *, int))(a1[8] + 16))(a1, v19);
  return 1;
}

int __cdecl skip_variable(_DWORD *a1) {
  unsigned __int8 **v1; // edi
  unsigned __int8 *v2;  // eax
  unsigned __int8 *v3;  // edx
  int v4;               // esi
  unsigned __int8 *v5;  // eax
  unsigned __int8 *v6;  // ecx
  int v7;               // esi
  unsigned __int8 *v9;  // [esp+18h] [ebp-10h]
  unsigned __int8 *v10; // [esp+1Ch] [ebp-Ch]

  v1 = (unsigned __int8 **)a1[8];
  v2 = *v1;
  v3 = v1[1];
  if (!v3) {
    if (!((unsigned __int8(__cdecl *)(_DWORD *))v1[3])(a1))
      return 0;
    v2 = *v1;
    v3 = v1[1];
  }
  v4 = *v2 << 8;
  v5 = v2 + 1;
  v9 = v5;
  v10 = v3 - 1;
  if (v3 != (unsigned __int8 *)1) {
    v6 = v5;
    goto LABEL_5;
  }
  if (!((unsigned __int8(__cdecl *)(_DWORD *))v1[3])(a1))
    return 0;
  v9 = *v1;
  v10 = v1[1];
  v6 = *v1;
LABEL_5:
  v7 = v4 + *v6 - 2;
  *(_DWORD *)(*a1 + 20) = 91;
  *(_DWORD *)(*a1 + 24) = a1[97];
  *(_DWORD *)(*a1 + 28) = v7;
  (*(void(__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  *v1 = v9 + 1;
  v1[1] = v10 - 1;
  if (v7 > 0)
    (*(void(__cdecl **)(_DWORD *, int))(a1[8] + 16))(a1, v7);
  return 1;
}

int __cdecl read_markers(int a1) {
  _DWORD *v1;            // edx
  unsigned __int8 **v2;  // esi
  unsigned __int8 *v3;   // edx
  unsigned __int8 *v4;   // eax
  char v5;               // di
  unsigned __int8 *v6;   // edx
  unsigned __int8 *v7;   // eax
  int v8;                // esi
  int v9;                // edx
  unsigned __int8 *v10;  // edi
  unsigned __int8 *v11;  // esi
  unsigned __int8 *v12;  // ecx
  unsigned __int8 *v13;  // edx
  int v14;               // esi
  unsigned __int8 *v15;  // eax
  unsigned __int8 *v16;  // edx
  int v17;               // edx
  unsigned __int8 *v18;  // edx
  unsigned __int8 *v19;  // eax
  unsigned __int8 *v20;  // eax
  unsigned __int8 *v21;  // edx
  unsigned int v22;      // edi
  _DWORD *v23;           // esi
  _DWORD *v24;           // eax
  int *v25;              // edx
  int v26;               // ecx
  int v27;               // eax
  _DWORD *v28;           // edx
  unsigned __int8 *v29;  // ecx
  unsigned __int8 *v30;  // edx
  unsigned __int8 *v31;  // esi
  unsigned __int8 *v32;  // edi
  char v33;              // al
  _DWORD *v34;           // ecx
  unsigned __int8 **v36; // edi
  unsigned __int8 *v37;  // edx
  unsigned __int8 *v38;  // eax
  unsigned __int8 *v39;  // edx
  unsigned __int8 *v40;  // eax
  unsigned __int8 *v41;  // esi
  int v42;               // esi
  unsigned __int8 *v43;  // edx
  unsigned __int8 *v44;  // eax
  int v45;               // esi
  unsigned __int8 *v46;  // edx
  unsigned __int8 *v47;  // eax
  unsigned __int8 *v48;  // edi
  int v49;               // eax
  unsigned __int8 *v50;  // edx
  int v51;               // eax
  int v52;               // esi
  __int16 v53;           // si
  unsigned __int8 *v54;  // edx
  int v55;               // eax
  unsigned __int16 v56;  // cx
  unsigned __int8 *v57;  // eax
  _DWORD *v58;           // ecx
  unsigned __int16 *v59; // esi
  unsigned __int8 *v60;  // edx
  unsigned __int8 *v61;  // eax
  int v62;               // esi
  unsigned __int8 *v63;  // edx
  unsigned __int8 *v64;  // eax
  unsigned __int8 *v65;  // edi
  unsigned __int8 *v66;  // eax
  int i;                 // esi
  unsigned __int8 *v68;  // edx
  unsigned __int8 v69;   // al
  int v70;               // ecx
  _BYTE *v71;            // eax
  int v72;               // edx
  char v73;              // cl
  _DWORD *v74;           // ecx
  _DWORD *v75;           // ecx
  int j;                 // esi
  unsigned __int8 *v77;  // ecx
  int v78;               // esi
  int v79;               // edx
  char v80;              // cl
  int v81;               // edx
  int v82;               // eax
  int v83;               // [esp+30h] [ebp-1B8h]
  int v84;               // [esp+34h] [ebp-1B4h]
  int v85;               // [esp+38h] [ebp-1B0h]
  int v86;               // [esp+3Ch] [ebp-1ACh]
  int v87;               // [esp+40h] [ebp-1A8h]
  int v88;               // [esp+44h] [ebp-1A4h]
  int v89;               // [esp+48h] [ebp-1A0h]
  unsigned __int8 **v90; // [esp+4Ch] [ebp-19Ch]
  int v91;               // [esp+50h] [ebp-198h]
  unsigned int v92;      // [esp+54h] [ebp-194h]
  int v93;               // [esp+58h] [ebp-190h]
  unsigned __int8 **v94; // [esp+5Ch] [ebp-18Ch]
  int v95;               // [esp+60h] [ebp-188h]
  int v96;               // [esp+64h] [ebp-184h]
  unsigned __int16 *v97; // [esp+68h] [ebp-180h]
  unsigned __int8 **v98; // [esp+6Ch] [ebp-17Ch]
  int v99;               // [esp+70h] [ebp-178h]
  int v100;              // [esp+74h] [ebp-174h]
  int v101;              // [esp+78h] [ebp-170h]
  int v102;              // [esp+7Ch] [ebp-16Ch]
  _DWORD *v103;          // [esp+80h] [ebp-168h]
  unsigned __int8 *v104; // [esp+84h] [ebp-164h]
  unsigned __int8 *v105; // [esp+88h] [ebp-160h]
  unsigned __int8 *v106; // [esp+8Ch] [ebp-15Ch]
  unsigned __int8 *v107; // [esp+90h] [ebp-158h]
  unsigned __int8 *v108; // [esp+94h] [ebp-154h]
  unsigned __int8 *v109; // [esp+98h] [ebp-150h]
  int v110;              // [esp+9Ch] [ebp-14Ch]
  int v111;              // [esp+A0h] [ebp-148h]
  int v112;              // [esp+A0h] [ebp-148h]
  unsigned __int8 *v113; // [esp+A4h] [ebp-144h]
  unsigned __int8 *v114; // [esp+A8h] [ebp-140h]
  unsigned __int8 *v115; // [esp+ACh] [ebp-13Ch]
  _BYTE v116[256];       // [esp+BFh] [ebp-129h] BYREF
  int v117;              // [esp+1BFh] [ebp-29h] BYREF
  int v118;              // [esp+1C3h] [ebp-25h]
  int v119;              // [esp+1C7h] [ebp-21h]
  int v120;              // [esp+1CBh] [ebp-1Dh]
  unsigned __int8 v121;  // [esp+1CFh] [ebp-19h]

  v1 = (_DWORD *)a1;
  if (*(_DWORD *)(a1 + 388))
    goto LABEL_17;
LABEL_2:
  if (*(_BYTE *)(v1[103] + 12)) {
    if (!(unsigned __int8)next_marker((_DWORD *)a1))
      return 0;
    v8 = a1;
  } else {
    v2 = (unsigned __int8 **)v1[8];
    v3 = *v2;
    v4 = v2[1];
    if (!v4) {
      if (!((unsigned __int8(__cdecl *)(int))v2[3])(a1))
        return 0;
      v3 = *v2;
      v4 = v2[1];
    }
    v5 = *v3;
    v83 = *v3;
    v6 = v3 + 1;
    v7 = v4 - 1;
    if (!v7) {
      if (!((unsigned __int8(__cdecl *)(int))v2[3])(a1))
        return 0;
      v6 = *v2;
      v7 = v2[1];
    }
    v106 = v7 - 1;
    v84 = *v6;
    v105 = v6 + 1;
    if (v5 != -1 || *v6 != 0xD8) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 53;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = v83;
      *(_DWORD *)(*(_DWORD *)a1 + 28) = v84;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    *(_DWORD *)(a1 + 388) = v84;
    *v2 = v105;
    v2[1] = v106;
    v8 = a1;
  }
  v9 = *(_DWORD *)(v8 + 388);
  if (v9 <= 207) {
    while (1) {
      if (v9 >= 205)
        goto LABEL_14;
      if (v9 != 196)
        break;
      v94 = *(unsigned __int8 ***)(a1 + 32);
      v60 = *v94;
      v61 = v94[1];
      if (!v61) {
        if (!((unsigned __int8(__cdecl *)(int))v94[3])(a1))
          return 0;
        v60 = *v94;
        v61 = v94[1];
      }
      v62 = *v60 << 8;
      v63 = v60 + 1;
      v64 = v61 - 1;
      if (!v64) {
        if (!((unsigned __int8(__cdecl *)(int))v94[3])(a1))
          return 0;
        v63 = *v94;
        v64 = v94[1];
      }
      v65 = v64 - 1;
      v109 = v63 + 1;
      v91 = v62 + *v63 - 2;
      while (v91 > 16) {
        if (v65) {
          v66 = v109;
        } else {
          if (!((unsigned __int8(__cdecl *)(int))v94[3])(a1))
            return 0;
          v109 = *v94;
          v65 = v94[1];
          v66 = *v94;
        }
        --v65;
        v92 = *v66;
        ++v109;
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 80;
        *(_DWORD *)(*(_DWORD *)a1 + 24) = v92;
        (*(void(__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
        LOBYTE(v117) = 0;
        v93 = 0;
        for (i = 0; i != 16; ++i) {
          if (v65) {
            v68 = v109;
          } else {
            if (!((unsigned __int8(__cdecl *)(int))v94[3])(a1))
              return 0;
            v65 = v94[1];
            v68 = *v94;
          }
          --v65;
          v69 = *v68;
          *((_BYTE *)&v117 + i + 1) = *v68;
          v109 = v68 + 1;
          v93 += v69;
        }
        v110 = v91 - 17;
        v74 = *(_DWORD **)a1;
        v74[6] = BYTE1(v117);
        v74[7] = BYTE2(v117);
        v74[8] = HIBYTE(v117);
        v74[9] = (unsigned __int8)v118;
        v74[10] = BYTE1(v118);
        v74[11] = BYTE2(v118);
        v74[12] = HIBYTE(v118);
        v74[13] = (unsigned __int8)v119;
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 86;
        (*(void(__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 2);
        v75 = *(_DWORD **)a1;
        v75[6] = BYTE1(v119);
        v75[7] = BYTE2(v119);
        v75[8] = HIBYTE(v119);
        v75[9] = (unsigned __int8)v120;
        v75[10] = BYTE1(v120);
        v75[11] = BYTE2(v120);
        v75[12] = HIBYTE(v120);
        v75[13] = v121;
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 86;
        (*(void(__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 2);
        if (v93 > 256 || v93 > v110) {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 8;
          (**(void(__cdecl ***)(int))a1)(a1);
        }
        if (v93 > 0) {
          for (j = 0; v93 != j; ++j) {
            if (v65) {
              v77 = v109;
            } else {
              if (!((unsigned __int8(__cdecl *)(int))v94[3])(a1))
                return 0;
              v77 = *v94;
              v65 = v94[1];
            }
            --v65;
            v116[j] = *v77;
            v109 = v77 + 1;
          }
        }
        v91 = v110 - v93;
        if ((v92 & 0x10) != 0) {
          v92 -= 16;
          v78 = a1 + 4 * v92 + 184;
        } else {
          v78 = a1 + 4 * v92 + 168;
        }
        if (v92 > 3) {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 30;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = v92;
          (**(void(__cdecl ***)(int))a1)(a1);
        }
        if (*(_DWORD *)v78) {
          v79 = *(_DWORD *)v78;
        } else {
          v82 = jpeg_alloc_huff_table(a1);
          *(_DWORD *)v78 = v82;
          v79 = v82;
        }
        *(_DWORD *)v79 = v117;
        *(_DWORD *)(v79 + 4) = v118;
        *(_DWORD *)(v79 + 8) = v119;
        *(_DWORD *)(v79 + 12) = v120;
        *(_BYTE *)(v79 + 16) = v121;
        memcpy((void *)(*(_DWORD *)v78 + 17), v116, 0x100u);
      }
      if (v91) {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 11;
        (**(void(__cdecl ***)(int))a1)(a1);
      }
      *v94 = v109;
      v94[1] = v65;
    LABEL_16:
      *(_DWORD *)(a1 + 388) = 0;
      v1 = (_DWORD *)a1;
      if (!*(_DWORD *)(a1 + 388))
        goto LABEL_2;
    LABEL_17:
      v9 = v1[97];
      if (v9 > 207)
        goto LABEL_18;
    }
    if (v9 > 196) {
      if (v9 != 201) {
        if (v9 >= 201 && v9 != 203) {
          if (v9 <= 203) {
            v73 = 1;
            goto LABEL_140;
          }
        LABEL_147:
          if ((unsigned __int8)skip_variable((_DWORD *)a1))
            goto LABEL_16;
          return 0;
        }
        goto LABEL_14;
      }
      v80 = 1;
    LABEL_176:
      if ((unsigned __int8)get_sof((_DWORD *)a1, 0, v80))
        goto LABEL_16;
      return 0;
    }
    if (v9 > 193) {
      if (v9 == 194) {
        v73 = 0;
      LABEL_140:
        if ((unsigned __int8)get_sof((_DWORD *)a1, 1, v73))
          goto LABEL_16;
        return 0;
      }
    LABEL_14:
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 60;
    LABEL_15:
      *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 388);
      (**(void(__cdecl ***)(int))a1)(a1);
      goto LABEL_16;
    }
    if (v9 >= 192) {
      v80 = 0;
      goto LABEL_176;
    }
    if (v9 == 1) {
    LABEL_128:
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 92;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 388);
      (*(void(__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
      goto LABEL_16;
    }
  LABEL_54:
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 68;
    goto LABEL_15;
  }
LABEL_18:
  if (v9 == 219) {
    v98 = *(unsigned __int8 ***)(a1 + 32);
    v43 = *v98;
    v44 = v98[1];
    if (!v44) {
      if (!((unsigned __int8(__cdecl *)(int))v98[3])(a1))
        return 0;
      v43 = *v98;
      v44 = v98[1];
    }
    v45 = *v43 << 8;
    v46 = v43 + 1;
    v47 = v44 - 1;
    if (!v47) {
      if (!((unsigned __int8(__cdecl *)(int))v98[3])(a1))
        return 0;
      v46 = *v98;
      v47 = v98[1];
    }
    v48 = v47 - 1;
    v104 = v46 + 1;
    v49 = v45 + *v46 - 2;
    v111 = v49;
    if (v49 <= 0)
      goto LABEL_110;
  LABEL_79:
    v95 = v49;
    if (v48) {
      v50 = v104;
    } else {
      if (!((unsigned __int8(__cdecl *)(int))v98[3])(a1))
        return 0;
      v48 = v98[1];
      v50 = *v98;
    }
    --v48;
    v51 = *v50;
    v104 = v50 + 1;
    v96 = v51 >> 4;
    v52 = v51 & 0xF;
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 81;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = v52;
    *(_DWORD *)(*(_DWORD *)a1 + 28) = v51 >> 4;
    (*(void(__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
    if (v52 > 3) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 31;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = v52;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    if (!*(_DWORD *)(a1 + 4 * v52 + 152))
      *(_DWORD *)(a1 + 4 * v52 + 152) = jpeg_alloc_quant_table(a1);
    v97 = *(unsigned __int16 **)(a1 + 4 * v52 + 152);
    v103 = &jpeg_natural_order;
    while (1) {
      if (!v96) {
        if (v48) {
          v57 = v104;
        } else {
          if (!((unsigned __int8(__cdecl *)(int))v98[3])(a1))
            return 0;
          v48 = v98[1];
          v57 = *v98;
        }
        --v48;
        v56 = *v57;
        v104 = v57 + 1;
        goto LABEL_90;
      }
      if (v48) {
        v53 = *v104 << 8;
        v54 = v104 + 1;
        v55 = (int)(v48 - 1);
        if (v48 == (unsigned __int8 *)1)
          goto LABEL_97;
      } else {
        if (!((unsigned __int8(__cdecl *)(int))v98[3])(a1))
          return 0;
        v53 = **v98 << 8;
        v54 = *v98 + 1;
        v55 = (int)(v98[1] - 1);
        if (v98[1] == (unsigned __int8 *)1) {
        LABEL_97:
          if (!((unsigned __int8(__cdecl *)(int))v98[3])(a1))
            return 0;
          v54 = *v98;
          v55 = (int)v98[1];
        }
      }
      v48 = (unsigned __int8 *)(v55 - 1);
      v56 = v53 + *v54;
      v104 = v54 + 1;
    LABEL_90:
      v97[*v103++] = v56;
      if (&unk_307240 == (_UNKNOWN *)v103) {
        v58 = *(_DWORD **)a1;
        if (*(int *)(*(_DWORD *)a1 + 104) > 1) {
          v59 = v97;
          v101 = 8;
          while (1) {
            v58[6] = *v59;
            v58[7] = v59[1];
            v58[8] = v59[2];
            v58[9] = v59[3];
            v58[10] = v59[4];
            v58[11] = v59[5];
            v58[12] = v59[6];
            v58[13] = v59[7];
            *(_DWORD *)(*(_DWORD *)a1 + 20) = 93;
            (*(void(__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 2);
            v59 += 8;
            if (!--v101)
              break;
            v58 = *(_DWORD **)a1;
          }
        }
        v112 = v111 - 65;
        v49 = v95 - 129;
        if (!v96)
          v49 = v112;
        v111 = v49;
        if (v49 <= 0) {
        LABEL_110:
          if (v111) {
            *(_DWORD *)(*(_DWORD *)a1 + 20) = 11;
            (**(void(__cdecl ***)(int))a1)(a1);
          }
          *v98 = v104;
          v98[1] = v48;
          goto LABEL_16;
        }
        goto LABEL_79;
      }
    }
  }
  if (v9 > 219) {
    if (v9 > 239) {
      if (v9 == 254) {
        if ((*(unsigned __int8(__cdecl **)(int))(*(_DWORD *)(a1 + 412) + 24))(
                a1))
          goto LABEL_16;
        return 0;
      }
      goto LABEL_54;
    }
    if (v9 >= 224) {
      if ((*(unsigned __int8(__cdecl **)(int))(*(_DWORD *)(a1 + 412) + 4 * v9 -
                                               868))(a1))
        goto LABEL_16;
      return 0;
    }
    if (v9 == 220)
      goto LABEL_147;
    if (v9 != 221)
      goto LABEL_54;
    v36 = *(unsigned __int8 ***)(a1 + 32);
    v37 = *v36;
    v38 = v36[1];
    if (!v38) {
      if (!((unsigned __int8(__cdecl *)(int))v36[3])(a1))
        return 0;
      v37 = *v36;
      v38 = v36[1];
    }
    v99 = *v37 << 8;
    v39 = v37 + 1;
    v40 = v38 - 1;
    if (!v40) {
      if (!((unsigned __int8(__cdecl *)(int))v36[3])(a1))
        return 0;
      v39 = *v36;
      v40 = v36[1];
    }
    v41 = v40 - 1;
    v113 = v39 + 1;
    if (v99 + *v39 != 4) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 11;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    if (!v41) {
      if (!((unsigned __int8(__cdecl *)(int))v36[3])(a1))
        return 0;
      v113 = *v36;
      v41 = v36[1];
    }
    v100 = *v113 << 8;
    v114 = v113 + 1;
    v115 = v41 - 1;
    if (v41 == (unsigned __int8 *)1) {
      if (!((unsigned __int8(__cdecl *)(int))v36[3])(a1))
        return 0;
      v114 = *v36;
      v115 = v36[1];
    }
    v42 = v100 + *v114;
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 82;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = v42;
    (*(void(__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
    *(_DWORD *)(a1 + 260) = v42;
    *v36 = v114 + 1;
    v36[1] = v115 - 1;
    goto LABEL_16;
  }
  if (v9 == 216) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 102;
    (*(void(__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
    v70 = *(_DWORD *)(a1 + 412);
    if (*(_BYTE *)(v70 + 12)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 61;
      (**(void(__cdecl ***)(int))a1)(a1);
      v70 = *(_DWORD *)(a1 + 412);
    }
    v71 = (_BYTE *)a1;
    v72 = 16;
    do {
      v71[210] = 0;
      v71[226] = 1;
      v71[242] = 5;
      ++v71;
      --v72;
    } while (v72);
    *(_DWORD *)(a1 + 260) = 0;
    *(_DWORD *)(a1 + 48) = 0;
    *(_BYTE *)(a1 + 274) = 0;
    *(_BYTE *)(a1 + 264) = 0;
    *(_BYTE *)(a1 + 265) = 1;
    *(_BYTE *)(a1 + 266) = 1;
    *(_BYTE *)(a1 + 267) = 0;
    *(_WORD *)(a1 + 268) = 1;
    *(_WORD *)(a1 + 270) = 1;
    *(_BYTE *)(a1 + 272) = 0;
    *(_BYTE *)(a1 + 273) = 0;
    *(_BYTE *)(v70 + 12) = 1;
    goto LABEL_16;
  }
  if (v9 < 216)
    goto LABEL_128;
  if (v9 != 217) {
    v90 = *(unsigned __int8 ***)(a1 + 32);
    v10 = *v90;
    v11 = v90[1];
    if (!*(_BYTE *)(*(_DWORD *)(a1 + 412) + 13)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 62;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    if (!v11) {
      if (!((unsigned __int8(__cdecl *)(int))v90[3])(a1))
        return 0;
      v10 = *v90;
      v11 = v90[1];
    }
    v86 = *v10 << 8;
    v12 = v10 + 1;
    v13 = v11 - 1;
    if (v11 == (unsigned __int8 *)1) {
      if (!((unsigned __int8(__cdecl *)(int))v90[3])(a1))
        return 0;
      v12 = *v90;
      v13 = v90[1];
    }
    v14 = *v12 + v86;
    v15 = v12 + 1;
    v16 = v13 - 1;
    if (!v16) {
      if (!((unsigned __int8(__cdecl *)(int))v90[3])(a1))
        return 0;
      v15 = *v90;
      v16 = v90[1];
    }
    v108 = v16 - 1;
    v17 = *v15;
    v88 = v17;
    v107 = v15 + 1;
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 103;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = v17;
    (*(void(__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
    if (v14 != 2 * v88 + 6 || v88 <= 0 || v88 > 4) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 11;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    *(_DWORD *)(a1 + 300) = v88;
    if (v88 > 0) {
      v102 = a1;
      v87 = 0;
      while (1) {
        if (v108) {
          v18 = v107;
          v19 = v107;
        } else {
          if (!((unsigned __int8(__cdecl *)(int))v90[3])(a1))
            return 0;
          v108 = v90[1];
          v18 = *v90;
          v19 = *v90;
        }
        v89 = *v18;
        v20 = v19 + 1;
        v21 = v108 - 1;
        if (v108 == (unsigned __int8 *)1) {
          if (!((unsigned __int8(__cdecl *)(int))v90[3])(a1))
            return 0;
          v20 = *v90;
          v21 = v90[1];
        }
        v108 = v21 - 1;
        v22 = *v20;
        v107 = v20 + 1;
        v23 = *(_DWORD **)(a1 + 204);
        v85 = *(_DWORD *)(a1 + 44);
        if (v85 <= 0)
          break;
        if (*v23 != v89) {
          v24 = v23 + 21;
          v25 = v23 + 21;
          v26 = 1;
          while (1) {
            v23 = v24;
            if (v85 == v26)
              break;
            v27 = *v25;
            ++v26;
            v25 += 21;
            if (v27 == v89)
              goto LABEL_45;
            v24 = v23 + 21;
          }
          v81 = a1;
          goto LABEL_183;
        }
      LABEL_45:
        *(_DWORD *)(v102 + 304) = v23;
        v23[5] = v22 >> 4;
        v23[6] = v22 & 0xF;
        v28 = (_DWORD *)(*(_DWORD *)a1 + 24);
        *v28 = v89;
        v28[1] = v23[5];
        v28[2] = v23[6];
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 104;
        (*(void(__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
        ++v87;
        v102 += 4;
        if (v88 == v87)
          goto LABEL_46;
      }
      v81 = a1;
    LABEL_183:
      *(_DWORD *)(*(_DWORD *)v81 + 20) = 5;
      *(_DWORD *)(*(_DWORD *)v81 + 24) = v89;
      (**(void(__cdecl ***)(int))v81)(v81);
      goto LABEL_45;
    }
  LABEL_46:
    if (!v108) {
      if (!((unsigned __int8(__cdecl *)(int))v90[3])(a1))
        return 0;
      v107 = *v90;
      v108 = v90[1];
    }
    v29 = v107 + 1;
    *(_DWORD *)(a1 + 372) = *v107;
    v30 = v108 - 1;
    if (v108 == (unsigned __int8 *)1) {
      if (!((unsigned __int8(__thiscall *)(unsigned __int8 *, int))v90[3])(v29,
                                                                           a1))
        return 0;
      v29 = *v90;
      v30 = v90[1];
    }
    v31 = v29 + 1;
    *(_DWORD *)(a1 + 376) = *v29;
    v32 = v30 - 1;
    if (v30 != (unsigned __int8 *)1) {
    LABEL_51:
      v33 = *v31;
      *(_DWORD *)(a1 + 380) = *v31 >> 4;
      *(_DWORD *)(a1 + 384) = v33 & 0xF;
      v34 = (_DWORD *)(*(_DWORD *)a1 + 24);
      *v34 = *(_DWORD *)(a1 + 372);
      v34[1] = *(_DWORD *)(a1 + 376);
      v34[2] = *(_DWORD *)(a1 + 380);
      v34[3] = *(_DWORD *)(a1 + 384);
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 105;
      (*(void(__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
      *(_DWORD *)(*(_DWORD *)(a1 + 412) + 16) = 0;
      ++*(_DWORD *)(a1 + 132);
      *v90 = v31 + 1;
      v90[1] = v32 - 1;
      *(_DWORD *)(a1 + 388) = 0;
      return 1;
    }
    if (((unsigned __int8(__cdecl *)(int))v90[3])(a1)) {
      v31 = *v90;
      v32 = v90[1];
      goto LABEL_51;
    }
    return 0;
  }
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 85;
  (*(void(__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
  *(_DWORD *)(a1 + 388) = 0;
  return 2;
}

int __cdecl read_restart_marker(_DWORD *a1) {
  if (!a1[97] && !(unsigned __int8)next_marker(a1))
    return 0;
  if (a1[97] == *(_DWORD *)(a1[103] + 16) + 208) {
    *(_DWORD *)(*a1 + 20) = 98;
    *(_DWORD *)(*a1 + 24) = *(_DWORD *)(a1[103] + 16);
    (*(void(__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 3);
    a1[97] = 0;
    goto LABEL_4;
  }
  if ((*(unsigned __int8(__cdecl **)(_DWORD *, _DWORD))(a1[8] + 20))(
          a1, *(_DWORD *)(a1[103] + 16))) {
  LABEL_4:
    *(_DWORD *)(a1[103] + 16) =
        ((unsigned __int8)*(_DWORD *)(a1[103] + 16) + 1) & 7;
    return 1;
  }
  return 0;
}

int __cdecl jpeg_resync_to_restart(_DWORD *a1, int a2) {
  int v2; // edi
  int v3; // esi

  v2 = a1[97];
  *(_DWORD *)(*a1 + 20) = 121;
  *(_DWORD *)(*a1 + 24) = v2;
  *(_DWORD *)(*a1 + 28) = a2;
  (*(void(__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
  while (1) {
    if (v2 > 191) {
      if ((unsigned int)(v2 - 208) > 7 || v2 == (((_BYTE)a2 + 1) & 7) + 208 ||
          v2 == (((_BYTE)a2 + 2) & 7) + 208) {
        v3 = 3;
        goto LABEL_10;
      }
      if (v2 != (((_BYTE)a2 - 1) & 7) + 208 &&
          v2 != (((_BYTE)a2 - 2) & 7) + 208) {
        v3 = 1;
        goto LABEL_10;
      }
    }
    v3 = 2;
  LABEL_10:
    *(_DWORD *)(*a1 + 20) = 97;
    *(_DWORD *)(*a1 + 24) = v2;
    *(_DWORD *)(*a1 + 28) = v3;
    (*(void(__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 4);
    if (v3 != 2)
      break;
    if (!(unsigned __int8)next_marker(a1))
      return 0;
    v2 = a1[97];
  }
  if (v3 != 3)
    a1[97] = 0;
  return 1;
}

_DWORD *__cdecl reset_marker_reader(_DWORD *a1) {
  _DWORD *result; // eax
  int v2;         // edx

  result = a1;
  v2 = a1[103];
  a1[51] = 0;
  a1[33] = 0;
  a1[97] = 0;
  *(_BYTE *)(v2 + 12) = 0;
  *(_BYTE *)(v2 + 13) = 0;
  *(_DWORD *)(v2 + 20) = 0;
  *(_DWORD *)(v2 + 160) = 0;
  return result;
}

int __cdecl jinit_marker_reader(int a1) {
  _DWORD *v1; // eax
  _DWORD *v2; // ecx
  int v3;     // edx
  int result; // eax

  v1 = (_DWORD *)(**(int(__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 168);
  v2 = v1;
  *(_DWORD *)(a1 + 412) = v1;
  *v1 = reset_marker_reader;
  v1[1] = read_markers;
  v1[2] = read_restart_marker;
  v1[6] = skip_variable;
  v1[23] = 0;
  v3 = 16;
  do {
    v1[7] = skip_variable;
    v1[24] = 0;
    ++v1;
    --v3;
  } while (v3);
  v2[7] = get_interesting_appn;
  v2[21] = get_interesting_appn;
  result = *(_DWORD *)(a1 + 412);
  *(_DWORD *)(a1 + 204) = 0;
  *(_DWORD *)(a1 + 132) = 0;
  *(_DWORD *)(a1 + 388) = 0;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 160) = 0;
  return result;
}

int __cdecl prepare_for_output_pass(int a1) {
  int v1;     // edi
  int result; // eax
  int v3;     // edx

  v1 = *(_DWORD *)(a1 + 392);
  if (*(_BYTE *)(v1 + 8)) {
    *(_BYTE *)(v1 + 8) = 0;
    (**(void(__cdecl ***)(int, _DWORD))(a1 + 432))(a1, 0);
    (**(void(__cdecl ***)(int, int))(a1 + 404))(a1, 2);
    result = (**(int(__cdecl ***)(int, int))(a1 + 396))(a1, 2);
  } else {
    if (*(_BYTE *)(a1 + 82) && !*(_DWORD *)(a1 + 124)) {
      if (*(_BYTE *)(a1 + 88) && *(_BYTE *)(a1 + 98)) {
        *(_DWORD *)(a1 + 432) = *(_DWORD *)(v1 + 24);
        *(_BYTE *)(v1 + 8) = 1;
      } else if (*(_BYTE *)(a1 + 96)) {
        *(_DWORD *)(a1 + 432) = *(_DWORD *)(v1 + 20);
      } else {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 46;
        (**(void(__cdecl ***)(int))a1)(a1);
      }
    }
    (**(void(__cdecl ***)(int))(a1 + 420))(a1);
    result = (*(int(__cdecl **)(int))(*(_DWORD *)(a1 + 400) + 8))(a1);
    if (!*(_BYTE *)(a1 + 73)) {
      if (!*(_BYTE *)(v1 + 16))
        (**(void(__cdecl ***)(int))(a1 + 428))(a1);
      (**(void(__cdecl ***)(int))(a1 + 424))(a1);
      if (*(_BYTE *)(a1 + 82))
        (**(void(__cdecl ***)(int, _DWORD))(a1 + 432))(
            a1, *(unsigned __int8 *)(v1 + 8));
      (**(void(__cdecl ***)(int, int))(a1 + 404))(
          a1, *(_BYTE *)(v1 + 8) != 0 ? 3 : 0);
      result = (**(int(__cdecl ***)(int, _DWORD))(a1 + 396))(a1, 0);
    }
  }
  v3 = *(_DWORD *)(a1 + 8);
  if (v3) {
    *(_DWORD *)(v3 + 12) = *(_DWORD *)(v1 + 12);
    result = *(_DWORD *)(v1 + 12) + 2 - (*(_BYTE *)(v1 + 8) == 0);
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16) = result;
    if (*(_BYTE *)(a1 + 72)) {
      result = *(_DWORD *)(a1 + 408);
      if (!*(_BYTE *)(result + 17)) {
        result = 2 - (*(_BYTE *)(a1 + 98) == 0);
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16) += result;
      }
    }
  }
  return result;
}

int __cdecl finish_output_pass(int a1) {
  int v1;     // esi
  int result; // eax

  v1 = *(_DWORD *)(a1 + 392);
  if (*(_BYTE *)(a1 + 82))
    result = (*(int(__cdecl **)(int))(*(_DWORD *)(a1 + 432) + 8))(a1);
  ++*(_DWORD *)(v1 + 12);
  return result;
}

int __cdecl jpeg_calc_output_dimensions(int a1) {
  int v1;          // ecx
  unsigned int v2; // edx
  _DWORD *v3;      // ecx
  int v4;          // esi
  int v5;          // edx
  _DWORD *v6;      // esi
  int v7;          // edx
  int result;      // eax
  int v9;          // ecx
  int v10;         // edx
  int v11;         // [esp+1Ch] [ebp-2Ch]
  int v12;         // [esp+20h] [ebp-28h]
  int v13;         // [esp+28h] [ebp-20h]
  int i;           // [esp+2Ch] [ebp-1Ch]

  if (*(_DWORD *)(a1 + 20) != 202) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 20);
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(a1 + 60);
  if (8 * v1 <= v2) {
    *(_DWORD *)(a1 + 100) = jdiv_round_up(*(_DWORD *)(a1 + 36), 8);
    *(_DWORD *)(a1 + 104) = jdiv_round_up(*(_DWORD *)(a1 + 40), 8);
    *(_DWORD *)(a1 + 288) = 1;
    goto LABEL_7;
  }
  if (v2 < 4 * v1) {
    if (v2 >= 2 * v1) {
      *(_DWORD *)(a1 + 100) = jdiv_round_up(*(_DWORD *)(a1 + 36), 2);
      *(_DWORD *)(a1 + 104) = jdiv_round_up(*(_DWORD *)(a1 + 40), 2);
      *(_DWORD *)(a1 + 288) = 4;
    } else {
      *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(a1 + 104) = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(a1 + 288) = 8;
    }
  LABEL_7:
    v3 = *(_DWORD **)(a1 + 204);
    if (*(int *)(a1 + 44) > 0)
      goto LABEL_8;
    goto LABEL_21;
  }
  *(_DWORD *)(a1 + 100) = jdiv_round_up(*(_DWORD *)(a1 + 36), 4);
  *(_DWORD *)(a1 + 104) = jdiv_round_up(*(_DWORD *)(a1 + 40), 4);
  *(_DWORD *)(a1 + 288) = 2;
  v3 = *(_DWORD **)(a1 + 204);
  if (*(int *)(a1 + 44) > 0) {
  LABEL_8:
    v4 = 0;
    do {
      v5 = *(_DWORD *)(a1 + 288);
      if (v5 <= 7) {
        v13 = v3[2];
        v11 = *(_DWORD *)(a1 + 280) * v5;
        if (2 * v5 * v13 <= v11) {
          v12 = *(_DWORD *)(a1 + 284) * v5;
          do {
            if (2 * v5 * v3[3] > v12)
              break;
            v5 *= 2;
            if (v5 > 7)
              break;
          } while (2 * v5 * v13 <= v11);
        }
      }
      v3[9] = v5;
      ++v4;
      v3 += 21;
    } while (*(_DWORD *)(a1 + 44) > v4);
    v6 = *(_DWORD **)(a1 + 204);
    v7 = *(_DWORD *)(a1 + 44);
    if (v7 > 0) {
      for (i = 0; i < v7; ++i) {
        v6[10] = jdiv_round_up(*(_DWORD *)(a1 + 36) * v6[9] * v6[2],
                               8 * *(_DWORD *)(a1 + 280));
        v6[11] = jdiv_round_up(*(_DWORD *)(a1 + 40) * v6[9] * v6[3],
                               8 * *(_DWORD *)(a1 + 284));
        v6 += 21;
        v7 = *(_DWORD *)(a1 + 44);
      }
    }
    goto LABEL_19;
  }
LABEL_21:
  v7 = *(_DWORD *)(a1 + 44);
  if (*(_DWORD *)(a1 + 52) > 5u) {
  LABEL_22:
    *(_DWORD *)(a1 + 108) = v7;
    goto LABEL_23;
  }
LABEL_19:
  switch (*(_DWORD *)(a1 + 52)) {
  case 1:
    *(_DWORD *)(a1 + 108) = 1;
    break;
  case 2:
  case 3:
    *(_DWORD *)(a1 + 108) = 3;
    break;
  case 4:
  case 5:
    *(_DWORD *)(a1 + 108) = 4;
    break;
  default:
    goto LABEL_22;
  }
LABEL_23:
  if (*(_BYTE *)(a1 + 82))
    result = 1;
  else
    result = *(_DWORD *)(a1 + 108);
  *(_DWORD *)(a1 + 112) = result;
  if (!*(_BYTE *)(a1 + 80) && !*(_BYTE *)(a1 + 274) &&
      *(_DWORD *)(a1 + 48) == 3 && *(_DWORD *)(a1 + 44) == 3 &&
      *(_DWORD *)(a1 + 52) == 2 && *(_DWORD *)(a1 + 108) == 3 &&
      (result = *(_DWORD *)(a1 + 204), *(_DWORD *)(result + 8) == 2) &&
      (v9 = result + 84, *(_DWORD *)(result + 92) == 1) &&
      (v10 = result + 168, *(_DWORD *)(result + 176) == 1) &&
      *(int *)(result + 12) <= 2 && *(_DWORD *)(result + 96) == 1 &&
      *(_DWORD *)(result + 180) == 1 &&
      (result = *(_DWORD *)(result + 36), result == *(_DWORD *)(a1 + 288)) &&
      result == *(_DWORD *)(v9 + 36) && result == *(_DWORD *)(v10 + 36)) {
    result = *(_DWORD *)(a1 + 284);
    *(_DWORD *)(a1 + 116) = result;
  } else {
    *(_DWORD *)(a1 + 116) = 1;
  }
  return result;
}

int __cdecl jinit_master_decompress(int a1) {
  int v1;     // eax
  int i;      // eax
  bool v3;    // al
  int result; // eax
  int v5;     // ecx
  int v6;     // edx
  _DWORD *v7; // eax
  _DWORD *v8; // ecx
  _DWORD *v9; // edx
  int v10;    // eax
  int v11;    // [esp+18h] [ebp-20h]
  int v12;    // [esp+1Ch] [ebp-1Ch]

  v1 = (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 28);
  *(_DWORD *)(a1 + 392) = v1;
  *(_DWORD *)v1 = prepare_for_output_pass;
  *(_DWORD *)(v1 + 4) = finish_output_pass;
  *(_BYTE *)(v1 + 8) = 0;
  v11 = *(_DWORD *)(a1 + 392);
  jpeg_calc_output_dimensions(a1);
  v12 = (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1408);
  *(_DWORD *)(a1 + 296) = v12 + 256;
  memset((void *)v12, 0, 0x100u);
  for (i = 0; i != 256; ++i)
    *(_BYTE *)(v12 + 256 + i) = i;
  LOWORD(i) = 0;
  do
    *(_BYTE *)(v12 + 384 + i++ + 128) = -1;
  while (i != 384);
  memset((void *)(v12 + 896), 0, 0x180u);
  memcpy((void *)(v12 + 1280), *(const void **)(a1 + 296), 0x80u);
  *(_DWORD *)(v11 + 12) = 0;
  v3 = 0;
  if (!*(_BYTE *)(a1 + 80) && !*(_BYTE *)(a1 + 274) &&
      *(_DWORD *)(a1 + 48) == 3 && *(_DWORD *)(a1 + 44) == 3 &&
      *(_DWORD *)(a1 + 52) == 2 && *(_DWORD *)(a1 + 108) == 3) {
    v7 = *(_DWORD **)(a1 + 204);
    if (v7[2] == 2) {
      v8 = v7 + 21;
      if (v7[23] == 1) {
        v9 = v7 + 42;
        if (v7[44] == 1 && (int)v7[3] <= 2 && v7[24] == 1 && v7[45] == 1) {
          v10 = v7[9];
          if (v10 == *(_DWORD *)(a1 + 288) && v10 == v8[9] && v10 == v9[9])
            v3 = 1;
        }
      }
    }
  }
  *(_BYTE *)(v11 + 16) = v3;
  *(_DWORD *)(v11 + 20) = 0;
  *(_DWORD *)(v11 + 24) = 0;
  if (*(_BYTE *)(a1 + 82) && *(_BYTE *)(a1 + 72)) {
    if (!*(_BYTE *)(a1 + 73))
      goto LABEL_11;
  LABEL_57:
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 47;
    (**(void(__cdecl ***)(int))a1)(a1);
    if (*(_DWORD *)(a1 + 108) != 3)
      goto LABEL_12;
    goto LABEL_54;
  }
  *(_BYTE *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 97) = 0;
  *(_BYTE *)(a1 + 98) = 0;
  if (!*(_BYTE *)(a1 + 82))
    goto LABEL_16;
  if (*(_BYTE *)(a1 + 73))
    goto LABEL_57;
LABEL_11:
  if (*(_DWORD *)(a1 + 108) != 3) {
  LABEL_12:
    *(_BYTE *)(a1 + 96) = 1;
    *(_BYTE *)(a1 + 97) = 0;
    *(_BYTE *)(a1 + 98) = 0;
    *(_DWORD *)(a1 + 124) = 0;
    goto LABEL_13;
  }
LABEL_54:
  if (*(_DWORD *)(a1 + 124)) {
    *(_BYTE *)(a1 + 97) = 1;
    if (!*(_BYTE *)(a1 + 96))
      goto LABEL_14;
    goto LABEL_56;
  }
  if (*(_BYTE *)(a1 + 88))
    *(_BYTE *)(a1 + 98) = 1;
  else
    *(_BYTE *)(a1 + 96) = 1;
LABEL_13:
  if (!*(_BYTE *)(a1 + 96))
    goto LABEL_14;
LABEL_56:
  jinit_1pass_quantizer((_DWORD *)a1);
  *(_DWORD *)(v11 + 20) = *(_DWORD *)(a1 + 432);
LABEL_14:
  if ((*(_DWORD *)(a1 + 96) & 0xFFFF00) != 0) {
    jinit_2pass_quantizer(a1);
    *(_DWORD *)(v11 + 24) = *(_DWORD *)(a1 + 432);
  }
LABEL_16:
  if (!*(_BYTE *)(a1 + 73)) {
    if (*(_BYTE *)(v11 + 16)) {
      jinit_merged_upsampler(a1);
    } else {
      jinit_color_deconverter(a1);
      jinit_upsampler(a1);
    }
    jinit_d_post_controller(a1, *(_BYTE *)(a1 + 98));
  }
  jinit_inverse_dct(a1);
  if (*(_BYTE *)(a1 + 209)) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 1;
    (**(void(__cdecl ***)(int))a1)(a1);
  LABEL_23:
    if (*(_BYTE *)(*(_DWORD *)(a1 + 408) + 16))
      goto LABEL_37;
    goto LABEL_24;
  }
  if (*(_BYTE *)(a1 + 208)) {
    jinit_phuff_decoder(a1);
    goto LABEL_23;
  }
  jinit_huff_decoder(a1);
  if (*(_BYTE *)(*(_DWORD *)(a1 + 408) + 16)) {
  LABEL_37:
    jinit_d_coef_controller(a1, 1);
    if (*(_BYTE *)(a1 + 73))
      goto LABEL_26;
  LABEL_38:
    jinit_d_main_controller(a1, 0);
    goto LABEL_26;
  }
LABEL_24:
  if (*(_BYTE *)(a1 + 72))
    goto LABEL_37;
  jinit_d_coef_controller(a1, 0);
  if (!*(_BYTE *)(a1 + 73))
    goto LABEL_38;
LABEL_26:
  (*(void(__cdecl **)(int))(*(_DWORD *)(a1 + 4) + 24))(a1);
  result = (*(int(__cdecl **)(int))(*(_DWORD *)(a1 + 408) + 8))(a1);
  v5 = *(_DWORD *)(a1 + 8);
  if (v5) {
    if (!*(_BYTE *)(a1 + 72)) {
      result = *(_DWORD *)(a1 + 408);
      if (*(_BYTE *)(result + 16)) {
        if (*(_BYTE *)(a1 + 208))
          v6 = 3 * *(_DWORD *)(a1 + 44) + 2;
        else
          v6 = *(_DWORD *)(a1 + 44);
        *(_DWORD *)(v5 + 4) = 0;
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 8) = *(_DWORD *)(a1 + 292) * v6;
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 12) = 0;
        result = 3 - (*(_BYTE *)(a1 + 98) == 0);
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16) = result;
        ++*(_DWORD *)(v11 + 12);
      }
    }
  }
  return result;
}

int __cdecl jinit_compress_master(int a1) {
  char v1; // al

  jinit_c_master_control(a1, 0);
  if (!*(_BYTE *)(a1 + 180)) {
    jinit_color_converter(a1);
    jinit_downsampler(a1);
    jinit_c_prep_controller(a1, 0);
  }
  jinit_forward_dct(a1);
  if (*(_BYTE *)(a1 + 181)) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 1;
    (**(void(__cdecl ***)(int))a1)(a1);
  LABEL_6:
    if (*(int *)(a1 + 172) > 1)
      goto LABEL_7;
    goto LABEL_10;
  }
  if (*(_BYTE *)(a1 + 216)) {
    jinit_phuff_encoder(a1);
    goto LABEL_6;
  }
  jinit_huff_encoder(a1);
  if (*(int *)(a1 + 172) > 1)
    goto LABEL_7;
LABEL_10:
  if (!*(_BYTE *)(a1 + 182)) {
    v1 = 0;
    goto LABEL_8;
  }
LABEL_7:
  v1 = 1;
LABEL_8:
  jinit_c_coef_controller(a1, v1);
  jinit_c_main_controller(a1, 0);
  jinit_marker_writer(a1);
  (*(void(__cdecl **)(int))(*(_DWORD *)(a1 + 4) + 24))(a1);
  return (**(int(__cdecl ***)(int))(a1 + 336))(a1);
}

int __cdecl inflate_codes_new(char a1, char a2, int a3, int a4, int a5) {
  int result; // eax

  result = (*(int(__cdecl **)(_DWORD, int, int))(a5 + 32))(*(_DWORD *)(a5 + 40),
                                                           1, 28);
  if (result) {
    *(_DWORD *)result = 0;
    *(_BYTE *)(result + 16) = a1;
    *(_BYTE *)(result + 17) = a2;
    *(_DWORD *)(result + 20) = a3;
    *(_DWORD *)(result + 24) = a4;
  }
  return result;
}

int __cdecl inflate_codes(_DWORD *a1, int a2, int a3) {
  _BYTE *v3;            // edx
  unsigned int v4;      // eax
  int v5;               // ecx
  unsigned int v7;      // edi
  unsigned __int8 *v8;  // edx
  int v9;               // edx
  _BYTE *v10;           // eax
  int v11;              // edi
  _BYTE *v12;           // edx
  unsigned int v13;     // ecx
  _BYTE *v14;           // edi
  unsigned int v15;     // edx
  _BYTE *v16;           // eax
  unsigned int v17;     // edx
  _BYTE *v18;           // ecx
  int v19;              // eax
  unsigned int v20;     // edi
  unsigned __int8 *v21; // edx
  unsigned int v22;     // edi
  unsigned __int8 *v23; // edx
  int v24;              // ecx
  int v25;              // eax
  unsigned __int8 *v26; // edx
  unsigned __int8 *v27; // ecx
  _BYTE *v28;           // edx
  int v29;              // edi
  int v30;              // ecx
  unsigned __int8 v31;  // al
  unsigned __int8 *v32; // edx
  _DWORD *v33;          // eax
  _BYTE *v34;           // eax
  unsigned int v35;     // eax
  _BYTE *v36;           // eax
  unsigned int v37;     // eax
  unsigned int v38;     // [esp+2Ch] [ebp-4Ch]
  int v39;              // [esp+2Ch] [ebp-4Ch]
  unsigned int v40;     // [esp+2Ch] [ebp-4Ch]
  unsigned int v41;     // [esp+2Ch] [ebp-4Ch]
  unsigned int v43;     // [esp+38h] [ebp-40h]
  unsigned int v44;     // [esp+3Ch] [ebp-3Ch]
  unsigned int v45;     // [esp+40h] [ebp-38h]
  unsigned int v46;     // [esp+44h] [ebp-34h]
  int v47;              // [esp+48h] [ebp-30h]
  unsigned __int8 *v48; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *v49; // [esp+50h] [ebp-28h]
  int v50;              // [esp+54h] [ebp-24h]
  unsigned int v51;     // [esp+58h] [ebp-20h]
  _BYTE *v52;           // [esp+5Ch] [ebp-1Ch]
  int v53;              // [esp+88h] [ebp+10h]

  v47 = a1[1];
  v48 = *(unsigned __int8 **)a2;
  v45 = *(_DWORD *)(a2 + 4);
  v43 = a1[8];
  v44 = a1[7];
  v3 = (_BYTE *)a1[13];
  v52 = v3;
  v4 = a1[12];
  if ((unsigned int)v3 >= v4)
    v46 = a1[11] - (_DWORD)v3;
  else
    v46 = v4 - (_DWORD)v3 - 1;
  while (2) {
    switch (*(_DWORD *)v47) {
    case 0:
      if (v46 <= 0x101 || v45 <= 9)
        goto LABEL_9;
      a1[8] = v43;
      a1[7] = v44;
      *(_DWORD *)(a2 + 4) = v45;
      *(_DWORD *)(a2 + 8) += &v48[-*(_DWORD *)a2];
      *(_DWORD *)a2 = v48;
      a1[13] = v52;
      a3 = inflate_fast(*(unsigned __int8 *)(v47 + 16),
                        *(unsigned __int8 *)(v47 + 17), *(_DWORD *)(v47 + 20),
                        *(_DWORD *)(v47 + 24), a1, (unsigned __int8 **)a2);
      v48 = *(unsigned __int8 **)a2;
      v45 = *(_DWORD *)(a2 + 4);
      v43 = a1[8];
      v44 = a1[7];
      v52 = (_BYTE *)a1[13];
      v35 = a1[12];
      v46 = (unsigned int)v52 >= v35 ? a1[11] - (_DWORD)v52
                                     : v35 - (_DWORD)v52 - 1;
      if (!a3) {
      LABEL_9:
        *(_DWORD *)(v47 + 12) = *(unsigned __int8 *)(v47 + 16);
        *(_DWORD *)(v47 + 8) = *(_DWORD *)(v47 + 20);
        *(_DWORD *)v47 = 1;
        goto LABEL_10;
      }
      *(_DWORD *)v47 = 2 * (a3 != 1) + 7;
      continue;
    case 1:
    LABEL_10:
      v49 = v48;
      v38 = *(_DWORD *)(v47 + 12);
      if (v44 >= v38)
        goto LABEL_74;
      if (!v45) {
        v8 = v48;
      LABEL_16:
        a1[8] = v43;
        a1[7] = v44;
        v5 = a2;
        *(_DWORD *)(a2 + 4) = 0;
        *(_DWORD *)(a2 + 8) += &v8[-*(_DWORD *)a2];
        *(_DWORD *)a2 = v8;
        a1[13] = v52;
        v53 = a3;
        goto LABEL_5;
      }
      v7 = v45;
      while (1) {
        --v7;
        v43 |= *v48++ << v44;
        v44 += 8;
        if (v38 <= v44)
          break;
        v8 = &v49[v45];
        if (&v49[v45] == v48) {
          a3 = 0;
          goto LABEL_16;
        }
      }
      v45 = v7;
      a3 = 0;
    LABEL_74:
      v29 = *(_DWORD *)(v47 + 8) + 8 * (inflate_mask[v38] & v43);
      v30 = *(unsigned __int8 *)(v29 + 1);
      v43 >>= v30;
      v44 -= v30;
      v31 = *(_BYTE *)v29;
      if (*(_BYTE *)v29) {
        if ((v31 & 0x10) != 0) {
          *(_DWORD *)(v47 + 8) = v31 & 0xF;
          *(_DWORD *)(v47 + 4) = *(_DWORD *)(v29 + 4);
          *(_DWORD *)v47 = 2;
        } else if ((v31 & 0x40) != 0) {
          if ((v31 & 0x20) == 0) {
            *(_DWORD *)v47 = 9;
            *(_DWORD *)(a2 + 24) = "invalid literal/length code";
            a1[8] = v43;
            a1[7] = v44;
            *(_DWORD *)(a2 + 4) = v45;
            *(_DWORD *)(a2 + 8) += &v48[-*(_DWORD *)a2];
            *(_DWORD *)a2 = v48;
            a1[13] = v52;
            v53 = -3;
            v5 = a2;
          LABEL_5:
            a2 = v5;
            return inflate_flush(a1, (_DWORD *)a2, v53);
          }
          *(_DWORD *)v47 = 7;
        } else {
          *(_DWORD *)(v47 + 12) = v31;
          *(_DWORD *)(v47 + 8) = v29 + 8 * *(_DWORD *)(v29 + 4);
        }
      } else {
        *(_DWORD *)(v47 + 8) = *(_DWORD *)(v29 + 4);
        *(_DWORD *)v47 = 6;
      }
      continue;
    case 2:
      v51 = *(_DWORD *)(v47 + 8);
      if (v44 >= v51) {
        v22 = v45;
      } else {
        if (!v45) {
          v27 = v48;
          goto LABEL_66;
        }
        v22 = v45;
        v26 = v48;
        while (1) {
          --v22;
          v43 |= *v26++ << v44;
          v44 += 8;
          if (v51 <= v44)
            break;
          v27 = &v48[v45];
          if (&v48[v45] == v26) {
            a3 = 0;
          LABEL_66:
            a1[8] = v43;
            a1[7] = v44;
            *(_DWORD *)(a2 + 4) = 0;
            *(_DWORD *)(a2 + 8) += &v27[-*(_DWORD *)a2];
            *(_DWORD *)a2 = v27;
            a1[13] = v52;
            v53 = a3;
            return inflate_flush(a1, (_DWORD *)a2, v53);
          }
        }
        v48 = v26;
        a3 = 0;
      }
      *(_DWORD *)(v47 + 4) += v43 & inflate_mask[v51];
      v43 >>= v51;
      v44 -= v51;
      *(_DWORD *)(v47 + 12) = *(unsigned __int8 *)(v47 + 17);
      *(_DWORD *)(v47 + 8) = *(_DWORD *)(v47 + 24);
      *(_DWORD *)v47 = 3;
    LABEL_54:
      v41 = *(_DWORD *)(v47 + 12);
      if (v44 >= v41) {
        v45 = v22;
      LABEL_56:
        v23 = (unsigned __int8 *)(*(_DWORD *)(v47 + 8) +
                                  8 * (inflate_mask[v41] & v43));
        v24 = v23[1];
        v43 >>= v24;
        v44 -= v24;
        v25 = *v23;
        if ((v25 & 0x10) != 0) {
          *(_DWORD *)(v47 + 8) = v25 & 0xF;
          *(_DWORD *)(v47 + 12) = *((_DWORD *)v23 + 1);
          *(_DWORD *)v47 = 4;
        } else {
          if ((v25 & 0x40) != 0) {
            *(_DWORD *)v47 = 9;
            *(_DWORD *)(a2 + 24) = "invalid distance code";
            a1[8] = v43;
            a1[7] = v44;
            *(_DWORD *)(a2 + 4) = v45;
            *(_DWORD *)(a2 + 8) += &v48[-*(_DWORD *)a2];
            *(_DWORD *)a2 = v48;
            a1[13] = v52;
            v53 = -3;
            return inflate_flush(a1, (_DWORD *)a2, v53);
          }
          *(_DWORD *)(v47 + 12) = v25;
          *(_DWORD *)(v47 + 8) = &v23[8 * *((_DWORD *)v23 + 1)];
        }
        continue;
      }
      if (!v22)
        goto LABEL_52;
      v45 = v22;
      v32 = v48;
      do {
        --v45;
        v43 |= *v32++ << v44;
        v44 += 8;
        if (v44 >= v41) {
          v48 = v32;
          a3 = 0;
          goto LABEL_56;
        }
      } while (v32 != &v48[v22]);
      v48 = v32;
      a3 = 0;
    LABEL_52:
      a1[8] = v43;
      a1[7] = v44;
      *(_DWORD *)(a2 + 4) = 0;
      *(_DWORD *)(a2 + 8) += &v48[-*(_DWORD *)a2];
      *(_DWORD *)a2 = v48;
      a1[13] = v52;
      v53 = a3;
      return inflate_flush(a1, (_DWORD *)a2, v53);
    case 3:
      v22 = v45;
      goto LABEL_54;
    case 4:
      v20 = *(_DWORD *)(v47 + 8);
      if (v44 >= v20) {
        v21 = v48;
      } else {
        if (!v45)
          goto LABEL_52;
        v21 = v48;
        v40 = v45;
        while (1) {
          --v40;
          v43 |= *v21++ << v44;
          v44 += 8;
          if (v20 <= v44)
            break;
          if (v21 == &v48[v45]) {
            v48 = v21;
            a3 = 0;
            goto LABEL_52;
          }
        }
        v45 = v40;
        a3 = 0;
      }
      v39 = *(_DWORD *)(v47 + 12) + (inflate_mask[v20] & v43);
      *(_DWORD *)(v47 + 12) = v39;
      v43 >>= v20;
      v44 -= v20;
      *(_DWORD *)v47 = 5;
      v48 = v21;
    LABEL_31:
      v14 = &v52[-v39];
      v15 = a1[10];
      if (v15 > (unsigned int)&v52[-v39]) {
        do
          v14 += a1[11] - v15;
        while (v15 > (unsigned int)v14);
      }
      if (!*(_DWORD *)(v47 + 4)) {
        v33 = (_DWORD *)v47;
        goto LABEL_84;
      }
      while (2) {
        if (v46)
          goto LABEL_42;
        v16 = (_BYTE *)a1[11];
        if (v16 != v52)
          goto LABEL_36;
        v28 = (_BYTE *)a1[12];
        v52 = (_BYTE *)a1[10];
        if (v28 == v52)
          goto LABEL_37;
        if (v28 <= v52)
          v46 = v16 - v52;
        else
          v46 = v28 - v52 - 1;
        if (!v46) {
        LABEL_36:
          v16 = v52;
        LABEL_37:
          a1[13] = v16;
          v50 = inflate_flush(a1, (_DWORD *)a2, a3);
          v17 = a1[13];
          v18 = (_BYTE *)a1[12];
          if (v17 >= (unsigned int)v18)
            v46 = a1[11] - v17;
          else
            v46 = (unsigned int)&v18[-v17 - 1];
          if (v17 != a1[11] || (v34 = (_BYTE *)a1[10], v52 = v34, v18 == v34)) {
            v52 = (_BYTE *)a1[13];
          } else if (v18 <= v34) {
            v46 = v17 - (_DWORD)v34;
          } else {
            v46 = v18 - v34 - 1;
          }
          if (!v46) {
            a1[8] = v43;
            a1[7] = v44;
            *(_DWORD *)(a2 + 4) = v45;
            *(_DWORD *)(a2 + 8) += &v48[-*(_DWORD *)a2];
            *(_DWORD *)a2 = v48;
            a1[13] = v52;
            v53 = v50;
            return inflate_flush(a1, (_DWORD *)a2, v53);
          }
        }
      LABEL_42:
        *v52++ = *v14++;
        --v46;
        if (v14 == (_BYTE *)a1[11])
          v14 = (_BYTE *)a1[10];
        v19 = *(_DWORD *)(v47 + 4) - 1;
        *(_DWORD *)(v47 + 4) = v19;
        if (v19) {
          a3 = 0;
          continue;
        }
        break;
      }
      a3 = 0;
      v33 = (_DWORD *)v47;
    LABEL_84:
      *v33 = 0;
      continue;
    case 5:
      v39 = *(_DWORD *)(v47 + 12);
      goto LABEL_31;
    case 6:
      if (v46) {
        v12 = v52;
        goto LABEL_29;
      }
      if (v52 == (_BYTE *)a1[11]) {
        v36 = (_BYTE *)a1[12];
        v12 = (_BYTE *)a1[10];
        if (v36 == v12) {
          v10 = v52;
        } else {
          if (v36 <= v12)
            v46 = v52 - v12;
          else
            v46 = v36 - v12 - 1;
          if (v46)
            goto LABEL_29;
          v10 = (_BYTE *)a1[10];
        }
      } else {
        v10 = v52;
      }
      a1[13] = v10;
      v11 = inflate_flush(a1, (_DWORD *)a2, a3);
      v12 = (_BYTE *)a1[13];
      v13 = a1[12];
      if ((unsigned int)v12 >= v13)
        v46 = a1[11] - (_DWORD)v12;
      else
        v46 = v13 - (_DWORD)v12 - 1;
      if (v12 == (_BYTE *)a1[11]) {
        v37 = a1[10];
        if (v13 != v37) {
          if (v13 <= v37)
            v46 = (unsigned int)&v12[-v37];
          else
            v46 = v13 - v37 - 1;
          v12 = (_BYTE *)a1[10];
        }
      }
      if (!v46) {
        a1[8] = v43;
        a1[7] = v44;
        *(_DWORD *)(a2 + 4) = v45;
        *(_DWORD *)(a2 + 8) += &v48[-*(_DWORD *)a2];
        *(_DWORD *)a2 = v48;
        a1[13] = v12;
        v53 = v11;
        return inflate_flush(a1, (_DWORD *)a2, v53);
      }
    LABEL_29:
      *v12 = *(_DWORD *)(v47 + 8);
      v52 = v12 + 1;
      --v46;
      *(_DWORD *)v47 = 0;
      a3 = 0;
      continue;
    case 7:
      if (v44 > 7) {
        v44 -= 8;
        ++v45;
        --v48;
      }
      a1[13] = v52;
      v9 = inflate_flush(a1, (_DWORD *)a2, a3);
      v52 = (_BYTE *)a1[13];
      if (v52 == (_BYTE *)a1[12]) {
        *(_DWORD *)v47 = 8;
      LABEL_21:
        a1[8] = v43;
        a1[7] = v44;
        *(_DWORD *)(a2 + 4) = v45;
        *(_DWORD *)(a2 + 8) += &v48[-*(_DWORD *)a2];
        *(_DWORD *)a2 = v48;
        a1[13] = v52;
        v53 = 1;
      } else {
        a1[8] = v43;
        a1[7] = v44;
        *(_DWORD *)(a2 + 4) = v45;
        *(_DWORD *)(a2 + 8) += &v48[-*(_DWORD *)a2];
        *(_DWORD *)a2 = v48;
        a1[13] = v52;
        v53 = v9;
      }
      return inflate_flush(a1, (_DWORD *)a2, v53);
    case 8:
      goto LABEL_21;
    case 9:
      a1[8] = v43;
      a1[7] = v44;
      *(_DWORD *)(a2 + 4) = v45;
      *(_DWORD *)(a2 + 8) += &v48[-*(_DWORD *)a2];
      *(_DWORD *)a2 = v48;
      a1[13] = v52;
      v53 = -3;
      return inflate_flush(a1, (_DWORD *)a2, v53);
    default:
      a1[8] = v43;
      a1[7] = v44;
      *(_DWORD *)(a2 + 4) = v45;
      v5 = a2;
      *(_DWORD *)(a2 + 8) += &v48[-*(_DWORD *)a2];
      *(_DWORD *)a2 = v48;
      a1[13] = v52;
      v53 = -2;
      goto LABEL_5;
    }
  }
}

int __cdecl inflate_codes_free(int a1, int a2) {
  return (*(int(__cdecl **)(_DWORD, int))(a2 + 36))(*(_DWORD *)(a2 + 40), a1);
}

int __cdecl inflate_flush(_DWORD *a1, _DWORD *a2, int a3) {
  char *v3;                                   // edi
  unsigned int v4;                            // eax
  size_t v5;                                  // esi
  size_t v6;                                  // eax
  size_t v7;                                  // edx
  int v8;                                     // eax
  int(__cdecl * v9)(_DWORD, char *, size_t);  // edx
  int v10;                                    // eax
  char *v11;                                  // eax
  _DWORD *v12;                                // ecx
  char *v14;                                  // edi
  size_t v15;                                 // esi
  size_t v16;                                 // eax
  size_t v17;                                 // edx
  int v18;                                    // eax
  int(__cdecl * v19)(_DWORD, char *, size_t); // edx
  int v20;                                    // eax
  char *v21;                                  // [esp+18h] [ebp-10h]
  char *__dst;                                // [esp+1Ch] [ebp-Ch]

  __dst = (char *)a2[3];
  v3 = (char *)a1[12];
  v4 = a1[13];
  if ((unsigned int)v3 > v4)
    v4 = a1[11];
  v5 = v4 - (_DWORD)v3;
  v6 = a2[4];
  if (v5 <= v6) {
    v7 = v6 - v5;
  } else {
    v5 = a2[4];
    v7 = 0;
  }
  if (v5) {
    v8 = 0;
    if (a3 != -5)
      v8 = a3;
    a3 = v8;
  }
  a2[4] = v7;
  a2[5] += v5;
  v9 = (int(__cdecl *)(_DWORD, char *, size_t))a1[14];
  if (v9) {
    v10 = v9(a1[15], v3, v5);
    a1[15] = v10;
    a2[12] = v10;
  }
  if (__dst) {
    memcpy(__dst, v3, v5);
    v21 = &__dst[v5];
    v11 = &v3[v5];
    v12 = a1;
    if (&v3[v5] != (char *)a1[11]) {
    LABEL_13:
      a2[3] = v21;
      a1[12] = v11;
      return a3;
    }
  } else {
    v21 = 0;
    v11 = &v3[v5];
    v12 = a1;
    if (&v3[v5] != (char *)a1[11])
      goto LABEL_13;
  }
  v14 = (char *)v12[10];
  if (v11 == (char *)v12[13])
    v12[13] = v14;
  v15 = a1[13] - (_DWORD)v14;
  v16 = a2[4];
  if (v15 <= v16) {
    v17 = v16 - v15;
  } else {
    v15 = a2[4];
    v17 = 0;
  }
  if (v15) {
    v18 = 0;
    if (a3 != -5)
      v18 = a3;
    a3 = v18;
  }
  a2[4] = v17;
  a2[5] += v15;
  v19 = (int(__cdecl *)(_DWORD, char *, size_t))a1[14];
  if (v19) {
    v20 = v19(a1[15], v14, v15);
    a1[15] = v20;
    a2[12] = v20;
  }
  if (v21) {
    memcpy(v21, v14, v15);
    v21 += v15;
  }
  a2[3] = v21;
  a1[12] = &v14[v15];
  return a3;
}

int __cdecl inflate_trees_bits(_DWORD *a1, unsigned int *a2, _DWORD *a3, int a4,
                               int a5) {
  unsigned int *v5; // eax
  unsigned int *v6; // esi
  int v7;           // eax
  int v8;           // edi
  _DWORD v10[7];    // [esp+2Ch] [ebp-1Ch] BYREF

  v10[0] = 0;
  v5 = (unsigned int *)(*(int(__cdecl **)(_DWORD, int, int))(a5 + 32))(
      *(_DWORD *)(a5 + 40), 19, 4);
  v6 = v5;
  if (!v5)
    return -4;
  v7 = huft_build(a1, 0x13u, 0x13u, 0, 0, a3, a2, a4, v10, v5);
  v8 = v7;
  if (v7 == -3) {
    *(_DWORD *)(a5 + 24) = "oversubscribed dynamic bit lengths tree";
  } else if (v7 == -5 || !*a2) {
    *(_DWORD *)(a5 + 24) = "incomplete dynamic bit lengths tree";
    v8 = -3;
  }
  (*(void(__cdecl **)(_DWORD, unsigned int *))(a5 + 36))(*(_DWORD *)(a5 + 40),
                                                         v6);
  return v8;
}

int __cdecl inflate_trees_dynamic(unsigned int a1, unsigned int a2, _DWORD *a3,
                                  unsigned int *a4, unsigned int *a5,
                                  _DWORD *a6, _DWORD *a7, int a8, int a9) {
  unsigned int *v9;  // eax
  unsigned int *v10; // edi
  int v11;           // eax
  int v12;           // esi
  int v14;           // eax
  _DWORD v15[7];     // [esp+3Ch] [ebp-1Ch] BYREF

  v15[0] = 0;
  v9 = (unsigned int *)(*(int(__cdecl **)(_DWORD, int, int))(a9 + 32))(
      *(_DWORD *)(a9 + 40), 288, 4);
  v10 = v9;
  if (v9) {
    v11 = huft_build(a3, a1, 0x101u, (int)&cplens, (int)&cplext, a6, a4, a8,
                     v15, v9);
    v12 = v11;
    if (v11) {
      if (v11 == -3) {
        *(_DWORD *)(a9 + 24) = "oversubscribed literal/length tree";
        goto LABEL_5;
      }
      if (v11 == -4)
        goto LABEL_5;
    } else if (*a4) {
      v14 = huft_build(&a3[a1], a2, 0, (int)&cpdist, (int)&cpdext, a7, a5, a8,
                       v15, v10);
      v12 = v14;
      if (v14) {
        switch (v14) {
        case -3:
          *(_DWORD *)(a9 + 24) = "oversubscribed distance tree";
          goto LABEL_5;
        case -5:
          *(_DWORD *)(a9 + 24) = "incomplete distance tree";
          LOWORD(v12) = -3;
          goto LABEL_5;
        case -4:
          goto LABEL_5;
        }
      } else if (*a5 || a1 <= 0x101) {
        (*(void(__cdecl **)(_DWORD, unsigned int *))(a9 + 36))(
            *(_DWORD *)(a9 + 40), v10);
        return 0;
      }
      *(_DWORD *)(a9 + 24) = "empty distance tree with lengths";
      v12 = -3;
      goto LABEL_5;
    }
    *(_DWORD *)(a9 + 24) = "incomplete literal/length tree";
    v12 = -3;
  LABEL_5:
    (*(void(__cdecl **)(_DWORD, unsigned int *))(a9 + 36))(*(_DWORD *)(a9 + 40),
                                                           v10);
    return v12;
  }
  return -4;
}

int __cdecl inflate_trees_fixed(_DWORD *a1, _DWORD *a2, _DWORD *a3,
                                _DWORD *a4) {
  *a1 = fixed_bl;
  *a2 = fixed_bd;
  *a3 = &fixed_tl;
  *a4 = &fixed_td;
  return 0;
}

int __cdecl jdiv_round_up(int a1, int a2) { return (a2 + a1 - 1) / a2; }

int __cdecl jround_up(int a1, int a2) {
  return a1 + a2 - 1 - (a1 + a2 - 1) % a2;
}

int __cdecl jcopy_sample_rows(int a1, int a2, int a3, int a4, int a5,
                              size_t __n) {
  const void **v6; // edi
  void **v7;       // esi
  int result;      // eax
  const void *v9;  // edx
  void *v10;       // eax
  int i;           // [esp+1Ch] [ebp-Ch]

  v6 = (const void **)(a1 + 4 * a2);
  v7 = (void **)(a3 + 4 * a4);
  result = a5;
  if (a5 > 0) {
    for (i = 0; i != a5; result = i) {
      v9 = *v6++;
      v10 = *v7++;
      memcpy(v10, v9, __n);
      ++i;
    }
  }
  return result;
}

void *__cdecl jcopy_block_row(void *__src, void *__dst, int a3) {
  return memcpy(__dst, __src, a3 << 7);
}

void *__cdecl jzero_far(void *__b, size_t __len) {
  return memset(__b, 0, __len);
}

int __cdecl jpeg_get_small(int a1, int a2) {
  return (*(int(__cdecl **)(int))(a1 + 24))(a2);
}

int __cdecl jpeg_free_small(int a1, int a2, int a3) {
  return (*(int(__cdecl **)(int, int))(a1 + 28))(a2, a3);
}

int __cdecl jpeg_get_large(int a1, int a2) {
  return (*(int(__cdecl **)(int))(a1 + 24))(a2);
}

int __cdecl jpeg_free_large(int a1, int a2, int a3) {
  return (*(int(__cdecl **)(int, int))(a1 + 28))(a2, a3);
}

int __cdecl jpeg_mem_available(int a1, int a2, int a3) { return a3; }

int __cdecl jpeg_open_backing_store(int a1) {
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 49;
  return (**(int (***)(void))a1)();
}

int jpeg_mem_init() { return 0; }

void jpeg_mem_term() { ; }

_BYTE *__cdecl color_quantize(_DWORD *a1, int a2, int a3, int a4) {
  _BYTE *result;       // eax
  int i;               // eax
  int v6;              // eax
  unsigned __int8 *v7; // esi
  int v8;              // ecx
  char v9;             // di
  _BYTE *v10;          // [esp+4h] [ebp-20h]
  int v11;             // [esp+8h] [ebp-1Ch]
  _BYTE *v12;          // [esp+Ch] [ebp-18h]
  int v13;             // [esp+10h] [ebp-14h]
  _BYTE *v14;          // [esp+14h] [ebp-10h]
  int v15;             // [esp+18h] [ebp-Ch]

  v11 = *(_DWORD *)(a1[108] + 24);
  result = (_BYTE *)a1[25];
  v14 = result;
  v15 = a1[27];
  if (a4 > 0) {
    v13 = 0;
    for (i = 0;; i = v13) {
      v6 = 4 * i;
      v7 = *(unsigned __int8 **)(a2 + v6);
      result = *(_BYTE **)(a3 + v6);
      if (v14) {
        v12 = result;
        v10 = &v14[(_DWORD)result];
        do {
          while (v15 <= 0) {
            *v12++ = 0;
            result = v10;
            if (v12 == v10)
              goto LABEL_10;
          }
          v8 = 0;
          v9 = 0;
          do
            v9 += *(_BYTE *)(*(_DWORD *)(v11 + 4 * v8++) + *v7++);
          while (v15 != v8);
          *v12++ = v9;
          result = v10;
        } while (v12 != v10);
      }
    LABEL_10:
      if (a4 == ++v13)
        break;
    }
  }
  return result;
}

int __cdecl color_quantize3(int a1, int a2, int a3, int a4) {
  int *v4;             // eax
  int result;          // eax
  int v6;              // eax
  unsigned __int8 *v7; // esi
  _BYTE *v8;           // eax
  _BYTE *v9;           // ecx
  char v10;            // dl
  int v11;             // [esp+4h] [ebp-1Ch]
  int v12;             // [esp+8h] [ebp-18h]
  int v13;             // [esp+Ch] [ebp-14h]
  int v14;             // [esp+10h] [ebp-10h]
  int v15;             // [esp+14h] [ebp-Ch]

  v4 = *(int **)(*(_DWORD *)(a1 + 432) + 24);
  v11 = *v4;
  v12 = v4[1];
  v13 = v4[2];
  v15 = *(_DWORD *)(a1 + 100);
  result = a4;
  if (a4 > 0) {
    v14 = 0;
    result = 0;
    do {
      v6 = 4 * result;
      v7 = *(unsigned __int8 **)(v6 + a2);
      v8 = *(_BYTE **)(v6 + a3);
      if (v15) {
        v9 = v8;
        do {
          v10 = *(_BYTE *)(v13 + v7[2]) + *(_BYTE *)(v12 + v7[1]) +
                *(_BYTE *)(v11 + *v7);
          v7 += 3;
          *v9++ = v10;
        } while (&v8[v15] != v9);
      }
      result = ++v14;
    } while (a4 != v14);
  }
  return result;
}

int __cdecl quantize_ord_dither(_DWORD *a1, int a2, int a3, int a4) {
  int result;           // eax
  int i;                // esi
  int v6;               // esi
  int j;                // ecx
  char *v8;             // edx
  char *v9;             // esi
  int v10;              // edi
  char v11;             // al
  int v12;              // [esp+18h] [ebp-40h]
  int v13;              // [esp+20h] [ebp-38h]
  unsigned __int8 *v14; // [esp+24h] [ebp-34h]
  int v15;              // [esp+28h] [ebp-30h]
  int v16;              // [esp+2Ch] [ebp-2Ch]
  char v17;             // [esp+30h] [ebp-28h]
  int v18;              // [esp+34h] [ebp-24h]
  int v19;              // [esp+38h] [ebp-20h]
  int v20;              // [esp+3Ch] [ebp-1Ch]
  size_t __len;         // [esp+40h] [ebp-18h]
  int v22;              // [esp+44h] [ebp-14h]
  void **v23;           // [esp+48h] [ebp-10h]
  int v24;              // [esp+4Ch] [ebp-Ch]

  v13 = a1[108];
  v18 = a1[27];
  __len = a1[25];
  result = a4;
  if (a4 > 0) {
    v20 = 0;
    for (i = 0;; i = v20) {
      v24 = 4 * i;
      v23 = (void **)(4 * i + a3);
      jzero_far(*v23, __len);
      v6 = *(_DWORD *)(v13 + 48);
      v17 = v6;
      if (v18 <= 0) {
        v11 = v6;
      } else {
        v22 = v6 << 6;
        v19 = 0;
        v12 = 48;
        for (j = 0;; j = v19) {
          v14 = (unsigned __int8 *)(*(_DWORD *)(a2 + v24) + j);
          v8 = (char *)*v23;
          v15 = *(_DWORD *)(*(_DWORD *)(v13 + 24) + 4 * v19);
          v16 = *(_DWORD *)(v12 + v13 + 4) + v22;
          if (__len) {
            v9 = (char *)*v23;
            v10 = 0;
            do {
              *v9 += *(_BYTE *)(v15 + *v14 + *(_DWORD *)(v16 + 4 * v10));
              v14 += v18;
              ++v9;
              v10 = ((_BYTE)v10 + 1) & 0xF;
            } while (&v8[__len] != v9);
          }
          ++v19;
          v12 += 4;
          if (v18 == v19)
            break;
        }
        v11 = v17;
      }
      result = (v11 + 1) & 0xF;
      *(_DWORD *)(v13 + 48) = result;
      if (a4 == ++v20)
        break;
    }
  }
  return result;
}

int __cdecl quantize3_ord_dither(int a1, int a2, int a3, int a4) {
  int *v4;              // eax
  int result;           // eax
  int i;                // eax
  int v7;               // eax
  _BYTE *v8;            // edi
  char v9;              // dl
  int v10;              // ecx
  _BYTE *v11;           // [esp+4h] [ebp-3Ch]
  _DWORD *v12;          // [esp+8h] [ebp-38h]
  unsigned __int8 *v13; // [esp+Ch] [ebp-34h]
  int v14;              // [esp+10h] [ebp-30h]
  int v15;              // [esp+14h] [ebp-2Ch]
  int v16;              // [esp+18h] [ebp-28h]
  int v17;              // [esp+1Ch] [ebp-24h]
  int v18;              // [esp+20h] [ebp-20h]
  int v19;              // [esp+24h] [ebp-1Ch]
  int v20;              // [esp+28h] [ebp-18h]
  int v21;              // [esp+2Ch] [ebp-14h]
  int v22;              // [esp+30h] [ebp-10h]
  int v23;              // [esp+34h] [ebp-Ch]

  v12 = *(_DWORD **)(a1 + 432);
  v4 = (int *)v12[6];
  v14 = *v4;
  v15 = v4[1];
  v16 = v4[2];
  v23 = *(_DWORD *)(a1 + 100);
  result = a4;
  if (a4 > 0) {
    v22 = 0;
    for (i = 0;; i = v10) {
      v20 = v12[12];
      v7 = 4 * i;
      v13 = *(unsigned __int8 **)(a2 + v7);
      v17 = (v20 << 6) + v12[13];
      v18 = (v20 << 6) + v12[14];
      v19 = v12[15] + (v20 << 6);
      if (v23) {
        v8 = *(_BYTE **)(v7 + a3);
        v21 = 0;
        v11 = &v8[v23];
        do {
          v9 = *(_BYTE *)(v16 + v13[2] + *(_DWORD *)(v19 + 4 * v21)) +
               *(_BYTE *)(v15 + v13[1] + *(_DWORD *)(v18 + 4 * v21)) +
               *(_BYTE *)(v14 + *v13 + *(_DWORD *)(v17 + 4 * v21));
          v13 += 3;
          *v8++ = v9;
          v21 = ((_BYTE)v21 + 1) & 0xF;
        } while (v11 != v8);
        result = ((_BYTE)v20 + 1) & 0xF;
        v12[12] = result;
        v10 = ++v22;
        if (a4 == v22)
          return result;
      } else {
        result = ((_BYTE)v20 + 1) & 0xF;
        v12[12] = result;
        v10 = ++v22;
        if (a4 == v22)
          return result;
      }
    }
  }
  return result;
}

char *__cdecl quantize_fs_dither(_DWORD *a1, int a2, int a3, int a4) {
  char *result;         // eax
  int i;                // eax
  __int16 *v6;          // edi
  char *v7;             // eax
  int v8;               // edx
  int v9;               // esi
  int v10;              // eax
  int v11;              // esi
  int v12;              // [esp+38h] [ebp-60h]
  __int16 v13;          // [esp+40h] [ebp-58h]
  __int16 v14;          // [esp+44h] [ebp-54h]
  unsigned __int8 *v15; // [esp+48h] [ebp-50h]
  _BYTE *v16;           // [esp+4Ch] [ebp-4Ch]
  int v17;              // [esp+50h] [ebp-48h]
  int v18;              // [esp+54h] [ebp-44h]
  int v19;              // [esp+58h] [ebp-40h]
  int v20;              // [esp+5Ch] [ebp-3Ch]
  int v21;              // [esp+60h] [ebp-38h]
  char *v22;            // [esp+64h] [ebp-34h]
  int v23;              // [esp+68h] [ebp-30h]
  size_t __len;         // [esp+6Ch] [ebp-2Ch]
  char *v25;            // [esp+70h] [ebp-28h]
  int v26;              // [esp+78h] [ebp-20h]
  int v27;              // [esp+7Ch] [ebp-1Ch]
  void **v28;           // [esp+80h] [ebp-18h]
  int v29;              // [esp+84h] [ebp-14h]
  _WORD *v30;           // [esp+88h] [ebp-10h]
  int v31;              // [esp+8Ch] [ebp-Ch]

  v31 = a1[108];
  v19 = a1[27];
  __len = a1[25];
  result = (char *)a1[74];
  v25 = result;
  if (a4 > 0) {
    v12 = a1[27] * (a1[25] - 1);
    v23 = 0;
    for (i = 0;; i = v23) {
      v29 = 4 * i;
      v28 = (void **)(4 * i + a3);
      result = (char *)jzero_far(*v28, __len);
      if (v19 > 0)
        break;
    LABEL_14:
      *(_BYTE *)(v31 + 84) = *(_BYTE *)(v31 + 84) == 0;
      if (a4 == ++v23)
        return result;
    }
    v27 = v31;
    v22 = 0;
    result = 0;
    while (1) {
      while (1) {
        v7 = &result[*(_DWORD *)(a2 + v29)];
        v15 = (unsigned __int8 *)v7;
        v16 = *v28;
        if (!*(_BYTE *)(v31 + 84))
          break;
        v15 = (unsigned __int8 *)&v7[v12];
        v16 = (char *)*v28 + __len - 1;
        v21 = -v19;
        v6 = (__int16 *)(*(_DWORD *)(v27 + 68) + 2 * __len + 2);
        v20 = -1;
        v17 = *(_DWORD *)(4 * (_DWORD)v22 + *(_DWORD *)(v31 + 24));
        v18 = *(_DWORD *)(4 * (_DWORD)v22 + *(_DWORD *)(v31 + 16));
        if (__len)
          goto LABEL_10;
      LABEL_7:
        *v6 = 0;
        ++v22;
        v27 += 4;
        result = v22;
        if ((char *)v19 == v22)
          goto LABEL_14;
      }
      v6 = *(__int16 **)(v27 + 68);
      v21 = v19;
      v20 = 1;
      v17 = *(_DWORD *)(4 * (_DWORD)v22 + *(_DWORD *)(v31 + 24));
      v18 = *(_DWORD *)(4 * (_DWORD)v22 + *(_DWORD *)(v31 + 16));
      if (!__len)
        goto LABEL_7;
    LABEL_10:
      v30 = v6;
      v8 = 0;
      v13 = 0;
      v14 = 0;
      v26 = 0;
      while (1) {
        v6 += v20;
        v9 = (unsigned __int8)v25[((v8 + *v6 + 8) >> 4) + *v15];
        v10 = *(unsigned __int8 *)(v17 + v9);
        *v16 += v10;
        v11 = v9 - *(unsigned __int8 *)(v18 + v10);
        *v30 = 3 * v11 + v14;
        v14 = 5 * v11 + v13;
        v8 = 7 * v11;
        v15 += v21;
        v16 += v20;
        ++v26;
        v13 = v11;
        if (__len == v26)
          break;
        v30 = v6;
      }
      *v6 = v14;
      ++v22;
      v27 += 4;
      result = v22;
      if ((char *)v19 == v22)
        goto LABEL_14;
    }
  }
  return result;
}

void finish_pass_1_quant() { ; }

int __cdecl new_color_map_1_quant(int a1) {
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 46;
  return (**(int (***)(void))a1)();
}

int __cdecl jinit_1pass_quantizer(_DWORD *a1) {
  void *(__cdecl * *v1)(int); // eax
  int v2;                     // esi
  int v3;                     // ecx
  int v4;                     // edx
  int i;                      // eax
  int v6;                     // edi
  int v7;                     // eax
  _DWORD *v8;                 // edx
  int v9;                     // eax
  int v10;                    // eax
  int k;                      // edx
  int result;                 // eax
  _DWORD *v13;                // edi
  int v14;                    // eax
  int v15;                    // esi
  int v16;                    // edi
  _DWORD *m;                  // edx
  int *v18;                   // edx
  int v19;                    // eax
  int *v20;                   // edi
  int v21;                    // eax
  int v22;                    // ecx
  int v23;                    // [esp+14h] [ebp-74h]
  int j;                      // [esp+18h] [ebp-70h]
  _DWORD *v25;                // [esp+30h] [ebp-58h]
  int v26;                    // [esp+34h] [ebp-54h]
  int v27;                    // [esp+38h] [ebp-50h]
  _DWORD *v28;                // [esp+3Ch] [ebp-4Ch]
  int v29;                    // [esp+40h] [ebp-48h]
  int v30;                    // [esp+44h] [ebp-44h]
  char v31;                   // [esp+4Bh] [ebp-3Dh]
  int v32;                    // [esp+4Ch] [ebp-3Ch]
  int v33;                    // [esp+50h] [ebp-38h]
  int v34;                    // [esp+54h] [ebp-34h]
  int v35;                    // [esp+5Ch] [ebp-2Ch]
  _DWORD *v36;                // [esp+60h] [ebp-28h]
  _DWORD *v37;                // [esp+64h] [ebp-24h]
  int v38;                    // [esp+68h] [ebp-20h]
  int v39;                    // [esp+6Ch] [ebp-1Ch]

  v1 = (void *(__cdecl **)(int))(*(int(__cdecl **)(_DWORD *, int, int))a1[1])(
      a1, 1, 88);
  a1[108] = v1;
  *v1 = start_pass_1_quant;
  v1[2] = (void *(__cdecl *)(int))finish_pass_1_quant;
  v1[3] = (void *(__cdecl *)(int))new_color_map_1_quant;
  v1[17] = 0;
  v1[13] = 0;
  if ((int)a1[27] > 4) {
    *(_DWORD *)(*a1 + 20) = 55;
    *(_DWORD *)(*a1 + 24) = 4;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  if ((int)a1[23] > 256) {
    *(_DWORD *)(*a1 + 20) = 57;
    *(_DWORD *)(*a1 + 24) = 256;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  v25 = (_DWORD *)a1[108];
  v28 = v25 + 8;
  v2 = a1[27];
  v29 = a1[23];
  v3 = 1;
  do {
    while (1) {
      ++v3;
      if (v2 > 1)
        break;
      v4 = v3;
      if (v29 < v3)
        goto LABEL_11;
    }
    v4 = v3;
    for (i = 1; i != v2; ++i)
      v4 *= v3;
  } while (v29 >= v4);
LABEL_11:
  v6 = v3 - 1;
  if (v3 - 1 <= 1) {
    *(_DWORD *)(*a1 + 20) = 56;
    *(_DWORD *)(*a1 + 24) = v4;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  if (v2 > 0) {
    v14 = 0;
    v38 = 1;
    do {
      v28[v14] = v6;
      v38 *= v6;
      ++v14;
    } while (v2 != v14);
  } else {
    v38 = 1;
  }
  if (v2 > 0) {
    v39 = v38;
    do {
    LABEL_45:
      v30 = 0;
      v31 = 0;
      v37 = &RGB_order_3637;
      while (1) {
        v19 = a1[13] == 2 ? *v37 : v30;
        v20 = &v28[v19];
        v21 = *v20 + 1;
        v22 = v21 * (v39 / *v20);
        if (v29 < v22)
          break;
        *v20 = v21;
        ++v30;
        ++v37;
        v31 = 1;
        v39 = v22;
        if (v2 == v30)
          goto LABEL_45;
      }
    } while (v31);
    v38 = v39;
  } else {
    v39 = v38;
  }
  if (a1[27] == 3) {
    v18 = (int *)(*a1 + 24);
    *v18 = v38;
    v18[1] = v25[8];
    v18[2] = v25[9];
    v18[3] = v25[10];
    *(_DWORD *)(*a1 + 20) = 94;
  } else {
    *(_DWORD *)(*a1 + 20) = 95;
    *(_DWORD *)(*a1 + 24) = v38;
  }
  (*(void(__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  v7 = (*(int(__cdecl **)(_DWORD *, int, int, _DWORD))(a1[1] + 8))(a1, 1, v38,
                                                                   a1[27]);
  v26 = v7;
  if ((int)a1[27] <= 0) {
    v25[4] = v7;
    v25[5] = v38;
    result = create_colorindex(a1);
    v13 = a1;
    if (a1[21] != 2)
      return result;
    goto LABEL_38;
  }
  v36 = v25;
  v33 = 0;
  v8 = v25;
  v9 = v39;
  while (1) {
    v27 = v8[8];
    v23 = v9 / v27;
    if (v27 > 0) {
      v10 = (v27 - 1) / 2;
      v35 = v10;
      v32 = 0;
      while (1) {
        for (j = v23 * v32; j < v38; j += v39) {
          if (v23 > 0) {
            for (k = 0; k != v23; ++k)
              *(_BYTE *)(*(_DWORD *)(v26 + 4 * v33) + k + j) = v10 / (v27 - 1);
          }
        }
        ++v32;
        v35 += 255;
        if (v27 == v32)
          break;
        v10 = v35;
      }
    }
    ++v33;
    ++v36;
    if (v33 >= a1[27])
      break;
    v9 = v23;
    v39 = v23;
    v8 = v36;
  }
  v25[4] = v26;
  v25[5] = v38;
  result = create_colorindex(a1);
  v13 = a1;
  if (a1[21] == 2) {
  LABEL_38:
    v34 = 2 * v13[25] + 4;
    result = v13[27];
    if (result > 0) {
      v15 = v13[108];
      v16 = 0;
      for (m = a1;; m = a1) {
        *(_DWORD *)(v15 + 68) =
            (*(int(__cdecl **)(_DWORD *, int, int))(m[1] + 4))(m, 1, v34);
        ++v16;
        v15 += 4;
        result = (int)a1;
        if (a1[27] <= v16)
          break;
      }
    }
  }
  return result;
}

void *__cdecl start_pass_1_quant(int a1) {
  int v1;               // esi
  int v2;               // eax
  void *result;         // eax
  void *v4;             // eax
  int v5;               // esi
  int v6;               // edx
  int v7;               // ecx
  int v8;               // eax
  void *v9;             // ecx
  int v10;              // edi
  int *v11;             // edx
  unsigned __int8 *v12; // esi
  int *v13;             // ecx
  int v14;              // eax
  int v15;              // eax
  int v16;              // ecx
  int v17;              // edi
  int v18;              // edi
  int *v19;             // [esp+18h] [ebp-40h]
  size_t __len;         // [esp+20h] [ebp-38h]
  int v21;              // [esp+24h] [ebp-34h]
  int v22;              // [esp+28h] [ebp-30h]
  int v23;              // [esp+2Ch] [ebp-2Ch]
  int v24;              // [esp+30h] [ebp-28h]
  int v25;              // [esp+34h] [ebp-24h]
  int v26;              // [esp+38h] [ebp-20h]
  int v27;              // [esp+3Ch] [ebp-1Ch]

  v1 = *(_DWORD *)(a1 + 432);
  *(_DWORD *)(a1 + 124) = *(_DWORD *)(v1 + 16);
  *(_DWORD *)(a1 + 120) = *(_DWORD *)(v1 + 20);
  v2 = *(_DWORD *)(a1 + 84);
  if (v2 == 1) {
    if (*(_DWORD *)(a1 + 108) == 3)
      v4 = quantize3_ord_dither;
    else
      v4 = quantize_ord_dither;
    *(_DWORD *)(v1 + 4) = v4;
    *(_DWORD *)(v1 + 48) = 0;
    if (!*(_BYTE *)(v1 + 28))
      create_colorindex((_DWORD *)a1);
    result = *(void **)(v1 + 52);
    if (!result) {
      v21 = *(_DWORD *)(a1 + 432);
      result = *(void **)(a1 + 108);
      if ((int)result > 0) {
        v27 = *(_DWORD *)(a1 + 432);
        v23 = 0;
        v5 = *(_DWORD *)(v27 + 32);
      LABEL_23:
        v22 = (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
        v10 = (v5 << 9) - 512;
        v11 = (int *)v22;
        v24 = 0;
        while (1) {
          v12 = (unsigned __int8 *)&base_dither_matrix + 16 * v24;
          v13 = v11;
          v19 = v11 + 16;
          do {
            while (1) {
              v14 = 65025 - 510 * *v12;
              if (v14 < 0)
                break;
              *v13 = v14 / v10;
              ++v12;
              if (v19 == ++v13)
                goto LABEL_28;
            }
            *v13++ = -((510 * *v12++ - 65025) / v10);
          } while (v19 != v13);
        LABEL_28:
          if (++v24 == 16)
            break;
          v11 += 16;
        }
        for (result = (void *)v22;; result = v9) {
          *(_DWORD *)(v27 + 52) = result;
          ++v23;
          v27 += 4;
          if (v23 >= *(_DWORD *)(a1 + 108))
            break;
          v5 = *(_DWORD *)(v27 + 32);
          if (v23 <= 0)
            goto LABEL_23;
          if (v5 != *(_DWORD *)(v21 + 32)) {
            v6 = v21;
            v7 = 0;
            while (v23 != ++v7) {
              v8 = *(_DWORD *)(v6 + 36);
              v6 += 4;
              if (v8 == v5)
                goto LABEL_19;
            }
            goto LABEL_23;
          }
          v7 = 0;
        LABEL_19:
          v9 = *(void **)(v21 + 4 * v7 + 52);
          if (!v9)
            goto LABEL_23;
        }
      }
    }
  } else if (v2) {
    if (v2 == 2) {
      *(_DWORD *)(v1 + 4) = quantize_fs_dither;
      *(_BYTE *)(v1 + 84) = 0;
      if (*(_DWORD *)(v1 + 68)) {
        v15 = *(_DWORD *)(a1 + 100);
        v16 = a1;
      } else {
        v15 = *(_DWORD *)(a1 + 100);
        v25 = 2 * v15 + 4;
        v16 = a1;
        if (*(int *)(a1 + 108) > 0) {
          v18 = *(_DWORD *)(a1 + 432);
          v26 = 0;
          do {
            *(_DWORD *)(v18 + 68) = (*(int(__cdecl **)(int, int, int))(
                *(_DWORD *)(a1 + 4) + 4))(a1, 1, v25);
            ++v26;
            v18 += 4;
          } while (*(_DWORD *)(a1 + 108) > v26);
          v15 = *(_DWORD *)(a1 + 100);
          v16 = a1;
        }
      }
      result = (void *)(2 * v15 + 4);
      __len = (size_t)result;
      if (*(int *)(v16 + 108) > 0) {
        v17 = 0;
        do {
          result = jzero_far(*(void **)(v1 + 68), __len);
          ++v17;
          v1 += 4;
        } while (v17 < *(_DWORD *)(a1 + 108));
      }
    } else {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 48;
      return (void *)(**(int(__cdecl ***)(int))a1)(a1);
    }
  } else if (*(_DWORD *)(a1 + 108) == 3) {
    result = color_quantize3;
    *(_DWORD *)(v1 + 4) = color_quantize3;
  } else {
    result = color_quantize;
    *(_DWORD *)(v1 + 4) = color_quantize;
  }
  return result;
}

int __cdecl prescan_quantize(int a1, int a2, int a3, int a4) {
  int result; // eax
  int i;      // eax
  _BYTE *v6;  // esi
  int j;      // edi
  _WORD *v8;  // edx
  int v9;     // ecx
  int v10;    // [esp+0h] [ebp-14h]
  int v11;    // [esp+4h] [ebp-10h]
  int v12;    // [esp+8h] [ebp-Ch]

  result = *(_DWORD *)(*(_DWORD *)(a1 + 432) + 24);
  v10 = result;
  v12 = *(_DWORD *)(a1 + 100);
  if (a4 > 0) {
    v11 = 0;
    for (i = 0;; i = v11) {
      v6 = *(_BYTE **)(a2 + 4 * i);
      result = v12;
      if (v12) {
        for (j = 0; j != v12; ++j) {
          v8 = (_WORD *)(*(_DWORD *)(v10 + 4 * (*v6 >> 3)) +
                         2 * ((v6[2] >> 3) + 32 * (v6[1] >> 2)));
          result = -1;
          v9 = (unsigned __int16)*v8;
          LOWORD(v9) = v9 + 1;
          if ((_WORD)v9)
            result = v9;
          *v8 = result;
          v6 += 3;
        }
      }
      if (a4 == ++v11)
        break;
    }
  }
  return result;
}

int __cdecl pass2_no_dither(_DWORD *a1, int a2, int a3, int a4) {
  int result; // eax
  int v5;     // eax
  _BYTE *v6;  // edi
  _BYTE *v7;  // eax
  int v8;     // ecx
  _WORD *v9;  // esi
  _BYTE *v10; // [esp+24h] [ebp-24h]
  int v11;    // [esp+28h] [ebp-20h]
  _BYTE *v12; // [esp+2Ch] [ebp-1Ch]
  int v13;    // [esp+30h] [ebp-18h]
  int v14;    // [esp+34h] [ebp-14h]
  int v15;    // [esp+38h] [ebp-10h]
  int v16;    // [esp+3Ch] [ebp-Ch]

  result = *(_DWORD *)(a1[108] + 24);
  v11 = result;
  v16 = a1[25];
  if (a4 > 0) {
    v15 = 0;
    result = 0;
    do {
      v5 = 4 * result;
      v6 = *(_BYTE **)(a2 + v5);
      v7 = *(_BYTE **)(a3 + v5);
      if (v16) {
        v12 = v7;
        v10 = &v7[v16];
        do {
          while (1) {
            v13 = *v6 >> 3;
            v14 = v6[1] >> 2;
            v8 = v6[2] >> 3;
            v6 += 3;
            v9 = (_WORD *)(*(_DWORD *)(v11 + 4 * v13) + 2 * (v8 + 32 * v14));
            if (!*v9)
              break;
            *v12++ = *(_BYTE *)v9 - 1;
            if (v12 == v10)
              goto LABEL_8;
          }
          fill_inverse_cmap(a1, v13, v14, v8);
          *v12++ = *(_BYTE *)v9 - 1;
        } while (v12 != v10);
      }
    LABEL_8:
      result = ++v15;
    } while (a4 != v15);
  }
  return result;
}

int __cdecl pass2_fs_dither(_DWORD *a1, int a2, int a3, int a4) {
  int *v4;              // eax
  int result;           // eax
  int v6;               // eax
  unsigned __int8 *v7;  // edx
  _BYTE *v8;            // eax
  int i;                // edx
  int v10;              // eax
  int v11;              // edi
  int v12;              // esi
  _WORD *v13;           // edi
  int v14;              // [esp+48h] [ebp-80h]
  int v15;              // [esp+4Ch] [ebp-7Ch]
  int v16;              // [esp+50h] [ebp-78h]
  int v17;              // [esp+54h] [ebp-74h]
  int v18;              // [esp+58h] [ebp-70h]
  __int16 v19;          // [esp+5Ch] [ebp-6Ch]
  __int16 v20;          // [esp+60h] [ebp-68h]
  __int16 v21;          // [esp+64h] [ebp-64h]
  __int16 v22;          // [esp+68h] [ebp-60h]
  __int16 v23;          // [esp+6Ch] [ebp-5Ch]
  __int16 v24;          // [esp+70h] [ebp-58h]
  __int16 *v25;         // [esp+74h] [ebp-54h]
  unsigned __int8 *v26; // [esp+78h] [ebp-50h]
  _BYTE *v27;           // [esp+7Ch] [ebp-4Ch]
  int v28;              // [esp+80h] [ebp-48h]
  int v29;              // [esp+84h] [ebp-44h]
  int v30;              // [esp+88h] [ebp-40h]
  int v31;              // [esp+8Ch] [ebp-3Ch]
  int v32;              // [esp+90h] [ebp-38h]
  int v33;              // [esp+94h] [ebp-34h]
  int v34;              // [esp+98h] [ebp-30h]
  int v35;              // [esp+9Ch] [ebp-2Ch]
  int v36;              // [esp+A0h] [ebp-28h]
  int v37;              // [esp+A4h] [ebp-24h]
  int v38;              // [esp+A8h] [ebp-20h]
  _WORD *v39;           // [esp+ACh] [ebp-1Ch]
  int v40;              // [esp+B0h] [ebp-18h]
  int v41;              // [esp+B4h] [ebp-14h]
  int v42;              // [esp+B8h] [ebp-10h]
  int v43;              // [esp+BCh] [ebp-Ch]

  v14 = a1[108];
  v15 = *(_DWORD *)(v14 + 24);
  v31 = a1[25];
  v32 = a1[74];
  v33 = *(_DWORD *)(v14 + 40);
  v4 = (int *)a1[31];
  v34 = *v4;
  v35 = v4[1];
  result = v4[2];
  v36 = result;
  if (a4 > 0) {
    v30 = 0;
    result = 0;
    do {
      while (1) {
        v6 = 4 * result;
        v7 = *(unsigned __int8 **)(a2 + v6);
        v26 = v7;
        v8 = *(_BYTE **)(a3 + v6);
        v27 = v8;
        if (!*(_BYTE *)(v14 + 36))
          break;
        v26 = &v7[3 * v31 - 3];
        v27 = &v8[v31 - 1];
        v25 = (__int16 *)(*(_DWORD *)(v14 + 32) + 6 * v31 + 6);
        *(_BYTE *)(v14 + 36) = 0;
        v28 = -1;
        v29 = -3;
        if (v31)
          goto LABEL_7;
      LABEL_4:
        *v25 = 0;
        v25[1] = 0;
        v25[2] = 0;
        result = ++v30;
        if (a4 == v30)
          return result;
      }
      v25 = *(__int16 **)(v14 + 32);
      *(_BYTE *)(v14 + 36) = 1;
      v28 = 1;
      v29 = 3;
      if (!v31)
        goto LABEL_4;
    LABEL_7:
      v37 = v29;
      v39 = v25;
      v18 = 0;
      v17 = 0;
      v16 = 0;
      v21 = 0;
      v20 = 0;
      v19 = 0;
      v24 = 0;
      v23 = 0;
      v22 = 0;
      v38 = 0;
      for (i = 2 * v29;; i = 2 * v29) {
        v25 = (__int16 *)((char *)v25 + i);
        v42 = *(
            unsigned __int8 *)(v32 +
                               *(_DWORD *)(v33 + 4 * ((v16 + *v25 + 8) >> 4)) +
                               *v26);
        v41 =
            *(unsigned __int8 *)(*(_DWORD *)(v33 +
                                             4 * ((v17 + (__int16)v39[v37 + 1] +
                                                   8) >>
                                                  4)) +
                                 v32 + v26[1]);
        v40 =
            *(unsigned __int8 *)(*(_DWORD *)(v33 +
                                             4 * ((v18 + (__int16)v39[v37 + 2] +
                                                   8) >>
                                                  4)) +
                                 v32 + v26[2]);
        v13 = (_WORD *)(*(_DWORD *)(v15 + 4 * (v42 >> 3)) +
                        2 * ((v40 >> 3) + 32 * (v41 >> 2)));
        if (!*v13)
          fill_inverse_cmap(a1, v42 >> 3, v41 >> 2, v40 >> 3);
        v10 = (unsigned __int16)*v13 - 1;
        *v27 = v10;
        v43 = v42 - *(unsigned __int8 *)(v34 + v10);
        v11 = v41 - *(unsigned __int8 *)(v35 + v10);
        v12 = v40 - *(unsigned __int8 *)(v36 + v10);
        *v39 = 3 * v43 + v22;
        v22 = 5 * v43 + v19;
        v16 = 7 * v43;
        v39[1] = 3 * v11 + v23;
        v23 = 5 * v11 + v20;
        v17 = 7 * v11;
        v39[2] = 3 * v12 + v24;
        v24 = 5 * v12 + v21;
        v18 = 7 * v12;
        v26 += v29;
        v27 += v28;
        ++v38;
        v19 = v43;
        v20 = v11;
        v21 = v12;
        if (v31 == v38)
          break;
        v39 = v25;
      }
      *v25 = v22;
      v25[1] = v23;
      v25[2] = v24;
      result = ++v30;
    } while (a4 != v30);
  }
  return result;
}

int __cdecl finish_pass1(int a1) {
  _DWORD *v1;            // edi
  _DWORD *v2;            // edx
  int v3;                // ecx
  _DWORD *v4;            // esi
  int v5;                // ecx
  int v6;                // edx
  int v7;                // eax
  int v8;                // eax
  _DWORD *v9;            // eax
  int v10;               // ecx
  int v11;               // edx
  int result;            // eax
  int *i;                // edx
  unsigned __int16 *v14; // edi
  int v15;               // ecx
  int v16;               // esi
  unsigned __int16 v17;  // ax
  int v18;               // edx
  int v19;               // esi
  int v20;               // eax
  int v21;               // eax
  int v22;               // [esp+24h] [ebp-84h]
  int v23;               // [esp+28h] [ebp-80h]
  int v24;               // [esp+30h] [ebp-78h]
  int v25;               // [esp+34h] [ebp-74h]
  int v26;               // [esp+38h] [ebp-70h]
  int v27;               // [esp+3Ch] [ebp-6Ch]
  int v28;               // [esp+40h] [ebp-68h]
  int v29;               // [esp+44h] [ebp-64h]
  int v30;               // [esp+48h] [ebp-60h]
  int v31;               // [esp+4Ch] [ebp-5Ch]
  int v32;               // [esp+50h] [ebp-58h]
  int v33;               // [esp+54h] [ebp-54h]
  int v34;               // [esp+58h] [ebp-50h]
  int v35;               // [esp+5Ch] [ebp-4Ch]
  int v36;               // [esp+60h] [ebp-48h]
  _DWORD *v37;           // [esp+64h] [ebp-44h]
  int *v38;              // [esp+68h] [ebp-40h]
  _DWORD *v39;           // [esp+6Ch] [ebp-3Ch]
  _DWORD *v40;           // [esp+70h] [ebp-38h]
  int v41;               // [esp+80h] [ebp-28h]
  int v42;               // [esp+84h] [ebp-24h]
  int v43;               // [esp+88h] [ebp-20h]
  int v44;               // [esp+8Ch] [ebp-1Ch]
  int v45;               // [esp+94h] [ebp-14h]
  int v46;               // [esp+98h] [ebp-10h]
  int v47;               // [esp+9Ch] [ebp-Ch]

  v22 = *(_DWORD *)(a1 + 432);
  *(_DWORD *)(a1 + 124) = *(_DWORD *)(v22 + 16);
  v23 = *(_DWORD *)(v22 + 20);
  v1 = (_DWORD *)(**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 32 * v23);
  *v1 = 0;
  v1[1] = 31;
  v1[2] = 0;
  v1[3] = 63;
  v1[4] = 0;
  v1[5] = 31;
  update_box(a1, v1);
  if (v23 <= 1) {
    v23 = 1;
  } else {
    v39 = v1 + 8;
    v40 = v1 + 9;
    v41 = 1;
  LABEL_17:
    if (v41 <= 0) {
    LABEL_24:
      v11 = v41;
      goto LABEL_25;
    }
    v9 = v1;
    v24 = 0;
    v10 = 0;
    v4 = 0;
    do {
      if (v24 < v9[7] && (int)v9[6] > 0) {
        v24 = v9[7];
        v4 = v9;
      }
      ++v10;
      v9 += 8;
    } while (v10 != v41);
    while (v4) {
      *v40 = v4[1];
      v40[2] = v4[3];
      v40[4] = v4[5];
      *(v40 - 1) = *v4;
      v40[1] = v4[2];
      v40[3] = v4[4];
      v45 = v4[1];
      v44 = v4[3];
      v43 = v4[2];
      v5 = 12 * (v44 - v43);
      v6 = v4[5];
      v42 = v4[4];
      if (v5 >= 16 * (v6 - v42)) {
        v7 = 1;
      } else {
        v5 = 16 * (v6 - v42);
        v7 = 2;
      }
      if (v5 < 8 * (v45 - *v4)) {
        v8 = (*v4 + v45) / 2;
        v4[1] = v8;
        *(v40 - 1) = v8 + 1;
      } else if (v7 == 1) {
        v20 = (v43 + v44) / 2;
        v4[3] = v20;
        v40[1] = v20 + 1;
      } else {
        v21 = (v42 + v6) / 2;
        v4[5] = v21;
        v40[3] = v21 + 1;
      }
      update_box(a1, v4);
      update_box(a1, v39);
      ++v41;
      v39 += 8;
      v40 += 8;
      if (v23 == v41)
        goto LABEL_27;
      if (v23 >= 2 * v41)
        goto LABEL_17;
      if (v41 <= 0)
        goto LABEL_24;
      v2 = v1;
      v25 = 0;
      v3 = 0;
      v4 = 0;
      do {
        if (v25 < v2[6]) {
          v25 = v2[6];
          v4 = v2;
        }
        ++v3;
        v2 += 8;
      } while (v3 != v41);
    }
    v23 = v41;
  }
LABEL_27:
  v38 = v1;
  v26 = 0;
  for (i = v1;; i = v38) {
    v27 = *i;
    v29 = v38[1];
    v47 = v38[2];
    v30 = v38[3];
    v46 = v38[4];
    v31 = v38[5];
    if (*i > v29) {
      v32 = 0;
      v33 = 0;
      v34 = 0;
      v35 = 0;
      v19 = 0;
    } else {
      v37 = (_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 432) + 24) + 4 * v27);
      v32 = 0;
      v33 = 0;
      v34 = 0;
      v35 = 0;
      do {
        if (v47 <= v30) {
          v36 = *v37 + 2 * (v46 + 32 * v47);
          v28 = v38[2];
          do {
            v14 = (unsigned __int16 *)v36;
            if (v46 <= v31) {
              v15 = v38[4];
              v16 = 8 * v46 + 4;
              do {
                v17 = *v14;
                v18 = *v14++;
                if (v17) {
                  v32 += v17;
                  v33 += v17 * (8 * v27 + 4);
                  v34 += v18 * (4 * v28 + 2);
                  v35 += v16 * v18;
                }
                ++v15;
                v16 += 8;
              } while (v31 >= v15);
            }
            ++v28;
            v36 += 64;
          } while (v30 >= v28);
        }
        ++v27;
        ++v37;
      } while (v29 >= v27);
      v19 = v32 >> 1;
    }
    *(_BYTE *)(v26 + **(_DWORD **)(a1 + 124)) = (v19 + v33) / v32;
    *(_BYTE *)(v26 + *(_DWORD *)(*(_DWORD *)(a1 + 124) + 4)) =
        (v19 + v34) / v32;
    *(_BYTE *)(v26 + *(_DWORD *)(*(_DWORD *)(a1 + 124) + 8)) =
        (v19 + v35) / v32;
    ++v26;
    v38 += 8;
    if (v23 == v26)
      break;
  }
  v11 = v23;
LABEL_25:
  *(_DWORD *)(a1 + 120) = v11;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 96;
  *(_DWORD *)(*(_DWORD *)a1 + 24) = v11;
  (*(void(__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
  result = v22;
  *(_BYTE *)(v22 + 28) = 1;
  return result;
}

void finish_pass2() { ; }

int __cdecl new_color_map_2_quant(int a1) {
  int result; // eax

  result = *(_DWORD *)(a1 + 432);
  *(_BYTE *)(result + 28) = 1;
  return result;
}

int __cdecl jinit_2pass_quantizer(int a1) {
  int i;       // edi
  _DWORD *v2;  // esi
  int v3;      // esi
  int result;  // eax
  int v5;      // edx
  int v6;      // ecx
  int v7;      // esi
  int v8;      // ecx
  int v9;      // eax
  int v10;     // edx
  int *v11;    // esi
  _DWORD *v12; // edx
  int v13;     // edi
  int *v14;    // edx
  int v15;     // [esp+14h] [ebp-24h]
  int v16;     // [esp+18h] [ebp-20h]
  int v17;     // [esp+1Ch] [ebp-1Ch]

  v15 = (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 44);
  *(_DWORD *)(a1 + 432) = v15;
  *(_DWORD *)v15 = start_pass_2_quant;
  *(_DWORD *)(v15 + 12) = new_color_map_2_quant;
  *(_DWORD *)(v15 + 32) = 0;
  *(_DWORD *)(v15 + 40) = 0;
  if (*(_DWORD *)(a1 + 108) != 3) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 47;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  *(_DWORD *)(v15 + 24) =
      (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 128);
  for (i = 0; i != 128; i += 4) {
    v2 = (_DWORD *)(*(_DWORD *)(v15 + 24) + i);
    *v2 = (*(int(__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1,
                                                                       4096);
  }
  *(_BYTE *)(v15 + 28) = 1;
  if (!*(_BYTE *)(a1 + 98)) {
    result = v15;
    *(_DWORD *)(v15 + 16) = 0;
    v5 = a1;
    if (!*(_DWORD *)(a1 + 84))
      goto LABEL_10;
  LABEL_20:
    *(_DWORD *)(v5 + 84) = 2;
    v6 = a1;
    if (*(_DWORD *)(a1 + 84) != 2)
      return result;
    goto LABEL_11;
  }
  v3 = *(_DWORD *)(a1 + 92);
  if (v3 <= 7) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 56;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = 8;
    (**(void(__cdecl ***)(int))a1)(a1);
  } else if (v3 > 256) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 57;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = 256;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  result = (*(int(__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(
      a1, 1, v3, 3);
  *(_DWORD *)(v15 + 16) = result;
  *(_DWORD *)(v15 + 20) = v3;
  v5 = a1;
  if (*(_DWORD *)(a1 + 84))
    goto LABEL_20;
LABEL_10:
  v6 = v5;
  if (*(_DWORD *)(v5 + 84) != 2)
    return result;
LABEL_11:
  *(_DWORD *)(v15 + 32) = (*(int(__cdecl **)(int, int, int))(
      *(_DWORD *)(v6 + 4) + 4))(v6, 1, 6 * *(_DWORD *)(v6 + 100) + 12);
  v7 = *(_DWORD *)(a1 + 432);
  v8 = (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 2044) + 1020;
  *(_DWORD *)(v7 + 40) = v8;
  v9 = 0;
  v10 = 0;
  do {
    *(_DWORD *)(v8 + 4 * v9) = v9;
    *(_DWORD *)(v8 + 4 * v10) = v10;
    ++v9;
    --v10;
  } while (v9 != 16);
  v11 = (int *)(v8 + 64);
  v12 = (_DWORD *)(v8 - 64);
  v17 = 16;
  v16 = 16;
  v13 = 32;
  do {
    *v11 = v17;
    *v12 = -v17;
    result = (++v16 & 1) == 0;
    v17 += result;
    ++v11;
    --v12;
    --v13;
  } while (v13);
  if (v16 <= 255) {
    v14 = (int *)(v8 + 4 * v16);
    result = v8 - 4 * v16;
    do {
      *v14 = v17;
      *(_DWORD *)result = -v17;
      ++v16;
      ++v14;
      result -= 4;
    } while (v16 != 256);
  }
  return result;
}

int __cdecl start_pass_2_quant(_DWORD *a1, char a2) {
  int result;                                 // eax
  int(__cdecl * v3)(_DWORD *, int, int, int); // eax
  size_t v4;                                  // esi
  int i;                                      // esi
  int v6;                                     // esi
  int v7;                                     // ecx
  int v8;                                     // eax
  int v9;                                     // edx
  int *v10;                                   // esi
  _DWORD *v11;                                // edx
  int v12;                                    // edi
  int *v13;                                   // edx
  _DWORD *v14;                                // eax
  int v15;                                    // [esp+10h] [ebp-28h]
  int v16;                                    // [esp+14h] [ebp-24h]
  int v17;                                    // [esp+18h] [ebp-20h]
  int v18;                                    // [esp+1Ch] [ebp-1Ch]

  v15 = a1[108];
  v16 = *(_DWORD *)(v15 + 24);
  if (a1[21])
    a1[21] = 2;
  if (a2) {
    *(_DWORD *)(v15 + 4) = prescan_quantize;
    result = (int)finish_pass1;
    *(_DWORD *)(v15 + 8) = finish_pass1;
    *(_BYTE *)(v15 + 28) = 1;
    goto LABEL_5;
  }
  if (a1[21] == 2)
    v3 = pass2_fs_dither;
  else
    v3 = pass2_no_dither;
  *(_DWORD *)(v15 + 4) = v3;
  *(_DWORD *)(v15 + 8) = finish_pass2;
  result = a1[30];
  if (result <= 0) {
    *(_DWORD *)(*a1 + 20) = 56;
    *(_DWORD *)(*a1 + 24) = 1;
    result = (*(int(__cdecl **)(_DWORD *)) * a1)(a1);
  } else if (result > 256) {
    *(_DWORD *)(*a1 + 20) = 57;
    *(_DWORD *)(*a1 + 24) = 256;
    result = (*(int(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  if (a1[21] != 2) {
  LABEL_5:
    if (!*(_BYTE *)(v15 + 28))
      return result;
    goto LABEL_18;
  }
  v4 = 6 * a1[25] + 12;
  if (!*(_DWORD *)(v15 + 32))
    *(_DWORD *)(v15 + 32) = (*(int(__cdecl **)(_DWORD *, int, int))(a1[1] + 4))(
        a1, 1, 6 * a1[25] + 12);
  jzero_far(*(void **)(v15 + 32), v4);
  result = v15;
  if (*(_DWORD *)(v15 + 40)) {
    *(_BYTE *)(v15 + 36) = 0;
  } else {
    v6 = a1[108];
    v7 = (*(int(__cdecl **)(_DWORD *, int, int))a1[1])(a1, 1, 2044) + 1020;
    *(_DWORD *)(v6 + 40) = v7;
    v8 = 0;
    v9 = 0;
    do {
      *(_DWORD *)(v7 + 4 * v8) = v8;
      *(_DWORD *)(v7 + 4 * v9) = v9;
      ++v8;
      --v9;
    } while (v8 != 16);
    v10 = (int *)(v7 + 64);
    v11 = (_DWORD *)(v7 - 64);
    v17 = 16;
    v18 = 16;
    v12 = 32;
    do {
      *v10 = v17;
      *v11 = -v17;
      v17 += (++v18 & 1) == 0;
      ++v10;
      --v11;
      --v12;
    } while (v12);
    if (v18 <= 255) {
      v13 = (int *)(v7 + 4 * v18);
      v14 = (_DWORD *)(v7 - 4 * v18);
      do {
        *v13 = v17;
        *v14 = -v17;
        ++v18;
        ++v13;
        --v14;
      } while (v18 != 256);
      result = v15;
    } else {
      result = v15;
    }
    *(_BYTE *)(result + 36) = 0;
  }
  if (*(_BYTE *)(v15 + 28)) {
  LABEL_18:
    for (i = 1; i != 33; ++i)
      jzero_far(*(void **)(v16 + 4 * i - 4), 0x1000u);
    result = v15;
    *(_BYTE *)(v15 + 28) = 0;
  }
  return result;
}

int __cdecl ycc_rgb_convert(_DWORD *a1, _DWORD *a2, int a3, _BYTE **a4,
                            int a5) {
  _DWORD *v5; // eax
  int result; // eax
  _BYTE *v7;  // edi
  int j;      // edx
  int v9;     // esi
  int v10;    // ecx
  int v11;    // [esp+8h] [ebp-38h]
  int v12;    // [esp+Ch] [ebp-34h]
  int v13;    // [esp+10h] [ebp-30h]
  int v14;    // [esp+14h] [ebp-2Ch]
  int v15;    // [esp+18h] [ebp-28h]
  int v16;    // [esp+1Ch] [ebp-24h]
  int v17;    // [esp+20h] [ebp-20h]
  int v18;    // [esp+24h] [ebp-1Ch]
  int v19;    // [esp+28h] [ebp-18h]
  int v20;    // [esp+2Ch] [ebp-14h]
  int v21;    // [esp+30h] [ebp-10h]
  int v22;    // [esp+34h] [ebp-Ch]
  int i;      // [esp+58h] [ebp+18h]

  v5 = (_DWORD *)a1[107];
  v16 = a1[25];
  v17 = a1[74];
  v18 = v5[2];
  v19 = v5[3];
  v20 = v5[4];
  result = v5[5];
  v21 = result;
  v22 = 4 * a3;
  for (i = a5 - 1; i >= 0; --i) {
    v12 = *(_DWORD *)(*a2 + v22);
    v13 = *(_DWORD *)(a2[1] + v22);
    v14 = *(_DWORD *)(a2[2] + v22);
    v7 = *a4++;
    result = v16;
    if (v16) {
      v15 = 0;
      for (j = 0;; j = v15) {
        v9 = *(unsigned __int8 *)(v13 + j);
        v11 = 4 * *(unsigned __int8 *)(v14 + j);
        v10 = v17 + *(unsigned __int8 *)(v12 + j);
        v7[2] = *(_BYTE *)(v10 + *(_DWORD *)(v18 + v11));
        v7[1] =
            *(_BYTE *)(v10 +
                       ((*(_DWORD *)(v20 + v11) + *(_DWORD *)(v21 + 4 * v9)) >>
                        16));
        result = *(unsigned __int8 *)(v10 + *(_DWORD *)(v19 + 4 * v9));
        *v7 = result;
        v7 += 3;
        if (v16 == ++v15)
          break;
      }
    }
    v22 += 4;
  }
  return result;
}

int __cdecl null_convert(int a1, int a2, int a3, int a4, int a5) {
  int v5;              // edi
  int result;          // eax
  _BYTE *v7;           // ecx
  unsigned __int8 *v8; // edx
  unsigned __int8 *v9; // esi
  int v10;             // [esp+0h] [ebp-18h]
  int i;               // [esp+4h] [ebp-14h]
  int v12;             // [esp+8h] [ebp-10h]
  int v13;             // [esp+Ch] [ebp-Ch]

  v5 = *(_DWORD *)(a1 + 44);
  v10 = *(_DWORD *)(a1 + 100);
  result = a5 - 1;
  if (a5 - 1 >= 0) {
    v13 = 4 * a3;
    v12 = 0;
    do {
      if (v5 > 0) {
        for (i = 0; i != v5; ++i) {
          result = *(_DWORD *)(*(_DWORD *)(a2 + 4 * i) + v13);
          v7 = (_BYTE *)(*(_DWORD *)(a4 + 4 * v12) + i);
          if (v10) {
            v8 = *(unsigned __int8 **)(*(_DWORD *)(a2 + 4 * i) + v13);
            v9 = &v8[v10];
            do {
              result = *v8;
              *v7 = result;
              ++v8;
              v7 += v5;
            } while (v8 != v9);
          }
        }
      }
      ++v12;
      v13 += 4;
    } while (a5 != v12);
  }
  return result;
}

int __cdecl grayscale_convert(int a1, int *a2, int a3, int a4, int a5) {
  return jcopy_sample_rows(*a2, a3, a4, 0, a5, *(_DWORD *)(a1 + 100));
}

int __cdecl gray_rgb_convert(int a1, _DWORD *a2, int a3, _BYTE **a4, int a5) {
  int result; // eax
  int i;      // edi
  int v7;     // esi
  _BYTE *v8;  // edx
  int j;      // ecx
  int v10;    // [esp+0h] [ebp-10h]
  int v11;    // [esp+4h] [ebp-Ch]

  v10 = *(_DWORD *)(a1 + 100);
  result = 4 * a3;
  v11 = 4 * a3;
  for (i = a5 - 1; i >= 0; --i) {
    v7 = *(_DWORD *)(*a2 + v11);
    v8 = *a4;
    result = (int)++a4;
    if (v10) {
      for (j = 0; j != v10; ++j) {
        result = *(unsigned __int8 *)(v7 + j);
        *v8 = result;
        v8[1] = result;
        v8[2] = result;
        v8 += 3;
      }
    }
    v11 += 4;
  }
  return result;
}

_BYTE *__cdecl ycck_cmyk_convert(_DWORD *a1, _DWORD *a2, int a3, _DWORD *a4,
                                 int a5) {
  _DWORD *v5;    // eax
  _BYTE *result; // eax
  _BYTE *v7;     // edi
  int j;         // edx
  int v9;        // ecx
  int v10;       // esi
  int v11;       // [esp+0h] [ebp-44h]
  int v12;       // [esp+8h] [ebp-3Ch]
  int v13;       // [esp+Ch] [ebp-38h]
  int v14;       // [esp+10h] [ebp-34h]
  int v15;       // [esp+14h] [ebp-30h]
  int v16;       // [esp+18h] [ebp-2Ch]
  int v17;       // [esp+1Ch] [ebp-28h]
  int v18;       // [esp+20h] [ebp-24h]
  int v19;       // [esp+24h] [ebp-20h]
  int v20;       // [esp+28h] [ebp-1Ch]
  int v21;       // [esp+2Ch] [ebp-18h]
  int v22;       // [esp+30h] [ebp-14h]
  _BYTE *v23;    // [esp+34h] [ebp-10h]
  int v24;       // [esp+38h] [ebp-Ch]
  int i;         // [esp+5Ch] [ebp+18h]

  v5 = (_DWORD *)a1[107];
  v18 = a1[25];
  v19 = a1[74];
  v20 = v5[2];
  v21 = v5[3];
  v22 = v5[4];
  result = (_BYTE *)v5[5];
  v23 = result;
  v24 = 4 * a3;
  for (i = a5 - 1; i >= 0; --i) {
    v13 = *(_DWORD *)(*a2 + v24);
    v14 = *(_DWORD *)(a2[1] + v24);
    v15 = *(_DWORD *)(a2[2] + v24);
    v16 = *(_DWORD *)(a2[3] + v24);
    result = (_BYTE *)*a4++;
    if (v18) {
      v17 = 0;
      v7 = result;
      for (j = 0;; j = v10) {
        v9 = *(unsigned __int8 *)(v13 + j);
        v11 = *(unsigned __int8 *)(v14 + j);
        v12 = 4 * *(unsigned __int8 *)(v15 + j);
        *v7 = *(_BYTE *)(v19 - (v9 + *(_DWORD *)(v20 + v12)) + 255);
        v11 *= 4;
        v7[1] =
            *(_BYTE *)(v19 -
                       (v9 + ((*(_DWORD *)(v22 + v12) + *(_DWORD *)&v23[v11]) >>
                              16)) +
                       255);
        v7[2] = *(_BYTE *)(v19 - (*(_DWORD *)(v21 + v11) + v9) + 255);
        result = (_BYTE *)*(unsigned __int8 *)(v16 + v17);
        v7[3] = (_BYTE)result;
        v10 = v17 + 1;
        v17 = v10;
        v7 += 4;
        if (v18 == v10)
          break;
      }
    }
    v24 += 4;
  }
  return result;
}

void start_pass_dcolor() { ; }

_BYTE *__cdecl jinit_color_deconverter(int a1) {
  void (**v1)(); // edi
  int v2;        // eax
  _BYTE *result; // eax
  int v4;        // eax
  int v5;        // eax
  int v6;        // eax
  int v7;        // ecx
  int v8;        // edx

  v1 = (void (**)())(**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 24);
  *(_DWORD *)(a1 + 428) = v1;
  *v1 = start_pass_dcolor;
  switch (*(_DWORD *)(a1 + 48)) {
  case 1:
    if (*(_DWORD *)(a1 + 44) != 1)
      goto LABEL_16;
    break;
  case 2:
  case 3:
    if (*(_DWORD *)(a1 + 44) != 3)
      goto LABEL_16;
    break;
  case 4:
  case 5:
    if (*(_DWORD *)(a1 + 44) != 4)
      goto LABEL_16;
    break;
  default:
    if (*(int *)(a1 + 44) <= 0) {
    LABEL_16:
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 10;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    break;
  }
  v2 = *(_DWORD *)(a1 + 52);
  if (v2 == 2) {
    *(_DWORD *)(a1 + 108) = 3;
    v4 = *(_DWORD *)(a1 + 48);
    if (v4 == 3) {
      v1[1] = (void (*)())ycc_rgb_convert;
      result = (_BYTE *)build_ycc_rgb_table(a1);
      goto LABEL_8;
    }
    if (v4 == 1) {
      result = gray_rgb_convert;
      v1[1] = (void (*)())gray_rgb_convert;
      goto LABEL_8;
    }
    if (v4 != 2)
      goto LABEL_7;
  LABEL_19:
    result = null_convert;
    v1[1] = (void (*)())null_convert;
    goto LABEL_8;
  }
  if (v2 == 4) {
    *(_DWORD *)(a1 + 108) = 4;
    v5 = *(_DWORD *)(a1 + 48);
    if (v5 == 5) {
      v1[1] = (void (*)())ycck_cmyk_convert;
      result = (_BYTE *)build_ycc_rgb_table(a1);
      goto LABEL_8;
    }
    if (v5 != 4)
      goto LABEL_7;
    goto LABEL_19;
  }
  if (v2 != 1) {
    if (v2 != *(_DWORD *)(a1 + 48)) {
    LABEL_7:
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 27;
      result = (_BYTE *)(**(int(__cdecl ***)(int))a1)(a1);
      goto LABEL_8;
    }
    *(_DWORD *)(a1 + 108) = *(_DWORD *)(a1 + 44);
    goto LABEL_19;
  }
  *(_DWORD *)(a1 + 108) = 1;
  v6 = *(_DWORD *)(a1 + 48);
  if (v6 != 1 && v6 != 3)
    goto LABEL_7;
  result = grayscale_convert;
  v1[1] = (void (*)())grayscale_convert;
  if (*(int *)(a1 + 44) > 1) {
    v7 = 1;
    v8 = 84;
    do {
      result = *(_BYTE **)(a1 + 204);
      result[v8 + 48] = 0;
      ++v7;
      v8 += 84;
    } while (*(_DWORD *)(a1 + 44) > v7);
  }
LABEL_8:
  if (*(_BYTE *)(a1 + 82)) {
    *(_DWORD *)(a1 + 112) = 1;
  } else {
    result = *(_BYTE **)(a1 + 108);
    *(_DWORD *)(a1 + 112) = result;
  }
  return result;
}

void *__cdecl start_output_pass(int a1) {
  _DWORD *v1;          // edi
  void *result;        // eax
  int v3;              // eax
  int v4;              // edx
  int v5;              // eax
  _WORD *v6;           // eax
  unsigned __int8 v7;  // dl
  _WORD *v8;           // eax
  int *v9;             // [esp+2Ch] [ebp-4Ch]
  unsigned __int8 v10; // [esp+4Bh] [ebp-2Dh]
  int v11;             // [esp+4Ch] [ebp-2Ch]
  int *v12;            // [esp+50h] [ebp-28h]
  int v13;             // [esp+54h] [ebp-24h]
  int i;               // [esp+58h] [ebp-20h]
  _WORD **v15;         // [esp+5Ch] [ebp-1Ch]

  v1 = *(_DWORD **)(a1 + 400);
  result = (void *)v1[4];
  if (result) {
    if (*(_BYTE *)(a1 + 81) && *(_BYTE *)(a1 + 208) && *(_DWORD *)(a1 + 148)) {
      if (v1[28]) {
        v3 = v1[28];
      } else {
        v3 = (**(int(__cdecl ***)(int, int, int))(a1 + 4))(
            a1, 1, 24 * *(_DWORD *)(a1 + 44));
        v1[28] = v3;
      }
      v13 = v3;
      v4 = *(_DWORD *)(a1 + 204);
      if (*(int *)(a1 + 44) > 0) {
        v6 = *(_WORD **)(v4 + 76);
        if (v6 && *v6 && v6[1] && v6[8] && v6[16] && v6[9] && v6[2]) {
          v15 = (_WORD **)(v4 + 160);
          v11 = 0;
          v10 = 0;
          while (1) {
            v12 = (int *)(*(_DWORD *)(a1 + 148) + (v11 << 8));
            if (*v12 < 0)
              break;
            for (i = 0; i != 5; ++i) {
              v9 = &v12[i];
              *(_DWORD *)(v13 + 4 * i + 4) = v9[1];
              v7 = v10;
              if (v9[1])
                v7 = 1;
              v10 = v7;
            }
            v13 += 24;
            if (*(_DWORD *)(a1 + 44) <= ++v11) {
              v5 = v7;
              goto LABEL_11;
            }
            v8 = *v15;
            if (*v15) {
              if (*v8) {
                if (v8[1]) {
                  if (v8[8]) {
                    if (v8[16]) {
                      if (v8[9]) {
                        v15 += 21;
                        if (v8[2])
                          continue;
                      }
                    }
                  }
                }
              }
            }
            break;
          }
        }
      } else {
        v5 = 0;
      LABEL_11:
        if (v5) {
          result = decompress_smooth_data;
          v1[3] = decompress_smooth_data;
          goto LABEL_4;
        }
      }
    }
    result = decompress_data;
    v1[3] = decompress_data;
  }
LABEL_4:
  *(_DWORD *)(a1 + 144) = 0;
  return result;
}

int __cdecl decompress_onepass(_DWORD *a1, int a2) {
  unsigned int v2;                                      // eax
  int i;                                                // ecx
  _DWORD *j;                                            // edx
  int v5;                                               // esi
  int v6;                                               // ecx
  int v7;                                               // eax
  int v8;                                               // edi
  unsigned int v9;                                      // edx
  _DWORD *v10;                                          // ecx
  int v12;                                              // eax
  int v13;                                              // [esp+24h] [ebp-44h]
  unsigned int v14;                                     // [esp+28h] [ebp-40h]
  unsigned int v15;                                     // [esp+2Ch] [ebp-3Ch]
  unsigned int v16;                                     // [esp+30h] [ebp-38h]
  int v17;                                              // [esp+34h] [ebp-34h]
  int v18;                                              // [esp+38h] [ebp-30h]
  int k;                                                // [esp+3Ch] [ebp-2Ch]
  int v20;                                              // [esp+40h] [ebp-28h]
  int v21;                                              // [esp+44h] [ebp-24h]
  int v22;                                              // [esp+48h] [ebp-20h]
  int v23;                                              // [esp+4Ch] [ebp-1Ch]
  int v24;                                              // [esp+50h] [ebp-18h]
  void(__cdecl * v25)(_DWORD *, int, _DWORD, int, int); // [esp+54h] [ebp-14h]
  _DWORD *v26;                                          // [esp+58h] [ebp-10h]
  _DWORD *v27;                                          // [esp+5Ch] [ebp-Ch]

  v13 = a1[100];
  v15 = a1[80] - 1;
  v2 = a1[73];
  v16 = v2 - 1;
  v21 = *(_DWORD *)(v13 + 24);
  if (v21 < *(_DWORD *)(v13 + 28)) {
    for (i = a1[100];; i = v13) {
      v14 = *(_DWORD *)(i + 20);
      if (v15 >= v14) {
        while (1) {
          jzero_far(*(void **)(v13 + 32), a1[82] << 7);
          if (!(*(unsigned __int8(__cdecl **)(_DWORD *, int))(a1[104] + 4))(
                  a1, v13 + 32))
            break;
          if ((int)a1[75] > 0) {
            v27 = a1;
            v17 = 0;
            v18 = 0;
            for (j = a1;; j = v27) {
              v5 = j[76];
              if (!*(_BYTE *)(v5 + 48))
                break;
              v6 = *(_DWORD *)(v5 + 4);
              v25 = *(void(__cdecl **)(_DWORD *, int, _DWORD, int, int))(
                  a1[105] + 4 * v6 + 4);
              if (v15 <= v14)
                v22 = *(_DWORD *)(v5 + 68);
              else
                v22 = *(_DWORD *)(v5 + 52);
              v23 = *(_DWORD *)(a2 + 4 * v6) + 4 * *(_DWORD *)(v5 + 36) * v21;
              v24 = *(_DWORD *)(v5 + 64) * v14;
              if (*(int *)(v5 + 56) <= 0)
                goto LABEL_10;
              v20 = 0;
              do {
                if ((v16 > a1[34] || v21 + v20 < *(_DWORD *)(v5 + 72)) &&
                    v22 > 0) {
                  v26 = (_DWORD *)(v13 + 4 * v17 + 32);
                  v8 = v24;
                  for (k = 0; k != v22; ++k) {
                    v25(a1, v5, *v26, v23, v8);
                    v7 = *(_DWORD *)(v5 + 36);
                    v8 += v7;
                    ++v26;
                  }
                } else {
                  v7 = *(_DWORD *)(v5 + 36);
                }
                v17 += *(_DWORD *)(v5 + 52);
                v23 += 4 * v7;
                ++v20;
              } while (v20 < *(_DWORD *)(v5 + 56));
              ++v18;
              ++v27;
              if (v18 >= a1[75])
                goto LABEL_23;
            LABEL_11:;
            }
            v17 += *(_DWORD *)(v5 + 60);
          LABEL_10:
            ++v18;
            ++v27;
            if (v18 >= a1[75])
              goto LABEL_23;
            goto LABEL_11;
          }
        LABEL_23:
          if (v15 < ++v14)
            goto LABEL_3;
        }
        *(_DWORD *)(v13 + 24) = v21;
        *(_DWORD *)(v13 + 20) = v14;
        return 0;
      }
    LABEL_3:
      *(_DWORD *)(v13 + 20) = 0;
      if (++v21 >= *(_DWORD *)(v13 + 28))
        break;
    }
    v2 = a1[73];
    ++a1[36];
    v9 = a1[34] + 1;
    a1[34] = v9;
    if (v9 < v2)
      goto LABEL_30;
    goto LABEL_35;
  }
  ++a1[36];
  v9 = a1[34] + 1;
  a1[34] = v9;
  if (v9 >= v2) {
  LABEL_35:
    (*(void(__cdecl **)(_DWORD *))(a1[102] + 12))(a1);
    return 4;
  }
LABEL_30:
  v10 = (_DWORD *)a1[100];
  if ((int)a1[75] <= 1) {
    if (v9 >= v2 - 1)
      v12 = *(_DWORD *)(a1[76] + 72);
    else
      v12 = *(_DWORD *)(a1[76] + 12);
    v10[7] = v12;
  } else {
    v10[7] = 1;
  }
  v10[5] = 0;
  v10[6] = 0;
  return 3;
}

int dummy_consume_data() { return 0; }

int __cdecl decompress_data(int a1, int a2) {
  int v2;                                       // esi
  int v3;                                       // eax
  int i;                                        // ecx
  int v6;                                       // eax
  int v7;                                       // esi
  unsigned int v8;                              // eax
  int v9;                                       // edx
  unsigned int v10;                             // [esp+24h] [ebp-34h]
  unsigned int v11;                             // [esp+28h] [ebp-30h]
  int v12;                                      // [esp+2Ch] [ebp-2Ch]
  int v13;                                      // [esp+30h] [ebp-28h]
  int v14;                                      // [esp+34h] [ebp-24h]
  int v15;                                      // [esp+38h] [ebp-20h]
  int v16;                                      // [esp+3Ch] [ebp-1Ch]
  int v17;                                      // [esp+40h] [ebp-18h]
  int v18;                                      // [esp+44h] [ebp-14h]
  void(__cdecl * v19)(int, int, int, int, int); // [esp+48h] [ebp-10h]
  int v20;                                      // [esp+4Ch] [ebp-Ch]

  v2 = *(_DWORD *)(a1 + 400);
  v10 = *(_DWORD *)(a1 + 292) - 1;
  while (1) {
    v3 = *(_DWORD *)(a1 + 140);
    if (*(_DWORD *)(a1 + 132) >= v3 &&
        (*(_DWORD *)(a1 + 132) != v3 ||
         *(_DWORD *)(a1 + 136) > *(_DWORD *)(a1 + 144)))
      break;
    if (!(**(int(__cdecl ***)(int))(a1 + 408))(a1))
      return 0;
  }
  v18 = *(_DWORD *)(a1 + 204);
  if (*(int *)(a1 + 44) > 0) {
    v20 = v2;
    v12 = 0;
    do {
      if (*(_BYTE *)(v18 + 48)) {
        v15 = (*(int(__cdecl **)(int, _DWORD, int, _DWORD, _DWORD))(
            *(_DWORD *)(a1 + 4) + 32))(a1, *(_DWORD *)(v20 + 72),
                                       *(_DWORD *)(a1 + 144) *
                                           *(_DWORD *)(v18 + 12),
                                       *(_DWORD *)(v18 + 12), 0);
        if (v10 <= *(_DWORD *)(a1 + 144)) {
          v9 = *(_DWORD *)(v18 + 32) % *(_DWORD *)(v18 + 12);
          if (!v9)
            v9 = *(_DWORD *)(v18 + 12);
          v14 = v9;
        } else {
          v14 = *(_DWORD *)(v18 + 12);
        }
        v19 = *(void(__cdecl **)(int, int, int, int, int))(
            *(_DWORD *)(a1 + 420) + 4 * v12 + 4);
        v16 = *(_DWORD *)(a2 + 4 * v12);
        if (v14 > 0) {
          v13 = 0;
          for (i = 0;; i = v13) {
            v7 = *(_DWORD *)(v15 + 4 * i);
            if (*(_DWORD *)(v18 + 28)) {
              v17 = 0;
              v11 = 0;
              do {
                v19(a1, v18, v7, v16, v17);
                v7 += 128;
                v6 = *(_DWORD *)(v18 + 36);
                v17 += v6;
                ++v11;
              } while (v11 < *(_DWORD *)(v18 + 28));
            } else {
              v6 = *(_DWORD *)(v18 + 36);
            }
            v16 += 4 * v6;
            if (v14 == ++v13)
              break;
          }
        }
      }
      ++v12;
      v18 += 84;
      v20 += 4;
    } while (v12 < *(_DWORD *)(a1 + 44));
  }
  v8 = *(_DWORD *)(a1 + 144) + 1;
  *(_DWORD *)(a1 + 144) = v8;
  if (v8 >= *(_DWORD *)(a1 + 292))
    return 4;
  else
    return 3;
}

int __cdecl decompress_smooth_data(_DWORD *a1, int a2) {
  _DWORD *i;                                             // eax
  int v3;                                                // edx
  _DWORD *v4;                                            // ecx
  int v5;                                                // eax
  _DWORD *v6;                                            // esi
  int v7;                                                // ecx
  unsigned int v8;                                       // esi
  _DWORD *v10;                                           // ecx
  _DWORD *v11;                                           // eax
  unsigned int v12;                                      // edi
  unsigned int v13;                                      // ecx
  __int16 **v14;                                         // ecx
  int *v15;                                              // edx
  unsigned __int16 *v16;                                 // eax
  __int16 **v17;                                         // edx
  __int16 *v18;                                          // edi
  __int16 *v19;                                          // ecx
  int v20;                                               // ecx
  int v21;                                               // edx
  int v22;                                               // eax
  int v23;                                               // ecx
  int v24;                                               // edx
  int v25;                                               // eax
  int v26;                                               // ecx
  int v27;                                               // edx
  int v28;                                               // eax
  int v29;                                               // ecx
  int v30;                                               // edx
  int v31;                                               // eax
  int v32;                                               // ecx
  int v33;                                               // edx
  int v34;                                               // eax
  int v35;                                               // eax
  __int16 **v36;                                         // ecx
  int v37;                                               // esi
  int v38;                                               // esi
  int v39;                                               // esi
  int v40;                                               // esi
  int v41;                                               // esi
  __int16 **v42;                                         // [esp+3Ch] [ebp-11Ch]
  int v43;                                               // [esp+40h] [ebp-118h]
  unsigned int v44;                                      // [esp+44h] [ebp-114h]
  unsigned int v45;                                      // [esp+48h] [ebp-110h]
  unsigned int v46;                                      // [esp+4Ch] [ebp-10Ch]
  int v47;                                               // [esp+50h] [ebp-108h]
  int v48;                                               // [esp+54h] [ebp-104h]
  int v49;                                               // [esp+58h] [ebp-100h]
  __int16 *v50;                                          // [esp+5Ch] [ebp-FCh]
  __int16 *v51;                                          // [esp+60h] [ebp-F8h]
  int v52;                                               // [esp+64h] [ebp-F4h]
  int v53;                                               // [esp+68h] [ebp-F0h]
  int v54;                                               // [esp+6Ch] [ebp-ECh]
  void(__cdecl * v55)(_DWORD *, int, _BYTE *, int, int); // [esp+70h] [ebp-E8h]
  char v56;                                              // [esp+76h] [ebp-E2h]
  char v57;                                              // [esp+77h] [ebp-E1h]
  int v58;                                               // [esp+78h] [ebp-E0h]
  int v59;                                               // [esp+7Ch] [ebp-DCh]
  int v60;                                               // [esp+80h] [ebp-D8h]
  int v61;                                               // [esp+84h] [ebp-D4h]
  int v62;                                               // [esp+88h] [ebp-D0h]
  int v63;                                               // [esp+8Ch] [ebp-CCh]
  int v64;                                               // [esp+90h] [ebp-C8h]
  int v65;                                               // [esp+94h] [ebp-C4h]
  int v66;                                               // [esp+98h] [ebp-C0h]
  int v67;                                               // [esp+9Ch] [ebp-BCh]
  int v68;                                               // [esp+A0h] [ebp-B8h]
  int v69;                                               // [esp+A4h] [ebp-B4h]
  int v70;                                               // [esp+A8h] [ebp-B0h]
  int v71;                                               // [esp+ACh] [ebp-ACh]
  int v72;                                               // [esp+B0h] [ebp-A8h]
  int *v73;                                              // [esp+B4h] [ebp-A4h]
  int *v74;                                              // [esp+B8h] [ebp-A0h]
  int *v75;                                              // [esp+BCh] [ebp-9Ch]
  int *v76;                                              // [esp+C0h] [ebp-98h]
  int *v77;                                              // [esp+C4h] [ebp-94h]
  int v78;                                               // [esp+C8h] [ebp-90h]
  int v79;                                               // [esp+CCh] [ebp-8Ch]
  _BYTE v80[2]; // [esp+D0h] [ebp-88h] BYREF
  __int16 v81;  // [esp+D2h] [ebp-86h]
  __int16 v82;  // [esp+D4h] [ebp-84h]
  __int16 v83;  // [esp+E0h] [ebp-78h]
  __int16 v84;  // [esp+E2h] [ebp-76h]
  __int16 v85;  // [esp+F0h] [ebp-68h]

  v43 = a1[100];
  v44 = a1[73] - 1;
  for (i = a1;; i = a1) {
    v3 = i[33];
    v4 = i;
    v5 = i[35];
    if (v3 > v5) {
      v8 = a1[36];
      v10 = a1;
      v11 = a1;
      goto LABEL_10;
    }
    v6 = v4;
    v7 = v4[102];
    if (*(_BYTE *)(v7 + 17)) {
      v8 = v6[36];
      v10 = a1;
      v11 = a1;
      goto LABEL_10;
    }
    if (v3 == v5) {
      v8 = a1[36];
      if (__PAIR64__(a1[34], a1[93]) >= __PAIR64__(v8, 1) &&
          a1[34] != v8 + (a1[93] == 0))
        break;
    }
    if (!(*(int(__cdecl **)(_DWORD *))v7)(a1))
      return 0;
  }
  v10 = a1;
  v11 = a1;
LABEL_10:
  v54 = v10[51];
  if ((int)v11[11] > 0) {
    v79 = v43;
    v47 = 0;
    v78 = 0;
    while (!*(_BYTE *)(v54 + 48)) {
      v11 = a1;
    LABEL_91:
      ++v47;
      v54 += 84;
      v78 += 24;
      v79 += 4;
      if (v47 >= v11[11])
        goto LABEL_92;
    }
    if (v44 <= v8) {
      v13 = *(_DWORD *)(v54 + 12);
      v12 = v13;
      v49 = *(_DWORD *)(v54 + 32) % v13;
      if (!v49) {
        v49 = *(_DWORD *)(v54 + 12);
        v57 = 1;
        if (v8)
          goto LABEL_16;
        goto LABEL_98;
      }
      v13 = *(_DWORD *)(v54 + 32) % v13;
      v57 = 1;
    } else {
      v49 = *(_DWORD *)(v54 + 12);
      v12 = v49;
      v13 = 2 * v49;
      v57 = 0;
    }
    if (v8) {
    LABEL_16:
      v14 = (__int16 **)((*(int(__cdecl **)(_DWORD *, _DWORD, unsigned int,
                                            unsigned int, _DWORD))(a1[1] + 32))(
                             a1, *(_DWORD *)(v79 + 72), v12 * (v8 - 1),
                             v13 + v12, 0) +
                         4 * *(_DWORD *)(v54 + 12));
      v56 = 0;
      goto LABEL_17;
    }
  LABEL_98:
    v14 = (__int16 **)(*(int(__cdecl **)(_DWORD *, _DWORD, _DWORD, unsigned int,
                                         _DWORD))(a1[1] + 32))(
        a1, *(_DWORD *)(v79 + 72), 0, v13, 0);
    v56 = 1;
  LABEL_17:
    v15 = (int *)(*(_DWORD *)(v43 + 112) + v78);
    v16 = *(unsigned __int16 **)(v54 + 76);
    v58 = *v16;
    v59 = v16[1];
    v61 = v16[8];
    v63 = v16[16];
    v62 = v16[9];
    v60 = v16[2];
    v55 = *(void(__cdecl **)(_DWORD *, int, _BYTE *, int, int))(a1[105] +
                                                                4 * v47 + 4);
    v52 = *(_DWORD *)(a2 + 4 * v47);
    if (v49 <= 0) {
      v8 = a1[36];
      v11 = a1;
    } else {
      v73 = v15 + 1;
      v74 = v15 + 2;
      v75 = v15 + 3;
      v76 = v15 + 4;
      v77 = v15 + 5;
      v48 = 0;
      v42 = v14;
      v17 = v14;
      v18 = *v14;
      if (v56) {
      LABEL_19:
        if (!v48) {
          v50 = v18;
          goto LABEL_21;
        }
        v36 = v42;
        goto LABEL_68;
      }
      while (1) {
        v36 = v17;
      LABEL_68:
        v50 = *(v36 - 1);
      LABEL_21:
        if (v57 && v48 == v49 - 1) {
          v51 = v18;
          v19 = v18;
        } else {
          v51 = v42[1];
          v19 = v51;
        }
        v66 = *v50;
        v69 = *v18;
        v72 = *v19;
        v46 = *(_DWORD *)(v54 + 28) - 1;
        v65 = v66;
        v64 = v66;
        v68 = v69;
        v67 = v69;
        v71 = v72;
        v70 = v72;
        v53 = 0;
        v45 = 0;
        while (1) {
          jcopy_block_row(v18, v80, 1);
          if (v46 > v45) {
            v50 += 64;
            v66 = *v50;
            v18 += 64;
            v69 = *v18;
            v51 += 64;
            v72 = *v51;
          } else {
            v18 += 64;
            v50 += 64;
            v51 += 64;
          }
          v20 = *v73;
          if (*v73 && !v81) {
            v21 = 36 * v58 * (v67 - v69);
            if (v21 < 0) {
              v37 = ((v59 << 7) - v21) / (v59 << 8);
              if (v20 > 0 && v37 >= 1 << v20)
                v37 = (1 << v20) - 1;
              v22 = -v37;
            } else {
              v22 = (v21 + (v59 << 7)) / (v59 << 8);
              if (v20 > 0 && v22 >= 1 << v20)
                v22 = (1 << v20) - 1;
            }
            v81 = v22;
          }
          v23 = *v74;
          if (*v74 && !v83) {
            v24 = 36 * v58 * (v65 - v71);
            if (v24 < 0) {
              v41 = ((v61 << 7) - v24) / (v61 << 8);
              if (v23 > 0 && v41 >= 1 << v23)
                v41 = (1 << v23) - 1;
              v25 = -v41;
            } else {
              v25 = (v24 + (v61 << 7)) / (v61 << 8);
              if (v23 > 0 && v25 >= 1 << v23)
                v25 = (1 << v23) - 1;
            }
            v83 = v25;
          }
          v26 = *v75;
          if (*v75 && !v85) {
            v27 = 9 * v58 * (v65 + v71 - 2 * v68);
            if (v27 < 0) {
              v40 = ((v63 << 7) - v27) / (v63 << 8);
              if (v26 > 0 && v40 >= 1 << v26)
                v40 = (1 << v26) - 1;
              v28 = -v40;
            } else {
              v28 = (v27 + (v63 << 7)) / (v63 << 8);
              if (v26 > 0 && v28 >= 1 << v26)
                v28 = (1 << v26) - 1;
            }
            v85 = v28;
          }
          v29 = *v76;
          if (*v76 && !v84) {
            v30 = 5 * v58 * (v64 - v66 - v70 + v72);
            if (v30 < 0) {
              v39 = ((v62 << 7) - v30) / (v62 << 8);
              if (v29 > 0 && v39 >= 1 << v29)
                v39 = (1 << v29) - 1;
              v31 = -v39;
            } else {
              v31 = (v30 + (v62 << 7)) / (v62 << 8);
              if (v29 > 0 && v31 >= 1 << v29)
                v31 = (1 << v29) - 1;
            }
            v84 = v31;
          }
          v32 = *v77;
          if (*v77 && !v82) {
            v33 = 9 * v58 * (v67 + v69 - 2 * v68);
            if (v33 < 0) {
              v38 = ((v60 << 7) - v33) / (v60 << 8);
              if (v32 > 0 && v38 >= 1 << v32)
                v38 = (1 << v32) - 1;
              v34 = -v38;
            } else {
              v34 = (v33 + (v60 << 7)) / (v60 << 8);
              if (v32 > 0 && v34 >= 1 << v32)
                v34 = (1 << v32) - 1;
            }
            v82 = v34;
          }
          v55(a1, v54, v80, v52, v53);
          v35 = *(_DWORD *)(v54 + 36);
          v53 += v35;
          if (v46 < ++v45)
            break;
          v70 = v71;
          v71 = v72;
          v67 = v68;
          v68 = v69;
          v64 = v65;
          v65 = v66;
        }
        v52 += 4 * v35;
        ++v48;
        ++v42;
        if (v49 == v48)
          break;
        v17 = v42;
        v18 = *v42;
        if (v56)
          goto LABEL_19;
      }
      v11 = a1;
      v8 = a1[36];
    }
    goto LABEL_91;
  }
LABEL_92:
  v11[36] = v8 + 1;
  if (v8 + 1 >= v11[73])
    return 4;
  else
    return 3;
}

_DWORD *__cdecl start_input_pass_0(_DWORD *a1) {
  _DWORD *result; // eax
  _DWORD *v2;     // edx

  result = a1;
  a1[34] = 0;
  v2 = (_DWORD *)a1[100];
  if ((int)a1[75] > 1) {
    v2[7] = 1;
  LABEL_3:
    v2[5] = 0;
    v2[6] = 0;
    return result;
  }
  if (a1[73] == 1) {
    result = *(_DWORD **)(a1[76] + 72);
    v2[7] = result;
    goto LABEL_3;
  }
  result = *(_DWORD **)(a1[76] + 12);
  v2[7] = result;
  v2[5] = 0;
  v2[6] = 0;
  return result;
}

int __cdecl consume_data(_DWORD *a1) {
  _DWORD *v1;       // esi
  _DWORD *v2;       // edi
  int v3;           // esi
  _DWORD *i;        // edx
  _DWORD *j;        // edi
  int v6;           // esi
  _DWORD *k;        // ecx
  int v8;           // edx
  int *v9;          // eax
  int v10;          // ecx
  unsigned int v11; // edx
  unsigned int v12; // eax
  _DWORD *v13;      // ecx
  _DWORD *v15;      // esi
  int v16;          // edi
  _DWORD *v17;      // ecx
  int v18;          // eax
  int v19;          // eax
  _DWORD *v20;      // [esp+3Ch] [ebp-4Ch]
  _DWORD *v21;      // [esp+44h] [ebp-44h]
  _DWORD *v22;      // [esp+4Ch] [ebp-3Ch]
  unsigned int v23; // [esp+50h] [ebp-38h]
  int v24;          // [esp+54h] [ebp-34h]
  int v25;          // [esp+58h] [ebp-30h]
  int v26;          // [esp+5Ch] [ebp-2Ch]
  int v27;          // [esp+60h] [ebp-28h]
  int v28;          // [esp+64h] [ebp-24h]
  _DWORD *v29;      // [esp+68h] [ebp-20h]
  int v30;          // [esp+6Ch] [ebp-1Ch]
  _DWORD v31[6];    // [esp+70h] [ebp-18h] BYREF

  v22 = (_DWORD *)a1[100];
  if ((int)a1[75] > 0) {
    v15 = a1;
    v16 = 1;
    v17 = a1;
    do {
      v31[v16 - 1] =
          (*(int(__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int))(v17[1] + 32))(
              a1, v22[*(_DWORD *)(v15[76] + 4) + 18],
              a1[34] * *(_DWORD *)(v15[76] + 12), *(_DWORD *)(v15[76] + 12), 1);
      v18 = v16++;
      ++v15;
      v17 = a1;
    } while (a1[75] > v18);
    v1 = v22;
    v2 = v22;
  } else {
    v1 = (_DWORD *)a1[100];
    v2 = v1;
  }
  v3 = v1[6];
  v27 = v3;
  if (v2[7] <= v3) {
  LABEL_23:
    v11 = a1[34] + 1;
    a1[34] = v11;
    v12 = a1[73];
    if (v11 >= v12) {
      (*(void(__cdecl **)(_DWORD *))(a1[102] + 12))(a1);
      return 4;
    } else {
      v13 = (_DWORD *)a1[100];
      if ((int)a1[75] <= 1) {
        if (v11 >= v12 - 1)
          v19 = *(_DWORD *)(a1[76] + 72);
        else
          v19 = *(_DWORD *)(a1[76] + 12);
        v13[7] = v19;
      } else {
        v13[7] = 1;
      }
      v13[5] = 0;
      v13[6] = 0;
      return 3;
    }
  } else {
    v30 = 4 * v3;
    v21 = v2 + 8;
    while (1) {
      v23 = v22[5];
      if (v23 < a1[80])
        break;
    LABEL_22:
      v22[5] = 0;
      ++v27;
      v30 += 4;
      if (v22[7] <= v27)
        goto LABEL_23;
    }
    for (i = a1;; i = a1) {
      if ((int)i[75] > 0) {
        v29 = i;
        v25 = 0;
        v24 = 0;
        for (j = i;; j = v29) {
          v6 = j[76];
          if (*(int *)(v6 + 56) > 0) {
            v28 = (*(_DWORD *)(v6 + 52) * v23) << 7;
            v20 = (_DWORD *)(v31[v25] + v30);
            v26 = 0;
            for (k = v20;; k = v20) {
              v8 = *k + v28;
              if (*(int *)(v6 + 52) > 0) {
                v9 = &v22[v24 + 8];
                v10 = 0;
                do {
                  *v9 = v8;
                  v8 += 128;
                  ++v10;
                  ++v9;
                } while (v10 < *(_DWORD *)(v6 + 52));
                v24 += v10;
              }
              ++v26;
              ++v20;
              if (v26 >= *(_DWORD *)(v6 + 56))
                break;
            }
          }
          ++v25;
          ++v29;
          i = a1;
          if (v25 >= a1[75])
            break;
        }
      }
      if (!(*(unsigned __int8(__cdecl **)(_DWORD *, _DWORD *))(i[104] + 4))(
              i, v21))
        break;
      if (++v23 >= a1[80])
        goto LABEL_22;
    }
    v22[6] = v27;
    v22[5] = v23;
    return 0;
  }
}

int __cdecl process_data_simple_main(_DWORD *a1, int a2, int a3, int a4) {
  int v4;          // edi
  int result;      // eax
  unsigned int v6; // esi
  int v7;          // [esp+2Ch] [ebp-Ch]

  v4 = a1[99];
  if (*(_BYTE *)(v4 + 48)) {
    v7 = v4 + 8;
  } else {
    v7 = v4 + 8;
    result = (*(int(__cdecl **)(_DWORD *, int))(a1[100] + 12))(a1, v4 + 8);
    if (!result)
      return result;
    *(_BYTE *)(v4 + 48) = 1;
  }
  v6 = a1[72];
  result = (*(int(__cdecl **)(_DWORD *, int, int, unsigned int, int, int, int))(
      a1[101] + 4))(a1, v7, v4 + 52, v6, a2, a3, a4);
  if (v6 <= *(_DWORD *)(v4 + 52)) {
    *(_BYTE *)(v4 + 48) = 0;
    *(_DWORD *)(v4 + 52) = 0;
  }
  return result;
}

unsigned int __cdecl process_data_context_main(_DWORD *a1, int a2,
                                               unsigned int *a3,
                                               unsigned int a4) {
  int v4;              // eax
  int v5;              // edi
  unsigned int result; // eax
  int v7;              // esi
  int v8;              // eax
  _DWORD *v9;          // esi
  int v10;             // esi
  int v11;             // edi
  int v12;             // ecx
  _DWORD *i;           // edi
  unsigned int v14;    // ecx
  int v15;             // esi
  int v16;             // edi
  _DWORD *v17;         // esi
  _DWORD *v18;         // edx
  int v19;             // ecx
  int v20;             // [esp+58h] [ebp-40h]
  int v21;             // [esp+64h] [ebp-34h]
  int v22;             // [esp+68h] [ebp-30h]
  int v23;             // [esp+6Ch] [ebp-2Ch]
  int v24;             // [esp+70h] [ebp-28h]
  _DWORD *v25;         // [esp+74h] [ebp-24h]
  int v26;             // [esp+78h] [ebp-20h]
  int v27;             // [esp+7Ch] [ebp-1Ch]
  int v28;             // [esp+80h] [ebp-18h]
  int v29;             // [esp+84h] [ebp-14h]
  int v30;             // [esp+88h] [ebp-10h]
  int v31;             // [esp+8Ch] [ebp-Ch]

  v4 = a1[99];
  v22 = v4;
  if (!*(_BYTE *)(v4 + 48)) {
    v7 = a1[99];
    result = (*(int(__cdecl **)(_DWORD *, _DWORD))(a1[100] + 12))(
        a1, *(_DWORD *)(v4 + 4 * *(_DWORD *)(v4 + 64) + 56));
    if (!result)
      return result;
    *(_BYTE *)(v7 + 48) = 1;
    ++*(_DWORD *)(v7 + 76);
    v5 = v22;
    result = *(_DWORD *)(v22 + 68);
    if (result != 1)
      goto LABEL_3;
  LABEL_14:
    v20 = v5 + 52;
    goto LABEL_8;
  }
  v5 = a1[99];
  result = *(_DWORD *)(v4 + 68);
  if (result == 1)
    goto LABEL_14;
LABEL_3:
  if (result == 2) {
    v20 = v22 + 52;
    (*(void(__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int, unsigned int *,
                        unsigned int))(a1[101] + 4))(
        a1, *(_DWORD *)(v22 + 4 * *(_DWORD *)(v22 + 64) + 56), v22 + 52,
        *(_DWORD *)(v22 + 72), a2, a3, a4);
    result = *(_DWORD *)(v22 + 52);
    if (result < *(_DWORD *)(v22 + 72))
      return result;
    *(_DWORD *)(v22 + 68) = 0;
    result = (unsigned int)a3;
    if (a4 <= *a3)
      return result;
  } else {
    if (result)
      return result;
    v20 = v22 + 52;
  }
  *(_DWORD *)(v22 + 52) = 0;
  *(_DWORD *)(v22 + 72) = a1[72] - 1;
  if (*(_DWORD *)(v22 + 76) == a1[73]) {
    v23 = a1[99];
    v25 = (_DWORD *)a1[51];
    if ((int)a1[11] > 0) {
      v24 = 0;
      for (i = a1;; i = a1) {
        v14 = v25[9] * v25[3];
        v15 = (int)v14 / i[72];
        if (v25[11] % v14)
          v14 = v25[11] % v14;
        if (!v24)
          *(_DWORD *)(v23 + 72) = (int)(v14 - 1) / v15 + 1;
        v16 = 2 * v15;
        if (2 * v15 > 0) {
          v17 = (_DWORD *)(*(_DWORD *)(*(_DWORD *)(v23 +
                                                   4 * *(_DWORD *)(v23 + 64) +
                                                   56) +
                                       4 * v24) +
                           4 * v14 - 4);
          v18 = (_DWORD *)(*(_DWORD *)(*(_DWORD *)(v23 +
                                                   4 * *(_DWORD *)(v23 + 64) +
                                                   56) +
                                       4 * v24) +
                           4 * v14);
          v19 = 0;
          do {
            *v18 = *v17;
            ++v19;
            ++v18;
          } while (v16 != v19);
        }
        ++v24;
        v25 += 21;
        if (a1[11] <= v24)
          break;
      }
    }
  }
  *(_DWORD *)(v22 + 68) = 1;
LABEL_8:
  (*(void(__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int, unsigned int *,
                      unsigned int))(a1[101] + 4))(
      a1, *(_DWORD *)(v22 + 4 * *(_DWORD *)(v22 + 64) + 56), v20,
      *(_DWORD *)(v22 + 72), a2, a3, a4);
  result = *(_DWORD *)(v22 + 52);
  if (result >= *(_DWORD *)(v22 + 72)) {
    if (*(_DWORD *)(v22 + 76) == 1) {
      v26 = a1[99];
      v8 = a1[72];
      v29 = a1[51];
      if ((int)a1[11] > 0) {
        v27 = 0;
        do {
          v9 = a1;
          v21 = *(_DWORD *)(v29 + 36) * *(_DWORD *)(v29 + 12) / a1[72];
          v30 = *(_DWORD *)(*(_DWORD *)(v26 + 56) + 4 * v27);
          v31 = *(_DWORD *)(*(_DWORD *)(v26 + 60) + 4 * v27);
          if (v21 > 0) {
            v28 = 0;
            v10 = 4 * (v8 + 2) * v21;
            v11 = -4 * v21;
            v12 = 4 * v21 * (v8 + 1);
            do {
              *(_DWORD *)(v11 + v30) = *(_DWORD *)(v12 + v30);
              *(_DWORD *)(v11 + v31) = *(_DWORD *)(v12 + v31);
              *(_DWORD *)(v10 + v30) = *(_DWORD *)(v30 + 4 * v28);
              *(_DWORD *)(v10 + v31) = *(_DWORD *)(v31 + 4 * v28++);
              v12 += 4;
              v11 += 4;
              v10 += 4;
            } while (v21 != v28);
            v9 = a1;
          }
          ++v27;
          v29 += 84;
        } while (v27 < v9[11]);
      }
    }
    *(_DWORD *)(v22 + 64) ^= 1u;
    *(_BYTE *)(v22 + 48) = 0;
    *(_DWORD *)(v22 + 52) = a1[72] + 1;
    result = a1[72] + 2;
    *(_DWORD *)(v22 + 72) = result;
    *(_DWORD *)(v22 + 68) = 2;
  }
  return result;
}

int __cdecl process_data_crank_post(int a1, int a2, int a3, int a4) {
  return (*(int(__cdecl **)(int, _DWORD, _DWORD, _DWORD, int, int, int))(
      *(_DWORD *)(a1 + 404) + 4))(a1, 0, 0, 0, a2, a3, a4);
}

int __cdecl jinit_d_main_controller(int a1, char a2) {
  int v2;      // esi
  int v3;      // eax
  _DWORD *v4;  // eax
  _DWORD *v5;  // edi
  _DWORD *v6;  // edi
  int result;  // eax
  int i;       // esi
  int v9;      // ecx
  int v10;     // esi
  int v11;     // edx
  int v12;     // ecx
  _DWORD *v13; // [esp+30h] [ebp-38h]
  int v14;     // [esp+34h] [ebp-34h]
  int v15;     // [esp+38h] [ebp-30h]
  int v16;     // [esp+3Ch] [ebp-2Ch]
  int v17;     // [esp+40h] [ebp-28h]
  int v18;     // [esp+44h] [ebp-24h]
  int v19;     // [esp+48h] [ebp-20h]
  _DWORD *v20; // [esp+4Ch] [ebp-1Ch]

  v13 = (_DWORD *)(**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 80);
  *(_DWORD *)(a1 + 396) = v13;
  *v13 = start_pass_main;
  if (a2) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  if (!*(_BYTE *)(*(_DWORD *)(a1 + 424) + 8)) {
    v15 = *(_DWORD *)(a1 + 288);
    v6 = *(_DWORD **)(a1 + 204);
    result = *(_DWORD *)(a1 + 44);
    if (result <= 0)
      return result;
    goto LABEL_10;
  }
  if (*(int *)(a1 + 288) <= 1) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 47;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  v16 = *(_DWORD *)(a1 + 396);
  v2 = *(_DWORD *)(a1 + 288);
  v3 = (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1,
                                                     8 * *(_DWORD *)(a1 + 44));
  *(_DWORD *)(v16 + 56) = v3;
  *(_DWORD *)(v16 + 60) = v3 + 4 * *(_DWORD *)(a1 + 44);
  v4 = *(_DWORD **)(a1 + 204);
  v5 = v4;
  if (*(int *)(a1 + 44) > 0) {
    v18 = 8 * v2 + 32;
    v19 = 4 * v2 + 16;
    v17 = 0;
    v9 = a1;
    do {
      v10 = v5[9] * v5[3] / *(_DWORD *)(v9 + 288);
      v11 = (**(int(__cdecl ***)(int, int, int))(v9 + 4))(v9, 1, v10 * v18) +
            4 * v10;
      v12 = 4 * v17;
      *(_DWORD *)(*(_DWORD *)(v16 + 56) + v12) = v11;
      *(_DWORD *)(*(_DWORD *)(v16 + 60) + v12) = v19 * v10 + v11;
      ++v17;
      v5 += 21;
      v9 = a1;
    } while (*(_DWORD *)(a1 + 44) > v17);
    v4 = *(_DWORD **)(a1 + 204);
  }
  v15 = *(_DWORD *)(a1 + 288) + 2;
  v6 = v4;
  result = *(_DWORD *)(a1 + 44);
  if (result > 0) {
  LABEL_10:
    v20 = v13;
    v14 = 0;
    for (i = a1;; i = a1) {
      result = (*(int(__cdecl **)(int, int, int, int))(*(_DWORD *)(i + 4) + 8))(
          a1, 1, v6[7] * v6[9], v15 * (v6[3] * v6[9] / *(_DWORD *)(i + 288)));
      v20[2] = result;
      ++v14;
      v6 += 21;
      ++v20;
      if (v14 >= *(_DWORD *)(a1 + 44))
        break;
    }
  }
  return result;
}

void *__cdecl start_pass_dpost(int a1, int a2) {
  _DWORD *v2;   // esi
  void *result; // eax

  v2 = *(_DWORD **)(a1 + 404);
  if (a2 == 2) {
    if (!v2[2]) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    result = post_process_2pass;
    v2[1] = post_process_2pass;
    v2[6] = 0;
    v2[5] = 0;
  } else if (a2 == 3) {
    if (!v2[2]) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    result = post_process_prepass;
    v2[1] = post_process_prepass;
    v2[6] = 0;
    v2[5] = 0;
  } else {
    if (a2) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
      result = (void *)(**(int(__cdecl ***)(int))a1)(a1);
    LABEL_5:
      v2[6] = 0;
      v2[5] = 0;
      return result;
    }
    if (*(_BYTE *)(a1 + 82)) {
      v2[1] = post_process_1pass;
      result = (void *)v2[3];
      if (!result) {
        result = (void *)(*(int(__cdecl **)(int, _DWORD, _DWORD, _DWORD, int))(
            *(_DWORD *)(a1 + 4) + 28))(a1, v2[2], 0, v2[4], 1);
        v2[3] = result;
      }
      goto LABEL_5;
    }
    result = *(void **)(*(_DWORD *)(a1 + 424) + 4);
    v2[1] = result;
    v2[6] = 0;
    v2[5] = 0;
  }
  return result;
}

int __cdecl post_process_1pass(_DWORD *a1, int a2, int a3, int a4, int a5,
                               int *a6, int a7) {
  int v7;          // edi
  unsigned int v8; // eax
  int result;      // eax
  _DWORD v10[3];   // [esp+2Ch] [ebp-Ch] BYREF

  v7 = a1[101];
  v8 = a7 - *a6;
  if (v8 > *(_DWORD *)(v7 + 16))
    v8 = *(_DWORD *)(v7 + 16);
  v10[0] = 0;
  (*(void(__cdecl **)(_DWORD *, int, int, int, _DWORD, _DWORD *, unsigned int))(
      a1[106] + 4))(a1, a2, a3, a4, *(_DWORD *)(v7 + 12), v10, v8);
  (*(void(__cdecl **)(_DWORD *, _DWORD, int, _DWORD))(a1[108] + 4))(
      a1, *(_DWORD *)(v7 + 12), a5 + 4 * *a6, v10[0]);
  result = v10[0] + *a6;
  *a6 = result;
  return result;
}

unsigned int __cdecl post_process_prepass(_DWORD *a1, int a2, int a3, int a4,
                                          int a5, _DWORD *a6) {
  _DWORD *v6;          // eax
  _DWORD *v7;          // edi
  unsigned int v8;     // esi
  unsigned int v9;     // eax
  unsigned int result; // eax
  unsigned int v11;    // [esp+2Ch] [ebp-Ch]

  v6 = a1;
  v7 = (_DWORD *)a1[101];
  if (!v7[6]) {
    v7[3] = (*(int(__cdecl **)(_DWORD *, _DWORD, _DWORD, _DWORD, int))(
        a1[1] + 28))(a1, v7[2], v7[5], v7[4], 1);
    v6 = a1;
  }
  v8 = v7[6];
  (*(void(__cdecl **)(_DWORD *, int, int, int, _DWORD, _DWORD *, _DWORD))(
      v6[106] + 4))(a1, a2, a3, a4, v7[3], v7 + 6, v7[4]);
  v9 = v7[6];
  if (v8 < v9) {
    v11 = v9 - v8;
    (*(void(__cdecl **)(_DWORD *, unsigned int, _DWORD, unsigned int))(
        a1[108] + 4))(a1, v7[3] + 4 * v8, 0, v9 - v8);
    *a6 += v11;
  }
  result = v7[4];
  if (v7[6] >= result) {
    v7[5] += result;
    v7[6] = 0;
  }
  return result;
}

unsigned int __cdecl post_process_2pass(_DWORD *a1, int a2, int a3, int a4,
                                        int a5, _DWORD *a6, int a7) {
  _DWORD *v7;          // edi
  int v8;              // ecx
  unsigned int v9;     // esi
  unsigned int v10;    // esi
  unsigned int result; // eax

  v7 = (_DWORD *)a1[101];
  if (!v7[6])
    v7[3] = (*(int(__cdecl **)(_DWORD *, _DWORD, _DWORD, _DWORD, _DWORD))(
        a1[1] + 28))(a1, v7[2], v7[5], v7[4], 0);
  v8 = v7[6];
  v9 = v7[4] - v8;
  if (v9 > a7 - *a6)
    v9 = a7 - *a6;
  if (v9 > a1[26] - v7[5])
    v9 = a1[26] - v7[5];
  (*(void(__cdecl **)(_DWORD *, int, int, unsigned int))(a1[108] + 4))(
      a1, v7[3] + 4 * v8, a5 + 4 * *a6, v9);
  *a6 += v9;
  v10 = v7[6] + v9;
  v7[6] = v10;
  result = v7[4];
  if (v10 >= result) {
    v7[5] += result;
    v7[6] = 0;
  }
  return result;
}

int __cdecl start_pass_huff_decoder(int a1) {
  int v1;           // ecx
  int v2;           // ecx
  int v3;           // esi
  int v4;           // ecx
  int v5;           // eax
  int v6;           // edx
  int result;       // eax
  int v8;           // edi
  int v9;           // eax
  unsigned int v10; // esi
  int v11;          // [esp+1Ch] [ebp-2Ch]
  int v12;          // [esp+30h] [ebp-18h]
  int v13;          // [esp+34h] [ebp-14h]
  int v14;          // [esp+38h] [ebp-10h]
  int v15;          // [esp+3Ch] [ebp-Ch]

  v12 = *(_DWORD *)(a1 + 416);
  if (*(_DWORD *)(a1 + 372)) {
    v1 = a1;
  } else {
    if (*(_DWORD *)(a1 + 376) == 63 && !*(_DWORD *)(a1 + 380) &&
        !*(_DWORD *)(a1 + 384))
      goto LABEL_5;
    v1 = a1;
  }
  *(_DWORD *)(*(_DWORD *)v1 + 20) = 122;
  (*(void(__cdecl **)(int, int))(*(_DWORD *)v1 + 4))(v1, -1);
LABEL_5:
  if (*(int *)(a1 + 300) > 0) {
    v15 = a1;
    v8 = v12;
    v13 = 0;
    do {
      v9 = *(_DWORD *)(v15 + 304);
      v10 = *(_DWORD *)(v9 + 24);
      jpeg_make_d_derived_tbl((int(__cdecl ***)(_DWORD, _DWORD, _DWORD))a1, 1,
                              *(_DWORD *)(v9 + 20),
                              (int *)(v12 + 40 + 4 * *(_DWORD *)(v9 + 20)));
      jpeg_make_d_derived_tbl((int(__cdecl ***)(_DWORD, _DWORD, _DWORD))a1, 0,
                              v10, (int *)(v12 + 56 + 4 * v10));
      *(_DWORD *)(v8 + 20) = 0;
      ++v13;
      v15 += 4;
      v8 += 4;
    } while (v13 < *(_DWORD *)(a1 + 300));
    v2 = a1;
  } else {
    v2 = a1;
  }
  if (*(int *)(v2 + 328) > 0) {
    v11 = v2;
    v3 = v12;
    v4 = v12;
    v14 = 0;
    v5 = a1;
    do {
      while (1) {
        v6 = *(_DWORD *)(v5 + 4 * *(_DWORD *)(v11 + 332) + 304);
        *(_DWORD *)(v3 + 72) = *(_DWORD *)(v12 + 4 * *(_DWORD *)(v6 + 20) + 40);
        *(_DWORD *)(v3 + 112) =
            *(_DWORD *)(v12 + 4 * *(_DWORD *)(v6 + 24) + 56);
        if (!*(_BYTE *)(v6 + 48))
          break;
        *(_BYTE *)(v4 + 152) = 1;
        *(_BYTE *)(v4 + 162) = *(_DWORD *)(v6 + 36) > 1;
        ++v14;
        v11 += 4;
        v3 += 4;
        ++v4;
        v5 = a1;
        if (v14 >= *(_DWORD *)(a1 + 328))
          goto LABEL_12;
      }
      *(_BYTE *)(v4 + 162) = 0;
      *(_BYTE *)(v4 + 152) = 0;
      ++v14;
      v11 += 4;
      v3 += 4;
      ++v4;
      v5 = a1;
    } while (v14 < *(_DWORD *)(a1 + 328));
  }
LABEL_12:
  *(_DWORD *)(v12 + 16) = 0;
  *(_DWORD *)(v12 + 12) = 0;
  *(_BYTE *)(v12 + 8) = 0;
  result = *(_DWORD *)(a1 + 260);
  *(_DWORD *)(v12 + 36) = result;
  return result;
}

int __cdecl jpeg_fill_bit_buffer(int a1, int a2, int a3, int a4) {
  unsigned __int8 *v4;   // edi
  int v5;                // esi
  int v7;                // eax
  unsigned __int8 v8;    // al
  int v9;                // edx
  unsigned __int8 **v10; // eax
  unsigned __int8 *v11;  // edi
  unsigned __int8 v12;   // al
  int v13;               // edx
  _DWORD *v14;           // [esp+1Ch] [ebp-Ch]

  v4 = *(unsigned __int8 **)a1;
  v5 = *(_DWORD *)(a1 + 4);
  v14 = *(_DWORD **)(a1 + 16);
  if (v14[97]) {
  LABEL_17:
    if (a3 < a4) {
      if (!*(_BYTE *)(v14[104] + 8)) {
        *(_DWORD *)(*v14 + 20) = 117;
        (*(void(__cdecl **)(_DWORD *, int))(*v14 + 4))(v14, -1);
        *(_BYTE *)(v14[104] + 8) = 1;
      }
      a2 <<= 25 - a3;
      a3 = 25;
    }
    goto LABEL_3;
  }
  if (a3 > 24) {
  LABEL_3:
    *(_DWORD *)a1 = v4;
    *(_DWORD *)(a1 + 4) = v5;
    *(_DWORD *)(a1 + 8) = a2;
    *(_DWORD *)(a1 + 12) = a3;
    return 1;
  }
  while (v5) {
  LABEL_6:
    --v5;
    v8 = *v4;
    v9 = *v4++;
    if (v8 == 0xFF) {
      do {
        while (v5) {
          --v5;
          v12 = *v4;
          v13 = *v4++;
          if (v12 != 0xFF)
            goto LABEL_14;
        }
        if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v14[8] + 12))(v14))
          return 0;
        v10 = (unsigned __int8 **)v14[8];
        v11 = *v10;
        v5 = (int)(v10[1] - 1);
        v12 = **v10;
        v13 = v12;
        v4 = v11 + 1;
      } while (v12 == 0xFF);
    LABEL_14:
      if (v12) {
        v14[97] = v13;
        goto LABEL_17;
      }
      v9 = 255;
    }
    a2 = v9 | (a2 << 8);
    a3 += 8;
    if (a3 > 24)
      goto LABEL_3;
  }
  if ((*(unsigned __int8(__cdecl **)(_DWORD *))(v14[8] + 12))(v14)) {
    v7 = v14[8];
    v4 = *(unsigned __int8 **)v7;
    v5 = *(_DWORD *)(v7 + 4);
    goto LABEL_6;
  }
  return 0;
}

int __cdecl jpeg_huff_decode(int a1, int a2, int a3, int a4, int a5) {
  int v5;  // eax
  int v6;  // edx
  int v7;  // edx
  int v8;  // edi
  int v9;  // esi
  int v10; // edx
  int v11; // eax
  int v13; // [esp+1Ch] [ebp-1Ch]
  int v14; // [esp+2Ch] [ebp-Ch]

  v5 = a3;
  if (a5 > a3) {
    if (!(unsigned __int8)jpeg_fill_bit_buffer(a1, a2, a3, a5))
      return -1;
    a2 = *(_DWORD *)(a1 + 8);
    v5 = *(_DWORD *)(a1 + 12);
    v6 = a2;
  } else {
    v6 = a2;
  }
  v13 = v5 - a5;
  v7 = ((1 << a5) - 1) & (v6 >> (v5 - a5));
  if (v7 <= *(_DWORD *)(a4 + 4 * a5)) {
    v8 = a5;
    *(_DWORD *)(a1 + 8) = a2;
    *(_DWORD *)(a1 + 12) = v13;
    if (a5 <= 16)
      return *(unsigned __int8 *)(*(_DWORD *)(a4 + 140) +
                                  *(_DWORD *)(a4 + 4 * v8 + 72) + v7 + 17);
  } else {
    v8 = a5;
    v9 = a4 + 4 * a5;
    do {
      v14 = 2 * v7;
      if (v13 <= 0) {
        if (!(unsigned __int8)jpeg_fill_bit_buffer(a1, a2, v13, 1))
          return -1;
        v10 = *(_DWORD *)(a1 + 8);
        a2 = v10;
        v13 = *(_DWORD *)(a1 + 12);
      } else {
        v10 = a2;
      }
      v7 = v14 | (v10 >> --v13) & 1;
      ++v8;
      v11 = *(_DWORD *)(v9 + 4);
      v9 += 4;
    } while (v11 < v7);
    *(_DWORD *)(a1 + 8) = a2;
    *(_DWORD *)(a1 + 12) = v13;
    if (v8 <= 16)
      return *(unsigned __int8 *)(*(_DWORD *)(a4 + 140) +
                                  *(_DWORD *)(a4 + 4 * v8 + 72) + v7 + 17);
  }
  *(_DWORD *)(**(_DWORD **)(a1 + 16) + 20) = 118;
  (*(void(__cdecl **)(_DWORD, int))(**(_DWORD **)(a1 + 16) + 4))(
      *(_DWORD *)(a1 + 16), -1);
  return 0;
}

int __cdecl decode_mcu(_DWORD *a1, int a2) {
  int v2;              // eax
  int *v3;             // edx
  int v4;              // esi
  int v5;              // edx
  int v6;              // eax
  int v7;              // eax
  int v8;              // ecx
  int v9;              // edi
  int v10;             // edx
  int v11;             // edx
  int v12;             // esi
  int v13;             // edx
  int v14;             // eax
  int v15;             // edi
  int v16;             // edx
  int v17;             // edx
  int v18;             // eax
  int v19;             // edx
  int v20;             // eax
  int v21;             // eax
  int v22;             // edx
  int v23;             // edi
  int v24;             // edx
  int v25;             // edx
  int v26;             // esi
  int v27;             // edx
  int v28;             // eax
  unsigned __int8 v29; // al
  int v30;             // edx
  int v31;             // edi
  int v32;             // edx
  int v33;             // edx
  int v34;             // edx
  int v35;             // eax
  int v37;             // eax
  int v38;             // eax
  int v39;             // edx
  int v40;             // edi
  int v41;             // edx
  int v42;             // edx
  int v43;             // esi
  int v44;             // edx
  int v45;             // eax
  unsigned __int8 v46; // al
  int v47;             // edx
  int v48;             // edi
  int v49;             // ecx
  int v50;             // eax
  int v51;             // eax
  _DWORD *v52;         // edx
  int v53;             // edx
  int v54;             // eax
  int v55;             // [esp+1Ch] [ebp-9Ch]
  int v56;             // [esp+1Ch] [ebp-9Ch]
  int v57;             // [esp+1Ch] [ebp-9Ch]
  int v58;             // [esp+34h] [ebp-84h]
  _WORD *v59;          // [esp+38h] [ebp-80h]
  int v60;             // [esp+3Ch] [ebp-7Ch]
  int v61;             // [esp+40h] [ebp-78h]
  int v62;             // [esp+44h] [ebp-74h]
  int v63;             // [esp+48h] [ebp-70h]
  int v64;             // [esp+4Ch] [ebp-6Ch]
  int v65;             // [esp+50h] [ebp-68h]
  int v66;             // [esp+54h] [ebp-64h]
  int v67;             // [esp+58h] [ebp-60h]
  int v68;             // [esp+5Ch] [ebp-5Ch]
  int v69;             // [esp+60h] [ebp-58h]
  int v70;             // [esp+64h] [ebp-54h]
  int v71;             // [esp+68h] [ebp-50h]
  int v72;             // [esp+6Ch] [ebp-4Ch]
  int v73;             // [esp+7Ch] [ebp-3Ch] BYREF
  int v74;             // [esp+80h] [ebp-38h]
  int v75;             // [esp+84h] [ebp-34h]
  int v76;             // [esp+88h] [ebp-30h]
  _DWORD *v77;         // [esp+8Ch] [ebp-2Ch]
  int v78;             // [esp+90h] [ebp-28h]
  int v79;             // [esp+94h] [ebp-24h]
  int v80;             // [esp+98h] [ebp-20h]
  int v81;             // [esp+9Ch] [ebp-1Ch]

  v2 = a1[104];
  v67 = v2;
  if (a1[65]) {
    if (*(_DWORD *)(v2 + 36))
      goto LABEL_3;
    v51 = *(_DWORD *)(v2 + 16);
    if (v51 <= -1)
      v51 += 7;
    *(_DWORD *)(a1[103] + 20) += v51 >> 3;
    *(_DWORD *)(v67 + 16) = 0;
    if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(a1[103] + 8))(a1))
      return 0;
    v52 = a1;
    if ((int)a1[75] > 0) {
      v53 = v67;
      v54 = 0;
      do {
        *(_DWORD *)(v53 + 20) = 0;
        ++v54;
        v53 += 4;
      } while (v54 < a1[75]);
      v52 = a1;
    }
    *(_DWORD *)(v67 + 36) = v52[65];
    if (v52[97]) {
    LABEL_3:
      v2 = v67;
    } else {
      *(_BYTE *)(v67 + 8) = 0;
      v2 = v67;
    }
  }
  if (*(_BYTE *)(v2 + 8))
    goto LABEL_54;
  v77 = a1;
  v3 = (int *)a1[8];
  v73 = *v3;
  v74 = v3[1];
  v58 = *(_DWORD *)(v67 + 12);
  v4 = *(_DWORD *)(v67 + 16);
  v78 = *(_DWORD *)(v67 + 20);
  v79 = *(_DWORD *)(v67 + 24);
  v80 = *(_DWORD *)(v67 + 28);
  v81 = *(_DWORD *)(v67 + 32);
  if ((int)a1[82] <= 0)
    goto LABEL_53;
  v65 = v67;
  v66 = v67;
  v64 = 1;
  do {
    v59 = *(_WORD **)(a2 + 4 * v64 - 4);
    v5 = *(_DWORD *)(v65 + 72);
    v60 = v5;
    v61 = *(_DWORD *)(v65 + 112);
    if (v4 <= 7) {
      if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v73, v58, v4, 0))
        return 0;
      v58 = v75;
      v4 = v76;
      if (v76 <= 7) {
        v9 = 1;
        if (v76 < 1)
          goto LABEL_107;
        goto LABEL_11;
      }
      v6 = v75;
      v5 = v60;
    } else {
      v6 = v58;
    }
    v7 = (unsigned __int8)(v6 >> (v4 - 8));
    v8 = *(_DWORD *)(v5 + 4 * v7 + 144);
    if (v8) {
      v4 -= v8;
      v15 = *(unsigned __int8 *)(v7 + v60 + 1168);
      goto LABEL_20;
    }
    v9 = 9;
    if (v4 < 9) {
    LABEL_107:
      if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v73, v58, v4, v9))
        return 0;
      v10 = v75;
      v58 = v75;
      v4 = v76;
      goto LABEL_12;
    }
  LABEL_11:
    v10 = v58;
  LABEL_12:
    v55 = v4 - v9;
    v11 = ((1 << v9) - 1) & (v10 >> (v4 - v9));
    if (v11 > *(_DWORD *)(v60 + 4 * v9)) {
      v12 = v60 + 4 * v9;
      do {
        v68 = 2 * v11;
        if (v55 <= 0) {
          if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v73, v58, v55, 1))
            return 0;
          v13 = v75;
          v58 = v75;
          v55 = v76;
        } else {
          v13 = v58;
        }
        v11 = v68 | (v13 >> --v55) & 1;
        ++v9;
        v14 = *(_DWORD *)(v12 + 4);
        v12 += 4;
      } while (v14 < v11);
    }
    v75 = v58;
    v76 = v55;
    if (v9 > 16) {
      *(_DWORD *)(*v77 + 20) = 118;
      (*(void(__cdecl **)(_DWORD *, int))(*v77 + 4))(v77, -1);
      v15 = 0;
    } else {
      v15 = *(unsigned __int8 *)(*(_DWORD *)(v60 + 4 * v9 + 72) +
                                 *(_DWORD *)(v60 + 140) + v11 + 17);
    }
    v58 = v75;
    v4 = v76;
  LABEL_20:
    if (v15) {
      if (v4 < v15) {
        if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v73, v58, v4, v15))
          return 0;
        v58 = v75;
        v4 = v76;
        v16 = v75;
      } else {
        v16 = v58;
      }
      v4 -= v15;
      v17 = ((1 << v15) - 1) & (v16 >> v4);
      if (v17 < extend_test[v15])
        v17 += extend_offset[v15];
      v15 = v17;
    }
    if (*(_BYTE *)(v66 + 152)) {
      v18 = a1[v64 + 82];
      v19 = *(&v78 + v18) + v15;
      *(&v78 + v18) = v19;
      *v59 = v19;
    }
    if (*(_BYTE *)(v66 + 162)) {
      v72 = 1;
      while (1) {
        if (v4 <= 7) {
          if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v73, v58, v4, 0))
            return 0;
          v58 = v75;
          v4 = v76;
          if (v76 <= 7) {
            v23 = 1;
            goto LABEL_34;
          }
          v20 = v75;
        } else {
          v20 = v58;
        }
        v21 = (unsigned __int8)(v20 >> (v4 - 8));
        v22 = *(_DWORD *)(v61 + 4 * v21 + 144);
        if (v22) {
          v4 -= v22;
          v37 = *(unsigned __int8 *)(v21 + v61 + 1168);
          v30 = v37 >> 4;
          v31 = v37 & 0xF;
          goto LABEL_44;
        }
        v23 = 9;
      LABEL_34:
        if (v4 < v23) {
          if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v73, v58, v4, v23))
            return 0;
          v24 = v75;
          v58 = v75;
          v4 = v76;
        } else {
          v24 = v58;
        }
        v56 = v4 - v23;
        v25 = ((1 << v23) - 1) & (v24 >> (v4 - v23));
        if (v25 > *(_DWORD *)(v61 + 4 * v23)) {
          v26 = v61 + 4 * v23;
          do {
            v69 = 2 * v25;
            if (v56 <= 0) {
              if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v73, v58, v56,
                                                         1))
                return 0;
              v27 = v75;
              v58 = v75;
              v56 = v76;
            } else {
              v27 = v58;
            }
            v25 = v69 | (v27 >> --v56) & 1;
            ++v23;
            v28 = *(_DWORD *)(v26 + 4);
            v26 += 4;
          } while (v25 > v28);
        }
        v75 = v58;
        v76 = v56;
        if (v23 > 16) {
          *(_DWORD *)(*v77 + 20) = 118;
          (*(void(__cdecl **)(_DWORD *, int))(*v77 + 4))(v77, -1);
          v30 = 0;
          v31 = 0;
        } else {
          v29 = *(_BYTE *)(*(_DWORD *)(v61 + 4 * v23 + 72) +
                           *(_DWORD *)(v61 + 140) + v25 + 17);
          v30 = (int)v29 >> 4;
          v31 = v29 & 0xF;
        }
        v58 = v75;
        v4 = v76;
      LABEL_44:
        if (v31) {
          v62 = v72 + v30;
          if (v4 < v31) {
            if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v73, v58, v4, v31))
              return 0;
            v58 = v75;
            v4 = v76;
            v32 = v75;
          } else {
            v32 = v58;
          }
          v4 -= v31;
          v33 = ((1 << v31) - 1) & (v32 >> v4);
          if (v33 < extend_test[v31])
            v33 += extend_offset[v31];
          v59[jpeg_natural_order[v62]] = v33;
          v34 = v62;
        } else {
          if (v30 != 15)
            goto LABEL_51;
          v34 = v72 + 15;
        }
        v72 = v34 + 1;
        if (v34 + 1 > 63)
          goto LABEL_51;
      }
    }
    v71 = 1;
    if (v4 > 7) {
    LABEL_70:
      v38 = (unsigned __int8)(v58 >> (v4 - 8));
      v39 = *(_DWORD *)(v61 + 4 * v38 + 144);
      if (v39)
        goto LABEL_89;
    LABEL_71:
      v40 = 9;
    LABEL_72:
      if (v4 < v40) {
        if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v73, v58, v4, v40))
          return 0;
        v41 = v75;
        v58 = v75;
        v4 = v76;
      } else {
        v41 = v58;
      }
      v57 = v4 - v40;
      v42 = ((1 << v40) - 1) & (v41 >> (v4 - v40));
      if (v42 > *(_DWORD *)(v61 + 4 * v40)) {
        v43 = v61 + 4 * v40;
        do {
          v63 = 2 * v42;
          if (v57 <= 0) {
            if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v73, v58, v57, 1))
              return 0;
            v44 = v75;
            v58 = v75;
            v57 = v76;
          } else {
            v44 = v58;
          }
          v42 = v63 | (v44 >> --v57) & 1;
          ++v40;
          v45 = *(_DWORD *)(v43 + 4);
          v43 += 4;
        } while (v42 > v45);
      }
      v75 = v58;
      v76 = v57;
      if (v40 > 16) {
        *(_DWORD *)(*v77 + 20) = 118;
        (*(void(__cdecl **)(_DWORD *, int))(*v77 + 4))(v77, -1);
        v47 = 0;
        v48 = 0;
      } else {
        v46 = *(_BYTE *)(*(_DWORD *)(v61 + 140) +
                         *(_DWORD *)(v61 + 4 * v40 + 72) + v42 + 17);
        v47 = (int)v46 >> 4;
        v48 = v46 & 0xF;
      }
      v58 = v75;
      v4 = v76;
      if (!v48)
        goto LABEL_90;
    LABEL_82:
      v70 = v71 + v47;
      if (v4 >= v48) {
      LABEL_83:
        v4 -= v48;
        v49 = v70;
        goto LABEL_84;
      }
      if ((unsigned __int8)jpeg_fill_bit_buffer((int)&v73, v58, v4, v48)) {
        v58 = v75;
        v4 = v76;
        goto LABEL_83;
      }
      return 0;
    }
    while (1) {
      if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v73, v58, v4, 0))
        return 0;
      v58 = v75;
      v4 = v76;
      if (v76 <= 7) {
        v40 = 1;
        goto LABEL_72;
      }
      v38 = (unsigned __int8)(v75 >> (v76 - 8));
      v39 = *(_DWORD *)(v61 + 4 * v38 + 144);
      if (!v39)
        goto LABEL_71;
    LABEL_89:
      v4 -= v39;
      v50 = *(unsigned __int8 *)(v38 + v61 + 1168);
      v47 = v50 >> 4;
      v48 = v50 & 0xF;
      if ((v50 & 0xF) != 0)
        goto LABEL_82;
    LABEL_90:
      if (v47 != 15)
        break;
      v49 = v71 + 15;
    LABEL_84:
      v71 = v49 + 1;
      if (v49 + 1 > 63)
        break;
      if (v4 > 7)
        goto LABEL_70;
    }
  LABEL_51:
    v35 = v64++;
    v65 += 4;
    ++v66;
  } while (v35 < a1[82]);
  v3 = (int *)a1[8];
LABEL_53:
  *v3 = v73;
  *(_DWORD *)(a1[8] + 4) = v74;
  *(_DWORD *)(v67 + 12) = v58;
  *(_DWORD *)(v67 + 16) = v4;
  *(_DWORD *)(v67 + 20) = v78;
  *(_DWORD *)(v67 + 24) = v79;
  *(_DWORD *)(v67 + 28) = v80;
  *(_DWORD *)(v67 + 32) = v81;
  v2 = v67;
LABEL_54:
  --*(_DWORD *)(v2 + 36);
  return 1;
}

_DWORD *__cdecl start_pass(_DWORD *a1) {
  _DWORD *result;                              // eax
  int v2;                                      // eax
  int(__cdecl * v3)(int, int, int, int, int);  // edx
  int v4;                                      // esi
  unsigned __int16 *v5;                        // edx
  int j;                                       // ecx
  int v7;                                      // eax
  unsigned __int16 *v8;                        // ecx
  int v9;                                      // esi
  __int16 *v10;                                // edi
  float *v11;                                  // edi
  double *i;                                   // esi
  unsigned __int16 *v13;                       // ecx
  float *v14;                                  // edx
  double v15;                                  // xmm1_8
  float v16;                                   // xmm0_4
  int v17;                                     // [esp+18h] [ebp-40h]
  int v18;                                     // [esp+1Ch] [ebp-3Ch]
  int v19;                                     // [esp+20h] [ebp-38h]
  int v20;                                     // [esp+24h] [ebp-34h]
  int(__cdecl * v21)(int, int, int, int, int); // [esp+28h] [ebp-30h]
  unsigned __int16 *v22;                       // [esp+2Ch] [ebp-2Ch]
  int v23;                                     // [esp+30h] [ebp-28h]
  double *v24;                                 // [esp+38h] [ebp-20h]
  int v25;                                     // [esp+3Ch] [ebp-1Ch]

  result = (_DWORD *)a1[105];
  v19 = a1[51];
  if ((int)a1[11] > 0) {
    v25 = a1[105];
    v20 = 0;
    v21 = 0;
    v17 = 0;
    while (1) {
      v2 = *(_DWORD *)(v19 + 36);
      if (v2 == 2) {
        v20 = 0;
        v21 = jpeg_idct_2x2;
        v3 = jpeg_idct_2x2;
      } else if (v2 > 2) {
        if (v2 != 4) {
          if (v2 == 8) {
            v7 = a1[19];
            if (v7 == 1) {
              v20 = 1;
              v21 = jpeg_idct_ifast;
              v3 = jpeg_idct_ifast;
            } else if (v7) {
              if (v7 == 2) {
                v20 = 2;
                v3 = jpeg_idct_float;
                v21 = jpeg_idct_float;
              } else {
                *(_DWORD *)(*a1 + 20) = 48;
                (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
                v3 = v21;
              }
            } else {
              v20 = 0;
              v21 = jpeg_idct_islow;
              v3 = jpeg_idct_islow;
            }
            goto LABEL_7;
          }
        LABEL_6:
          *(_DWORD *)(*a1 + 20) = 7;
          *(_DWORD *)(*a1 + 24) = *(_DWORD *)(v19 + 36);
          (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
          v3 = v21;
          goto LABEL_7;
        }
        v20 = 0;
        v3 = jpeg_idct_4x4;
        v21 = jpeg_idct_4x4;
      } else {
        if (v2 != 1)
          goto LABEL_6;
        v20 = 0;
        v21 = jpeg_idct_1x1;
        v3 = jpeg_idct_1x1;
      }
    LABEL_7:
      *(_DWORD *)(v25 + 4) = v3;
      if (*(_BYTE *)(v19 + 48) && v20 != *(_DWORD *)(v25 + 44) &&
          (v22 = *(unsigned __int16 **)(v19 + 76)) != 0) {
        *(_DWORD *)(v25 + 44) = v20;
        if (v20 != 1) {
          if (v20 == 2) {
            v11 = *(float **)(v19 + 80);
            v18 = 0;
            v24 = (double *)&aanscalefactor_3704;
            for (i = (double *)&aanscalefactor_3704;;
                 i = (double *)&aanscalefactor_3704) {
              v13 = &v22[v18];
              v14 = v11;
              v15 = *v24;
              do {
                v16 = (double)*v13 * v15 * *i;
                *v14 = v16;
                ++v13;
                ++i;
                ++v14;
              } while (&aanscales_3696 != (_UNKNOWN *)i);
              v18 += 8;
              v11 += 8;
              ++v24;
              if (v18 == 64)
                break;
            }
          } else {
            v4 = *(_DWORD *)(v19 + 80);
            v5 = v22;
            for (j = 1; j != 65; ++j)
              *(_DWORD *)(v4 + 4 * j - 4) = *v5++;
          }
          goto LABEL_14;
        }
        v23 = *(_DWORD *)(v19 + 80);
        v8 = v22;
        v9 = 1;
        v10 = (__int16 *)&aanscales_3696;
        do
          *(_DWORD *)(v23 + 4 * v9++ - 4) = (*v10++ * *v8++ + 2048) >> 12;
        while (v9 != 65);
        ++v17;
        v19 += 84;
        v25 += 4;
        result = a1;
        if (v17 >= a1[11])
          return result;
      } else {
      LABEL_14:
        ++v17;
        v19 += 84;
        v25 += 4;
        result = a1;
        if (v17 >= a1[11])
          return result;
      }
    }
  }
  return result;
}

int __cdecl jinit_inverse_dct(int a1) {
  _DWORD *v1; // edx
  int result; // eax
  int v3;     // edi
  _DWORD *v4; // esi
  int i;      // edx
  void *v6;   // eax
  int v7;     // [esp+1Ch] [ebp-1Ch]

  v1 = (_DWORD *)(**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 84);
  *(_DWORD *)(a1 + 420) = v1;
  *v1 = start_pass;
  result = a1;
  v3 = *(_DWORD *)(a1 + 204);
  if (*(int *)(a1 + 44) > 0) {
    v4 = v1;
    v7 = 0;
    for (i = a1;; i = a1) {
      v6 = (void *)(**(int(__cdecl ***)(int, int, int))(i + 4))(i, 1, 256);
      *(_DWORD *)(v3 + 80) = v6;
      memset(v6, 0, 0x100u);
      v4[11] = -1;
      ++v7;
      v3 += 84;
      ++v4;
      result = a1;
      if (*(_DWORD *)(a1 + 44) <= v7)
        break;
    }
  }
  return result;
}

int __cdecl start_pass_merged_upsample(int a1) {
  int v1;     // edx
  int result; // eax

  v1 = *(_DWORD *)(a1 + 424);
  *(_BYTE *)(v1 + 36) = 0;
  result = *(_DWORD *)(a1 + 104);
  *(_DWORD *)(v1 + 44) = result;
  return result;
}

_DWORD *__cdecl merged_2v_upsample(int a1, int a2, _DWORD *a3, int a4, int a5,
                                   _DWORD *a6, int a7) {
  int v7;          // esi
  unsigned int v8; // edi
  int v9;          // edx
  _DWORD *result;  // eax
  int v11;         // [esp+28h] [ebp-10h] BYREF
  int v12;         // [esp+2Ch] [ebp-Ch]

  v7 = *(_DWORD *)(a1 + 424);
  if (*(_BYTE *)(v7 + 36)) {
    jcopy_sample_rows(v7 + 32, 0, a5 + 4 * *a6, 0, 1, *(_DWORD *)(v7 + 40));
    *(_BYTE *)(v7 + 36) = 0;
    v8 = 1;
  } else {
    v8 = *(_DWORD *)(v7 + 44);
    if (v8 >= 2)
      v8 = 2;
    v9 = *a6;
    if (v8 > a7 - *a6)
      v8 = a7 - *a6;
    v11 = *(_DWORD *)(a5 + 4 * v9);
    if (v8 <= 1) {
      v12 = *(_DWORD *)(v7 + 32);
      *(_BYTE *)(v7 + 36) = 1;
    } else {
      v12 = *(_DWORD *)(a5 + 4 * v9 + 4);
    }
    (*(void(__cdecl **)(int, int, _DWORD, int *))(v7 + 12))(a1, a2, *a3, &v11);
  }
  result = a6;
  *a6 += v8;
  *(_DWORD *)(v7 + 44) -= v8;
  if (!*(_BYTE *)(v7 + 36))
    ++*a3;
  return result;
}

int __cdecl merged_1v_upsample(int a1, int a2, _DWORD *a3, int a4, int a5,
                               _DWORD *a6) {
  int result; // eax

  result = (*(int(__cdecl **)(int, int, _DWORD, int))(
      *(_DWORD *)(a1 + 424) + 12))(a1, a2, *a3, a5 + 4 * *a6);
  ++*a6;
  ++*a3;
  return result;
}

unsigned int __cdecl h2v1_merged_upsample(_DWORD *a1, _DWORD *a2, int a3,
                                          _BYTE **a4) {
  _DWORD *v4;           // eax
  unsigned int result;  // eax
  int v6;               // ecx
  int v7;               // edx
  int v8;               // eax
  int v9;               // edi
  int v10;              // esi
  unsigned __int8 *i;   // edx
  int v12;              // ecx
  int v13;              // eax
  int v14;              // edx
  int v15;              // esi
  int v16;              // edx
  int v17;              // ecx
  int v18;              // [esp+0h] [ebp-38h]
  int v19;              // [esp+4h] [ebp-34h]
  int v20;              // [esp+8h] [ebp-30h]
  _BYTE *v21;           // [esp+Ch] [ebp-2Ch]
  unsigned __int8 *v22; // [esp+10h] [ebp-28h]
  unsigned __int8 *v23; // [esp+14h] [ebp-24h]
  int v24;              // [esp+18h] [ebp-20h]
  int v25;              // [esp+1Ch] [ebp-1Ch]
  int v26;              // [esp+20h] [ebp-18h]
  int v27;              // [esp+24h] [ebp-14h]
  int v28;              // [esp+28h] [ebp-10h]
  unsigned __int8 *v29; // [esp+2Ch] [ebp-Ch]

  v4 = (_DWORD *)a1[106];
  v24 = a1[74];
  v25 = v4[4];
  v26 = v4[5];
  v27 = v4[6];
  v28 = v4[7];
  v22 = *(unsigned __int8 **)(*a2 + 4 * a3);
  v23 = *(unsigned __int8 **)(4 * a3 + a2[2]);
  v21 = *a4;
  result = a1[25];
  if (result >> 1) {
    v19 = *(_DWORD *)(4 * a3 + a2[1]) + (result >> 1);
    for (i = *(unsigned __int8 **)(4 * a3 + a2[1]);; i = v29) {
      v29 = i + 1;
      v12 = *v23++;
      v12 *= 4;
      v13 = 4 * *i;
      v14 = (*(_DWORD *)(v27 + v12) + *(_DWORD *)(v28 + v13)) >> 16;
      v18 = *(_DWORD *)(v26 + v13);
      v15 = *v22;
      v20 = *(_DWORD *)(v25 + v12) + v24;
      v21[2] = *(_BYTE *)(v20 + v15);
      v16 = v24 + v14;
      v21[1] = *(_BYTE *)(v16 + v15);
      *v21 = *(_BYTE *)(v24 + v18 + v15);
      v17 = v22[1];
      v22 += 2;
      v21[5] = *(_BYTE *)(v20 + v17);
      v21[4] = *(_BYTE *)(v16 + v17);
      v21[3] = *(_BYTE *)(v24 + v18 + v17);
      v21 += 6;
      if (v29 == (unsigned __int8 *)v19)
        break;
    }
    result = a1[25];
  } else {
    v29 = *(unsigned __int8 **)(4 * a3 + a2[1]);
  }
  if ((result & 1) != 0) {
    v6 = 4 * *v23;
    v7 = 4 * *v29;
    v8 = (*(_DWORD *)(v27 + v6) + *(_DWORD *)(v28 + v7)) >> 16;
    v9 = *(_DWORD *)(v26 + v7);
    v10 = *v22;
    v21[2] = *(_BYTE *)(v24 + *(_DWORD *)(v25 + v6) + v10);
    v21[1] = *(_BYTE *)(v24 + v8 + v10);
    result = *(unsigned __int8 *)(v24 + v9 + v10);
    *v21 = result;
  }
  return result;
}

unsigned int __cdecl h2v2_merged_upsample(_DWORD *a1, _DWORD *a2, int a3,
                                          int a4) {
  _DWORD *v4;           // eax
  unsigned __int8 *v5;  // edx
  unsigned int result;  // eax
  unsigned __int8 *i;   // ecx
  int v8;               // eax
  int v9;               // edx
  int v10;              // esi
  int v11;              // ecx
  int v12;              // esi
  int v13;              // edx
  int v14;              // edx
  int v15;              // edx
  int v16;              // edx
  int v17;              // eax
  int v18;              // ecx
  int v19;              // esi
  int v20;              // ecx
  int v21;              // edx
  int v22;              // [esp+4h] [ebp-44h]
  int v23;              // [esp+4h] [ebp-44h]
  unsigned __int8 *v24; // [esp+8h] [ebp-40h]
  int v25;              // [esp+Ch] [ebp-3Ch]
  int v26;              // [esp+10h] [ebp-38h]
  _BYTE *v27;           // [esp+14h] [ebp-34h]
  _BYTE *v28;           // [esp+18h] [ebp-30h]
  unsigned __int8 *v29; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *v30; // [esp+20h] [ebp-28h]
  unsigned __int8 *v31; // [esp+24h] [ebp-24h]
  int v32;              // [esp+28h] [ebp-20h]
  int v33;              // [esp+2Ch] [ebp-1Ch]
  int v34;              // [esp+30h] [ebp-18h]
  int v35;              // [esp+34h] [ebp-14h]
  int v36;              // [esp+38h] [ebp-10h]
  unsigned __int8 *v37; // [esp+3Ch] [ebp-Ch]

  v4 = (_DWORD *)a1[106];
  v32 = a1[74];
  v33 = v4[4];
  v34 = v4[5];
  v35 = v4[6];
  v36 = v4[7];
  v29 = *(unsigned __int8 **)(*a2 + 8 * a3);
  v30 = *(unsigned __int8 **)(*a2 + 8 * a3 + 4);
  v31 = *(unsigned __int8 **)(a2[1] + 4 * a3);
  v5 = *(unsigned __int8 **)(4 * a3 + a2[2]);
  v27 = *(_BYTE **)a4;
  v28 = *(_BYTE **)(a4 + 4);
  result = a1[25];
  if (result >> 1) {
    v24 = &v5[result >> 1];
    for (i = *(unsigned __int8 **)(4 * a3 + a2[2]);; i = v37) {
      v8 = *v31++;
      v37 = i + 1;
      v9 = 4 * *i;
      v8 *= 4;
      v10 = (*(_DWORD *)(v35 + v9) + *(_DWORD *)(v36 + v8)) >> 16;
      v22 = *(_DWORD *)(v34 + v8);
      v11 = *v29;
      v26 = *(_DWORD *)(v33 + v9) + v32;
      v27[2] = *(_BYTE *)(v26 + v11);
      v12 = v32 + v10;
      v27[1] = *(_BYTE *)(v12 + v11);
      *v27 = *(_BYTE *)(v32 + v22 + v11);
      v13 = v29[1];
      v29 += 2;
      v27[5] = *(_BYTE *)(v26 + v13);
      v27[4] = *(_BYTE *)(v12 + v13);
      v27[3] = *(_BYTE *)(v32 + v22 + v13);
      v27 += 6;
      v14 = *v30;
      v28[2] = *(_BYTE *)(v26 + v14);
      v28[1] = *(_BYTE *)(v12 + v14);
      *v28 = *(_BYTE *)(v32 + v22 + v14);
      v15 = v30[1];
      v30 += 2;
      v28[5] = *(_BYTE *)(v26 + v15);
      v28[4] = *(_BYTE *)(v12 + v15);
      v28[3] = *(_BYTE *)(v32 + v22 + v15);
      v28 += 6;
      if (v37 == v24)
        break;
    }
    v5 = v37;
    result = a1[25];
  }
  if ((result & 1) != 0) {
    v16 = 4 * *v5;
    v17 = 4 * *v31;
    v18 = (*(_DWORD *)(v35 + v16) + *(_DWORD *)(v36 + v17)) >> 16;
    v23 = *(_DWORD *)(v34 + v17);
    v19 = *v29;
    v25 = *(_DWORD *)(v33 + v16) + v32;
    v27[2] = *(_BYTE *)(v25 + v19);
    v20 = v32 + v18;
    v27[1] = *(_BYTE *)(v20 + v19);
    *v27 = *(_BYTE *)(v32 + v23 + v19);
    v21 = *v30;
    v28[2] = *(_BYTE *)(v25 + v21);
    v28[1] = *(_BYTE *)(v20 + v21);
    result = *(unsigned __int8 *)(v32 + v23 + v21);
    *v28 = result;
  }
  return result;
}

int __cdecl jinit_merged_upsampler(int a1) {
  int v1;     // esi
  int v2;     // edx
  _DWORD *v3; // esi
  int v4;     // ecx
  char *v5;   // edi
  int result; // eax
  int v7;     // [esp+14h] [ebp-24h]
  int v8;     // [esp+18h] [ebp-20h]
  char *v9;   // [esp+1Ch] [ebp-1Ch]

  v1 = (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 48);
  *(_DWORD *)(a1 + 424) = v1;
  *(_DWORD *)v1 = start_pass_merged_upsample;
  *(_BYTE *)(v1 + 8) = 0;
  v2 = *(_DWORD *)(a1 + 108) * *(_DWORD *)(a1 + 100);
  *(_DWORD *)(v1 + 40) = v2;
  if (*(_DWORD *)(a1 + 284) == 2) {
    *(_DWORD *)(v1 + 4) = merged_2v_upsample;
    *(_DWORD *)(v1 + 12) = h2v2_merged_upsample;
    *(_DWORD *)(v1 + 32) =
        (*(int(__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1, v2);
  } else {
    *(_DWORD *)(v1 + 4) = merged_1v_upsample;
    *(_DWORD *)(v1 + 12) = h2v1_merged_upsample;
    *(_DWORD *)(v1 + 32) = 0;
  }
  v3 = *(_DWORD **)(a1 + 424);
  v3[4] = (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v3[5] = (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v3[6] = (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v3[7] = (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v4 = 0;
  v7 = -11728000;
  v8 = -14831872;
  v9 = (char *)&unk_5B6900;
  v5 = (char *)&FS_CreatePath(.eh);
  do {
    *(_DWORD *)(v3[4] + v4) = v7 >> 16;
    *(_DWORD *)(v3[5] + v4) = v8 >> 16;
    *(_DWORD *)(v3[6] + v4) = v9;
    result = v3[7];
    *(_DWORD *)(result + v4) = v5;
    v4 += 4;
    v7 += 91881;
    v8 += 116130;
    v9 -= 46802;
    v5 -= 22554;
  } while (v4 != 1024);
  return result;
}

int __cdecl start_pass_phuff_decoder(int *a1) {
  int v1;           // eax
  bool v2;          // dl
  int *v3;          // ecx
  int v4;           // eax
  int *v5;          // eax
  int *v6;          // edx
  int *v7;          // ecx
  int *v8;          // esi
  int v9;           // edi
  int *v10;         // esi
  int v11;          // eax
  int *v12;         // edx
  int result;       // eax
  void *v14;        // eax
  int v15;          // edi
  int v16;          // edx
  int *v17;         // ecx
  unsigned int v18; // esi
  int *v19;         // edx
  int v20;          // edx
  int *v21;         // edi
  int v22;          // esi
  int v23;          // [esp+20h] [ebp-38h]
  bool v24;         // [esp+27h] [ebp-31h]
  int v25;          // [esp+28h] [ebp-30h]
  int v26;          // [esp+2Ch] [ebp-2Ch]
  int *v27;         // [esp+30h] [ebp-28h]
  int *v28;         // [esp+34h] [ebp-24h]
  int v29;          // [esp+38h] [ebp-20h]
  int v30;          // [esp+3Ch] [ebp-1Ch]

  v23 = a1[104];
  v1 = a1[93];
  v24 = v1 == 0;
  if (v1) {
    v20 = a1[94];
    v2 = v1 > v20 || v20 > 63;
    if (a1[75] != 1)
      goto LABEL_3;
    v3 = a1;
  } else {
    if (a1[94]) {
    LABEL_3:
      v2 = 1;
      v3 = a1;
      goto LABEL_4;
    }
    v2 = 0;
    v3 = a1;
  }
LABEL_4:
  v4 = v3[95];
  if (v4) {
    if (v3[96] != v4 - 1)
      v2 = 1;
    v5 = a1;
    if (a1[96] <= 13)
      goto LABEL_8;
  LABEL_40:
    v19 = v5;
    goto LABEL_46;
  }
  v5 = v3;
  if (v3[96] > 13)
    goto LABEL_40;
LABEL_8:
  if (!v2)
    goto LABEL_9;
  v19 = a1;
LABEL_46:
  *(_DWORD *)(*v19 + 20) = 16;
  *(_DWORD *)(*a1 + 24) = a1[93];
  *(_DWORD *)(*a1 + 28) = a1[94];
  *(_DWORD *)(*a1 + 32) = a1[95];
  *(_DWORD *)(*a1 + 36) = a1[96];
  (*(void(__cdecl **)(int *)) * a1)(a1);
LABEL_9:
  if (a1[75] <= 0) {
    if (a1[95]) {
    LABEL_30:
      if (v24)
        v14 = decode_mcu_DC_refine;
      else
        v14 = decode_mcu_AC_refine;
      *(_DWORD *)(v23 + 4) = v14;
      goto LABEL_33;
    }
  } else {
    v28 = a1;
    v25 = 0;
    v6 = a1;
    v7 = a1;
    while (1) {
      v26 = *(_DWORD *)(v6[76] + 4);
      v8 = (int *)(v7[37] + (v26 << 8));
      if (!v24) {
        if (*v8 < 0) {
          *(_DWORD *)(*v7 + 20) = 115;
          *(_DWORD *)(*v7 + 24) = v26;
          *(_DWORD *)(*v7 + 28) = 0;
          (*(void(__cdecl **)(int *, int))(*v7 + 4))(v7, -1);
        }
        v7 = a1;
      }
      v9 = v7[93];
      if (v9 <= v7[94]) {
        v10 = &v8[v9];
        do {
          v11 = *v10;
          if (*v10 < 0)
            v11 = 0;
          v12 = a1;
          if (v11 != a1[95]) {
            *(_DWORD *)(*a1 + 20) = 115;
            *(_DWORD *)(*a1 + 24) = v26;
            *(_DWORD *)(*a1 + 28) = v9;
            (*(void(__cdecl **)(int *, int))(*a1 + 4))(a1, -1);
            v12 = a1;
          }
          *v10 = v12[96];
          ++v9;
          ++v10;
        } while (v9 <= v12[94]);
        v7 = a1;
      }
      ++v25;
      ++v28;
      if (v25 >= v7[75])
        break;
      v6 = v28;
    }
    if (v7[95])
      goto LABEL_30;
  }
  if (!v24) {
    *(_DWORD *)(v23 + 4) = decode_mcu_AC_first;
    if (a1[75] <= 0)
      goto LABEL_28;
    goto LABEL_34;
  }
  *(_DWORD *)(v23 + 4) = decode_mcu_DC_first;
LABEL_33:
  if (a1[75] <= 0)
    goto LABEL_28;
LABEL_34:
  if (v24) {
    v21 = a1;
    v22 = v23;
    v29 = 0;
    do {
      if (!a1[95])
        jpeg_make_d_derived_tbl(
            (int(__cdecl ***)(_DWORD, _DWORD, _DWORD))a1, 1,
            *(_DWORD *)(v21[76] + 20),
            (int *)(v23 + 4 * *(_DWORD *)(v21[76] + 20) + 44));
      *(_DWORD *)(v22 + 24) = 0;
      ++v29;
      ++v21;
      v22 += 4;
    } while (v29 < a1[75]);
  } else {
    v27 = a1;
    v15 = v23;
    v30 = 0;
    v16 = v23 + 44;
    v17 = a1;
    while (1) {
      v18 = *(_DWORD *)(v17[76] + 24);
      jpeg_make_d_derived_tbl((int(__cdecl ***)(_DWORD, _DWORD, _DWORD))a1, 0,
                              v18, (int *)(v16 + 4 * v18));
      *(_DWORD *)(v23 + 60) = *(_DWORD *)(v23 + 4 * v18 + 44);
      *(_DWORD *)(v15 + 24) = 0;
      ++v30;
      ++v27;
      v15 += 4;
      if (v30 >= a1[75])
        break;
      v17 = v27;
      v16 = v23 + 44;
    }
  }
LABEL_28:
  *(_DWORD *)(v23 + 16) = 0;
  *(_DWORD *)(v23 + 12) = 0;
  *(_BYTE *)(v23 + 8) = 0;
  *(_DWORD *)(v23 + 20) = 0;
  result = a1[65];
  *(_DWORD *)(v23 + 40) = result;
  return result;
}

int __cdecl decode_mcu_AC_refine(_DWORD *a1, int *a2) {
  int v2;         // eax
  int v3;         // ecx
  int v4;         // edi
  int v5;         // eax
  int *v7;        // edx
  _DWORD *v8;     // esi
  __int16 *v9;    // edi
  int v10;        // eax
  __int16 v11;    // dx
  char v12;       // cl
  int v13;        // eax
  int v14;        // edx
  int v15;        // eax
  int v16;        // eax
  int v17;        // eax
  int v18;        // eax
  _DWORD *v19;    // edi
  int v20;        // eax
  __int16 v21;    // dx
  __int16 *v22;   // esi
  int v23;        // eax
  int v24;        // eax
  int v25;        // edx
  int v26;        // eax
  int v27;        // ecx
  _DWORD *v28;    // edx
  int v29;        // [esp+2Ch] [ebp-16Ch]
  int v30;        // [esp+30h] [ebp-168h]
  int v31;        // [esp+34h] [ebp-164h]
  int v32;        // [esp+38h] [ebp-160h]
  int v33;        // [esp+3Ch] [ebp-15Ch]
  int v34;        // [esp+40h] [ebp-158h]
  int v35;        // [esp+44h] [ebp-154h]
  int v36;        // [esp+48h] [ebp-150h]
  int v37;        // [esp+4Ch] [ebp-14Ch]
  int v38;        // [esp+50h] [ebp-148h]
  int v39;        // [esp+54h] [ebp-144h]
  int v40;        // [esp+58h] [ebp-140h]
  int v41;        // [esp+5Ch] [ebp-13Ch]
  _DWORD v42[64]; // [esp+6Ch] [ebp-12Ch] BYREF
  int v43;        // [esp+16Ch] [ebp-2Ch] BYREF
  int v44;        // [esp+170h] [ebp-28h]
  int v45;        // [esp+174h] [ebp-24h]
  int v46;        // [esp+178h] [ebp-20h]
  _DWORD *v47;    // [esp+17Ch] [ebp-1Ch]

  v2 = a1[104];
  v41 = v2;
  v29 = a1[94];
  v3 = a1[96];
  v30 = 1 << v3;
  v31 = -1 << v3;
  if (a1[65]) {
    if (*(_DWORD *)(v2 + 40))
      goto LABEL_3;
    v24 = *(_DWORD *)(v2 + 16);
    if (v24 <= -1)
      v24 += 7;
    *(_DWORD *)(a1[103] + 20) += v24 >> 3;
    *(_DWORD *)(v41 + 16) = 0;
    if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(a1[103] + 8))(a1))
      return 0;
    if ((int)a1[75] > 0) {
      v25 = v41;
      v26 = 0;
      do {
        *(_DWORD *)(v25 + 24) = 0;
        ++v26;
        v25 += 4;
      } while (v26 < a1[75]);
    }
    *(_DWORD *)(v41 + 20) = 0;
    *(_DWORD *)(v41 + 40) = a1[65];
    if (a1[97]) {
    LABEL_3:
      v4 = v41;
      if (*(_BYTE *)(v41 + 8)) {
      LABEL_4:
        v5 = v4;
        goto LABEL_5;
      }
      goto LABEL_8;
    }
    *(_BYTE *)(v41 + 8) = 0;
    v4 = v41;
  } else {
    v4 = a1[104];
  }
  if (*(_BYTE *)(v4 + 8))
    goto LABEL_4;
LABEL_8:
  v47 = a1;
  v7 = (int *)a1[8];
  v43 = *v7;
  v44 = v7[1];
  v36 = *(_DWORD *)(v4 + 12);
  v37 = *(_DWORD *)(v4 + 16);
  v34 = *(_DWORD *)(v41 + 20);
  v35 = *a2;
  v38 = *(_DWORD *)(v41 + 60);
  v32 = a1[93];
  if (v34) {
    v39 = 0;
  LABEL_10:
    if (v29 >= v32) {
      v8 = &jpeg_natural_order[v32];
      do {
        v9 = (__int16 *)(v35 + 2 * *v8);
        if (*v9) {
          if (v37 <= 0) {
            if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v43, v36, v37, 1))
              goto LABEL_71;
            v36 = v45;
            v37 = v46;
            v10 = v45;
          } else {
            v10 = v36;
          }
          if (((v10 >> --v37) & 1) != 0) {
            v11 = *v9;
            if ((*v9 & v30) == 0) {
              if (v11 < 0)
                *v9 = v11 + v31;
              else
                *v9 = v11 + v30;
            }
          }
        }
        ++v32;
        ++v8;
      } while (v29 >= v32);
    }
    --v34;
    v7 = (int *)a1[8];
    goto LABEL_21;
  }
  if (v29 < a1[93])
    goto LABEL_51;
  v39 = 0;
  do {
    if (v37 <= 7) {
      if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v43, v36, v37, 0))
        goto LABEL_71;
      v36 = v45;
      v37 = v46;
      if (v46 <= 7) {
        v15 = 1;
        goto LABEL_28;
      }
      v12 = v46;
    } else {
      v12 = v37;
    }
    v13 = (unsigned __int8)(v36 >> (v12 - 8));
    v14 = *(_DWORD *)(v38 + 4 * v13 + 144);
    if (v14) {
      v37 -= v14;
      v16 = *(unsigned __int8 *)(v13 + v38 + 1168);
      goto LABEL_30;
    }
    v15 = 9;
  LABEL_28:
    v16 = jpeg_huff_decode((int)&v43, v36, v37, v38, v15);
    if (v16 < 0)
      goto LABEL_71;
    v36 = v45;
    v37 = v46;
  LABEL_30:
    v33 = v16 >> 4;
    v17 = v16 & 0xF;
    if (v17) {
      if (v17 != 1) {
        *(_DWORD *)(*a1 + 20) = 118;
        (*(void(__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
      }
      if (v37 <= 0) {
        if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v43, v36, v37, 1))
          goto LABEL_71;
        v36 = v45;
        v37 = v46;
        v18 = v45;
      } else {
        v18 = v36;
      }
      if (((v18 >> --v37) & 1) != 0)
        v40 = v30;
      else
        v40 = v31;
      goto LABEL_37;
    }
    if (v33 != 15) {
      v34 = 1 << v33;
      if (!v33)
        goto LABEL_83;
      if (v33 <= v37)
        goto LABEL_82;
      if ((unsigned __int8)jpeg_fill_bit_buffer((int)&v43, v36, v37, v33)) {
        v36 = v45;
        v37 = v46;
      LABEL_82:
        v37 -= v33;
        v34 += (v34 - 1) & (v36 >> v37);
      LABEL_83:
        if (!v34) {
          v7 = (int *)a1[8];
          goto LABEL_21;
        }
        goto LABEL_10;
      }
    LABEL_71:
      if (v39 > 0) {
        v27 = 0;
        v28 = &v42[v39];
        do {
          *(_WORD *)(v35 + 2 * *(v28 - 1)) = 0;
          ++v27;
          --v28;
        } while (v39 != v27);
      }
      return 0;
    }
    v40 = 0;
  LABEL_37:
    v19 = &jpeg_natural_order[v32];
    do {
      v22 = (__int16 *)(v35 + 2 * *v19);
      if (*v22) {
        if (v37 <= 0) {
          if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v43, v36, v37, 1))
            goto LABEL_71;
          v36 = v45;
          v37 = v46;
          v20 = v45;
        } else {
          v20 = v36;
        }
        if (((v20 >> --v37) & 1) != 0) {
          v21 = *v22;
          if ((*v22 & v30) == 0) {
            if (v21 < 0)
              *v22 = v21 + v31;
            else
              *v22 = v21 + v30;
          }
        }
        goto LABEL_44;
      }
      if (--v33 < 0)
        break;
    LABEL_44:
      ++v32;
      ++v19;
    } while (v29 >= v32);
    if (v40) {
      v23 = jpeg_natural_order[v32];
      *(_WORD *)(v35 + 2 * v23) = v40;
      v42[v39++] = v23;
    }
    ++v32;
  } while (v29 >= v32);
  v7 = (int *)a1[8];
LABEL_51:
  v34 = 0;
LABEL_21:
  *v7 = v43;
  *(_DWORD *)(a1[8] + 4) = v44;
  *(_DWORD *)(v41 + 12) = v36;
  *(_DWORD *)(v41 + 16) = v37;
  *(_DWORD *)(v41 + 20) = v34;
  v5 = v41;
LABEL_5:
  --*(_DWORD *)(v5 + 40);
  return 1;
}

int __cdecl jinit_phuff_decoder(int a1) {
  int(__cdecl * *v1)(int *); // eax
  int v2;                    // edx
  int result;                // eax
  int v4;                    // esi
  _DWORD *v5;                // edx
  int v6;                    // ecx

  v1 = (int(__cdecl **)(int *))(**(int(__cdecl ***)(int, int, int))(a1 + 4))(
      a1, 1, 64);
  *(_DWORD *)(a1 + 416) = v1;
  *v1 = start_pass_phuff_decoder;
  v2 = 4;
  do {
    v1[11] = 0;
    ++v1;
    --v2;
  } while (v2);
  result = (**(int(__cdecl ***)(int, int, _DWORD))(a1 + 4))(
      a1, 1, *(_DWORD *)(a1 + 44) << 8);
  *(_DWORD *)(a1 + 148) = result;
  if (*(int *)(a1 + 44) > 0) {
    v4 = 0;
    do {
      v5 = (_DWORD *)result;
      v6 = 64;
      do {
        *v5++ = -1;
        --v6;
      } while (v6);
      ++v4;
      result += 256;
    } while (v4 < *(_DWORD *)(a1 + 44));
  }
  return result;
}

int __cdecl decode_mcu_DC_first(_DWORD *a1, int a2) {
  int v2;      // eax
  int *v3;     // edx
  int v4;      // edi
  int v5;      // esi
  int v6;      // eax
  int v7;      // eax
  int v8;      // edx
  int v9;      // eax
  int v10;     // esi
  int v11;     // edx
  int v12;     // edx
  int v13;     // eax
  int v14;     // eax
  int v16;     // eax
  int v17;     // edx
  int v18;     // eax
  int *v19;    // [esp+20h] [ebp-68h]
  int v20;     // [esp+28h] [ebp-60h]
  int v21;     // [esp+2Ch] [ebp-5Ch]
  int v22;     // [esp+30h] [ebp-58h]
  _WORD *v23;  // [esp+34h] [ebp-54h]
  int v24;     // [esp+38h] [ebp-50h]
  int v25;     // [esp+3Ch] [ebp-4Ch]
  int v26;     // [esp+48h] [ebp-40h]
  int v27;     // [esp+4Ch] [ebp-3Ch]
  int v28;     // [esp+50h] [ebp-38h]
  int v29;     // [esp+54h] [ebp-34h]
  int v30;     // [esp+58h] [ebp-30h]
  int v31;     // [esp+5Ch] [ebp-2Ch] BYREF
  int v32;     // [esp+60h] [ebp-28h]
  int v33;     // [esp+64h] [ebp-24h]
  int v34;     // [esp+68h] [ebp-20h]
  _DWORD *v35; // [esp+6Ch] [ebp-1Ch]

  v2 = a1[104];
  v20 = v2;
  v21 = a1[96];
  if (a1[65]) {
    if (*(_DWORD *)(v2 + 40))
      goto LABEL_3;
    v16 = *(_DWORD *)(v2 + 16);
    if (v16 <= -1)
      v16 += 7;
    *(_DWORD *)(a1[103] + 20) += v16 >> 3;
    *(_DWORD *)(v20 + 16) = 0;
    if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(a1[103] + 8))(a1))
      return 0;
    if ((int)a1[75] > 0) {
      v17 = v20;
      v18 = 0;
      do {
        *(_DWORD *)(v17 + 24) = 0;
        ++v18;
        v17 += 4;
      } while (v18 < a1[75]);
    }
    *(_DWORD *)(v20 + 20) = 0;
    *(_DWORD *)(v20 + 40) = a1[65];
    if (a1[97]) {
    LABEL_3:
      v2 = v20;
    } else {
      *(_BYTE *)(v20 + 8) = 0;
      v2 = v20;
    }
  }
  if (*(_BYTE *)(v2 + 8))
    goto LABEL_22;
  v35 = a1;
  v3 = (int *)a1[8];
  v31 = *v3;
  v32 = v3[1];
  v24 = *(_DWORD *)(v20 + 12);
  v4 = *(_DWORD *)(v20 + 16);
  v26 = *(_DWORD *)(v20 + 20);
  v27 = *(_DWORD *)(v20 + 24);
  v28 = *(_DWORD *)(v20 + 28);
  v29 = *(_DWORD *)(v20 + 32);
  v30 = *(_DWORD *)(v20 + 36);
  if ((int)a1[82] <= 0)
    goto LABEL_21;
  v25 = 1;
  v19 = a1 + 83;
  do {
    v23 = *(_WORD **)(a2 + 4 * v25 - 4);
    v22 = *v19;
    v5 = *(_DWORD *)(v20 + 4 * *(_DWORD *)(a1[*v19 + 76] + 20) + 44);
    if (v4 <= 7) {
      if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v31, v24, v4, 0))
        return 0;
      v24 = v33;
      v4 = v34;
      if (v34 <= 7) {
        v9 = 1;
        goto LABEL_11;
      }
      v6 = v33;
    } else {
      v6 = v24;
    }
    v7 = (unsigned __int8)(v6 >> (v4 - 8));
    v8 = *(_DWORD *)(v5 + 4 * v7 + 144);
    if (v8) {
      v4 -= v8;
      v10 = *(unsigned __int8 *)(v7 + v5 + 1168);
      goto LABEL_13;
    }
    v9 = 9;
  LABEL_11:
    v10 = jpeg_huff_decode((int)&v31, v24, v4, v5, v9);
    if (v10 < 0)
      return 0;
    v24 = v33;
    v4 = v34;
  LABEL_13:
    if (v10) {
      if (v4 < v10) {
        if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v31, v24, v4, v10))
          return 0;
        v11 = v33;
        v24 = v33;
        v4 = v34;
      } else {
        v11 = v24;
      }
      v4 -= v10;
      v12 = ((1 << v10) - 1) & (v11 >> v4);
      if (v12 < extend_test_0[v10])
        v12 += extend_offset_0[v10];
      v10 = v12;
    }
    v13 = *(&v27 + v22) + v10;
    *(&v27 + v22) = v13;
    *v23 = v13 << v21;
    v14 = v25++;
    ++v19;
  } while (v14 < a1[82]);
  v3 = (int *)a1[8];
LABEL_21:
  *v3 = v31;
  *(_DWORD *)(a1[8] + 4) = v32;
  *(_DWORD *)(v20 + 12) = v24;
  *(_DWORD *)(v20 + 16) = v4;
  *(_DWORD *)(v20 + 20) = v26;
  *(_DWORD *)(v20 + 24) = v27;
  *(_DWORD *)(v20 + 28) = v28;
  *(_DWORD *)(v20 + 32) = v29;
  *(_DWORD *)(v20 + 36) = v30;
  v2 = v20;
LABEL_22:
  --*(_DWORD *)(v2 + 40);
  return 1;
}

int __cdecl decode_mcu_AC_first(_DWORD *a1, int *a2) {
  int v2;      // eax
  int v3;      // edi
  int v4;      // eax
  int v5;      // ecx
  int v6;      // eax
  int *v8;     // edx
  int v9;      // esi
  int v10;     // edx
  int v11;     // edx
  int v12;     // eax
  int v13;     // eax
  int v14;     // eax
  int v15;     // edx
  int v16;     // eax
  int v17;     // eax
  int v18;     // edi
  int v19;     // eax
  int v20;     // edx
  int v21;     // eax
  int v22;     // edi
  int v23;     // eax
  int v24;     // [esp+2Ch] [ebp-5Ch]
  int v25;     // [esp+30h] [ebp-58h]
  int v26;     // [esp+34h] [ebp-54h]
  int v27;     // [esp+3Ch] [ebp-4Ch]
  int v28;     // [esp+40h] [ebp-48h]
  int v29;     // [esp+44h] [ebp-44h]
  int v30;     // [esp+48h] [ebp-40h]
  int v31;     // [esp+4Ch] [ebp-3Ch]
  int v32;     // [esp+5Ch] [ebp-2Ch] BYREF
  int v33;     // [esp+60h] [ebp-28h]
  int v34;     // [esp+64h] [ebp-24h]
  int v35;     // [esp+68h] [ebp-20h]
  _DWORD *v36; // [esp+6Ch] [ebp-1Ch]

  v2 = a1[104];
  v24 = v2;
  v25 = a1[94];
  v26 = a1[96];
  if (a1[65]) {
    if (*(_DWORD *)(v2 + 40))
      goto LABEL_3;
    v19 = *(_DWORD *)(v2 + 16);
    if (v19 <= -1)
      v19 += 7;
    *(_DWORD *)(a1[103] + 20) += v19 >> 3;
    *(_DWORD *)(v24 + 16) = 0;
    if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(a1[103] + 8))(a1))
      return 0;
    if ((int)a1[75] > 0) {
      v20 = v24;
      v21 = 0;
      do {
        *(_DWORD *)(v20 + 24) = 0;
        ++v21;
        v20 += 4;
      } while (v21 < a1[75]);
    }
    *(_DWORD *)(v24 + 20) = 0;
    *(_DWORD *)(v24 + 40) = a1[65];
    if (a1[97]) {
    LABEL_3:
      v3 = v24;
      if (*(_BYTE *)(v24 + 8)) {
      LABEL_10:
        v6 = v3;
        goto LABEL_7;
      }
      goto LABEL_4;
    }
    *(_BYTE *)(v24 + 8) = 0;
    v3 = v24;
  } else {
    v3 = a1[104];
  }
  if (*(_BYTE *)(v3 + 8))
    goto LABEL_10;
LABEL_4:
  v4 = *(_DWORD *)(v3 + 20);
  if (v4) {
    v5 = v4 - 1;
    goto LABEL_6;
  }
  v36 = a1;
  v8 = (int *)a1[8];
  v32 = *v8;
  v33 = v8[1];
  v28 = *(_DWORD *)(v24 + 12);
  v9 = *(_DWORD *)(v24 + 16);
  v27 = *a2;
  v29 = *(_DWORD *)(v24 + 60);
  v31 = a1[93];
  if (v25 < v31) {
  LABEL_12:
    v5 = 0;
    goto LABEL_13;
  }
  while (1) {
    if (v9 <= 7) {
      if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v32, v28, v9, 0))
        return 0;
      v28 = v34;
      v9 = v35;
      if (v35 <= 7) {
        v16 = 1;
        goto LABEL_24;
      }
      v13 = v34;
    } else {
      v13 = v28;
    }
    v14 = (unsigned __int8)(v13 >> (v9 - 8));
    v15 = *(_DWORD *)(v29 + 4 * v14 + 144);
    if (v15) {
      v9 -= v15;
      v17 = *(unsigned __int8 *)(v14 + v29 + 1168);
      goto LABEL_26;
    }
    v16 = 9;
  LABEL_24:
    v17 = jpeg_huff_decode((int)&v32, v28, v9, v29, v16);
    if (v17 < 0)
      return 0;
    v28 = v34;
    v9 = v35;
  LABEL_26:
    v30 = v17 >> 4;
    v18 = v17 & 0xF;
    if ((v17 & 0xF) != 0) {
      if (v9 < v18) {
        if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v32, v28, v9, v18))
          return 0;
        v28 = v34;
        v9 = v35;
        v10 = v34;
      } else {
        v10 = v28;
      }
      v9 -= v18;
      v11 = ((1 << v18) - 1) & (v10 >> v9);
      if (v11 < extend_test_0[v18])
        v11 += extend_offset_0[v18];
      *(_WORD *)(v27 + 2 * jpeg_natural_order[v30 + v31]) = v11 << v26;
      v12 = v30 + v31;
      goto LABEL_19;
    }
    if (v30 != 15)
      break;
    v12 = v31 + 15;
  LABEL_19:
    v31 = v12 + 1;
    if (v25 < v12 + 1) {
      v8 = (int *)a1[8];
      goto LABEL_12;
    }
  }
  v22 = 1 << v30;
  if (!v30)
    goto LABEL_50;
  if (v30 <= v9) {
    v23 = v28;
    goto LABEL_49;
  }
  if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v32, v28, v9, v30))
    return 0;
  v28 = v34;
  v9 = v35;
  v23 = v34;
LABEL_49:
  v9 -= v30;
  v22 += (v22 - 1) & (v23 >> v9);
LABEL_50:
  v5 = v22 - 1;
  v8 = (int *)a1[8];
LABEL_13:
  *v8 = v32;
  *(_DWORD *)(a1[8] + 4) = v33;
  *(_DWORD *)(v24 + 12) = v28;
  *(_DWORD *)(v24 + 16) = v9;
LABEL_6:
  *(_DWORD *)(v24 + 20) = v5;
  v6 = v24;
LABEL_7:
  --*(_DWORD *)(v6 + 40);
  return 1;
}

int __cdecl decode_mcu_DC_refine(_DWORD *a1, int a2) {
  int v2;      // eax
  _DWORD *v3;  // eax
  int *v4;     // edx
  int v5;      // edi
  int v6;      // ecx
  int v7;      // esi
  int v9;      // eax
  int v10;     // edx
  int v11;     // eax
  int v12;     // [esp+14h] [ebp-34h]
  _WORD *v13;  // [esp+18h] [ebp-30h]
  int v14;     // [esp+1Ch] [ebp-2Ch]
  int v15;     // [esp+2Ch] [ebp-1Ch] BYREF
  int v16;     // [esp+30h] [ebp-18h]
  int v17;     // [esp+34h] [ebp-14h]
  int v18;     // [esp+38h] [ebp-10h]
  _DWORD *v19; // [esp+3Ch] [ebp-Ch]

  v2 = a1[104];
  v14 = v2;
  v12 = 1 << a1[96];
  if (a1[65]) {
    if (*(_DWORD *)(v2 + 40))
      goto LABEL_3;
    v9 = *(_DWORD *)(v2 + 16);
    if (v9 <= -1)
      v9 += 7;
    *(_DWORD *)(a1[103] + 20) += v9 >> 3;
    *(_DWORD *)(v14 + 16) = 0;
    if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(a1[103] + 8))(a1))
      return 0;
    if ((int)a1[75] > 0) {
      v10 = v14;
      v11 = 0;
      do {
        *(_DWORD *)(v10 + 24) = 0;
        ++v11;
        v10 += 4;
      } while (v11 < a1[75]);
    }
    *(_DWORD *)(v14 + 20) = 0;
    *(_DWORD *)(v14 + 40) = a1[65];
    if (a1[97]) {
    LABEL_3:
      v3 = a1;
    } else {
      *(_BYTE *)(v14 + 8) = 0;
      v3 = a1;
    }
  } else {
    v3 = a1;
  }
  v19 = v3;
  v4 = (int *)v3[8];
  v15 = *v4;
  v16 = v4[1];
  v5 = *(_DWORD *)(v14 + 12);
  v6 = *(_DWORD *)(v14 + 16);
  if ((int)a1[82] > 0) {
    v7 = 0;
    do {
      v13 = *(_WORD **)(a2 + 4 * v7);
      if (v6 <= 0) {
        if (!(unsigned __int8)jpeg_fill_bit_buffer((int)&v15, v5, v6, 1))
          return 0;
        v5 = v17;
        v6 = v18;
      }
      if (((v5 >> --v6) & 1) != 0)
        *v13 |= v12;
      ++v7;
    } while (v7 < a1[82]);
    v4 = (int *)a1[8];
  }
  *v4 = v15;
  *(_DWORD *)(a1[8] + 4) = v16;
  *(_DWORD *)(v14 + 12) = v5;
  *(_DWORD *)(v14 + 16) = v6;
  --*(_DWORD *)(v14 + 40);
  return 1;
}

int __cdecl start_pass_upsample(_DWORD *a1) {
  int v1;     // ecx
  int result; // eax

  v1 = a1[106];
  *(_DWORD *)(v1 + 92) = a1[71];
  result = a1[26];
  *(_DWORD *)(v1 + 96) = result;
  return result;
}

int __cdecl sep_upsample(_DWORD *a1, int a2, _DWORD *a3, int a4, int a5,
                         _DWORD *a6, int a7) {
  int v7;          // edi
  int v8;          // ecx
  unsigned int v9; // esi
  int result;      // eax
  signed int v11;  // esi
  int v12;         // esi
  int i;           // eax
  int v14;         // [esp+34h] [ebp-14h]
  int v15;         // [esp+38h] [ebp-10h]
  int v16;         // [esp+3Ch] [ebp-Ch]

  v7 = a1[106];
  v8 = *(_DWORD *)(v7 + 92);
  if (v8 < a1[71]) {
    v14 = v7 + 12;
  } else {
    v16 = a1[51];
    if ((int)a1[11] > 0) {
      v12 = a1[106];
      v15 = 0;
      v14 = v7 + 12;
      for (i = v7 + 12;; i = v7 + 12) {
        (*(void(__cdecl **)(_DWORD *, int, int, int))(v12 + 52))(
            a1, v16,
            *(_DWORD *)(a2 + 4 * v15) + 4 * *(_DWORD *)(v12 + 100) * *a3,
            4 * v15 + i);
        ++v15;
        v16 += 84;
        v12 += 4;
        if (a1[11] <= v15)
          break;
      }
    } else {
      v14 = v7 + 12;
    }
    v8 = 0;
    *(_DWORD *)(v7 + 92) = 0;
  }
  v9 = a1[71] - v8;
  if (v9 > *(_DWORD *)(v7 + 96))
    v9 = *(_DWORD *)(v7 + 96);
  if (v9 > a7 - *a6)
    v9 = a7 - *a6;
  result = (*(int(__cdecl **)(_DWORD *, int, int, int, unsigned int))(
      a1[107] + 4))(a1, v14, v8, a5 + 4 * *a6, v9);
  *a6 += v9;
  *(_DWORD *)(v7 + 96) -= v9;
  v11 = *(_DWORD *)(v7 + 92) + v9;
  *(_DWORD *)(v7 + 92) = v11;
  if (v11 >= a1[71]) {
    result = (int)a3;
    ++*a3;
  }
  return result;
}

_DWORD *__cdecl fullsize_upsample(int a1, int a2, int a3, _DWORD *a4) {
  _DWORD *result; // eax

  result = a4;
  *a4 = a3;
  return result;
}

_DWORD *__cdecl noop_upsample(int a1, int a2, int a3, _DWORD *a4) {
  _DWORD *result; // eax

  result = a4;
  *a4 = 0;
  return result;
}

int __cdecl int_upsample(size_t *a1, int a2, char **a3, int *a4) {
  size_t v4;  // edx
  int v5;     // eax
  int result; // eax
  char **i;   // edx
  char *v8;   // esi
  _BYTE *v9;  // eax
  char v10;   // cl
  _BYTE *v11; // edx
  _BYTE *v12; // [esp+2Ch] [ebp-2Ch]
  int v13;    // [esp+3Ch] [ebp-1Ch]
  int v14;    // [esp+40h] [ebp-18h]
  int v15;    // [esp+44h] [ebp-14h]
  int v16;    // [esp+48h] [ebp-10h]
  char **v17; // [esp+4Ch] [ebp-Ch]

  v4 = a1[106];
  v13 = *a4;
  v5 = *(_DWORD *)(a2 + 4);
  v14 = *(unsigned __int8 *)(v5 + v4 + 140);
  result = *(unsigned __int8 *)(v5 + v4 + 150);
  v15 = result;
  if ((int)a1[71] > 0) {
    v17 = a3;
    v16 = 0;
    for (i = a3;; i = v17) {
      v8 = *i;
      v9 = *(_BYTE **)(v13 + 4 * v16);
      v12 = &v9[a1[25]];
      while (v12 > v9) {
        v10 = *v8++;
        if (v14 > 0) {
          v11 = &v9[v14];
          do
            *v9++ = v10;
          while (v11 != v9);
          v9 = v11;
        }
      }
      if (v15 > 1)
        jcopy_sample_rows(v13, v16, v13, v16 + 1, v15 - 1, a1[25]);
      result = v15;
      v16 += v15;
      ++v17;
      if ((int)a1[71] <= v16)
        break;
    }
  }
  return result;
}

int __cdecl h2v1_upsample(int a1, int a2, int a3, int *a4) {
  int result; // eax
  int v5;     // edi
  char *v6;   // ecx
  _BYTE *v7;  // edx
  _BYTE *v8;  // esi
  char v9;    // al
  int v10;    // edx
  int v11;    // [esp+0h] [ebp-Ch]

  v11 = *a4;
  result = a1;
  if (*(int *)(a1 + 284) > 0) {
    v5 = 1;
    do {
      v6 = *(char **)(a3 + 4 * v5 - 4);
      v7 = *(_BYTE **)(v11 + 4 * v5 - 4);
      v8 = &v7[*(_DWORD *)(a1 + 100)];
      if (v7 >= v8) {
        v10 = a1;
      } else {
        do {
          v9 = *v6++;
          *v7 = v9;
          v7[1] = v9;
          v7 += 2;
        } while (v8 > v7);
        v10 = a1;
      }
      result = v5++;
    } while (*(_DWORD *)(v10 + 284) > result);
  }
  return result;
}

int __cdecl h2v2_upsample(int a1, int a2, int a3, int *a4) {
  int result; // eax
  int v5;     // edi
  char *v6;   // ecx
  _BYTE *v7;  // edx
  size_t v8;  // eax
  _BYTE *v9;  // esi
  char v10;   // al
  int v11;    // [esp+2Ch] [ebp-Ch]

  v11 = *a4;
  result = a1;
  if (*(int *)(a1 + 284) > 0) {
    v5 = 0;
    do {
      v6 = *(char **)(a3 + 2 * v5);
      v7 = *(_BYTE **)(v11 + 4 * v5);
      v8 = *(_DWORD *)(a1 + 100);
      v9 = &v7[v8];
      if (v7 < &v7[v8]) {
        do {
          v10 = *v6++;
          *v7 = v10;
          v7[1] = v10;
          v7 += 2;
        } while (v9 > v7);
        v8 = *(_DWORD *)(a1 + 100);
      }
      jcopy_sample_rows(v11, v5, v11, v5 + 1, 1, v8);
      v5 += 2;
      result = a1;
    } while (v5 < *(_DWORD *)(a1 + 284));
  }
  return result;
}

int __cdecl h2v1_fancy_upsample(int a1, int a2, int a3, int *a4) {
  int result;           // eax
  unsigned __int8 *v5;  // edx
  _BYTE *v6;            // ecx
  int v7;               // eax
  unsigned __int8 *v8;  // edi
  _BYTE *v9;            // esi
  int v10;              // eax
  unsigned __int8 *v11; // ecx
  int v12;              // edx
  int v13;              // ecx
  int v14;              // [esp+4h] [ebp-10h]
  int v15;              // [esp+8h] [ebp-Ch]

  v14 = *a4;
  result = *(_DWORD *)(a1 + 284);
  if (result > 0) {
    v15 = 1;
    do {
      v5 = *(unsigned __int8 **)(a3 + 4 * v15 - 4);
      v6 = *(_BYTE **)(v14 + 4 * v15 - 4);
      v7 = *v5;
      v8 = v5 + 1;
      *v6 = v7;
      v6[1] = (3 * v7 + v5[1] + 2) >> 2;
      v9 = v6 + 2;
      if (*(_DWORD *)(a2 + 40) != 2) {
        v11 = v5 + 1;
        v10 = *(_DWORD *)(a2 + 40) - 2;
        while (1) {
          v12 = 3 * *v11;
          *v9 = (v12 + *(v11 - 1) + 1) >> 2;
          v9[1] = (v12 + v11[1] + 2) >> 2;
          v9 += 2;
          if (&v8[v10] == v11 + 1)
            break;
          ++v11;
        }
        v8 += v10;
      }
      v13 = *v8;
      *v9 = (3 * v13 + *(v8 - 1) + 1) >> 2;
      v9[1] = v13;
      result = v15++;
    } while (*(_DWORD *)(a1 + 284) > result);
  }
  return result;
}

_BYTE **__cdecl h2v2_fancy_upsample(int a1, int a2, unsigned __int8 **a3,
                                    _DWORD *a4) {
  _BYTE **result;       // eax
  _BYTE **i;            // esi
  unsigned __int8 *v6;  // esi
  _BYTE *v7;            // ecx
  int v8;               // edx
  unsigned __int8 *v9;  // edi
  int v10;              // ecx
  unsigned __int8 *v11; // edi
  unsigned __int8 *v12; // esi
  int v13;              // edi
  int v14;              // [esp+0h] [ebp-38h]
  unsigned __int8 *v16; // [esp+Ch] [ebp-2Ch]
  int v17;              // [esp+10h] [ebp-28h]
  int v18;              // [esp+14h] [ebp-24h]
  int v19;              // [esp+18h] [ebp-20h]
  int j;                // [esp+1Ch] [ebp-1Ch]
  _BYTE **v21;          // [esp+20h] [ebp-18h]
  _BYTE **v22;          // [esp+24h] [ebp-14h]
  _BYTE *v23;           // [esp+28h] [ebp-10h]
  unsigned __int8 *v24; // [esp+2Ch] [ebp-Ch]

  result = (_BYTE **)*a4;
  if (*(int *)(a1 + 284) > 0) {
    v22 = (_BYTE **)*a4;
    v19 = 0;
    for (i = (_BYTE **)*a4;; i = v22) {
      v21 = i;
      for (j = 0; j != 2; ++j) {
        v11 = *a3;
        if (j)
          v6 = a3[1];
        else
          v6 = *(a3 - 1);
        v7 = *v21;
        v17 = *v6 + 3 * *v11;
        v8 = 3 * v11[1] + v6[1];
        v9 = v11 + 2;
        v24 = v6 + 2;
        *v7 = (4 * v17 + 8) >> 4;
        v7[1] = (v8 + 3 * v17 + 7) >> 4;
        v23 = v7 + 2;
        if (*(_DWORD *)(a2 + 40) == 2) {
          v10 = v17;
        } else {
          v12 = v9;
          v13 = v8;
          v18 = v17;
          v16 = &v12[*(_DWORD *)(a2 + 40) - 2];
          while (1) {
            v14 = *v24++ + 3 * *v12++;
            *v23 = (3 * v13 + v18 + 8) >> 4;
            v23[1] = (v14 + 3 * v13 + 7) >> 4;
            v23 += 2;
            v18 = v13;
            if (v12 == v16)
              break;
            v13 = v14;
          }
          v8 = v14;
          v10 = v13;
        }
        *v23 = (3 * v8 + v10 + 8) >> 4;
        v23[1] = (4 * v8 + 7) >> 4;
        ++v21;
      }
      v19 += 2;
      ++a3;
      v22 += 2;
      result = (_BYTE **)a1;
      if (*(_DWORD *)(a1 + 284) <= v19)
        break;
    }
  }
  return result;
}

int __cdecl jinit_upsampler(int a1) {
  int result;                             // eax
  int i;                                  // edx
  int v3;                                 // ecx
  int v4;                                 // esi
  int v5;                                 // ecx
  int v6;                                 // edx
  int v7;                                 // edi
  int v8;                                 // eax
  int v9;                                 // edx
  int v10;                                // ecx
  int(__cdecl * v11)(int, int, int, int); // edi
  int v12;                                // esi
  int v13;                                // eax
  int v14;                                // [esp+1Ch] [ebp-3Ch]
  int v15;                                // [esp+28h] [ebp-30h]
  int v16;                                // [esp+2Ch] [ebp-2Ch]
  char v17;                               // [esp+33h] [ebp-25h]
  _DWORD *v18;                            // [esp+34h] [ebp-24h]
  int v19;                                // [esp+38h] [ebp-20h]
  int v20;                                // [esp+3Ch] [ebp-1Ch]

  v20 = (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 160);
  *(_DWORD *)(a1 + 424) = v20;
  *(_DWORD *)v20 = start_pass_upsample;
  *(_DWORD *)(v20 + 4) = sep_upsample;
  *(_BYTE *)(v20 + 8) = 0;
  if (*(_BYTE *)(a1 + 274)) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 25;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  result = a1;
  if (*(_BYTE *)(a1 + 80) && *(int *)(a1 + 288) > 1) {
    v17 = 1;
    v16 = *(_DWORD *)(a1 + 204);
    if (*(int *)(a1 + 44) <= 0)
      return result;
  LABEL_8:
    v19 = v20;
    v18 = (_DWORD *)v20;
    v15 = 0;
    for (i = a1;; i = a1) {
      v3 = *(_DWORD *)(v16 + 36);
      v14 = *(_DWORD *)(i + 288);
      v4 = *(_DWORD *)(v16 + 8) * v3 / v14;
      v5 = *(_DWORD *)(v16 + 12) * v3 / v14;
      v6 = *(_DWORD *)(a1 + 280);
      v7 = *(_DWORD *)(a1 + 284);
      v18[25] = v5;
      if (!*(_BYTE *)(v16 + 48)) {
        v18[13] = noop_upsample;
        goto LABEL_10;
      }
      if (v4 != v6 || v5 != v7)
        break;
      v18[13] = fullsize_upsample;
    LABEL_10:
      ++v15;
      v16 += 84;
      ++v18;
      ++v19;
      result = v15;
      if (v15 >= *(_DWORD *)(a1 + 44))
        return result;
    }
    if (v6 != 2 * v4)
      goto LABEL_15;
    if (v5 == v7) {
      if (v17 && *(_DWORD *)(v16 + 40) > 2u)
        v18[13] = h2v1_fancy_upsample;
      else
        v18[13] = h2v1_upsample;
      goto LABEL_18;
    }
    if (v7 == 2 * v5) {
      if (v17 && *(_DWORD *)(v16 + 40) > 2u) {
        v18[13] = h2v2_fancy_upsample;
        *(_BYTE *)(v20 + 8) = 1;
      } else {
        v18[13] = h2v2_upsample;
      }
    } else {
    LABEL_15:
      v8 = v6 / v4;
      if (v6 % v4 || (v9 = v7 % v5, v10 = v7 / v5, v9)) {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 38;
        (**(void(__cdecl ***)(int))a1)(a1);
      } else {
        v18[13] = int_upsample;
        *(_BYTE *)(v19 + 140) = v8;
        *(_BYTE *)(v19 + 150) = v10;
      }
    }
  LABEL_18:
    v11 = *(int(__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8);
    v12 = *(_DWORD *)(a1 + 284);
    v13 = jround_up(*(_DWORD *)(a1 + 100), *(_DWORD *)(a1 + 280));
    v18[3] = v11(a1, 1, v13, v12);
    goto LABEL_10;
  }
  v17 = 0;
  v16 = *(_DWORD *)(a1 + 204);
  if (*(int *)(a1 + 44) > 0)
    goto LABEL_8;
  return result;
}

void *__cdecl start_pass_coef(_DWORD *a1, int a2) {
  _DWORD *v2;   // edi
  _DWORD *v3;   // edx
  void *result; // eax
  int v5;       // eax

  v2 = (_DWORD *)a1[83];
  v2[2] = 0;
  v3 = (_DWORD *)a1[83];
  if ((int)a1[58] <= 1) {
    if (v3[2] < (unsigned int)(a1[57] - 1))
      v5 = *(_DWORD *)(a1[59] + 12);
    else
      v5 = *(_DWORD *)(a1[59] + 72);
    v3[5] = v5;
  } else {
    v3[5] = 1;
  }
  v3[3] = 0;
  v3[4] = 0;
  if (a2 == 2) {
    if (!v2[16]) {
      *(_DWORD *)(*a1 + 20) = 4;
      (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
    }
    result = compress_output;
    v2[1] = compress_output;
  } else if (a2 == 3) {
    if (!v2[16]) {
      *(_DWORD *)(*a1 + 20) = 4;
      (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
    }
    result = compress_first_pass;
    v2[1] = compress_first_pass;
  } else if (a2) {
    *(_DWORD *)(*a1 + 20) = 4;
    return (void *)(*(int(__cdecl **)(_DWORD *)) * a1)(a1);
  } else {
    if (v2[16]) {
      *(_DWORD *)(*a1 + 20) = 4;
      (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
    }
    result = compress_data;
    v2[1] = compress_data;
  }
  return result;
}

int __cdecl jinit_c_coef_controller(int a1, char a2) {
  _DWORD *v2;                                         // edi
  int result;                                         // eax
  int v4;                                             // esi
  int v5;                                             // edi
  int v6;                                             // eax
  _DWORD *v7;                                         // edx
  int v8;                                             // ecx
  int(__cdecl * v9)(int, int, _DWORD, int, int, int); // [esp+20h] [ebp-28h]
  int v10;                                            // [esp+24h] [ebp-24h]
  int *v11;                                           // [esp+28h] [ebp-20h]
  _DWORD *v12;                                        // [esp+2Ch] [ebp-1Ch]

  v2 = (_DWORD *)(**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 104);
  *(_DWORD *)(a1 + 332) = v2;
  *v2 = start_pass_coef;
  if (a2) {
    v11 = *(int **)(a1 + 72);
    result = *(_DWORD *)(a1 + 64);
    if (result > 0) {
      v12 = v2;
      v10 = 0;
      do {
        v9 = *(int(__cdecl **)(int, int, _DWORD, int, int, int))(
            *(_DWORD *)(a1 + 4) + 20);
        v4 = v11[3];
        v5 = jround_up(v11[8], v4);
        v6 = jround_up(v11[7], v11[2]);
        v12[16] = v9(a1, 1, 0, v6, v5, v4);
        ++v10;
        v11 += 21;
        ++v12;
        result = a1;
      } while (*(_DWORD *)(a1 + 64) > v10);
    }
  } else {
    result = (*(int(__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1,
                                                                          1280);
    v7 = v2;
    v8 = 10;
    do {
      v7[6] = result;
      ++v7;
      result += 128;
      --v8;
    } while (v8);
    v2[16] = 0;
  }
  return result;
}

int __cdecl compress_data(_DWORD *a1, int a2) {
  int v2;           // eax
  _DWORD *v3;       // edi
  int v4;           // eax
  int v5;           // esi
  _WORD **v6;       // ecx
  int v7;           // eax
  int v8;           // eax
  _WORD **v9;       // ecx
  int v10;          // esi
  _DWORD *v11;      // eax
  _DWORD *v12;      // edx
  int v13;          // eax
  _DWORD *v15;      // [esp+30h] [ebp-48h]
  _DWORD *v16;      // [esp+38h] [ebp-40h]
  unsigned int v17; // [esp+3Ch] [ebp-3Ch]
  unsigned int v18; // [esp+40h] [ebp-38h]
  unsigned int v19; // [esp+44h] [ebp-34h]
  int v20;          // [esp+48h] [ebp-30h]
  int v21;          // [esp+4Ch] [ebp-2Ch]
  int i;            // [esp+50h] [ebp-28h]
  int v23;          // [esp+54h] [ebp-24h]
  int v24;          // [esp+58h] [ebp-20h]
  int v25;          // [esp+5Ch] [ebp-1Ch]
  int v26;          // [esp+60h] [ebp-18h]
  _DWORD *v27;      // [esp+68h] [ebp-10h]
  int v28;          // [esp+6Ch] [ebp-Ch]

  v16 = (_DWORD *)a1[83];
  v18 = a1[63] - 1;
  v19 = a1[57] - 1;
  v2 = v16[4];
  v23 = v2;
  if (v2 < v16[5]) {
    v28 = 8 * v2;
    v15 = v16 + 6;
    while (1) {
      v17 = v16[3];
      if (v18 < v17)
        goto LABEL_28;
      do {
        if ((int)a1[58] <= 0) {
          if (!(*(unsigned __int8(__cdecl **)(_DWORD *, _DWORD *))(a1[88] + 4))(
                  a1, v15))
            goto LABEL_34;
          goto LABEL_27;
        }
        v27 = a1;
        v20 = 0;
        v21 = 0;
        v3 = (_DWORD *)a1[59];
        if (v18 > v17) {
        LABEL_6:
          v24 = v3[13];
          goto LABEL_7;
        }
        while (1) {
          v24 = v3[17];
        LABEL_7:
          v26 = v3[16] * v17;
          if ((int)v3[14] > 0) {
            v25 = v28;
            for (i = 0; i < v3[14]; ++i) {
              while (v19 <= v16[2] && v23 + i >= v3[18]) {
                jzero_far((void *)v16[v20 + 6], v3[13] << 7);
                if ((int)v3[13] > 0) {
                  v8 = v20 - 1;
                  v9 = (_WORD **)&v16[v20 + 6];
                  v10 = 0;
                  while (1) {
                    **v9 = *(_WORD *)v16[v8 + 6];
                    ++v10;
                    ++v9;
                    if (v10 >= v3[13])
                      break;
                    v8 = v20 - 1;
                  }
                  v7 = v3[13];
                  goto LABEL_17;
                }
              LABEL_16:
                v7 = v3[13];
              LABEL_17:
                v20 += v7;
                v25 += 8;
                if (++i >= v3[14])
                  goto LABEL_18;
              }
              (*(void(__cdecl **)(_DWORD *, _DWORD *, _DWORD, _DWORD, int, int,
                                  int))(a1[87] + 4))(
                  a1, v3, *(_DWORD *)(a2 + 4 * v3[1]), v16[v20 + 6], v25, v26,
                  v24);
              v4 = v3[13];
              if (v24 < v4) {
                jzero_far((void *)v16[v20 + 6 + v24], (v4 - v24) << 7);
                v5 = v24;
                if (v24 < v3[13]) {
                  v6 = (_WORD **)&v16[v20 + 6 + v24];
                  do {
                    **v6 = **(v6 - 1);
                    ++v5;
                    ++v6;
                  } while (v5 < v3[13]);
                }
                goto LABEL_16;
              }
              v20 += v4;
              v25 += 8;
            }
          }
        LABEL_18:
          ++v21;
          ++v27;
          if (v21 >= a1[58])
            break;
          v3 = (_DWORD *)v27[59];
          if (v18 > v17)
            goto LABEL_6;
        }
        if (!(*(unsigned __int8(__cdecl **)(_DWORD *, _DWORD *))(a1[88] + 4))(
                a1, v15)) {
        LABEL_34:
          v16[4] = v23;
          v16[3] = v17;
          return 0;
        }
      LABEL_27:
        ++v17;
      } while (v18 >= v17);
    LABEL_28:
      v16[3] = 0;
      ++v23;
      v28 += 8;
      if (v23 >= v16[5]) {
        ++v16[2];
        v11 = a1;
        v12 = (_DWORD *)a1[83];
        if ((int)a1[58] <= 1)
          goto LABEL_30;
      LABEL_36:
        v12[5] = 1;
        goto LABEL_37;
      }
    }
  }
  ++v16[2];
  v11 = a1;
  v12 = (_DWORD *)a1[83];
  if ((int)a1[58] > 1)
    goto LABEL_36;
LABEL_30:
  if (v12[2] >= (unsigned int)(v11[57] - 1))
    v13 = *(_DWORD *)(a1[59] + 72);
  else
    v13 = *(_DWORD *)(v11[59] + 12);
  v12[5] = v13;
LABEL_37:
  v12[3] = 0;
  v12[4] = 0;
  return 1;
}

int __cdecl compress_output(_DWORD *a1) {
  _DWORD *v1;       // ecx
  _DWORD *v2;       // edi
  int v3;           // ecx
  _DWORD *v4;       // ecx
  _DWORD *j;        // edi
  int v6;           // esi
  _DWORD *k;        // ecx
  int v8;           // edx
  int *v9;          // eax
  int v10;          // ecx
  _DWORD *v11;      // edx
  int v12;          // eax
  _DWORD *v14;      // esi
  int v15;          // edi
  _DWORD *i;        // ecx
  int v17;          // eax
  _DWORD *v18;      // [esp+3Ch] [ebp-4Ch]
  _DWORD *v19;      // [esp+44h] [ebp-44h]
  _DWORD *v20;      // [esp+4Ch] [ebp-3Ch]
  unsigned int v21; // [esp+50h] [ebp-38h]
  int v22;          // [esp+54h] [ebp-34h]
  int v23;          // [esp+58h] [ebp-30h]
  int v24;          // [esp+5Ch] [ebp-2Ch]
  int v25;          // [esp+60h] [ebp-28h]
  int v26;          // [esp+64h] [ebp-24h]
  _DWORD *v27;      // [esp+68h] [ebp-20h]
  int v28;          // [esp+6Ch] [ebp-1Ch]
  _DWORD v29[6];    // [esp+70h] [ebp-18h] BYREF

  v20 = (_DWORD *)a1[83];
  if ((int)a1[58] > 0) {
    v14 = a1;
    v15 = 1;
    for (i = a1;; i = a1) {
      v29[v15 - 1] = (*(int(__cdecl **)(_DWORD *, _DWORD, int, _DWORD, _DWORD))(
          i[1] + 32))(a1, v20[*(_DWORD *)(v14[59] + 4) + 16],
                      v20[2] * *(_DWORD *)(v14[59] + 12),
                      *(_DWORD *)(v14[59] + 12), 0);
      v17 = v15++;
      ++v14;
      if (a1[58] <= v17)
        break;
    }
    v1 = v20;
    v2 = v20;
  } else {
    v1 = (_DWORD *)a1[83];
    v2 = v1;
  }
  v3 = v1[4];
  v25 = v3;
  if (v2[5] > v3) {
    v28 = 4 * v3;
    v19 = v2 + 6;
    do {
      v21 = v20[3];
      v4 = a1;
      if (v21 < a1[63]) {
        while (1) {
          if ((int)v4[58] > 0) {
            v27 = v4;
            v23 = 0;
            v22 = 0;
            for (j = v4;; j = v27) {
              v6 = j[59];
              if (*(int *)(v6 + 56) > 0) {
                v26 = (*(_DWORD *)(v6 + 52) * v21) << 7;
                v18 = (_DWORD *)(v29[v23] + v28);
                v24 = 0;
                for (k = v18;; k = v18) {
                  v8 = *k + v26;
                  if (*(int *)(v6 + 52) > 0) {
                    v9 = &v20[v22 + 6];
                    v10 = 0;
                    do {
                      *v9 = v8;
                      v8 += 128;
                      ++v10;
                      ++v9;
                    } while (v10 < *(_DWORD *)(v6 + 52));
                    v22 += v10;
                  }
                  ++v24;
                  ++v18;
                  if (v24 >= *(_DWORD *)(v6 + 56))
                    break;
                }
              }
              ++v23;
              ++v27;
              if (v23 >= a1[58])
                break;
            }
            v4 = a1;
          }
          if (!(*(unsigned __int8(__cdecl **)(_DWORD *, _DWORD *))(v4[88] + 4))(
                  v4, v19))
            break;
          if (++v21 >= a1[63])
            goto LABEL_22;
          v4 = a1;
        }
        v20[4] = v25;
        v20[3] = v21;
        return 0;
      }
    LABEL_22:
      v20[3] = 0;
      ++v25;
      v28 += 4;
    } while (v20[5] > v25);
    ++v20[2];
    v11 = (_DWORD *)a1[83];
    if ((int)a1[58] > 1)
      goto LABEL_28;
    goto LABEL_24;
  }
  ++v2[2];
  v11 = (_DWORD *)a1[83];
  if ((int)a1[58] <= 1) {
  LABEL_24:
    if (v11[2] >= (unsigned int)(a1[57] - 1))
      v12 = *(_DWORD *)(a1[59] + 72);
    else
      v12 = *(_DWORD *)(a1[59] + 12);
    v11[5] = v12;
    goto LABEL_29;
  }
LABEL_28:
  v11[5] = 1;
LABEL_29:
  v11[3] = 0;
  v11[4] = 0;
  return 1;
}

int __cdecl compress_first_pass(_DWORD *a1, int a2) {
  int v2;           // eax
  int v3;           // edx
  int v4;           // edi
  int v5;           // edx
  int i;            // edx
  int v7;           // esi
  void *v8;         // esi
  __int16 v9;       // cx
  _WORD *v10;       // eax
  int j;            // edx
  void **k;         // edx
  char *v13;        // edi
  int v14;          // esi
  __int16 v15;      // cx
  _WORD *v16;       // eax
  int n;            // edx
  unsigned int v19; // [esp+34h] [ebp-54h]
  int v20;          // [esp+40h] [ebp-48h]
  unsigned int v21; // [esp+44h] [ebp-44h]
  unsigned int v22; // [esp+48h] [ebp-40h]
  int m;            // [esp+4Ch] [ebp-3Ch]
  int v24;          // [esp+50h] [ebp-38h]
  unsigned int v25; // [esp+54h] [ebp-34h]
  int v26;          // [esp+58h] [ebp-30h]
  int v27;          // [esp+5Ch] [ebp-2Ch]
  int v28;          // [esp+60h] [ebp-28h]
  int v29;          // [esp+64h] [ebp-24h]
  int v30;          // [esp+68h] [ebp-20h]
  unsigned int v31; // [esp+6Ch] [ebp-1Ch]
  void **v32;       // [esp+70h] [ebp-18h]
  int v33;          // [esp+74h] [ebp-14h]
  int *v34;         // [esp+78h] [ebp-10h]
  int v35;          // [esp+7Ch] [ebp-Ch]

  v20 = a1[83];
  v21 = a1[57] - 1;
  v28 = a1[18];
  if ((int)a1[16] > 0) {
    v33 = a1[83];
    v24 = 0;
    do {
      v34 = (int *)(v28 + 12);
      v29 = (*(int(__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int))(
          a1[1] + 32))(a1, *(_DWORD *)(v33 + 64),
                       *(_DWORD *)(v20 + 8) * *(_DWORD *)(v28 + 12),
                       *(_DWORD *)(v28 + 12), 1);
      if (v21 > *(_DWORD *)(v20 + 8)) {
        v27 = *(_DWORD *)(v28 + 12);
        v2 = v28;
        v3 = v28;
      } else {
        v5 = *(_DWORD *)(v28 + 32) % *(_DWORD *)(v28 + 12);
        if (!v5)
          v5 = *(_DWORD *)(v28 + 12);
        v27 = v5;
        v2 = v28;
        v3 = v28;
      }
      v22 = *(_DWORD *)(v2 + 28);
      v25 = *(_DWORD *)(v3 + 8);
      v4 = v22 % v25;
      if ((int)(v22 % v25) >= 1)
        v4 = v25 - v22 % v25;
      if (v27 > 0) {
        v26 = 0;
        for (i = 0;; i = v26) {
          v7 = *(_DWORD *)(v29 + 4 * i);
          (*(void(__cdecl **)(_DWORD *, int, _DWORD, int, int, _DWORD,
                              unsigned int))(a1[87] + 4))(
              a1, v28, *(_DWORD *)(a2 + 4 * v24), v7, 8 * v26, 0, v22);
          if (v4 > 0) {
            v8 = (void *)((v22 << 7) + v7);
            jzero_far(v8, v4 << 7);
            v9 = *((_WORD *)v8 - 64);
            v10 = v8;
            for (j = 0; j != v4; ++j) {
              *v10 = v9;
              v10 += 64;
            }
          }
          if (v27 == ++v26)
            break;
        }
      }
      if (v21 == *(_DWORD *)(v20 + 8)) {
        v19 = (v4 + v22) / v25;
        if (v27 < *v34) {
          v30 = (v4 + v22) << 7;
          v31 = v25 << 7;
          v32 = (void **)(v29 + 4 * v27);
          v35 = v27;
          for (k = v32;; k = v32) {
            v13 = (char *)*k;
            v14 = (int)*(k - 1);
            jzero_far(*k, v30);
            if (v19) {
              for (m = 0; m != v19; ++m) {
                v15 = *(_WORD *)(v14 + v31 - 128);
                if ((int)v25 > 0) {
                  v16 = v13;
                  for (n = 0; n != v25; ++n) {
                    *v16 = v15;
                    v16 += 64;
                  }
                }
                v13 += v31;
                v14 += v31;
              }
            }
            ++v35;
            ++v32;
            if (*v34 <= v35)
              break;
          }
        }
      }
      ++v24;
      v28 += 84;
      v33 += 4;
    } while (v24 < a1[16]);
  }
  return (unsigned __int8)compress_output(a1);
}

unsigned int __cdecl process_data_simple_main_0(_DWORD *a1, int a2, _DWORD *a3,
                                                int a4) {
  int v4;              // esi
  unsigned int result; // eax
  int v6;              // [esp+2Ch] [ebp-Ch]

  v4 = a1[81];
  result = *(_DWORD *)(v4 + 8);
  if (result < a1[57]) {
    result = v4 + 24;
    v6 = v4 + 24;
    do {
      if (*(_DWORD *)(v4 + 12) <= 7u)
        result =
            (*(int(__cdecl **)(_DWORD *, int, _DWORD *, int, int, int, int))(
                a1[82] + 4))(a1, a2, a3, a4, v6, v4 + 12, 8);
      if (*(_DWORD *)(v4 + 12) != 8)
        break;
      result = (*(int(__cdecl **)(_DWORD *, int))(a1[83] + 4))(a1, v6);
      if (!(_BYTE)result) {
        if (!*(_BYTE *)(v4 + 16)) {
          result = (unsigned int)a3;
          --*a3;
          *(_BYTE *)(v4 + 16) = 1;
        }
        return result;
      }
      if (*(_BYTE *)(v4 + 16)) {
        ++*a3;
        *(_BYTE *)(v4 + 16) = 0;
      }
      *(_DWORD *)(v4 + 12) = 0;
      result = *(_DWORD *)(v4 + 8) + 1;
      *(_DWORD *)(v4 + 8) = result;
    } while (result < a1[57]);
  }
  return result;
}

int __cdecl pass_startup(int a1) {
  *(_BYTE *)(*(_DWORD *)(a1 + 320) + 12) = 0;
  (*(void(__cdecl **)(int))(*(_DWORD *)(a1 + 336) + 4))(a1);
  return (*(int(__cdecl **)(int))(*(_DWORD *)(a1 + 336) + 8))(a1);
}

int __cdecl finish_pass_master(int a1) {
  _DWORD *v1; // esi
  int result; // eax

  v1 = *(_DWORD **)(a1 + 320);
  (*(void(__cdecl **)(int))(*(_DWORD *)(a1 + 352) + 8))(a1);
  result = v1[4];
  if (result != 1) {
    if (result) {
      if (result != 2) {
      LABEL_4:
        ++v1[5];
        return result;
      }
      if (*(_BYTE *)(a1 + 182)) {
        v1[4] = 1;
        ++v1[7];
        goto LABEL_7;
      }
    } else {
      v1[4] = 2;
      if (*(_BYTE *)(a1 + 182))
        goto LABEL_4;
    }
    ++v1[7];
  LABEL_7:
    ++v1[5];
    return result;
  }
  v1[4] = 2;
  ++v1[5];
  return result;
}

int __cdecl jinit_c_master_control(int a1, char a2) {
  int v2;           // eax
  int *v3;          // ecx
  int *v4;          // eax
  int v5;           // esi
  int *v6;          // edi
  int v7;           // eax
  int v8;           // eax
  int v9;           // eax
  int v10;          // esi
  int v11;          // edi
  int v12;          // edx
  int *v13;         // eax
  int v14;          // eax
  int v15;          // ecx
  int *v16;         // edi
  int v17;          // esi
  int v18;          // edx
  int *k;           // ecx
  int *v20;         // esi
  int *v21;         // esi
  signed int v22;   // edi
  int v23;          // edx
  int m;            // eax
  int v25;          // edx
  _DWORD *v26;      // esi
  int v27;          // ecx
  _DWORD *v28;      // eax
  int i;            // edx
  int v30;          // edx
  int v31;          // esi
  int v32;          // ecx
  int result;       // eax
  int *v34;         // esi
  int v35;          // edi
  int v36;          // esi
  int v37;          // [esp+18h] [ebp-A60h]
  int v38;          // [esp+1Ch] [ebp-A5Ch]
  int *v39;         // [esp+24h] [ebp-A54h]
  int v40;          // [esp+28h] [ebp-A50h]
  int v41;          // [esp+2Ch] [ebp-A4Ch]
  int v42;          // [esp+30h] [ebp-A48h]
  unsigned int v43; // [esp+34h] [ebp-A44h]
  int v44;          // [esp+38h] [ebp-A40h]
  int *v45;         // [esp+3Ch] [ebp-A3Ch]
  signed int v46;   // [esp+40h] [ebp-A38h]
  int v47;          // [esp+44h] [ebp-A34h]
  int v48;          // [esp+48h] [ebp-A30h]
  int j;            // [esp+4Ch] [ebp-A2Ch]
  _DWORD v50[649];  // [esp+54h] [ebp-A24h] BYREF

  v37 = (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 32);
  *(_DWORD *)(a1 + 320) = v37;
  *(_DWORD *)v37 = prepare_for_pass;
  *(_DWORD *)(v37 + 4) = pass_startup;
  *(_DWORD *)(v37 + 8) = finish_pass_master;
  *(_BYTE *)(v37 + 13) = 0;
  if (*(_DWORD *)(a1 + 40) && *(_DWORD *)(a1 + 36) && *(int *)(a1 + 64) > 0 &&
      *(int *)(a1 + 44) > 0) {
    v2 = a1;
    if (*(int *)(a1 + 40) > 65500)
      goto LABEL_77;
  } else {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 32;
    (**(void(__cdecl ***)(int))a1)(a1);
    v2 = a1;
    if (*(int *)(a1 + 40) > 65500) {
    LABEL_77:
      v25 = v2;
      goto LABEL_71;
    }
  }
  if (*(int *)(v2 + 36) <= 65500) {
    v3 = (int *)a1;
    if (*(_DWORD *)(a1 + 60) == 8)
      goto LABEL_72;
    goto LABEL_6;
  }
  v25 = a1;
LABEL_71:
  *(_DWORD *)(*(_DWORD *)v25 + 20) = 41;
  *(_DWORD *)(*(_DWORD *)v25 + 24) = 65500;
  (**(void(__cdecl ***)(int))v25)(v25);
  v3 = (int *)a1;
  if (*(_DWORD *)(a1 + 60) == 8) {
  LABEL_72:
    v4 = v3;
    if (v3[16] > 10)
      goto LABEL_73;
    goto LABEL_7;
  }
LABEL_6:
  *(_DWORD *)(*v3 + 20) = 15;
  *(_DWORD *)(*v3 + 24) = v3[15];
  (*(void(__cdecl **)(int *)) * v3)(v3);
  v4 = (int *)a1;
  if (*(int *)(a1 + 64) > 10) {
  LABEL_73:
    *(_DWORD *)(*v4 + 20) = 26;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(*(_DWORD *)a1 + 28) = 10;
    (**(void(__cdecl ***)(int))a1)(a1);
    v4 = (int *)a1;
  }
LABEL_7:
  v4[55] = 1;
  v4[56] = 1;
  v5 = v4[18];
  if (v4[16] <= 0)
    goto LABEL_22;
  v38 = 0;
  do {
    v6 = (int *)(v5 + 8);
    if ((unsigned int)(*(_DWORD *)(v5 + 8) - 1) > 3 ||
        (v7 = *(_DWORD *)(v5 + 12), v7 <= 0) || v7 > 4) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 18;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v8 = *v6;
    if (*v6 < *(_DWORD *)(a1 + 220))
      v8 = *(_DWORD *)(a1 + 220);
    *(_DWORD *)(a1 + 220) = v8;
    v9 = *(_DWORD *)(v5 + 12);
    if (v9 < *(_DWORD *)(a1 + 224))
      v9 = *(_DWORD *)(a1 + 224);
    *(_DWORD *)(a1 + 224) = v9;
    ++v38;
    v5 += 84;
  } while (v38 < *(_DWORD *)(a1 + 64));
  v10 = *(_DWORD *)(a1 + 72);
  if (*(int *)(a1 + 64) <= 0) {
  LABEL_22:
    v12 = a1;
  } else {
    v11 = 0;
    do {
      *(_DWORD *)(v10 + 4) = v11;
      *(_DWORD *)(v10 + 36) = 8;
      *(_DWORD *)(v10 + 28) =
          jdiv_round_up(*(_DWORD *)(v10 + 8) * *(_DWORD *)(a1 + 36),
                        8 * *(_DWORD *)(a1 + 220));
      *(_DWORD *)(v10 + 32) =
          jdiv_round_up(*(_DWORD *)(v10 + 12) * *(_DWORD *)(a1 + 40),
                        8 * *(_DWORD *)(a1 + 224));
      *(_DWORD *)(v10 + 40) = jdiv_round_up(
          *(_DWORD *)(v10 + 8) * *(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 220));
      *(_DWORD *)(v10 + 44) = jdiv_round_up(
          *(_DWORD *)(v10 + 12) * *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 224));
      *(_BYTE *)(v10 + 48) = 1;
      ++v11;
      v10 += 84;
    } while (*(_DWORD *)(a1 + 64) > v11);
    v12 = a1;
  }
  *(_DWORD *)(a1 + 228) =
      jdiv_round_up(*(_DWORD *)(v12 + 40), 8 * *(_DWORD *)(v12 + 224));
  if (!*(_DWORD *)(a1 + 176)) {
    *(_BYTE *)(a1 + 216) = 0;
    *(_DWORD *)(a1 + 172) = 1;
    v30 = a1;
    goto LABEL_90;
  }
  if (*(int *)(a1 + 172) <= 0) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 19;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = 0;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  v13 = *(int **)(a1 + 176);
  v39 = v13;
  if (v13[5] || v13[6] != 63) {
    *(_BYTE *)(a1 + 216) = 1;
    if (*(int *)(a1 + 64) > 0) {
      v26 = v50;
      v27 = 0;
      do {
        v28 = v26;
        for (i = 0; i != 64; ++i)
          *v28++ = -1;
        ++v27;
        v26 += 64;
        v14 = a1;
      } while (*(_DWORD *)(a1 + 64) > v27);
      if (*(int *)(a1 + 172) > 0) {
      LABEL_30:
        v40 = 1;
        v15 = *v39;
        v41 = *v39;
        if ((unsigned int)(*v39 - 1) > 3)
          goto LABEL_99;
        while (1) {
          if (v41 > 0) {
            v16 = v39;
            v47 = 0;
            while (1) {
              v17 = v16[1];
              if (v17 < 0) {
                v18 = a1;
              } else {
                if (v17 < *(_DWORD *)(a1 + 64))
                  goto LABEL_38;
                v18 = a1;
              }
              *(_DWORD *)(*(_DWORD *)v18 + 20) = 19;
              *(_DWORD *)(*(_DWORD *)v18 + 24) = v40;
              (**(void(__cdecl ***)(int))v18)(v18);
            LABEL_38:
              if (v47 <= 0 || v17 > *v16) {
                ++v47;
                ++v16;
                if (v41 == v47)
                  break;
              } else {
                *(_DWORD *)(*(_DWORD *)a1 + 20) = 19;
                *(_DWORD *)(*(_DWORD *)a1 + 24) = v40;
                (**(void(__cdecl ***)(int))a1)(a1);
                ++v47;
                ++v16;
                if (v41 == v47)
                  break;
              }
            }
          }
          v46 = v39[5];
          v42 = v39[6];
          v43 = v39[7];
          v44 = v39[8];
          if (!*(_BYTE *)(a1 + 216)) {
            if (v46 || v42 != 63 || v43 || v44) {
              *(_DWORD *)(*(_DWORD *)a1 + 20) = 17;
              *(_DWORD *)(*(_DWORD *)a1 + 24) = v40;
              (**(void(__cdecl ***)(int))a1)(a1);
            }
            if (v41 > 0) {
              v34 = v39;
              for (j = 0; j != v41; ++j) {
                v35 = v34[1];
                if (*((_BYTE *)&v50[640] + v35 + 2)) {
                  *(_DWORD *)(*(_DWORD *)a1 + 20) = 19;
                  *(_DWORD *)(*(_DWORD *)a1 + 24) = v40;
                  (**(void(__cdecl ***)(int))a1)(a1);
                }
                *((_BYTE *)&v50[640] + v35 + 2) = 1;
                ++v34;
              }
            }
            goto LABEL_97;
          }
          if ((unsigned int)v46 > 0x3F || v46 > v42 || v42 > 63 || v43 > 0xA ||
              (unsigned int)v39[8] > 0xA) {
            *(_DWORD *)(*(_DWORD *)a1 + 20) = 17;
            *(_DWORD *)(*(_DWORD *)a1 + 24) = v40;
            (**(void(__cdecl ***)(int))a1)(a1);
          }
          if (v46) {
            if (v41 == 1)
              goto LABEL_49;
          } else if (!v42) {
            goto LABEL_49;
          }
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 17;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = v40;
          (**(void(__cdecl ***)(int))a1)(a1);
        LABEL_49:
          if (v41 > 0) {
            v45 = v39;
            v48 = 0;
            for (k = v39;; k = v45) {
              v20 = &v50[64 * k[1]];
              if (v46 && *v20 < 0) {
                *(_DWORD *)(*(_DWORD *)a1 + 20) = 17;
                *(_DWORD *)(*(_DWORD *)a1 + 24) = v40;
                (**(void(__cdecl ***)(int))a1)(a1);
              }
              if (v46 <= v42)
                break;
            LABEL_63:
              ++v48;
              ++v45;
              if (v41 == v48)
                goto LABEL_97;
            }
            v21 = &v20[v46];
            v22 = v46;
            while (2) {
              while (*v21 < 0) {
                if (!v43)
                  goto LABEL_59;
                *(_DWORD *)(*(_DWORD *)a1 + 20) = 17;
                *(_DWORD *)(*(_DWORD *)a1 + 24) = v40;
                (**(void(__cdecl ***)(int))a1)(a1);
                *v21 = v44;
                ++v22;
                ++v21;
                if (v42 < v22)
                  goto LABEL_63;
              }
              if (v43 != *v21 || v44 != v43 - 1) {
                *(_DWORD *)(*(_DWORD *)a1 + 20) = 17;
                *(_DWORD *)(*(_DWORD *)a1 + 24) = v40;
                (**(void(__cdecl ***)(int))a1)(a1);
              }
            LABEL_59:
              *v21 = v44;
              ++v22;
              ++v21;
              if (v42 < v22)
                goto LABEL_63;
              continue;
            }
          }
        LABEL_97:
          v39 += 9;
          ++v40;
          v14 = a1;
          if (v40 > *(_DWORD *)(a1 + 172))
            goto LABEL_83;
          v15 = *v39;
          v41 = *v39;
          if ((unsigned int)(*v39 - 1) > 3) {
          LABEL_99:
            *(_DWORD *)(*(_DWORD *)a1 + 20) = 26;
            *(_DWORD *)(*(_DWORD *)a1 + 24) = v15;
            *(_DWORD *)(*(_DWORD *)a1 + 28) = 4;
            (**(void(__cdecl ***)(int))a1)(a1);
          }
        }
      }
      goto LABEL_83;
    }
    goto LABEL_28;
  }
  *(_BYTE *)(a1 + 216) = 0;
  v23 = *(_DWORD *)(a1 + 64);
  if (v23 > 0) {
    for (m = 0; m != v23; ++m)
      *((_BYTE *)&v50[640] + m + 2) = 0;
  LABEL_28:
    v14 = a1;
    goto LABEL_29;
  }
  v14 = a1;
LABEL_29:
  if (*(int *)(v14 + 172) > 0)
    goto LABEL_30;
LABEL_83:
  if (*(_BYTE *)(v14 + 216)) {
    v30 = v14;
    if (*(int *)(v14 + 64) <= 0)
      goto LABEL_90;
    v31 = 0;
    do {
      if ((int)v50[64 * v31] < 0) {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 45;
        (**(void(__cdecl ***)(int))a1)(a1);
      }
      ++v31;
      v32 = a1;
    } while (v31 < *(_DWORD *)(a1 + 64));
    goto LABEL_89;
  }
  if (*(int *)(a1 + 64) > 0) {
    v36 = 0;
    do {
      if (!*((_BYTE *)&v50[640] + v36 + 2)) {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 45;
        (**(void(__cdecl ***)(int))a1)(a1);
      }
      ++v36;
      v32 = a1;
    } while (v36 < *(_DWORD *)(a1 + 64));
  LABEL_89:
    v30 = v32;
    goto LABEL_90;
  }
  v30 = a1;
LABEL_90:
  if (*(_BYTE *)(v30 + 216))
    *(_BYTE *)(v30 + 182) = 1;
  if (a2)
    *(_DWORD *)(v37 + 16) = 2 - (*(_BYTE *)(a1 + 182) != 0);
  else
    *(_DWORD *)(v37 + 16) = 0;
  *(_DWORD *)(v37 + 28) = 0;
  *(_DWORD *)(v37 + 20) = 0;
  if (*(_BYTE *)(a1 + 182))
    result = 2 * *(_DWORD *)(a1 + 172);
  else
    result = *(_DWORD *)(a1 + 172);
  *(_DWORD *)(v37 + 24) = result;
  return result;
}

int __cdecl prepare_for_pass(int *a1) {
  int v1;      // eax
  int result;  // eax
  int v3;      // edx
  int v4;      // edx
  _DWORD *v5;  // edi
  int *v6;     // edx
  int v7;      // edx
  _DWORD *v8;  // edi
  int v9;      // edx
  _DWORD *v10; // edi
  int *v11;    // edx
  _DWORD *v12; // esi
  int *v13;    // ecx
  _DWORD *v14; // esi
  int *v15;    // ecx
  int *v16;    // ecx
  int *v17;    // edx
  int v18;     // esi
  int v19;     // ecx
  int v20;     // edi
  int *v21;    // edx
  int v22;     // esi
  int v23;     // ecx
  int v24;     // edi
  _DWORD *v25; // esi
  int *v26;    // ecx
  int *v27;    // edx
  int v28;     // esi
  int v29;     // ecx
  int v30;     // edi
  int v31;     // [esp+1Ch] [ebp-2Ch]
  int v32;     // [esp+1Ch] [ebp-2Ch]
  int v33;     // [esp+1Ch] [ebp-2Ch]
  int v34;     // [esp+2Ch] [ebp-1Ch]
  int v35;     // [esp+2Ch] [ebp-1Ch]
  int k;       // [esp+2Ch] [ebp-1Ch]
  int i;       // [esp+2Ch] [ebp-1Ch]
  int v38;     // [esp+2Ch] [ebp-1Ch]
  int j;       // [esp+2Ch] [ebp-1Ch]
  int v40;     // [esp+30h] [ebp-18h]
  int v41;     // [esp+34h] [ebp-14h]
  int v42;     // [esp+38h] [ebp-10h]
  int v43;     // [esp+3Ch] [ebp-Ch]

  v40 = a1[80];
  v1 = *(_DWORD *)(v40 + 16);
  if (v1 == 1) {
    v7 = a1[44];
    if (v7) {
      v8 = (_DWORD *)(v7 + 36 * *(_DWORD *)(v40 + 28));
      a1[58] = *v8;
      if ((int)*v8 > 0) {
        v14 = v8;
        v15 = a1;
        v42 = 0;
        v35 = a1[18];
        do {
          v15[59] = v35 + 84 * v14[1];
          ++v42;
          ++v14;
          ++v15;
        } while (*v8 > v42);
      }
      a1[76] = v8[5];
      a1[77] = v8[6];
      a1[78] = v8[7];
      a1[79] = v8[8];
    } else {
      if (a1[16] > 4) {
        *(_DWORD *)(*a1 + 20) = 26;
        *(_DWORD *)(*a1 + 24) = a1[16];
        *(_DWORD *)(*a1 + 28) = 4;
        (*(void(__cdecl **)(int *)) * a1)(a1);
      }
      v32 = a1[16];
      a1[58] = v32;
      if (a1[16] > 0) {
        v21 = a1;
        v22 = 0;
        v23 = 0;
        v24 = a1[18];
        for (i = v24;; v24 = i) {
          v21[59] = v23 + v24;
          ++v22;
          v23 += 84;
          ++v21;
          if (v22 >= v32)
            break;
        }
      }
      a1[76] = 0;
      a1[77] = 63;
      a1[78] = 0;
      a1[79] = 0;
    }
    per_scan_setup(a1);
    if (a1[76]) {
      v16 = a1;
    } else {
      if (a1[78] && !*((_BYTE *)a1 + 181)) {
        *(_DWORD *)(v40 + 16) = 2;
        ++*(_DWORD *)(v40 + 20);
      LABEL_21:
        if (*((_BYTE *)a1 + 182)) {
          v11 = a1;
        } else {
          v9 = a1[44];
          if (v9) {
            v10 = (_DWORD *)(v9 + 36 * *(_DWORD *)(a1[80] + 28));
            a1[58] = *v10;
            if ((int)*v10 > 0) {
              v25 = v10;
              v26 = a1;
              v43 = 0;
              v38 = a1[18];
              do {
                v26[59] = v38 + 84 * v25[1];
                ++v43;
                ++v25;
                ++v26;
              } while (v43 < *v10);
            }
            a1[76] = v10[5];
            a1[77] = v10[6];
            a1[78] = v10[7];
            a1[79] = v10[8];
          } else {
            if (a1[16] > 4) {
              *(_DWORD *)(*a1 + 20) = 26;
              *(_DWORD *)(*a1 + 24) = a1[16];
              *(_DWORD *)(*a1 + 28) = 4;
              (*(void(__cdecl **)(int *)) * a1)(a1);
            }
            v33 = a1[16];
            a1[58] = v33;
            if (a1[16] > 0) {
              v27 = a1;
              v28 = 0;
              v29 = 0;
              v30 = a1[18];
              for (j = v30;; v30 = j) {
                v27[59] = v29 + v30;
                ++v28;
                v29 += 84;
                ++v27;
                if (v28 >= v33)
                  break;
              }
            }
            a1[76] = 0;
            a1[77] = 63;
            a1[78] = 0;
            a1[79] = 0;
          }
          per_scan_setup(a1);
          v11 = a1;
        }
        (*(void(__cdecl **)(int *, _DWORD))v11[88])(v11, 0);
        (*(void(__cdecl **)(int *, int))a1[83])(a1, 2);
        if (!*(_DWORD *)(v40 + 28))
          (*(void(__cdecl **)(int *))(a1[84] + 4))(a1);
        (*(void(__cdecl **)(int *))(a1[84] + 8))(a1);
        *(_BYTE *)(v40 + 12) = 0;
        goto LABEL_5;
      }
      v16 = a1;
    }
    (*(void(__cdecl **)(int *, int))v16[88])(v16, 1);
    (*(void(__cdecl **)(int *, int))a1[83])(a1, 2);
    *(_BYTE *)(v40 + 12) = 0;
    goto LABEL_5;
  }
  if (v1) {
    if (v1 != 2) {
      *(_DWORD *)(*a1 + 20) = 48;
      (*(void(__cdecl **)(int *)) * a1)(a1);
      goto LABEL_5;
    }
    goto LABEL_21;
  }
  v4 = a1[44];
  if (v4) {
    v5 = (_DWORD *)(v4 + 36 * *(_DWORD *)(v40 + 28));
    a1[58] = *v5;
    if ((int)*v5 > 0) {
      v12 = v5;
      v13 = a1;
      v41 = 0;
      v34 = a1[18];
      do {
        v13[59] = v34 + 84 * v12[1];
        ++v41;
        ++v12;
        ++v13;
      } while (v41 < *v5);
    }
    a1[76] = v5[5];
    a1[77] = v5[6];
    a1[78] = v5[7];
    a1[79] = v5[8];
  } else {
    if (a1[16] > 4) {
      *(_DWORD *)(*a1 + 20) = 26;
      *(_DWORD *)(*a1 + 24) = a1[16];
      *(_DWORD *)(*a1 + 28) = 4;
      (*(void(__cdecl **)(int *)) * a1)(a1);
    }
    v31 = a1[16];
    a1[58] = v31;
    if (a1[16] > 0) {
      v17 = a1;
      v18 = 0;
      v19 = 0;
      v20 = a1[18];
      for (k = v20;; v20 = k) {
        v17[59] = v19 + v20;
        ++v18;
        v19 += 84;
        ++v17;
        if (v18 >= v31)
          break;
      }
    }
    a1[76] = 0;
    a1[77] = 63;
    a1[78] = 0;
    a1[79] = 0;
  }
  per_scan_setup(a1);
  v6 = a1;
  if (!*((_BYTE *)a1 + 180)) {
    (*(void(__cdecl **)(int *))a1[85])(a1);
    (*(void(__cdecl **)(int *))a1[86])(a1);
    (*(void(__cdecl **)(int *, _DWORD))a1[82])(a1, 0);
    v6 = a1;
  }
  (*(void(__cdecl **)(int *))v6[87])(v6);
  (*(void(__cdecl **)(int *, _DWORD))a1[88])(a1,
                                             *((unsigned __int8 *)a1 + 182));
  (*(void(__cdecl **)(int *, int))a1[83])(a1, 3 * (*(_DWORD *)(v40 + 24) >= 2));
  (*(void(__cdecl **)(int *, _DWORD))a1[81])(a1, 0);
  *(_BYTE *)(v40 + 12) = *((_BYTE *)a1 + 182) == 0;
LABEL_5:
  result = *(_DWORD *)(v40 + 24) - 1;
  *(_BYTE *)(v40 + 13) = *(_DWORD *)(v40 + 20) == result;
  v3 = a1[2];
  if (v3) {
    *(_DWORD *)(v3 + 12) = *(_DWORD *)(v40 + 20);
    result = *(_DWORD *)(v40 + 24);
    *(_DWORD *)(a1[2] + 16) = result;
  }
  return result;
}

int __cdecl start_pass_prep(_DWORD *a1, int a2) {
  _DWORD *v2; // esi
  int result; // eax

  v2 = (_DWORD *)a1[82];
  if (a2) {
    *(_DWORD *)(*a1 + 20) = 4;
    (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
  }
  v2[12] = a1[10];
  v2[13] = 0;
  v2[14] = 0;
  result = 2 * a1[56];
  v2[15] = result;
  return result;
}

int __cdecl jinit_c_prep_controller(int a1, char a2) {
  _DWORD *v2;  // edx
  int result;  // eax
  int v4;      // esi
  _DWORD *v5;  // edi
  int j;       // edx
  int v7;      // esi
  char *v8;    // esi
  int v9;      // edi
  int i;       // edx
  _DWORD *v11; // [esp+1Ch] [ebp-7Ch]
  int v12;     // [esp+5Ch] [ebp-3Ch]
  int v13;     // [esp+64h] [ebp-34h]
  int v14;     // [esp+68h] [ebp-30h]
  int v15;     // [esp+6Ch] [ebp-2Ch]
  char *v16;   // [esp+70h] [ebp-28h]
  int v17;     // [esp+74h] [ebp-24h]
  int v18;     // [esp+78h] [ebp-20h]
  int v19;     // [esp+7Ch] [ebp-1Ch]

  if (a2) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  v2 = (_DWORD *)(**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 64);
  *(_DWORD *)(a1 + 328) = v2;
  *v2 = start_pass_prep;
  if (*(_BYTE *)(*(_DWORD *)(a1 + 344) + 8)) {
    v2[1] = pre_process_context;
    v7 = *(_DWORD *)(a1 + 328);
    v13 = *(_DWORD *)(a1 + 224);
    v17 = (**(int(__cdecl ***)(int, int, int))(a1 + 4))(
        a1, 1, 20 * *(_DWORD *)(a1 + 64) * v13);
    result = *(_DWORD *)(a1 + 72);
    v15 = result;
    if (*(int *)(a1 + 64) > 0) {
      v18 = 4 * v13;
      v19 = v7;
      v14 = 0;
      do {
        v16 = (char *)(*(int(__cdecl **)(int, int, int, int))(
            *(_DWORD *)(a1 + 4) + 8))(a1, 1,
                                      8 * *(_DWORD *)(a1 + 220) *
                                          *(_DWORD *)(v15 + 28) /
                                          *(_DWORD *)(v15 + 8),
                                      3 * v13);
        memcpy((void *)(v18 + v17), v16, 12 * v13);
        if (v13 > 0) {
          v8 = &v16[8 * v13];
          v11 = (_DWORD *)(v17 + 16 * v13);
          v9 = 0;
          for (i = v17;; i = v17) {
            *(_DWORD *)(i + 4 * v9) = *(_DWORD *)v8;
            *v11 = *(_DWORD *)&v16[4 * v9++];
            v8 += 4;
            ++v11;
            if (v13 == v9)
              break;
          }
        }
        *(_DWORD *)(v19 + 8) = v18 + v17;
        result = 20 * v13;
        v17 += 20 * v13;
        ++v14;
        v15 += 84;
        v19 += 4;
      } while (*(_DWORD *)(a1 + 64) > v14);
    }
  } else {
    v2[1] = pre_process_data;
    result = a1;
    v4 = *(_DWORD *)(a1 + 72);
    if (*(int *)(a1 + 64) > 0) {
      v5 = v2;
      v12 = 0;
      for (j = a1;; j = a1) {
        v5[2] =
            (*(int(__cdecl **)(int, int, int, _DWORD))(*(_DWORD *)(j + 4) + 8))(
                a1, 1,
                8 * *(_DWORD *)(a1 + 220) * *(_DWORD *)(v4 + 28) /
                    *(_DWORD *)(v4 + 8),
                *(_DWORD *)(a1 + 224));
        ++v12;
        v4 += 84;
        ++v5;
        result = v12;
        if (v12 >= *(_DWORD *)(a1 + 64))
          break;
      }
    }
  }
  return result;
}

_DWORD *__cdecl pre_process_context(_DWORD *a1, int a2, unsigned int *a3,
                                    unsigned int a4, int a5, _DWORD *a6,
                                    _DWORD *a7) {
  _DWORD *result;   // eax
  unsigned int v8;  // esi
  int v9;           // eax
  int v10;          // edx
  int v11;          // edi
  int v12;          // esi
  int j;            // edx
  int v14;          // eax
  int v15;          // edx
  unsigned int v16; // eax
  unsigned int v17; // eax
  int v18;          // edx
  _DWORD *v19;      // edi
  _DWORD *v20;      // edx
  int v21;          // esi
  _DWORD *i;        // ecx
  int v23;          // eax
  int v24;          // [esp+2Ch] [ebp-2Ch]
  int v25;          // [esp+30h] [ebp-28h]
  _DWORD *v26;      // [esp+34h] [ebp-24h]
  int v27;          // [esp+38h] [ebp-20h]
  size_t __n;       // [esp+3Ch] [ebp-1Ch]
  int v29;          // [esp+40h] [ebp-18h]
  _DWORD *v30;      // [esp+44h] [ebp-14h]
  unsigned int v31; // [esp+48h] [ebp-10h]
  int v32;          // [esp+4Ch] [ebp-Ch]

  v26 = (_DWORD *)a1[82];
  v25 = 3 * a1[56];
LABEL_2:
  result = a7;
  while (*a6 < (unsigned int)a7) {
    v8 = *a3;
    if (*a3 < a4) {
      v15 = v26[13];
      v16 = v26[15] - v15;
      if (a4 - v8 <= v16)
        v16 = a4 - v8;
      v31 = v16;
      (*(void(__cdecl **)(_DWORD *, unsigned int, _DWORD *, int, unsigned int))(
          a1[85] + 4))(a1, a2 + 4 * v8, v26 + 2, v15, v16);
      if (v26[12] == a1[10] && (int)a1[16] > 0) {
        v19 = v26;
        v27 = 0;
        v20 = a1;
        do {
          if ((int)v20[56] > 0) {
            v21 = 2;
            for (i = a1;; i = a1) {
              jcopy_sample_rows(v19[2], 0, v19[2], 1 - v21, 1, i[9]);
              v23 = v21++;
              v20 = a1;
              if (v23 > a1[56])
                break;
            }
          }
          ++v27;
          ++v19;
        } while (v20[16] > v27);
      }
      *a3 += v31;
      v17 = v26[13] + v31;
      v26[13] = v17;
      v26[12] -= v31;
      if (v17 != v26[15])
        goto LABEL_2;
    } else {
      result = v26;
      if (v26[12])
        return result;
      v9 = v26[13];
      if (v9 >= v26[15])
        goto LABEL_16;
      if ((int)a1[16] > 0) {
        v30 = v26;
        v32 = 0;
        v10 = v26[15];
        while (1) {
          __n = a1[9];
          v11 = v30[2];
          if (v10 <= v9) {
            ++v32;
            ++v30;
            if (v32 >= a1[16])
              goto LABEL_15;
          } else {
            v29 = v9 - 1;
            v12 = v9;
            v24 = v10;
            for (j = v9 - 1;; j = v29) {
              jcopy_sample_rows(v11, j, v11, v12++, 1, __n);
              if (v24 == v12)
                break;
            }
            v10 = v26[15];
            ++v32;
            ++v30;
            if (v32 >= a1[16]) {
            LABEL_15:
              v26[13] = v10;
              v9 = v10;
              goto LABEL_16;
            }
          }
          v9 = v26[13];
        }
      }
      v18 = v26[15];
      v26[13] = v18;
      v9 = v18;
    LABEL_16:
      if (v9 != v26[15])
        goto LABEL_2;
    }
    (*(void(__cdecl **)(_DWORD *, _DWORD *, _DWORD, int, _DWORD))(a1[86] + 4))(
        a1, v26 + 2, v26[14], a5, *a6);
    ++*a6;
    v14 = 0;
    if (v25 > a1[56] + v26[14])
      v14 = a1[56] + v26[14];
    v26[14] = v14;
    if (v25 <= v26[13])
      v26[13] = 0;
    v26[15] = a1[56] + v26[13];
    result = a7;
  }
  return result;
}

_DWORD *__cdecl pre_process_data(_DWORD *a1, int a2, unsigned int *a3,
                                 unsigned int a4, int a5, unsigned int *a6,
                                 unsigned int a7) {
  _DWORD *result;   // eax
  unsigned int v8;  // edi
  int v9;           // edx
  unsigned int v10; // esi
  int v11;          // edx
  int v12;          // ecx
  unsigned int v13; // eax
  int v14;          // eax
  _DWORD *i;        // edx
  int v16;          // edi
  int v17;          // esi
  int v18;          // edx
  int v19;          // edi
  int v20;          // esi
  int j;            // ecx
  int v22;          // eax
  int v23;          // [esp+20h] [ebp-38h]
  int v24;          // [esp+24h] [ebp-34h]
  _DWORD *v25;      // [esp+2Ch] [ebp-2Ch]
  int v26;          // [esp+30h] [ebp-28h]
  int v27;          // [esp+34h] [ebp-24h]
  size_t __n;       // [esp+38h] [ebp-20h]
  int v29;          // [esp+3Ch] [ebp-1Ch]
  int v30;          // [esp+40h] [ebp-18h]
  int v31;          // [esp+44h] [ebp-14h]
  _DWORD *v32;      // [esp+48h] [ebp-10h]
  int v33;          // [esp+4Ch] [ebp-Ch]

  result = (_DWORD *)a1[82];
  v25 = result;
  while (1) {
    v8 = *a3;
    if (*a3 >= a4)
      return result;
    result = (_DWORD *)a7;
    if (*a6 >= a7)
      return result;
    v9 = v25[13];
    v10 = a4 - v8;
    if (a4 - v8 > a1[56] - v9)
      v10 = a1[56] - v9;
    (*(void(__cdecl **)(_DWORD *, unsigned int, _DWORD *, int, unsigned int))(
        a1[85] + 4))(a1, a2 + 4 * v8, v25 + 2, v9, v10);
    *a3 += v10;
    v11 = v25[13] + v10;
    v12 = v11;
    v25[13] = v11;
    v13 = v25[12] - v10;
    v25[12] = v13;
    if (!v13 && v11 < a1[56]) {
      if ((int)a1[16] > 0) {
        v32 = v25;
        v26 = 0;
        v14 = a1[56];
        for (i = v25;; i = v32) {
          __n = a1[9];
          v16 = i[2];
          if (v14 <= v12) {
            ++v26;
            ++v32;
            if (v26 >= a1[16])
              goto LABEL_16;
          } else {
            v31 = v12 - 1;
            v17 = v12;
            v24 = v14;
            do
              jcopy_sample_rows(v16, v31, v16, v17++, 1, __n);
            while (v17 != v24);
            v14 = a1[56];
            ++v26;
            ++v32;
            if (v26 >= a1[16]) {
            LABEL_16:
              v25[13] = v14;
              v12 = v14;
              goto LABEL_17;
            }
          }
          v12 = v25[13];
        }
      }
      v22 = a1[56];
      v25[13] = v22;
      v12 = v22;
    }
  LABEL_17:
    if (v12 == a1[56]) {
      (*(void(__cdecl **)(_DWORD *, _DWORD *, _DWORD, int, unsigned int))(
          a1[86] + 4))(a1, v25 + 2, 0, a5, *a6);
      v25[13] = 0;
      ++*a6;
    }
    result = (_DWORD *)v25[12];
    if (!result) {
      result = a6;
      if (a7 > *a6) {
        v27 = a1[18];
        if ((int)a1[16] > 0) {
          v33 = 0;
          do {
            v18 = *a6 * *(_DWORD *)(v27 + 12);
            v29 = 8 * *(_DWORD *)(v27 + 28);
            v19 = *(_DWORD *)(a5 + 4 * v33);
            if ((int)(*(_DWORD *)(v27 + 12) * a7) > v18) {
              v30 = v18 - 1;
              v20 = *a6 * *(_DWORD *)(v27 + 12);
              v23 = *(_DWORD *)(v27 + 12) * a7;
              for (j = v18 - 1;; j = v30) {
                jcopy_sample_rows(v19, j, v19, v20++, 1, v29);
                if (v23 == v20)
                  break;
              }
            }
            ++v33;
            v27 += 84;
          } while (v33 < a1[16]);
        }
        result = a6;
        *a6 = a7;
        return result;
      }
    }
  }
}

_DWORD *__cdecl rgb_ycc_start(int a1) {
  int v1;         // esi
  _DWORD *result; // eax
  int v3;         // edi
  int v4;         // esi
  int v5;         // ecx
  char *v6;       // [esp+1Ch] [ebp-2Ch]
  int v7;         // [esp+2Ch] [ebp-1Ch]
  int v8;         // [esp+30h] [ebp-18h]
  int v9;         // [esp+34h] [ebp-14h]
  int v10;        // [esp+38h] [ebp-10h]
  int v11;        // [esp+3Ch] [ebp-Ch]

  v1 = *(_DWORD *)(a1 + 340);
  result =
      (_DWORD *)(**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 0x2000);
  *(_DWORD *)(v1 + 8) = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0x8000;
  v11 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = (char *)&unk_807FFF;
  do {
    *result = v8;
    result[256] = v9;
    result[512] = v10;
    result[768] = v11;
    result[1024] = v3;
    result[1280] = v6;
    result[1536] = v4;
    result[1792] = v5;
    ++v7;
    ++result;
    v6 += 0x8000;
    v8 += 19595;
    v9 += 38470;
    v10 += 7471;
    v11 -= 11059;
    v3 -= 21709;
    v4 -= 27439;
    v5 -= 5329;
  } while (v7 != 256);
  return result;
}

int __cdecl rgb_ycc_convert(int a1, unsigned __int8 **a2, _DWORD *a3, int a4,
                            int a5) {
  int result;          // eax
  unsigned __int8 *v6; // edi
  int v7;              // edx
  int v8;              // ecx
  int v9;              // esi
  _DWORD *v10;         // esi
  _DWORD *v11;         // [esp+0h] [ebp-2Ch]
  int v12;             // [esp+4h] [ebp-28h]
  int v13;             // [esp+8h] [ebp-24h]
  int v14;             // [esp+Ch] [ebp-20h]
  int v15;             // [esp+10h] [ebp-1Ch]
  int v16;             // [esp+14h] [ebp-18h]
  int j;               // [esp+18h] [ebp-14h]
  int v18;             // [esp+1Ch] [ebp-10h]
  int v19;             // [esp+20h] [ebp-Ch]
  int i;               // [esp+44h] [ebp+18h]

  v13 = *(_DWORD *)(*(_DWORD *)(a1 + 340) + 8);
  v18 = *(_DWORD *)(a1 + 36);
  result = 4 * a4;
  v19 = 4 * a4;
  for (i = a5 - 1; i >= 0; --i) {
    v6 = *a2++;
    v14 = *(_DWORD *)(*a3 + v19);
    v15 = *(_DWORD *)(a3[1] + v19);
    v16 = *(_DWORD *)(a3[2] + v19);
    result = v18;
    if (v18) {
      for (j = 0; j != v18; ++j) {
        v7 = v6[2];
        v8 = v6[1];
        v9 = *v6;
        v6 += 3;
        v11 = (_DWORD *)(v13 + 4 * v8);
        v10 = (_DWORD *)(v13 + 4 * v9);
        *(_BYTE *)(v14 + j) =
            (unsigned int)(v10[512] + v11[256] + *(_DWORD *)(v13 + 4 * v7)) >>
            16;
        v12 = v13 + 4 * v7;
        *(_BYTE *)(v15 + j) =
            (unsigned int)(v10[1280] + v11[1024] + *(_DWORD *)(v12 + 3072)) >>
            16;
        result = (v10[1792] + v11[1536] + *(_DWORD *)(v12 + 5120)) >> 16;
        *(_BYTE *)(v16 + j) = result;
      }
    }
    v19 += 4;
  }
  return result;
}

int __cdecl rgb_gray_convert(int a1, unsigned __int8 **a2, _DWORD *a3, int a4,
                             int a5) {
  int result;          // eax
  unsigned __int8 *v6; // esi
  int j;               // edi
  int v8;              // eax
  int v9;              // [esp+0h] [ebp-20h]
  int v10;             // [esp+4h] [ebp-1Ch]
  int v11;             // [esp+8h] [ebp-18h]
  int v12;             // [esp+Ch] [ebp-14h]
  int v13;             // [esp+10h] [ebp-10h]
  int v14;             // [esp+14h] [ebp-Ch]
  int i;               // [esp+38h] [ebp+18h]

  v11 = *(_DWORD *)(*(_DWORD *)(a1 + 340) + 8);
  v13 = *(_DWORD *)(a1 + 36);
  result = 4 * a4;
  v14 = 4 * a4;
  for (i = a5 - 1; i >= 0; --i) {
    v6 = *a2++;
    result = *(_DWORD *)(*a3 + v14);
    v12 = result;
    if (v13) {
      for (j = 0; j != v13; ++j) {
        v8 = v6[2];
        v10 = v6[1];
        v9 = *v6;
        v6 += 3;
        result =
            (*(_DWORD *)(v11 + 4 * v9 + 2048) +
             *(_DWORD *)(v11 + 4 * v10 + 1024) + *(_DWORD *)(v11 + 4 * v8)) >>
            16;
        *(_BYTE *)(v12 + j) = result;
      }
    }
    v14 += 4;
  }
  return result;
}

int __cdecl cmyk_ycck_convert(int a1, unsigned __int8 **a2, _DWORD *a3, int a4,
                              int a5) {
  int result;           // eax
  int j;                // edi
  int v7;               // esi
  int v8;               // ecx
  _DWORD *v9;           // esi
  _DWORD *v10;          // [esp+0h] [ebp-34h]
  int v11;              // [esp+8h] [ebp-2Ch]
  int v12;              // [esp+8h] [ebp-2Ch]
  int v13;              // [esp+Ch] [ebp-28h]
  unsigned __int8 *v14; // [esp+10h] [ebp-24h]
  int v15;              // [esp+14h] [ebp-20h]
  int v16;              // [esp+18h] [ebp-1Ch]
  int v17;              // [esp+1Ch] [ebp-18h]
  int v18;              // [esp+20h] [ebp-14h]
  int v19;              // [esp+24h] [ebp-10h]
  int v20;              // [esp+28h] [ebp-Ch]
  int i;                // [esp+4Ch] [ebp+18h]

  v13 = *(_DWORD *)(*(_DWORD *)(a1 + 340) + 8);
  v19 = *(_DWORD *)(a1 + 36);
  result = 4 * a4;
  v20 = 4 * a4;
  for (i = a5 - 1; i >= 0; --i) {
    v14 = *a2++;
    v15 = *(_DWORD *)(*a3 + v20);
    v16 = *(_DWORD *)(a3[1] + v20);
    v17 = *(_DWORD *)(a3[2] + v20);
    result = *(_DWORD *)(v20 + a3[3]);
    v18 = result;
    if (v19) {
      for (j = 0; j != v19; ++j) {
        v11 = 255 - *v14;
        v7 = 255 - v14[1];
        v8 = 255 - v14[2];
        *(_BYTE *)(v18 + j) = v14[3];
        v14 += 4;
        v11 *= 4;
        v9 = (_DWORD *)(v13 + 4 * v7);
        v10 = (_DWORD *)(v13 + 4 * v8);
        *(_BYTE *)(v15 + j) =
            (unsigned int)(v10[512] + v9[256] + *(_DWORD *)(v13 + v11)) >> 16;
        v12 = v13 + v11;
        *(_BYTE *)(v16 + j) =
            (unsigned int)(v10[1280] + v9[1024] + *(_DWORD *)(v12 + 3072)) >>
            16;
        result = (v10[1792] + v9[1536] + *(_DWORD *)(v12 + 5120)) >> 16;
        *(_BYTE *)(v17 + j) = result;
      }
    }
    v20 += 4;
  }
  return result;
}

int __cdecl grayscale_convert_0(int a1, unsigned __int8 **a2, _DWORD *a3,
                                int a4, int a5) {
  int result;          // eax
  int v6;              // edi
  unsigned __int8 *v7; // ecx
  int v8;              // esi
  int j;               // edx
  int v10;             // [esp+0h] [ebp-10h]
  int v11;             // [esp+4h] [ebp-Ch]
  int i;               // [esp+28h] [ebp+18h]

  v10 = *(_DWORD *)(a1 + 36);
  result = *(_DWORD *)(a1 + 44);
  v11 = result;
  v6 = 4 * a4;
  for (i = a5 - 1; i >= 0; --i) {
    v7 = *a2++;
    v8 = *(_DWORD *)(*a3 + v6);
    result = v10;
    if (v10) {
      for (j = 0; j != v10; ++j) {
        result = *v7;
        *(_BYTE *)(v8 + j) = result;
        v7 += v11;
      }
    }
    v6 += 4;
  }
  return result;
}

int __cdecl null_convert_0(int a1, int a2, int a3, int a4, int a5) {
  int result; // eax
  int i;      // edi
  int v7;     // ecx
  int v8;     // esi
  int j;      // edx
  int v10;    // [esp+0h] [ebp-18h]
  int v11;    // [esp+4h] [ebp-14h]
  int v12;    // [esp+8h] [ebp-10h]
  int v13;    // [esp+Ch] [ebp-Ch]

  v10 = *(_DWORD *)(a1 + 64);
  v11 = *(_DWORD *)(a1 + 36);
  result = a5 - 1;
  if (a5 - 1 >= 0) {
    v13 = 4 * a4;
    v12 = 0;
    do {
      if (v10 > 0) {
        for (i = 0; i != v10; ++i) {
          v7 = *(_DWORD *)(a2 + 4 * v12);
          v8 = *(_DWORD *)(*(_DWORD *)(a3 + 4 * i) + v13);
          if (v11) {
            for (j = 0; j != v11; ++j) {
              *(_BYTE *)(v8 + j) = *(_BYTE *)(v7 + i);
              v7 += v10;
            }
          }
        }
      }
      ++v12;
      v13 += 4;
      result = a5;
    } while (v12 != a5);
  }
  return result;
}

void null_method() { ; }

void *__cdecl jinit_color_converter(int a1) {
  _DWORD *v1;   // edi
  int v2;       // edx
  void *result; // eax
  int v4;       // eax
  int v5;       // eax
  int v6;       // eax

  v1 = (_DWORD *)(**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 12);
  *(_DWORD *)(a1 + 340) = v1;
  *v1 = null_method;
  switch (*(_DWORD *)(a1 + 48)) {
  case 1:
    if (*(_DWORD *)(a1 + 44) != 1)
      goto LABEL_10;
    break;
  case 2:
  case 3:
    if (*(_DWORD *)(a1 + 44) != 3)
      goto LABEL_10;
    break;
  case 4:
  case 5:
    if (*(_DWORD *)(a1 + 44) != 4)
      goto LABEL_10;
    break;
  default:
    if (*(int *)(a1 + 44) <= 0) {
    LABEL_10:
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 9;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    break;
  }
  v2 = *(_DWORD *)(a1 + 68);
  switch (v2) {
  case 1:
    if (*(_DWORD *)(a1 + 64) != 1) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 10;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v6 = *(_DWORD *)(a1 + 48);
    switch (v6) {
    case 1:
      goto LABEL_38;
    case 2:
      *v1 = rgb_ycc_start;
      result = rgb_gray_convert;
      v1[1] = rgb_gray_convert;
      break;
    case 3:
    LABEL_38:
      result = grayscale_convert_0;
      v1[1] = grayscale_convert_0;
      break;
    default:
      goto LABEL_19;
    }
    return result;
  case 2:
    if (*(_DWORD *)(a1 + 64) != 3) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 10;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    if (*(_DWORD *)(a1 + 48) != 2)
      goto LABEL_19;
    goto LABEL_6;
  case 3:
    if (*(_DWORD *)(a1 + 64) != 3) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 10;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v5 = *(_DWORD *)(a1 + 48);
    if (v5 == 2) {
      *v1 = rgb_ycc_start;
      result = rgb_ycc_convert;
      v1[1] = rgb_ycc_convert;
      return result;
    }
    if (v5 != 3)
      goto LABEL_19;
    goto LABEL_6;
  case 4:
    if (*(_DWORD *)(a1 + 64) != 4) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 10;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    if (*(_DWORD *)(a1 + 48) == 4)
      goto LABEL_6;
    goto LABEL_19;
  case 5:
    if (*(_DWORD *)(a1 + 64) != 4) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 10;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    v4 = *(_DWORD *)(a1 + 48);
    if (v4 == 4) {
      *v1 = rgb_ycc_start;
      result = cmyk_ycck_convert;
      v1[1] = cmyk_ycck_convert;
    } else if (v4 == 5) {
    LABEL_6:
      result = null_convert_0;
      v1[1] = null_convert_0;
    } else {
    LABEL_19:
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 27;
      return (void *)(**(int(__cdecl ***)(int))a1)(a1);
    }
    return result;
  default:
    if (v2 != *(_DWORD *)(a1 + 48) ||
        *(_DWORD *)(a1 + 64) != *(_DWORD *)(a1 + 44)) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 27;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    goto LABEL_6;
  }
}

void start_pass_downsample() { ; }

int __cdecl sep_downsample(_DWORD *a1, int a2, int a3, int a4, int a5) {
  int result; // eax
  int v6;     // esi
  int v7;     // edi
  int v8;     // [esp+2Ch] [ebp-Ch]

  result = a1[86];
  v6 = a1[18];
  if ((int)a1[16] > 0) {
    v7 = a1[86];
    v8 = 1;
    do {
      (*(void(__cdecl **)(_DWORD *, int, int, int))(v7 + 12))(
          a1, v6, *(_DWORD *)(a2 + 4 * v8 - 4) + 4 * a3,
          *(_DWORD *)(a4 + 4 * v8 - 4) + 4 * *(_DWORD *)(v6 + 12) * a5);
      result = v8;
      v6 += 84;
      ++v8;
      v7 += 4;
    } while (a1[16] > result);
  }
  return result;
}

int __cdecl int_downsample(_DWORD *a1, _DWORD *a2, int a3, int a4) {
  int result;          // eax
  int v5;              // esi
  _DWORD *v6;          // eax
  int v7;              // edi
  unsigned __int8 *v8; // edx
  int j;               // ecx
  int i;               // esi
  _BYTE *v11;          // eax
  char v12;            // cl
  int v13;             // edx
  int v14;             // [esp+4h] [ebp-38h]
  int v15;             // [esp+8h] [ebp-34h]
  int v16;             // [esp+Ch] [ebp-30h]
  int v17;             // [esp+10h] [ebp-2Ch]
  int v18;             // [esp+14h] [ebp-28h]
  int v19;             // [esp+1Ch] [ebp-20h]
  int v20;             // [esp+20h] [ebp-1Ch]
  int v21;             // [esp+24h] [ebp-18h]
  _BYTE *v22;          // [esp+28h] [ebp-14h]
  int v23;             // [esp+2Ch] [ebp-10h]
  _DWORD *v24;         // [esp+30h] [ebp-Ch]

  v21 = 8 * a2[7];
  v15 = a1[55] / a2[2];
  v16 = a1[56];
  v14 = v16 / a2[3];
  v23 = a1[9];
  if (v15 * v21 - v23 > 0 && v16 > 0) {
    for (i = 0; i != v16; ++i) {
      v11 = (_BYTE *)(*(_DWORD *)(a3 + 4 * i) + v23);
      v12 = *(v11 - 1);
      v13 = *(_DWORD *)(a3 + 4 * i) + v15 * v21;
      do
        *v11++ = v12;
      while (v11 != (_BYTE *)v13);
    }
  }
  result = a2[3];
  if (result > 0) {
    v17 = 0;
    v18 = 0;
    do {
      v22 = *(_BYTE **)(a4 + 4 * v18);
      result = v21;
      if (v21) {
        v19 = 0;
        v20 = 0;
        do {
          if (v14 <= 0) {
            v5 = 0;
          } else {
            v6 = (_DWORD *)(a3 + 4 * v17);
            v24 = v6;
            v7 = 0;
            v5 = 0;
            while (1) {
              v8 = (unsigned __int8 *)(*v6 + v20);
              if (v15 > 0) {
                for (j = 0; j != v15; ++j)
                  v5 += *v8++;
              }
              ++v7;
              ++v24;
              if (v14 == v7)
                break;
              v6 = v24;
            }
          }
          result = (v5 + v14 * v15 / 2) / (v14 * v15);
          *v22++ = result;
          ++v19;
          v20 += v15;
        } while (v21 != v19);
      }
      v17 += v14;
      ++v18;
    } while (a2[3] > v18);
  }
  return result;
}

int __cdecl jinit_downsampler(int a1) {
  int v1;     // esi
  int v2;     // edi
  int v3;     // edx
  int v4;     // ecx
  int v5;     // edx
  int result; // eax
  int v7;     // edi
  int v8;     // [esp+1Ch] [ebp-2Ch]
  int v9;     // [esp+20h] [ebp-28h]
  int v10;    // [esp+24h] [ebp-24h]
  char v11;   // [esp+2Bh] [ebp-1Dh]
  int v12;    // [esp+2Ch] [ebp-1Ch]

  v9 = (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 52);
  *(_DWORD *)(a1 + 344) = v9;
  *(_DWORD *)v9 = start_pass_downsample;
  *(_DWORD *)(v9 + 4) = sep_downsample;
  *(_BYTE *)(v9 + 8) = 0;
  if (*(_BYTE *)(a1 + 183)) {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 25;
    (**(void(__cdecl ***)(int))a1)(a1);
  }
  v1 = *(_DWORD *)(a1 + 72);
  if (*(int *)(a1 + 64) <= 0) {
    v11 = 1;
    v5 = a1;
    result = *(_DWORD *)(a1 + 184);
    if (result)
      goto LABEL_22;
    return result;
  }
  v12 = v9;
  v10 = 0;
  v11 = 1;
  do {
    while (1) {
      v3 = *(_DWORD *)(v1 + 8);
      v4 = *(_DWORD *)(a1 + 220);
      if (v3 == v4 && *(_DWORD *)(v1 + 12) == *(_DWORD *)(a1 + 224))
        break;
      if (v4 != 2 * v3)
        goto LABEL_6;
      v8 = *(_DWORD *)(v1 + 12);
      v7 = *(_DWORD *)(a1 + 224);
      if (v8 == v7) {
        *(_DWORD *)(v12 + 12) = h2v1_downsample;
        v11 = 0;
      } else {
        if (2 * v8 != v7) {
        LABEL_6:
          if (v4 % v3 || *(_DWORD *)(a1 + 224) % *(_DWORD *)(v1 + 12)) {
            *(_DWORD *)(*(_DWORD *)a1 + 20) = 38;
            (**(void(__cdecl ***)(int))a1)(a1);
          } else {
            *(_DWORD *)(v12 + 12) = int_downsample;
            v11 = 0;
          }
          goto LABEL_9;
        }
        if (*(_DWORD *)(a1 + 184)) {
          *(_DWORD *)(v12 + 12) = h2v2_smooth_downsample;
          *(_BYTE *)(v9 + 8) = 1;
        } else {
          *(_DWORD *)(v12 + 12) = h2v2_downsample;
        }
      }
    LABEL_9:
      ++v10;
      v1 += 84;
      v12 += 4;
      v2 = a1;
      if (v10 >= *(_DWORD *)(a1 + 64))
        goto LABEL_14;
    }
    if (*(_DWORD *)(a1 + 184)) {
      *(_DWORD *)(v12 + 12) = fullsize_smooth_downsample;
      *(_BYTE *)(v9 + 8) = 1;
      goto LABEL_9;
    }
    *(_DWORD *)(v12 + 12) = fullsize_downsample;
    ++v10;
    v1 += 84;
    v12 += 4;
    v2 = a1;
  } while (v10 < *(_DWORD *)(a1 + 64));
LABEL_14:
  v5 = v2;
  result = *(_DWORD *)(v2 + 184);
  if (!result)
    return result;
LABEL_22:
  if (!v11) {
    *(_DWORD *)(*(_DWORD *)v5 + 20) = 99;
    return (*(int(__cdecl **)(int, _DWORD))(*(_DWORD *)v5 + 4))(v5, 0);
  }
  return result;
}

int __cdecl fullsize_smooth_downsample(_DWORD *a1, int a2, int a3, int a4) {
  int result;           // eax
  int v5;               // edi
  _DWORD *v6;           // eax
  unsigned __int8 *v7;  // ecx
  int v8;               // edi
  int v9;               // ecx
  int v10;              // edx
  _BYTE *v11;           // edi
  _BYTE *v12;           // esi
  unsigned __int8 *j;   // edx
  int v14;              // ecx
  int v15;              // edi
  int i;                // esi
  _BYTE *v17;           // eax
  char v18;             // cl
  _BYTE *v19;           // edx
  _BYTE *v20;           // [esp+4h] [ebp-54h]
  int v21;              // [esp+8h] [ebp-50h]
  unsigned __int8 *v22; // [esp+Ch] [ebp-4Ch]
  int v23;              // [esp+10h] [ebp-48h]
  int v24;              // [esp+14h] [ebp-44h]
  int v25;              // [esp+18h] [ebp-40h]
  int v26;              // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 *v27; // [esp+28h] [ebp-30h]
  unsigned __int8 *v28; // [esp+2Ch] [ebp-2Ch]
  int v29;              // [esp+30h] [ebp-28h]
  int v30;              // [esp+34h] [ebp-24h]
  int v31;              // [esp+38h] [ebp-20h]
  int v32;              // [esp+3Ch] [ebp-1Ch]
  unsigned __int8 *v33; // [esp+40h] [ebp-18h]
  unsigned __int8 *v34; // [esp+44h] [ebp-14h]
  unsigned __int8 *v35; // [esp+48h] [ebp-10h]

  v21 = 8 * *(_DWORD *)(a2 + 28);
  v25 = a1[9];
  v26 = a1[56] + 2;
  if (v21 - v25 > 0 && v26 > 0) {
    for (i = 0; i != v26; ++i) {
      v17 = (_BYTE *)(*(_DWORD *)(a3 - 4 + 4 * i) + v25);
      v18 = *(v17 - 1);
      v19 = (_BYTE *)(*(_DWORD *)(a3 - 4 + 4 * i) + v21);
      do
        *v17++ = v18;
      while (v17 != v19);
    }
  }
  v23 = 0x10000 - (a1[46] << 9);
  v24 = a1[46] << 6;
  result = *(_DWORD *)(a2 + 12);
  if (result > 0) {
    v29 = 1;
    do {
      v6 = (_DWORD *)(a3 + 4 * v29);
      v22 = (unsigned __int8 *)*(v6 - 1);
      v7 = (unsigned __int8 *)*(v6 - 2);
      v8 = *v22;
      v30 = v8 + *(unsigned __int8 *)*v6 + *v7;
      v34 = v7 + 1;
      v33 = (unsigned __int8 *)(*v6 + 1);
      v35 = v22 + 1;
      v9 = *v33 + v7[1] + v22[1];
      v10 = (v8 * v23 + v24 * (v9 + v30 + v30 - v8) + 0x8000) >> 16;
      v11 = *(_BYTE **)(4 * v29 + a4 - 4);
      *v11 = v10;
      v12 = v11 + 1;
      if (v21 == 2) {
        v5 = v30;
      } else {
        v27 = v34;
        v28 = v33;
        v31 = v9;
        v32 = v30;
        v20 = &v12[v21 - 2];
        for (j = v34;; j = v27) {
          v14 = *v35++;
          v15 = v28[1] + j[1] + *v35;
          *v12++ = (unsigned int)(v14 * v23 + v24 * (v15 + v32 + v31 - v14) +
                                  0x8000) >>
                   16;
          ++v27;
          ++v28;
          v32 = v31;
          if (v20 == v12)
            break;
          v31 = v15;
        }
        v12 = v20;
        v9 = v15;
        v5 = v31;
      }
      *v12 =
          (*v35 * v23 + v24 * (v9 + v5 + v9 - (unsigned int)*v35) + 0x8000) >>
          16;
      result = v29++;
    } while (*(_DWORD *)(a2 + 12) > result);
  }
  return result;
}

int __cdecl fullsize_downsample(int a1, int a2, int a3, int a4) {
  int result; // eax
  int v5;     // edi
  int i;      // esi
  char v7;    // cl
  int v8;     // edx
  int v9;     // [esp+28h] [ebp-10h]
  int v10;    // [esp+2Ch] [ebp-Ch]

  jcopy_sample_rows(a3, 0, a4, 0, *(_DWORD *)(a1 + 224), *(_DWORD *)(a1 + 36));
  v9 = *(_DWORD *)(a1 + 36);
  v10 = *(_DWORD *)(a1 + 224);
  result = *(_DWORD *)(a2 + 28);
  v5 = 8 * result - v9;
  if (v5 > 0) {
    result = *(_DWORD *)(a1 + 224);
    if (v10 > 0) {
      for (i = 0; i != v10; ++i) {
        result = *(_DWORD *)(a4 + 4 * i) + v9;
        v7 = *(_BYTE *)(result - 1);
        v8 = result + v5;
        do
          *(_BYTE *)result++ = v7;
        while (result != v8);
      }
    }
  }
  return result;
}

int __cdecl h2v1_downsample(int a1, int a2, int a3, int a4) {
  int v4;              // eax
  int v5;              // edi
  int result;          // eax
  _BYTE *v7;           // esi
  unsigned __int8 *v8; // ecx
  int j;               // edi
  int i;               // esi
  _BYTE *v11;          // eax
  char v12;            // cl
  _BYTE *v13;          // edx
  int v14;             // [esp+0h] [ebp-1Ch]
  int v15;             // [esp+4h] [ebp-18h]
  int v16;             // [esp+8h] [ebp-14h]
  int v17;             // [esp+Ch] [ebp-10h]
  int v18;             // [esp+10h] [ebp-Ch]

  v4 = *(_DWORD *)(a2 + 28);
  v14 = 8 * v4;
  v16 = *(_DWORD *)(a1 + 36);
  v17 = *(_DWORD *)(a1 + 224);
  v5 = 16 * v4 - v16;
  if (v5 > 0 && v17 > 0) {
    for (i = 0; i != v17; ++i) {
      v11 = (_BYTE *)(*(_DWORD *)(a3 + 4 * i) + v16);
      v12 = *(v11 - 1);
      v13 = &v11[v5];
      do
        *v11++ = v12;
      while (v11 != v13);
    }
  }
  result = *(_DWORD *)(a2 + 12);
  if (result > 0) {
    v18 = 1;
    do {
      v7 = *(_BYTE **)(a4 + 4 * v18 - 4);
      v8 = *(unsigned __int8 **)(a3 + 4 * v18 - 4);
      if (v14) {
        v15 = 0;
        for (j = 0; j != v14; ++j) {
          *v7++ = (v15 + v8[1] + *v8) >> 1;
          v15 ^= 1u;
          v8 += 2;
        }
      }
      result = v18++;
    } while (*(_DWORD *)(a2 + 12) > result);
  }
  return result;
}

int __cdecl h2v2_smooth_downsample(_DWORD *a1, int a2, unsigned __int8 **a3,
                                   int a4) {
  int v4;                // eax
  int v5;                // edi
  int v6;                // edx
  int result;            // eax
  _BYTE *v8;             // eax
  unsigned __int8 *v9;   // edi
  unsigned __int8 *v10;  // ecx
  int v11;               // edx
  int v12;               // esi
  int i;                 // esi
  unsigned __int8 *v14;  // eax
  unsigned __int8 v15;   // cl
  unsigned __int8 *v16;  // edx
  unsigned __int8 *v17;  // [esp+4h] [ebp-64h]
  unsigned __int8 *v18;  // [esp+8h] [ebp-60h]
  unsigned __int8 *v19;  // [esp+Ch] [ebp-5Ch]
  int v20;               // [esp+18h] [ebp-50h]
  int v21;               // [esp+1Ch] [ebp-4Ch]
  int v22;               // [esp+24h] [ebp-44h]
  int v23;               // [esp+28h] [ebp-40h]
  int v24;               // [esp+2Ch] [ebp-3Ch]
  int v25;               // [esp+30h] [ebp-38h]
  int v26;               // [esp+3Ch] [ebp-2Ch]
  unsigned __int8 **v27; // [esp+44h] [ebp-24h]
  unsigned __int8 *v28;  // [esp+4Ch] [ebp-1Ch]
  unsigned __int8 *v29;  // [esp+50h] [ebp-18h]
  _BYTE *v30;            // [esp+54h] [ebp-14h]
  unsigned __int8 *v31;  // [esp+58h] [ebp-10h]
  unsigned __int8 *v32;  // [esp+5Ch] [ebp-Ch]

  v4 = *(_DWORD *)(a2 + 28);
  v21 = 8 * v4;
  v24 = a1[9];
  v25 = a1[56] + 2;
  v5 = 16 * v4 - v24;
  if (v5 > 0 && v25 > 0) {
    for (i = 0; i != v25; ++i) {
      v14 = &a3[i - 1][v24];
      v15 = *(v14 - 1);
      v16 = &v14[v5];
      do
        *v14++ = v15;
      while (v14 != v16);
    }
  }
  v6 = a1[46];
  result = 80 * v6;
  v22 = 0x4000 - 80 * v6;
  v23 = 16 * v6;
  if (*(int *)(a2 + 12) > 0) {
    v27 = a3;
    v20 = 0;
    do {
      v17 = v27[1];
      v18 = *(v27 - 1);
      v19 = v27[2];
      v32 = *v27 + 2;
      v31 = v17 + 2;
      v28 = v18 + 2;
      v29 = v19 + 2;
      v8 = *(_BYTE **)(a4 + 4 * v20);
      *v8 = (v22 * (v17[1] + *v17 + (*v27)[1] + **v27) +
             v23 * (v19[2] + *v18 + v18[2] + *v19 +
                    2 * (v17[2] + *v17 + *v32 + **v27 + v19[1] + *v19 + *v18 +
                         (unsigned int)v18[1])) +
             0x8000) >>
            16;
      v30 = v8 + 1;
      if (v21 != 2) {
        v26 = 0;
        do {
          v9 = &v32[2 * v26];
          v10 = &v28[2 * v26];
          v11 = v31[2 * v26 + 2] + v31[2 * v26 - 1] + v9[2] + *(v9 - 1) +
                v29[1] + *v29 + v10[1] + *v10;
          v12 = *(v29 - 1) + v10[2] + *(v10 - 1);
          v29 += 2;
          *v30++ = (v22 * (v31[2 * v26 + 1] + v31[2 * v26] + v9[1] + *v9) +
                    v23 * ((unsigned int)*v29 + v12 + 2 * v11) + 0x8000) >>
                   16;
          ++v26;
        } while (v26 != v21 - 2);
        v32 += 2 * v26;
        v31 += 2 * v26;
        v28 += 2 * v26;
      }
      *v30 = (v22 * (v31[1] + *v31 + v32[1] + *v32) +
              v23 * (*(v29 - 1) + *(v28 - 1) + v28[1] + v29[1] +
                     2 * (v31[1] + *(v31 - 1) + v32[1] + *(v32 - 1) + v29[1] +
                          *v29 + v28[1] + (unsigned int)*v28)) +
              0x8000) >>
             16;
      ++v20;
      v27 += 2;
      result = a2;
    } while (*(_DWORD *)(a2 + 12) > v20);
  }
  return result;
}

int __cdecl h2v2_downsample(int a1, int a2, unsigned __int8 **a3, int a4) {
  int v4;                // eax
  int v5;                // edi
  int result;            // eax
  unsigned __int8 **v7;  // eax
  _BYTE *v8;             // edi
  unsigned __int8 *v9;   // esi
  unsigned __int8 *v10;  // ecx
  int i;                 // esi
  unsigned __int8 *v12;  // eax
  unsigned __int8 v13;   // cl
  unsigned __int8 *v14;  // edx
  int v15;               // [esp+0h] [ebp-24h]
  int j;                 // [esp+4h] [ebp-20h]
  int v17;               // [esp+8h] [ebp-1Ch]
  int v18;               // [esp+Ch] [ebp-18h]
  int v19;               // [esp+10h] [ebp-14h]
  int v20;               // [esp+14h] [ebp-10h]
  unsigned __int8 **v21; // [esp+18h] [ebp-Ch]

  v4 = *(_DWORD *)(a2 + 28);
  v17 = 8 * v4;
  v19 = *(_DWORD *)(a1 + 36);
  v20 = *(_DWORD *)(a1 + 224);
  v5 = 16 * v4 - v19;
  if (v5 > 0 && v20 > 0) {
    for (i = 0; i != v20; ++i) {
      v12 = &a3[i][v19];
      v13 = *(v12 - 1);
      v14 = &v12[v5];
      do
        *v12++ = v13;
      while (v12 != v14);
    }
  }
  result = *(_DWORD *)(a2 + 12);
  if (result > 0) {
    v7 = a3;
    v21 = a3;
    v15 = 0;
    while (1) {
      v8 = *(_BYTE **)(a4 + 4 * v15);
      v9 = *v7;
      v10 = v7[1];
      if (v17) {
        v18 = 1;
        for (j = 0; j != v17; ++j) {
          *v8++ = (v18 + v10[1] + *v10 + v9[1] + *v9) >> 2;
          v18 ^= 3u;
          v9 += 2;
          v10 += 2;
        }
      }
      ++v15;
      v21 += 2;
      result = a2;
      if (*(_DWORD *)(a2 + 12) <= v15)
        break;
      v7 = v21;
    }
  }
  return result;
}

int __cdecl start_pass_fdctmgr(int a1) {
  int result;            // eax
  unsigned int v2;       // esi
  int v3;                // edx
  int v4;                // eax
  bool v5;               // cf
  int v6;                // eax
  int v7;                // esi
  unsigned __int16 *v8;  // edx
  int i;                 // ecx
  unsigned __int16 *v10; // ecx
  int v11;               // esi
  __int16 *v12;          // edi
  int v13;               // eax
  float *v14;            // edi
  unsigned __int16 *v15; // ecx
  float *v16;            // edx
  double *v17;           // esi
  double v18;            // xmm1_8
  float v19;             // xmm0_4
  int v20;               // [esp+20h] [ebp-38h]
  int v21;               // [esp+24h] [ebp-34h]
  int v22;               // [esp+28h] [ebp-30h]
  int v23;               // [esp+2Ch] [ebp-2Ch]
  int v24;               // [esp+30h] [ebp-28h]
  double *v25;           // [esp+38h] [ebp-20h]
  unsigned __int16 *v26; // [esp+3Ch] [ebp-1Ch]

  v20 = *(_DWORD *)(a1 + 348);
  v23 = *(_DWORD *)(a1 + 72);
  result = *(_DWORD *)(a1 + 64);
  if (result > 0) {
    v21 = 0;
    while (1) {
      v2 = *(_DWORD *)(v23 + 16);
      if (v2 > 3) {
        v3 = a1;
      } else {
        v3 = a1;
        if (*(_DWORD *)(a1 + 4 * v2 + 76)) {
          v26 = *(unsigned __int16 **)(a1 + 4 * v2 + 76);
          v4 = *(_DWORD *)(a1 + 188);
          v5 = v4 == 0;
          if (v4 == 1)
            goto LABEL_18;
          goto LABEL_9;
        }
      }
      *(_DWORD *)(*(_DWORD *)v3 + 20) = 52;
      *(_DWORD *)(*(_DWORD *)v3 + 24) = v2;
      (**(void(__cdecl ***)(int))v3)(v3);
      v26 = *(unsigned __int16 **)(a1 + 4 * v2 + 76);
      v4 = *(_DWORD *)(a1 + 188);
      v5 = v4 == 0;
      if (v4 == 1) {
      LABEL_18:
        if (!*(_DWORD *)(v20 + 4 * v2 + 12))
          *(_DWORD *)(v20 + 4 * v2 + 12) =
              (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 256);
        v24 = *(_DWORD *)(v20 + 4 * v2 + 12);
        v10 = v26;
        v11 = 1;
        v12 = (__int16 *)&aanscales_3680;
        do
          *(_DWORD *)(v24 + 4 * v11++ - 4) = (*v12++ * *v10++ + 1024) >> 11;
        while (v11 != 65);
        goto LABEL_5;
      }
    LABEL_9:
      if (v5) {
        v6 = v20;
        if (!*(_DWORD *)(v20 + 4 * v2 + 12)) {
          *(_DWORD *)(v20 + 4 * v2 + 12) =
              (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 256);
          v6 = v20;
        }
        v7 = *(_DWORD *)(v6 + 4 * v2 + 12);
        v8 = v26;
        for (i = 1; i != 65; ++i)
          *(_DWORD *)(v7 + 4 * i - 4) = 8 * *v8++;
        ++v21;
        v23 += 84;
        result = a1;
        if (v21 >= *(_DWORD *)(a1 + 64))
          return result;
      } else {
        if (v4 == 2) {
          v13 = v20;
          if (!*(_DWORD *)(v20 + 4 * v2 + 32)) {
            *(_DWORD *)(v20 + 4 * v2 + 32) =
                (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 256);
            v13 = v20;
          }
          v14 = *(float **)(v13 + 4 * v2 + 32);
          v22 = 0;
          v25 = (double *)&aanscalefactor_3688;
          do {
            v15 = &v26[v22];
            v16 = v14;
            v17 = (double *)&aanscalefactor_3688;
            v18 = *v25;
            do {
              v19 = 1.0 / ((double)*v15 * v18 * *v17 * 8.0);
              *v16 = v19;
              ++v15;
              ++v17;
              ++v16;
            } while (v17 != (double *)&aanscales_3680);
            v22 += 8;
            v14 += 8;
            ++v25;
          } while (v22 != 64);
        } else {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 48;
          (**(void(__cdecl ***)(int))a1)(a1);
        }
      LABEL_5:
        ++v21;
        v23 += 84;
        result = a1;
        if (v21 >= *(_DWORD *)(a1 + 64))
          return result;
      }
    }
  }
  return result;
}

int __cdecl forward_DCT(int a1, int a2, int a3, int a4, int a5, int a6,
                        int a7) {
  int v7;                        // edx
  int result;                    // eax
  _BYTE *v10;                    // ecx
  int i;                         // esi
  unsigned __int8 *v12;          // edx
  int v13;                       // edx
  int v14;                       // ecx
  int v15;                       // eax
  int v16;                       // eax
  int v17;                       // eax
  void(__cdecl * v18)(_DWORD *); // [esp+20h] [ebp-118h]
  int v19;                       // [esp+24h] [ebp-114h]
  int v20;                       // [esp+28h] [ebp-110h]
  int v21;                       // [esp+2Ch] [ebp-10Ch]
  _DWORD v22[8];                 // [esp+30h] [ebp-108h] BYREF
  _BYTE v23[232];                // [esp+50h] [ebp-E8h] BYREF

  v7 = *(_DWORD *)(a1 + 348);
  v18 = *(void(__cdecl **)(_DWORD *))(v7 + 8);
  v19 = *(_DWORD *)(v7 + 4 * *(_DWORD *)(a2 + 16) + 12);
  v21 = a3 + 4 * a5;
  result = a7;
  if (!a7)
    return result;
  v20 = 0;
  v10 = v23;
  while (2) {
    for (i = 1; i != 9; ++i) {
      v12 = (unsigned __int8 *)(*(_DWORD *)(v21 + 4 * i - 4) + a6);
      *((_DWORD *)v10 - 8) = *v12 - 128;
      *((_DWORD *)v10 - 7) = v12[1] - 128;
      *((_DWORD *)v10 - 6) = v12[2] - 128;
      *((_DWORD *)v10 - 5) = v12[3] - 128;
      *((_DWORD *)v10 - 4) = v12[4] - 128;
      *((_DWORD *)v10 - 3) = v12[5] - 128;
      *((_DWORD *)v10 - 2) = v12[6] - 128;
      *((_DWORD *)v10 - 1) = v12[7] - 128;
      v10 += 32;
    }
    v18(v22);
    LOWORD(i) = 1;
    do {
      v13 = *(_DWORD *)(v19 + 4 * i - 4);
      v14 = v22[i - 1];
      if (v14 < 0) {
        v17 = (v13 >> 1) - v14;
        if (v13 > v17) {
        LABEL_8:
          LOWORD(v16) = 0;
          goto LABEL_9;
        }
        v16 = -(v17 / v13);
      } else {
        v15 = v14 + (v13 >> 1);
        if (v13 > v15)
          goto LABEL_8;
        v16 = v15 / v13;
      }
    LABEL_9:
      *(_WORD *)(a4 + 2 * i++ - 2) = v16;
    } while (i != 65);
    ++v20;
    a6 += 8;
    a4 += 128;
    result = v20;
    if (a7 != v20) {
      v10 = v23;
      continue;
    }
    return result;
  }
}

__int16 __cdecl forward_DCT_float(int a1, int a2, int a3, int a4, int a5,
                                  int a6, int a7) {
  int v7;                                    // edx
  __int16 result;                            // ax
  float *i;                                  // ecx
  int j;                                     // edi
  unsigned __int8 *v12;                      // edx
  int k;                                     // edx
  int v14;                                   // [esp+1Ch] [ebp-13Ch]
  void(__thiscall * v15)(float *, _DWORD *); // [esp+30h] [ebp-128h]
  int v16;                                   // [esp+34h] [ebp-124h]
  int v17;                                   // [esp+3Ch] [ebp-11Ch]
  _DWORD v18[8];                             // [esp+40h] [ebp-118h] BYREF
  _BYTE v19[248];                            // [esp+60h] [ebp-F8h] BYREF

  v7 = *(_DWORD *)(a1 + 348);
  v15 = *(void(__thiscall **)(float *, _DWORD *))(v7 + 28);
  v14 = *(_DWORD *)(v7 + 4 * *(_DWORD *)(a2 + 16) + 32);
  v17 = a3 + 4 * a5;
  result = a7;
  if (a7) {
    v16 = 0;
    for (i = (float *)v19;; i = (float *)v19) {
      for (j = 1; j != 9; ++j) {
        v12 = (unsigned __int8 *)(*(_DWORD *)(v17 + 4 * j - 4) + a6);
        *(i - 8) = (float)(*v12 - 128);
        *(i - 7) = (float)(v12[1] - 128);
        *(i - 6) = (float)(v12[2] - 128);
        *(i - 5) = (float)(v12[3] - 128);
        *(i - 4) = (float)(v12[4] - 128);
        *(i - 3) = (float)(v12[5] - 128);
        *(i - 2) = (float)(v12[6] - 128);
        *(i - 1) = (float)(v12[7] - 128);
        i += 8;
      }
      v15(i, v18);
      for (k = 1; k != 65; ++k) {
        result = (int)(float)((float)(*(float *)&v18[k - 1] *
                                      *(float *)(v14 + 4 * k - 4)) +
                              16384.5) -
                 0x4000;
        *(_WORD *)(a4 + 2 * k - 2) = result;
      }
      ++v16;
      a6 += 8;
      a4 += 128;
      if (a7 == v16)
        break;
    }
  }
  return result;
}

int __cdecl start_pass_huff(int a1, char a2) {
  _DWORD *v2;       // edi
  void *v3;         // eax
  int i;            // edx
  unsigned int v5;  // eax
  unsigned int v6;  // edx
  int v7;           // eax
  unsigned int v8;  // esi
  int result;       // eax
  void *v10;        // eax
  int v11;          // [esp+20h] [ebp-28h]
  unsigned int v12; // [esp+24h] [ebp-24h]
  int v13;          // [esp+28h] [ebp-20h]
  _DWORD *v14;      // [esp+2Ch] [ebp-1Ch]

  v2 = *(_DWORD **)(a1 + 352);
  if (a2) {
    v2[1] = encode_mcu_gather;
    v3 = finish_pass_gather;
  } else {
    v2[1] = encode_mcu_huff;
    v3 = finish_pass_huff;
  }
  v2[2] = v3;
  if (*(int *)(a1 + 232) > 0) {
    v13 = a1;
    v14 = v2;
    v11 = 0;
    for (i = a1;; i = v13) {
      v7 = *(_DWORD *)(i + 236);
      v8 = *(_DWORD *)(v7 + 20);
      v12 = *(_DWORD *)(v7 + 24);
      if (a2)
        break;
      jpeg_make_c_derived_tbl((int(__cdecl ***)(_DWORD, _DWORD, _DWORD))a1, 1,
                              v8, &v2[v8 + 11]);
      jpeg_make_c_derived_tbl((int(__cdecl ***)(_DWORD, _DWORD, _DWORD))a1, 0,
                              v12, &v2[v12 + 15]);
    LABEL_12:
      v14[5] = 0;
      ++v11;
      v13 += 4;
      ++v14;
      if (v11 >= *(_DWORD *)(a1 + 232))
        goto LABEL_16;
    }
    if (v8 > 3) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 50;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = v8;
      (**(void(__cdecl ***)(int))a1)(a1);
    }
    if (v12 > 3) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 50;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = v12;
      (**(void(__cdecl ***)(int))a1)(a1);
      if (v2[v8 + 19]) {
      LABEL_9:
        memset((void *)v2[v8 + 19], 0, 0x404u);
        v5 = v12;
        if (v2[v12 + 23]) {
        LABEL_10:
          v6 = v5;
        LABEL_11:
          memset((void *)v2[v6 + 23], 0, 0x404u);
          goto LABEL_12;
        }
      LABEL_19:
        v2[v12 + 23] =
            (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1028);
        v6 = v12;
        goto LABEL_11;
      }
    } else if (v2[v8 + 19]) {
      goto LABEL_9;
    }
    v10 = (void *)(**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1028);
    v2[v8 + 19] = v10;
    memset(v10, 0, 0x404u);
    v5 = v12;
    if (v2[v12 + 23])
      goto LABEL_10;
    goto LABEL_19;
  }
LABEL_16:
  v2[3] = 0;
  v2[4] = 0;
  result = *(_DWORD *)(a1 + 192);
  v2[9] = result;
  v2[10] = 0;
  return result;
}

int __cdecl encode_mcu_gather(_DWORD *a1, int a2) {
  _DWORD *v2;   // edi
  _DWORD *v3;   // edx
  int v4;       // edx
  int v5;       // edi
  int v6;       // eax
  int v7;       // esi
  int v8;       // esi
  _DWORD *i;    // edx
  __int16 v10;  // ax
  int v11;      // edx
  int v12;      // eax
  int v13;      // eax
  int v14;      // edx
  int v15;      // eax
  int v16;      // edi
  int v17;      // eax
  int v19;      // edx
  int v20;      // eax
  int v21;      // [esp+1Ch] [ebp-3Ch]
  int v22;      // [esp+24h] [ebp-34h]
  _DWORD *v23;  // [esp+28h] [ebp-30h]
  __int16 *v24; // [esp+2Ch] [ebp-2Ch]
  char *v25;    // [esp+30h] [ebp-28h]
  int v26;      // [esp+34h] [ebp-24h]
  _DWORD *v27;  // [esp+38h] [ebp-20h]
  int v28;      // [esp+3Ch] [ebp-1Ch]

  v22 = a1[88];
  if (a1[48]) {
    if (!*(_DWORD *)(a1[88] + 36)) {
      if ((int)a1[58] > 0) {
        v19 = a1[88];
        v20 = 0;
        do {
          *(_DWORD *)(v19 + 20) = 0;
          ++v20;
          v19 += 4;
        } while (v20 < a1[58]);
      }
      *(_DWORD *)(v22 + 36) = a1[48];
    }
    --*(_DWORD *)(v22 + 36);
    v2 = a1;
  } else {
    v2 = a1;
  }
  if ((int)v2[65] <= 0)
    return 1;
  v27 = v2;
  v26 = 1;
  v21 = a2 + 4;
  v3 = v2;
  while (2) {
    v28 = v3[66];
    v4 = a1[v28 + 59];
    v23 = *(_DWORD **)(v22 + 4 * *(_DWORD *)(v4 + 24) + 92);
    v5 = *(_DWORD *)(v22 + 4 * *(_DWORD *)(v4 + 20) + 76);
    v24 = *(__int16 **)(v21 - 4);
    v6 = *v24 - *(_DWORD *)(v22 + 4 * v28 + 20);
    if (v6 < 0)
      v6 = *(_DWORD *)(v22 + 4 * v28 + 20) - *v24;
    if (v6) {
      v7 = 0;
      do {
        ++v7;
        v6 >>= 1;
      } while (v6);
      if (v7 > 11) {
        *(_DWORD *)(*a1 + 20) = 6;
        (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
      }
      v6 = v7;
    }
    ++*(_DWORD *)(v5 + 4 * v6);
    v8 = 0;
    v25 = (char *)&jpeg_natural_order;
    for (i = &jpeg_natural_order;; i = v25) {
      v10 = v24[i[1]];
      v11 = v10;
      if (v10)
        break;
      ++v8;
      v25 += 4;
      if (&unk_30723C == (_UNKNOWN *)v25)
        goto LABEL_27;
    LABEL_16:;
    }
    if (v8 > 15) {
      v12 = v23[240];
      do {
        ++v12;
        v8 -= 16;
      } while (v8 > 15);
      v23[240] = v12;
    }
    v13 = v11;
    v14 = -v11;
    if (v13 <= -1)
      v13 = v14;
    v15 = v13 >> 1;
    if (v15) {
      v16 = 1;
      do {
        ++v16;
        v15 >>= 1;
      } while (v15);
      if (v16 > 10) {
        *(_DWORD *)(*a1 + 20) = 6;
        (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
      }
    } else {
      v16 = 1;
    }
    ++v23[16 * v8 + v16];
    v8 = 0;
    v25 += 4;
    if (&unk_30723C != (_UNKNOWN *)v25)
      goto LABEL_16;
  LABEL_27:
    if (v8 > 0)
      ++*v23;
    *(_DWORD *)(v22 + 4 * v28 + 20) = **(__int16 **)(v21 - 4);
    v17 = v26++;
    v21 += 4;
    ++v27;
    if (a1[65] > v17) {
      v3 = v27;
      continue;
    }
    return 1;
  }
}

int __cdecl jpeg_gen_optimal_table(int a1, int a2, int a3) {
  int i;           // eax
  int v4;          // edx
  int v5;          // edi
  int v6;          // ecx
  int v7;          // eax
  int v8;          // ecx
  int v9;          // eax
  _DWORD *v10;     // ecx
  int v11;         // eax
  int j;           // eax
  int v13;         // esi
  _DWORD *v14;     // edi
  int v15;         // eax
  char v16;        // di
  int v17;         // esi
  int v18;         // ecx
  char *v19;       // edx
  int v21;         // edx
  char *v22;       // ecx
  int v24;         // edx
  int v25;         // ecx
  int k;           // eax
  int result;      // eax
  int v28;         // [esp+20h] [ebp-848h]
  int v29;         // [esp+24h] [ebp-844h]
  int v30;         // [esp+2Ch] [ebp-83Ch]
  _DWORD v31[257]; // [esp+34h] [ebp-834h]
  _DWORD __b[257]; // [esp+438h] [ebp-430h] BYREF
  _DWORD v33[8];   // [esp+83Fh] [ebp-29h] BYREF
  char v34;        // [esp+85Fh] [ebp-9h]

  memset(v33, 0, sizeof(v33));
  v34 = 0;
  memset(__b, 0, sizeof(__b));
  for (i = 0; i != 257; ++i)
    v31[i] = -1;
  *(_DWORD *)(a3 + 1024) = 1;
  while (1) {
    v4 = 0;
    v5 = -1;
    v6 = 1000000000;
    do {
      v7 = *(_DWORD *)(a3 + 4 * v4);
      if (v7 && v7 <= v6) {
        v5 = v4;
        v6 = *(_DWORD *)(a3 + 4 * v4);
      }
      ++v4;
    } while (v4 != 257);
    LOWORD(v4) = 0;
    v8 = 1000000000;
    v30 = -1;
    do {
      v9 = *(_DWORD *)(a3 + 4 * v4);
      if (v9 && v9 <= v8 && v5 != v4) {
        v8 = *(_DWORD *)(a3 + 4 * v4);
        v30 = v4;
      }
      ++v4;
    } while (v4 != 257);
    if (v30 < 0)
      break;
    v10 = (_DWORD *)(a3 + 4 * v30);
    *(_DWORD *)(a3 + 4 * v5) += *v10;
    *v10 = 0;
    ++__b[v5];
    v11 = v31[v5];
    if (v11 >= 0) {
      while (1) {
        ++__b[v11];
        if ((int)v31[v11] < 0)
          break;
        v11 = v31[v11];
      }
    } else {
      v11 = v5;
    }
    v31[v11] = v30;
    ++__b[v30];
    for (j = v31[v30]; j >= 0; j = v31[j])
      ++__b[j];
  }
  v13 = 1;
  v14 = &__b[1];
  do {
    v15 = *(v14 - 1);
    if (v15) {
      if (v15 > 32) {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 39;
        (**(void(__cdecl ***)(int))a1)(a1);
        v15 = *(v14 - 1);
      }
      ++*((_BYTE *)v33 + v15);
    }
    ++v13;
    ++v14;
  } while (v13 != 258);
  v29 = 32;
  do {
    while (1) {
      v16 = *((_BYTE *)v33 + v29);
      if (v16)
        break;
      if (--v29 <= 16)
        goto LABEL_39;
    }
    v28 = v29 - 1;
    v17 = v29 - 2;
    if (!*((_BYTE *)v33 + v29 - 2)) {
    LABEL_33:
      v18 = v17;
      v19 = (char *)v33 + v17;
      do
        --v18;
      while (!*--v19);
      goto LABEL_35;
    }
    while (1) {
      v18 = v17;
    LABEL_35:
      *((_BYTE *)v33 + v29) = v16 - 2;
      ++*((_BYTE *)v33 + v28);
      *((_BYTE *)v33 + v18 + 1) += 2;
      --*((_BYTE *)v33 + v18);
      v16 = *((_BYTE *)v33 + v29);
      if (!v16)
        break;
      v17 = v29 - 2;
      if (!*((_BYTE *)v33 + v29 - 2))
        goto LABEL_33;
    }
    --v29;
  } while (v28 > 16);
LABEL_39:
  v21 = v29;
  if (!*((_BYTE *)v33 + v29)) {
    v22 = (char *)v33 + v29;
    v21 = v29;
    do
      --v21;
    while (!*--v22);
  }
  --*((_BYTE *)v33 + v21);
  *(_DWORD *)a2 = v33[0];
  *(_DWORD *)(a2 + 4) = v33[1];
  *(_DWORD *)(a2 + 8) = v33[2];
  *(_DWORD *)(a2 + 12) = v33[3];
  *(_BYTE *)(a2 + 16) = v33[4];
  v24 = 1;
  v25 = 0;
  do {
    for (k = 0; k != 256; ++k) {
      while (__b[k] != v24) {
        if (++k == 256)
          goto LABEL_47;
      }
      *(_BYTE *)(a2 + v25++ + 17) = k;
    }
  LABEL_47:
    ++v24;
  } while (v24 != 33);
  result = a2;
  *(_BYTE *)(a2 + 273) = 0;
  return result;
}

int __cdecl finish_pass_gather(int a1) {
  int result;    // eax
  int i;         // ecx
  int v3;        // edi
  int v4;        // ecx
  int v5;        // esi
  int v6;        // eax
  int v7;        // esi
  int v8;        // [esp+10h] [ebp-28h]
  int v9;        // [esp+14h] [ebp-24h]
  int v10;       // [esp+18h] [ebp-20h]
  int v11;       // [esp+1Ch] [ebp-1Ch]
  int v12;       // [esp+28h] [ebp-10h]
  _DWORD v13[3]; // [esp+2Ch] [ebp-Ch]

  result = *(_DWORD *)(a1 + 352);
  v8 = result;
  v13[0] = 0;
  v12 = 0;
  if (*(int *)(a1 + 232) > 0) {
    v11 = a1;
    v9 = 0;
    for (i = a1;; i = v11) {
      v6 = *(_DWORD *)(i + 236);
      v7 = *(_DWORD *)(v6 + 20);
      result = *(_DWORD *)(v6 + 24);
      v10 = result;
      if (*((_BYTE *)v13 + v7)) {
        v4 = result;
      } else {
        v3 = 4 * v7;
        if (!*(_DWORD *)(a1 + 4 * v7 + 92))
          *(_DWORD *)(a1 + v3 + 92) = jpeg_alloc_huff_table(a1);
        result = jpeg_gen_optimal_table(a1, *(_DWORD *)(a1 + v3 + 92),
                                        *(_DWORD *)(v8 + 4 * v7 + 76));
        *((_BYTE *)v13 + v7) = 1;
        v4 = v10;
      }
      if (!*((_BYTE *)&v13[-1] + v4)) {
        v5 = 4 * v4;
        if (!*(_DWORD *)(a1 + 4 * v4 + 108))
          *(_DWORD *)(a1 + v5 + 108) = jpeg_alloc_huff_table(a1);
        jpeg_gen_optimal_table(a1, *(_DWORD *)(a1 + v5 + 108),
                               *(_DWORD *)(v8 + 4 * v10 + 92));
        result = v10;
        *((_BYTE *)&v13[-1] + v10) = 1;
      }
      ++v9;
      v11 += 4;
      if (*(_DWORD *)(a1 + 232) <= v9)
        break;
    }
  }
  return result;
}

int __cdecl finish_pass_huff(_DWORD *a1) {
  _DWORD *v1; // esi
  _DWORD *v2; // eax
  int v3;     // edi
  int result; // eax
  int v5;     // [esp+14h] [ebp-34h]
  int v6;     // [esp+18h] [ebp-30h]
  int i;      // [esp+1Ch] [ebp-2Ch]
  int v8;     // [esp+20h] [ebp-28h]
  _BYTE *v9;  // [esp+24h] [ebp-24h]
  int v10;    // [esp+28h] [ebp-20h]
  int v11;    // [esp+2Ch] [ebp-1Ch]
  int v12;    // [esp+30h] [ebp-18h]
  int v13;    // [esp+34h] [ebp-14h]
  int v14;    // [esp+38h] [ebp-10h]
  int v15;    // [esp+3Ch] [ebp-Ch]

  v1 = (_DWORD *)a1[88];
  v2 = (_DWORD *)a1[8];
  v9 = (_BYTE *)*v2;
  v3 = v2[1];
  v13 = v1[8];
  v12 = v1[7];
  v11 = v1[6];
  v10 = v1[5];
  v14 = v1[3];
  v8 = v1[4];
  v15 = v8 + 7;
  for (i = v14 | (127 << (24 - (v8 + 7))); v15 > 7; v15 -= 8) {
    *v9++ = BYTE2(i);
    if (--v3) {
      if (BYTE2(i) != 255)
        goto LABEL_4;
    } else {
      v5 = a1[8];
      if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v5 + 12))(a1))
        goto LABEL_12;
      v9 = *(_BYTE **)v5;
      v3 = *(_DWORD *)(v5 + 4);
      if (BYTE2(i) != 255)
        goto LABEL_4;
    }
    *v9++ = 0;
    if (!--v3) {
      v6 = a1[8];
      if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v6 + 12))(a1)) {
      LABEL_12:
        *(_DWORD *)(*a1 + 20) = 24;
        (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
        goto LABEL_6;
      }
      v9 = *(_BYTE **)v6;
      v3 = *(_DWORD *)(v6 + 4);
    }
  LABEL_4:
    i <<= 8;
  }
  v14 = 0;
  v8 = 0;
LABEL_6:
  *(_DWORD *)a1[8] = v9;
  *(_DWORD *)(a1[8] + 4) = v3;
  v1[8] = v13;
  v1[7] = v12;
  v1[6] = v11;
  v1[5] = v10;
  result = v14;
  v1[3] = v14;
  v1[4] = v8;
  return result;
}

int __cdecl encode_mcu_huff(_DWORD *a1, int a2) {
  int v2;       // eax
  int v3;       // edi
  _DWORD *v4;   // esi
  _DWORD *j;    // edx
  int v6;       // edx
  int v7;       // esi
  int v8;       // eax
  char v9;      // al
  int v10;      // esi
  int v11;      // edx
  int v12;      // eax
  _BYTE *v14;   // edx
  int v15;      // edi
  int v16;      // edx
  int i;        // eax
  int v18;      // esi
  int v19;      // edi
  __int16 v20;  // ax
  __int16 v21;  // ax
  char v22;     // al
  int v23;      // esi
  int v24;      // edx
  char v25;     // al
  int v26;      // edi
  int v27;      // edi
  int v28;      // eax
  char v29;     // dl
  int v30;      // esi
  int v31;      // edx
  int v32;      // esi
  int v33;      // edx
  int v34;      // edi
  int v35;      // esi
  int v36;      // edi
  int v37;      // esi
  int v38;      // edx
  int v39;      // edi
  int v40;      // edi
  int v41;      // edi
  int v42;      // edi
  int v43;      // edi
  int v44;      // esi
  int v45;      // esi
  char v46;     // al
  int v47;      // esi
  int v48;      // edx
  int v49;      // eax
  int v50;      // edi
  int v51;      // edi
  int v52;      // [esp+10h] [ebp-E8h]
  _DWORD *v53;  // [esp+14h] [ebp-E4h]
  int v54;      // [esp+18h] [ebp-E0h]
  int v55;      // [esp+1Ch] [ebp-DCh]
  int v56;      // [esp+20h] [ebp-D8h]
  int *v57;     // [esp+24h] [ebp-D4h]
  __int16 *v58; // [esp+28h] [ebp-D0h]
  int v59;      // [esp+2Ch] [ebp-CCh]
  int v60;      // [esp+30h] [ebp-C8h]
  int v61;      // [esp+30h] [ebp-C8h]
  int v62;      // [esp+34h] [ebp-C4h]
  int v63;      // [esp+38h] [ebp-C0h]
  int v64;      // [esp+40h] [ebp-B8h]
  int v65;      // [esp+48h] [ebp-B0h]
  int v66;      // [esp+4Ch] [ebp-ACh]
  int v67;      // [esp+54h] [ebp-A4h]
  int v68;      // [esp+58h] [ebp-A0h]
  int v69;      // [esp+60h] [ebp-98h]
  int v70;      // [esp+68h] [ebp-90h]
  int v71;      // [esp+6Ch] [ebp-8Ch]
  int v72;      // [esp+74h] [ebp-84h]
  _BYTE *v73;   // [esp+78h] [ebp-80h]
  _DWORD *v74;  // [esp+7Ch] [ebp-7Ch]
  int v75;      // [esp+80h] [ebp-78h]
  int v76;      // [esp+84h] [ebp-74h]
  int v77;      // [esp+88h] [ebp-70h]
  int v78;      // [esp+8Ch] [ebp-6Ch]
  int v79;      // [esp+90h] [ebp-68h]
  int v80;      // [esp+94h] [ebp-64h]
  int v81;      // [esp+98h] [ebp-60h]
  int v82;      // [esp+9Ch] [ebp-5Ch]
  int v83;      // [esp+A0h] [ebp-58h]
  int v84;      // [esp+A0h] [ebp-58h]
  int v85;      // [esp+A4h] [ebp-54h]
  int v86;      // [esp+A8h] [ebp-50h]
  int v87;      // [esp+ACh] [ebp-4Ch]
  int v88;      // [esp+C4h] [ebp-34h]
  int v89;      // [esp+C8h] [ebp-30h]
  int v90;      // [esp+CCh] [ebp-2Ch]
  int v91;      // [esp+D0h] [ebp-28h]
  int v92;      // [esp+D4h] [ebp-24h]
  int v93;      // [esp+D8h] [ebp-20h]

  v53 = (_DWORD *)a1[88];
  v2 = a1[8];
  v73 = *(_BYTE **)v2;
  v3 = *(_DWORD *)(v2 + 4);
  v88 = v53[3];
  v89 = v53[4];
  v90 = v53[5];
  v91 = v53[6];
  v92 = v53[7];
  v93 = v53[8];
  v77 = v88;
  v83 = v89;
  if (!a1[48]) {
    v4 = a1;
    goto LABEL_17;
  }
  if (v53[9]) {
    v4 = a1;
    goto LABEL_4;
  }
  v55 = v53[10];
  v85 = v89 + 7;
  v76 = v88 | (127 << (24 - (v89 + 7)));
  if (v89 + 7 > 7) {
    v56 = BYTE2(v76);
    *v73++ = BYTE2(v76);
    if (!--v3)
      goto LABEL_33;
    while (1) {
      if (v56 == 255) {
        *v73++ = 0;
        if (!--v3) {
          v35 = a1[8];
          if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v35 + 12))(a1))
            return 0;
          v73 = *(_BYTE **)v35;
          v3 = *(_DWORD *)(v35 + 4);
        }
      }
      v76 <<= 8;
      v85 -= 8;
      if (v85 <= 7)
        break;
      v56 = BYTE2(v76);
      *v73++ = BYTE2(v76);
      if (!--v3) {
      LABEL_33:
        v18 = a1[8];
        if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v18 + 12))(a1))
          return 0;
        v73 = *(_BYTE **)v18;
        v3 = *(_DWORD *)(v18 + 4);
      }
    }
  }
  v77 = 0;
  v83 = 0;
  *v73 = -1;
  v14 = v73 + 1;
  v15 = v3 - 1;
  if (!v15) {
    v44 = a1[8];
    if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v44 + 12))(a1))
      return 0;
    v15 = *(_DWORD *)(v44 + 4);
    v14 = *(_BYTE **)v44;
  }
  *v14 = v55 - 48;
  v73 = v14 + 1;
  v3 = v15 - 1;
  if (!v3) {
    v45 = a1[8];
    if ((*(unsigned __int8(__cdecl **)(_DWORD *))(v45 + 12))(a1)) {
      v73 = *(_BYTE **)v45;
      v3 = *(_DWORD *)(v45 + 4);
      goto LABEL_25;
    }
    return 0;
  }
LABEL_25:
  v16 = a1[58];
  if (v16 > 0) {
    for (i = 0; i != v16; ++i)
      *(&v90 + i) = 0;
    v4 = a1;
  LABEL_4:
    if ((int)v4[65] > 0) {
    LABEL_5:
      v75 = 1;
      v52 = 1;
      for (j = a1;; j = a1) {
        v54 = j[v52 + 65];
        v6 = j[v54 + 59];
        v57 = (int *)v53[*(_DWORD *)(v6 + 24) + 15];
        v7 = v53[*(_DWORD *)(v6 + 20) + 11];
        v58 = *(__int16 **)(v52 * 4 + a2 - 4);
        v8 = *v58 - *(&v90 + v54);
        if (v8 < 0) {
          v59 = v8 - 1;
          v8 = *(&v90 + v54) - *v58;
        } else {
          v59 = *v58 - *(&v90 + v54);
        }
        if (!v8)
          break;
        v64 = 0;
        do {
          ++v64;
          v8 >>= 1;
        } while (v8);
        if (v64 <= 11)
          goto LABEL_10;
        *(_DWORD *)(*a1 + 20) = 6;
        (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
        v25 = *(_BYTE *)(v64 + v7 + 1024);
        v62 = v25;
        v63 = *(_DWORD *)(v7 + 4 * v64);
        if (!v25) {
        LABEL_55:
          *(_DWORD *)(*a1 + 20) = 40;
          (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
        }
      LABEL_11:
        v78 = v83 + v62;
        v10 = v77 | ((v63 & ((1 << v62) - 1)) << (24 - (v83 + v62)));
        if (v83 + v62 > 7) {
          while (1) {
            *v73++ = BYTE2(v10);
            if (--v3) {
              if (BYTE2(v10) == 255)
                goto LABEL_81;
            } else {
              v19 = a1[8];
              if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v19 + 12))(a1))
                return 0;
              v73 = *(_BYTE **)v19;
              v3 = *(_DWORD *)(v19 + 4);
              if (BYTE2(v10) == 255) {
              LABEL_81:
                *v73++ = 0;
                if (!--v3) {
                  v34 = a1[8];
                  if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v34 + 12))(a1))
                    return 0;
                  v73 = *(_BYTE **)v34;
                  v3 = *(_DWORD *)(v34 + 4);
                }
              }
            }
            v10 <<= 8;
            v78 -= 8;
            if (v78 <= 7) {
              v11 = v78;
              goto LABEL_38;
            }
          }
        }
        v11 = v83 + v62;
      LABEL_38:
        v77 = v10;
        v83 = v11;
        if (v64) {
          v72 = v11 + v64;
          v32 = v10 | ((v59 & ((1 << v64) - 1)) << (24 - (v11 + v64)));
          if (v11 + v64 <= 7) {
            v33 = v11 + v64;
          } else {
            do {
              *v73++ = BYTE2(v32);
              if (!--v3) {
                v40 = a1[8];
                if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v40 + 12))(a1))
                  return 0;
                v73 = *(_BYTE **)v40;
                v3 = *(_DWORD *)(v40 + 4);
              }
              if (BYTE2(v32) == 255) {
                *v73++ = 0;
                if (!--v3) {
                  v42 = a1[8];
                  if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v42 + 12))(a1))
                    return 0;
                  v73 = *(_BYTE **)v42;
                  v3 = *(_DWORD *)(v42 + 4);
                }
              }
              v32 <<= 8;
              v72 -= 8;
            } while (v72 > 7);
            v33 = v72;
          }
          v83 = v33;
          v77 = v32;
        }
        v60 = 0;
        v74 = &jpeg_natural_order;
        v20 = v58[unk_307144];
        v87 = v20;
        if (!v20) {
        LABEL_40:
          ++v60;
          goto LABEL_41;
        }
        while (1) {
          if (v60 > 15) {
            while (1) {
              v22 = *((_BYTE *)v57 + 1264);
              v65 = v22;
              v66 = v57[240];
              if (!v22) {
                *(_DWORD *)(*a1 + 20) = 40;
                (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
              }
              v80 = v83 + v65;
              v23 = v77 | ((v66 & ((1 << v65) - 1)) << (24 - (v83 + v65)));
              if (v83 + v65 > 7)
                break;
              v24 = v83 + v65;
            LABEL_62:
              v77 = v23;
              v83 = v24;
              v60 -= 16;
              if (v60 <= 15)
                goto LABEL_63;
            }
            while (2) {
              *v73++ = BYTE2(v23);
              if (--v3) {
                if (BYTE2(v23) != 255)
                  goto LABEL_49;
              LABEL_58:
                *v73++ = 0;
                if (!--v3) {
                  v27 = a1[8];
                  if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v27 + 12))(a1))
                    return 0;
                  v73 = *(_BYTE **)v27;
                  v3 = *(_DWORD *)(v27 + 4);
                }
              } else {
                v26 = a1[8];
                if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v26 + 12))(a1))
                  return 0;
                v73 = *(_BYTE **)v26;
                v3 = *(_DWORD *)(v26 + 4);
                if (BYTE2(v23) == 255)
                  goto LABEL_58;
              }
            LABEL_49:
              v23 <<= 8;
              v80 -= 8;
              if (v80 <= 7) {
                v24 = v80;
                goto LABEL_62;
              }
              continue;
            }
          }
        LABEL_63:
          if (v87 < 0) {
            v86 = v87 - 1;
            v87 = -v87;
          } else {
            v86 = v87;
          }
          v28 = v87 >> 1;
          if (v87 >> 1) {
            v69 = 1;
            do {
              ++v69;
              v28 >>= 1;
            } while (v28);
            if (v69 > 10) {
              *(_DWORD *)(*a1 + 20) = 6;
              (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
            }
          } else {
            v69 = 1;
          }
          v61 = 16 * v60;
          v29 = *((_BYTE *)v57 + v69 + v61 + 1024);
          v67 = v29;
          v68 = v57[v69 + v61];
          if (!v29) {
            *(_DWORD *)(*a1 + 20) = 40;
            (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
          }
          v81 = v83 + v67;
          v30 = v77 | ((v68 & ((1 << v67) - 1)) << (24 - (v83 + v67)));
          if (v83 + v67 <= 7) {
            v31 = v83 + v67;
          } else {
            do {
              *v73++ = BYTE2(v30);
              if (!--v3) {
                v36 = a1[8];
                if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v36 + 12))(a1))
                  return 0;
                v73 = *(_BYTE **)v36;
                v3 = *(_DWORD *)(v36 + 4);
              }
              if (BYTE2(v30) == 255) {
                *v73++ = 0;
                if (!--v3) {
                  v39 = a1[8];
                  if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v39 + 12))(a1))
                    return 0;
                  v73 = *(_BYTE **)v39;
                  v3 = *(_DWORD *)(v39 + 4);
                }
              }
              v30 <<= 8;
              v81 -= 8;
            } while (v81 > 7);
            v31 = v81;
          }
          v84 = v31;
          if (!v69) {
            *(_DWORD *)(*a1 + 20) = 40;
            (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
          }
          v79 = v84 + v69;
          v37 = v30 | ((v86 & ((1 << v69) - 1)) << (24 - (v84 + v69)));
          if (v84 + v69 <= 7) {
            v38 = v84 + v69;
          } else {
            do {
              *v73++ = BYTE2(v37);
              if (!--v3) {
                v41 = a1[8];
                if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v41 + 12))(a1))
                  return 0;
                v73 = *(_BYTE **)v41;
                v3 = *(_DWORD *)(v41 + 4);
              }
              if (BYTE2(v37) == 255) {
                *v73++ = 0;
                if (!--v3) {
                  v43 = a1[8];
                  if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v43 + 12))(a1))
                    return 0;
                  v73 = *(_BYTE **)v43;
                  v3 = *(_DWORD *)(v43 + 4);
                }
              }
              v37 <<= 8;
              v79 -= 8;
            } while (v79 > 7);
            v38 = v79;
          }
          v77 = v37;
          v83 = v38;
          v60 = 0;
        LABEL_41:
          if (&unk_30723C == (_UNKNOWN *)++v74)
            break;
          v21 = v58[v74[1]];
          v87 = v21;
          if (!v21)
            goto LABEL_40;
        }
        if (v60 > 0) {
          v46 = *((_BYTE *)v57 + 1024);
          v70 = v46;
          v71 = *v57;
          if (!v46) {
            *(_DWORD *)(*a1 + 20) = 40;
            (*(void(__cdecl **)(_DWORD *)) * a1)(a1);
          }
          v82 = v83 + v70;
          v47 = v77 | ((v71 & ((1 << v70) - 1)) << (24 - (v83 + v70)));
          if (v83 + v70 <= 7) {
            v48 = v83 + v70;
          } else {
            do {
              *v73++ = BYTE2(v47);
              if (!--v3) {
                v50 = a1[8];
                if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v50 + 12))(a1))
                  return 0;
                v73 = *(_BYTE **)v50;
                v3 = *(_DWORD *)(v50 + 4);
              }
              if (BYTE2(v47) == 255) {
                *v73++ = 0;
                if (!--v3) {
                  v51 = a1[8];
                  if (!(*(unsigned __int8(__cdecl **)(_DWORD *))(v51 + 12))(a1))
                    return 0;
                  v73 = *(_BYTE **)v51;
                  v3 = *(_DWORD *)(v51 + 4);
                }
              }
              v47 <<= 8;
              v82 -= 8;
            } while (v82 > 7);
            v48 = v82;
          }
          v77 = v47;
          v83 = v48;
        }
        *(&v90 + v54) = **(__int16 **)(v52 * 4 + a2 - 4);
        v49 = v75++;
        ++v52;
        if (a1[65] <= v49) {
          v4 = a1;
          goto LABEL_18;
        }
      }
      v64 = 0;
    LABEL_10:
      v9 = *(_BYTE *)(v64 + v7 + 1024);
      v62 = v9;
      v63 = *(_DWORD *)(v7 + 4 * v64);
      if (!v9)
        goto LABEL_55;
      goto LABEL_11;
    }
    goto LABEL_18;
  }
  v4 = a1;
LABEL_17:
  if ((int)v4[65] > 0)
    goto LABEL_5;
LABEL_18:
  *(_DWORD *)v4[8] = v73;
  *(_DWORD *)(v4[8] + 4) = v3;
  v88 = v77;
  v89 = v83;
  v53[3] = v77;
  v53[4] = v89;
  v53[5] = v90;
  v53[6] = v91;
  v53[7] = v92;
  v53[8] = v93;
  v12 = a1[48];
  if (!v12)
    return 1;
  if (!v53[9]) {
    v53[9] = v12;
    v53[10] = ((unsigned __int8)v53[10] + 1) & 7;
  }
  --v53[9];
  return 1;
}

int __cdecl start_pass_phuff(int a1, char a2) {
  int v2;           // edi
  int v3;           // eax
  unsigned int v4;  // esi
  void *v5;         // eax
  int v6;           // eax
  int result;       // eax
  int v8;           // eax
  unsigned int v9;  // esi
  int i;            // edx
  int v11;          // eax
  int v12;          // eax
  unsigned int v13; // esi
  void *v14;        // eax
  char v15;         // [esp+13h] [ebp-25h]
  int v16;          // [esp+14h] [ebp-24h]
  int v17;          // [esp+18h] [ebp-20h]
  int v18;          // [esp+1Ch] [ebp-1Ch]

  v2 = *(_DWORD *)(a1 + 352);
  *(_DWORD *)(v2 + 32) = a1;
  *(_BYTE *)(v2 + 12) = a2;
  v15 = *(_DWORD *)(a1 + 304) == 0;
  if (*(_DWORD *)(a1 + 312)) {
    if (*(_DWORD *)(a1 + 304)) {
      *(_DWORD *)(v2 + 4) = encode_mcu_AC_refine;
      if (!*(_DWORD *)(v2 + 64))
        *(_DWORD *)(v2 + 64) =
            (**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1000);
    } else {
      *(_DWORD *)(v2 + 4) = encode_mcu_DC_refine;
    }
  } else {
    if (*(_DWORD *)(a1 + 304)) {
      *(_DWORD *)(v2 + 4) = encode_mcu_AC_first;
      if (!a2)
        goto LABEL_4;
    LABEL_16:
      *(_DWORD *)(v2 + 8) = finish_pass_gather_phuff;
      if (*(int *)(a1 + 232) <= 0)
        goto LABEL_17;
      goto LABEL_5;
    }
    *(_DWORD *)(v2 + 4) = encode_mcu_DC_first;
  }
  if (a2)
    goto LABEL_16;
LABEL_4:
  *(_DWORD *)(v2 + 8) = finish_pass_phuff;
  if (*(int *)(a1 + 232) <= 0)
    goto LABEL_17;
LABEL_5:
  v17 = a1;
  v18 = v2;
  v16 = 0;
  if (v15) {
    for (i = a1;; i = v17) {
      v12 = *(_DWORD *)(i + 236);
      *(_DWORD *)(v18 + 36) = 0;
      if (*(_DWORD *)(a1 + 312)) {
        v11 = a1;
        goto LABEL_25;
      }
      v13 = *(_DWORD *)(v12 + 20);
      if (a2)
        break;
      jpeg_make_c_derived_tbl((int(__cdecl ***)(_DWORD, _DWORD, _DWORD))a1, v15,
                              v13, (int *)(v2 + 4 * v13 + 76));
      v11 = a1;
    LABEL_25:
      ++v16;
      v17 += 4;
      v18 += 4;
      if (v16 >= *(_DWORD *)(v11 + 232))
        goto LABEL_17;
    }
    if (v13 > 3) {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 50;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = v13;
      (**(void(__cdecl ***)(int))a1)(a1);
      if (*(_DWORD *)(v2 + 4 * v13 + 92))
        goto LABEL_31;
    } else if (*(_DWORD *)(v2 + 4 * v13 + 92)) {
    LABEL_31:
      v14 = *(void **)(v2 + 4 * v13 + 92);
    LABEL_32:
      memset(v14, 0, 0x404u);
      v11 = a1;
      goto LABEL_25;
    }
    v14 = (void *)(**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1028);
    *(_DWORD *)(v2 + 4 * v13 + 92) = v14;
    goto LABEL_32;
  }
  if (a2) {
    v3 = *(_DWORD *)(a1 + 236);
    *(_DWORD *)(v2 + 36) = 0;
    v4 = *(_DWORD *)(v3 + 24);
    *(_DWORD *)(v2 + 52) = v4;
    if (v4 > 3)
      goto LABEL_12;
    while (1) {
      if (*(_DWORD *)(v2 + 4 * v4 + 92)) {
        v5 = *(void **)(v2 + 4 * v4 + 92);
      } else {
        v5 = (void *)(**(int(__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1028);
        *(_DWORD *)(v2 + 4 * v4 + 92) = v5;
      }
      memset(v5, 0, 0x404u);
      ++v16;
      v17 += 4;
      v18 += 4;
      if (v16 >= *(_DWORD *)(a1 + 232))
        break;
      v6 = *(_DWORD *)(v17 + 236);
      *(_DWORD *)(v18 + 36) = 0;
      v4 = *(_DWORD *)(v6 + 24);
      *(_DWORD *)(v2 + 52) = v4;
      if (v4 > 3) {
      LABEL_12:
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 50;
        *(_DWORD *)(*(_DWORD *)a1 + 24) = v4;
        (**(void(__cdecl ***)(int))a1)(a1);
      }
    }
  } else {
    do {
      v8 = *(_DWORD *)(v17 + 236);
      *(_DWORD *)(v18 + 36) = 0;
      v9 = *(_DWORD *)(v8 + 24);
      *(_DWORD *)(v2 + 52) = v9;
      jpeg_make_c_derived_tbl((int(__cdecl ***)(_DWORD, _DWORD, _DWORD))a1, 0,
                              v9, (int *)(v2 + 4 * v9 + 76));
      ++v16;
      v17 += 4;
      v18 += 4;
    } while (v16 < *(_DWORD *)(a1 + 232));
  }
LABEL_17:
  *(_DWORD *)(v2 + 56) = 0;
  *(_DWORD *)(v2 + 60) = 0;
  *(_DWORD *)(v2 + 24) = 0;
  *(_DWORD *)(v2 + 28) = 0;
  result = *(_DWORD *)(a1 + 192);
  *(_DWORD *)(v2 + 68) = result;
  *(_DWORD *)(v2 + 72) = 0;
  return result;
}

int __cdecl finish_pass_phuff(int a1) {
  int v1;     // esi
  int v2;     // eax
  int result; // eax
  int v4;     // edi
  _BYTE *v5;  // eax
  int v6;     // eax
  _BYTE *v7;  // eax
  int v8;     // eax
  int v9;     // edi
  int v10;    // [esp+18h] [ebp-10h]
  int v11;    // [esp+1Ch] [ebp-Ch]

  v1 = *(_DWORD *)(a1 + 352);
  *(_DWORD *)(v1 + 16) = **(_DWORD **)(a1 + 32);
  *(_DWORD *)(v1 + 20) = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4);
  emit_eobrun(v1);
  v2 = *(_DWORD *)(v1 + 28);
  if (!*(_BYTE *)(v1 + 12)) {
    v11 = v2 + 7;
    v10 = *(_DWORD *)(v1 + 24) | (127 << (24 - (v2 + 7)));
    if (v2 + 7 <= 7) {
    LABEL_3:
      *(_DWORD *)(v1 + 24) = v10;
      *(_DWORD *)(v1 + 28) = v11;
      goto LABEL_4;
    }
    while (1) {
      v5 = *(_BYTE **)(v1 + 16);
      *v5 = BYTE2(v10);
      *(_DWORD *)(v1 + 16) = v5 + 1;
      v6 = *(_DWORD *)(v1 + 20) - 1;
      *(_DWORD *)(v1 + 20) = v6;
      if (!v6)
        break;
      if (BYTE2(v10) == 255)
        goto LABEL_11;
    LABEL_8:
      v10 <<= 8;
      v11 -= 8;
      if (v11 <= 7)
        goto LABEL_3;
    }
    v4 = *(_DWORD *)(*(_DWORD *)(v1 + 32) + 32);
    if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v4 + 12))(
            *(_DWORD *)(v1 + 32))) {
      *(_DWORD *)(**(_DWORD **)(v1 + 32) + 20) = 24;
      (***(void(__cdecl ****)(_DWORD))(v1 + 32))(*(_DWORD *)(v1 + 32));
    }
    *(_DWORD *)(v1 + 16) = *(_DWORD *)v4;
    *(_DWORD *)(v1 + 20) = *(_DWORD *)(v4 + 4);
    if (BYTE2(v10) != 255)
      goto LABEL_8;
  LABEL_11:
    v7 = *(_BYTE **)(v1 + 16);
    *v7 = 0;
    *(_DWORD *)(v1 + 16) = v7 + 1;
    v8 = *(_DWORD *)(v1 + 20) - 1;
    *(_DWORD *)(v1 + 20) = v8;
    if (!v8) {
      v9 = *(_DWORD *)(*(_DWORD *)(v1 + 32) + 32);
      if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v9 + 12))(
              *(_DWORD *)(v1 + 32))) {
        *(_DWORD *)(**(_DWORD **)(v1 + 32) + 20) = 24;
        (***(void(__cdecl ****)(_DWORD))(v1 + 32))(*(_DWORD *)(v1 + 32));
      }
      *(_DWORD *)(v1 + 16) = *(_DWORD *)v9;
      *(_DWORD *)(v1 + 20) = *(_DWORD *)(v9 + 4);
    }
    goto LABEL_8;
  }
LABEL_4:
  *(_DWORD *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 28) = 0;
  **(_DWORD **)(a1 + 32) = *(_DWORD *)(v1 + 16);
  result = *(_DWORD *)(v1 + 20);
  *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4) = result;
  return result;
}

int __cdecl finish_pass_gather_phuff(_DWORD *a1) {
  int result;    // eax
  _DWORD *i;     // edx
  _DWORD *v3;    // edx
  int v4;        // eax
  int v5;        // esi
  int v6;        // esi
  int *v7;       // edi
  int *v8;       // edi
  int v9;        // [esp+10h] [ebp-28h]
  bool v10;      // [esp+17h] [ebp-21h]
  int v11;       // [esp+18h] [ebp-20h]
  _DWORD *v12;   // [esp+1Ch] [ebp-1Ch]
  _DWORD v13[3]; // [esp+2Ch] [ebp-Ch]

  v9 = a1[88];
  emit_eobrun(v9);
  v10 = a1[76] == 0;
  v13[0] = 0;
  result = a1[58];
  if (result > 0) {
    v12 = a1;
    v11 = 0;
    if (v10) {
      for (i = a1;; i = v12) {
        v4 = i[59];
        v3 = a1;
        if (!a1[78]) {
          v5 = *(_DWORD *)(v4 + 20);
          if (*((_BYTE *)v13 + v5)) {
            v3 = a1;
          } else {
            v8 = &a1[v5 + 23];
            if (!*v8)
              *v8 = jpeg_alloc_huff_table((int)a1);
            jpeg_gen_optimal_table((int)a1, *v8, *(_DWORD *)(v9 + 4 * v5 + 92));
            *((_BYTE *)v13 + v5) = 1;
            v3 = a1;
          }
        }
        ++v11;
        ++v12;
        result = v11;
        if (v11 >= v3[58])
          break;
      }
    } else {
      do {
        v6 = *(_DWORD *)(v12[59] + 24);
        if (!*((_BYTE *)v13 + v6)) {
          v7 = &a1[v6 + 27];
          if (!*v7)
            *v7 = jpeg_alloc_huff_table((int)a1);
          jpeg_gen_optimal_table((int)a1, *v7, *(_DWORD *)(v9 + 4 * v6 + 92));
          *((_BYTE *)v13 + v6) = 1;
        }
        ++v11;
        ++v12;
        result = v11;
      } while (v11 < a1[58]);
    }
  }
  return result;
}

int __cdecl encode_mcu_AC_refine(int a1, int *a2) {
  int v2;           // edi
  int v3;           // eax
  int v4;           // eax
  int *v5;          // esi
  int *i;           // eax
  int v7;           // edx
  int v8;           // eax
  int v9;           // eax
  bool v10;         // zf
  int v11;          // eax
  int *j;           // ecx
  unsigned int v13; // eax
  int v14;          // eax
  int v16;          // eax
  int v17;          // eax
  char v18;         // dl
  int v19;          // esi
  _BYTE *v20;       // eax
  int v21;          // eax
  _BYTE *v22;       // eax
  int v23;          // eax
  _BYTE *n;         // edx
  int v25;          // esi
  _BYTE *v26;       // eax
  int v27;          // eax
  _BYTE *v28;       // eax
  int v29;          // eax
  int v30;          // ecx
  int v31;          // eax
  int v32;          // eax
  int v33;          // ecx
  int v34;          // esi
  _BYTE *v35;       // eax
  int v36;          // eax
  _BYTE *v37;       // eax
  int v38;          // eax
  int v39;          // esi
  int v40;          // eax
  char v41;         // dl
  int k;            // esi
  _BYTE *v43;       // eax
  int v44;          // eax
  _BYTE *m;         // ecx
  int v46;          // esi
  _BYTE *v47;       // eax
  int v48;          // eax
  _BYTE *v49;       // eax
  int v50;          // eax
  _BYTE *v51;       // eax
  int v52;          // eax
  int v53;          // [esp+1Ch] [ebp-1CCh]
  int v54;          // [esp+2Ch] [ebp-1BCh]
  int v55;          // [esp+34h] [ebp-1B4h]
  int v56;          // [esp+38h] [ebp-1B0h]
  int v57;          // [esp+3Ch] [ebp-1ACh]
  int v58;          // [esp+40h] [ebp-1A8h]
  int v59;          // [esp+44h] [ebp-1A4h]
  int v60;          // [esp+48h] [ebp-1A0h]
  int v61;          // [esp+4Ch] [ebp-19Ch]
  int v62;          // [esp+50h] [ebp-198h]
  int v63;          // [esp+54h] [ebp-194h]
  int v64;          // [esp+5Ch] [ebp-18Ch]
  int v65;          // [esp+60h] [ebp-188h]
  int v66;          // [esp+64h] [ebp-184h]
  int v67;          // [esp+6Ch] [ebp-17Ch]
  int v68;          // [esp+70h] [ebp-178h]
  int v69;          // [esp+74h] [ebp-174h]
  int v70;          // [esp+78h] [ebp-170h]
  int v71;          // [esp+7Ch] [ebp-16Ch]
  int v72;          // [esp+84h] [ebp-164h]
  int v73;          // [esp+88h] [ebp-160h]
  int v74;          // [esp+8Ch] [ebp-15Ch]
  int v75;          // [esp+94h] [ebp-154h]
  int v76;          // [esp+98h] [ebp-150h]
  int *v77;         // [esp+9Ch] [ebp-14Ch]
  _DWORD *v78;      // [esp+A0h] [ebp-148h]
  int *v79;         // [esp+A4h] [ebp-144h]
  int v80;          // [esp+A8h] [ebp-140h]
  int v81;          // [esp+ACh] [ebp-13Ch]
  int v82;          // [esp+B0h] [ebp-138h]
  int v83;          // [esp+B4h] [ebp-134h]
  int v84;          // [esp+B8h] [ebp-130h]
  int v85;          // [esp+BCh] [ebp-12Ch]
  int v86;          // [esp+C0h] [ebp-128h]
  _BYTE *v87;       // [esp+C4h] [ebp-124h]
  _BYTE *v88;       // [esp+C8h] [ebp-120h]
  int v89;          // [esp+CCh] [ebp-11Ch]
  _BYTE v90[280];   // [esp+D0h] [ebp-118h] BYREF

  v2 = *(_DWORD *)(a1 + 352);
  v59 = *(_DWORD *)(a1 + 308);
  v60 = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(v2 + 16) = **(_DWORD **)(a1 + 32);
  *(_DWORD *)(v2 + 20) = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4);
  if (*(_DWORD *)(a1 + 192) && !*(_DWORD *)(v2 + 68))
    emit_restart(v2, *(_DWORD *)(v2 + 72));
  v61 = *a2;
  v3 = *(_DWORD *)(a1 + 304);
  v89 = v3;
  if (v59 < v3) {
    v56 = 0;
  } else {
    v4 = v3;
    v79 = &jpeg_natural_order[v4];
    v5 = (int *)&v90[v4 * 4];
    v54 = *(_DWORD *)(a1 + 304);
    v56 = 0;
    for (i = &jpeg_natural_order[v4];; i = v79) {
      v53 = *i;
      v7 = *(__int16 *)(v61 + 2 * *i);
      v8 = -v7;
      if (v7 > -1)
        v8 = *(__int16 *)(v61 + 2 * v53);
      v9 = v8 >> v60;
      *v5 = v9;
      v10 = v9 == 1;
      v11 = v54;
      if (!v10)
        v11 = v56;
      v56 = v11;
      ++v54;
      ++v79;
      ++v5;
      if (v59 < v54)
        break;
    }
  }
  v57 = *(_DWORD *)(v2 + 60) + *(_DWORD *)(v2 + 64);
  if (v59 >= v89) {
    v77 = (int *)&v90[4 * v89];
    v78 = &jpeg_natural_order[v89];
    v55 = 0;
    v58 = 0;
    for (j = v77;; j = v77) {
      v80 = *j;
      if (!*j) {
        ++v55;
        goto LABEL_15;
      }
      if (v55 > 15 && v89 <= v56)
        break;
    LABEL_20:
      if (v80 <= 1) {
        emit_eobrun(v2);
        v30 = 16 * v55 + 1;
        v31 = *(_DWORD *)(v2 + 52);
        if (*(_BYTE *)(v2 + 12)) {
          ++*(_DWORD *)(*(_DWORD *)(v2 + 4 * v31 + 92) + 4 * v30);
        } else {
          v40 = *(_DWORD *)(v2 + 4 * v31 + 76);
          v41 = *(_BYTE *)(v30 + v40 + 1024);
          v69 = v41;
          v70 = *(_DWORD *)(v40 + 4 * v30);
          v71 = *(_DWORD *)(v2 + 28);
          if (!v41) {
            *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 40;
            (***(void(__cdecl ****)(_DWORD))(v2 + 32))(*(_DWORD *)(v2 + 32));
          }
          if (!*(_BYTE *)(v2 + 12)) {
            v84 = v71 + v69;
            for (k = *(_DWORD *)(v2 + 24) |
                     ((v70 & ((1 << v69) - 1)) << (24 - (v71 + v69)));
                 v84 > 7; v84 -= 8) {
              v43 = *(_BYTE **)(v2 + 16);
              *v43 = BYTE2(k);
              *(_DWORD *)(v2 + 16) = v43 + 1;
              v44 = *(_DWORD *)(v2 + 20) - 1;
              *(_DWORD *)(v2 + 20) = v44;
              if (!v44) {
                v72 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
                if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v72 + 12))(
                        *(_DWORD *)(v2 + 32))) {
                  *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
                  (***(void(__cdecl ****)(_DWORD))(v2 + 32))(
                      *(_DWORD *)(v2 + 32));
                }
                *(_DWORD *)(v2 + 16) = *(_DWORD *)v72;
                *(_DWORD *)(v2 + 20) = *(_DWORD *)(v72 + 4);
              }
              if (BYTE2(k) == 255) {
                v51 = *(_BYTE **)(v2 + 16);
                *v51 = 0;
                *(_DWORD *)(v2 + 16) = v51 + 1;
                v52 = *(_DWORD *)(v2 + 20) - 1;
                *(_DWORD *)(v2 + 20) = v52;
                if (!v52) {
                  v73 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
                  if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v73 + 12))(
                          *(_DWORD *)(v2 + 32))) {
                    *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
                    (***(void(__cdecl ****)(_DWORD))(v2 + 32))(
                        *(_DWORD *)(v2 + 32));
                  }
                  *(_DWORD *)(v2 + 16) = *(_DWORD *)v73;
                  *(_DWORD *)(v2 + 20) = *(_DWORD *)(v73 + 4);
                }
              }
              k <<= 8;
            }
            *(_DWORD *)(v2 + 24) = k;
            *(_DWORD *)(v2 + 28) = v84;
          }
        }
        if (*(_BYTE *)(v2 + 12))
          goto LABEL_76;
        v86 = *(_DWORD *)(v2 + 28) + 1;
        v32 = *(_DWORD *)(v2 + 24) |
              ((*(__int16 *)(v61 + 2 * *v78) >= 0) << (24 - v86));
        v85 = v32;
        if (v86 <= 7) {
          v33 = *(_DWORD *)(v2 + 24) |
                ((*(__int16 *)(v61 + 2 * *v78) >= 0) << (24 - v86));
          goto LABEL_75;
        }
        while (1) {
          v74 = BYTE2(v32);
          v35 = *(_BYTE **)(v2 + 16);
          *v35 = v74;
          *(_DWORD *)(v2 + 16) = v35 + 1;
          v36 = *(_DWORD *)(v2 + 20) - 1;
          *(_DWORD *)(v2 + 20) = v36;
          if (v36)
            break;
          v34 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
          if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v34 + 12))(
                  *(_DWORD *)(v2 + 32))) {
            *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
            (***(void(__cdecl ****)(_DWORD))(v2 + 32))(*(_DWORD *)(v2 + 32));
          }
          *(_DWORD *)(v2 + 16) = *(_DWORD *)v34;
          *(_DWORD *)(v2 + 20) = *(_DWORD *)(v34 + 4);
          if (v74 == 255)
            goto LABEL_85;
        LABEL_81:
          v85 <<= 8;
          v86 -= 8;
          if (v86 <= 7) {
            v33 = v85;
          LABEL_75:
            *(_DWORD *)(v2 + 24) = v33;
            *(_DWORD *)(v2 + 28) = v86;
          LABEL_76:
            if (!*(_BYTE *)(v2 + 12) && v58) {
              v88 = (_BYTE *)v57;
              for (m = (_BYTE *)v57;; m = v88) {
                if (!*(_BYTE *)(v2 + 12)) {
                  v83 = *(_DWORD *)(v2 + 28) + 1;
                  v46 = *(_DWORD *)(v2 + 24) | ((*m & 1) << (24 - v83));
                  if (v83 > 7) {
                    while (1) {
                      v47 = *(_BYTE **)(v2 + 16);
                      *v47 = BYTE2(v46);
                      *(_DWORD *)(v2 + 16) = v47 + 1;
                      v48 = *(_DWORD *)(v2 + 20) - 1;
                      *(_DWORD *)(v2 + 20) = v48;
                      if (v48) {
                        if (BYTE2(v46) == 255)
                          goto LABEL_114;
                      LABEL_109:
                        v46 <<= 8;
                        v83 -= 8;
                        if (v83 <= 7)
                          break;
                      } else {
                        v75 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
                        if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v75 + 12))(
                                *(_DWORD *)(v2 + 32))) {
                          *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
                          (***(void(__cdecl ****)(_DWORD))(v2 + 32))(
                              *(_DWORD *)(v2 + 32));
                        }
                        *(_DWORD *)(v2 + 16) = *(_DWORD *)v75;
                        *(_DWORD *)(v2 + 20) = *(_DWORD *)(v75 + 4);
                        if (BYTE2(v46) != 255)
                          goto LABEL_109;
                      LABEL_114:
                        v49 = *(_BYTE **)(v2 + 16);
                        *v49 = 0;
                        *(_DWORD *)(v2 + 16) = v49 + 1;
                        v50 = *(_DWORD *)(v2 + 20) - 1;
                        *(_DWORD *)(v2 + 20) = v50;
                        if (v50)
                          goto LABEL_109;
                        v76 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
                        if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v76 + 12))(
                                *(_DWORD *)(v2 + 32))) {
                          *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
                          (***(void(__cdecl ****)(_DWORD))(v2 + 32))(
                              *(_DWORD *)(v2 + 32));
                        }
                        *(_DWORD *)(v2 + 16) = *(_DWORD *)v76;
                        *(_DWORD *)(v2 + 20) = *(_DWORD *)(v76 + 4);
                        v46 <<= 8;
                        v83 -= 8;
                        if (v83 <= 7)
                          break;
                      }
                    }
                  }
                  *(_DWORD *)(v2 + 24) = v46;
                  *(_DWORD *)(v2 + 28) = v83;
                }
                if (++v88 == (_BYTE *)(v57 + v58))
                  break;
              }
            }
            v57 = *(_DWORD *)(v2 + 64);
            v55 = 0;
            v58 = 0;
          LABEL_15:
            ++v89;
            ++v77;
            ++v78;
            if (v59 < v89)
              goto LABEL_22;
            goto LABEL_16;
          }
          BYTE2(v32) = BYTE2(v85);
        }
        if (v74 != 255)
          goto LABEL_81;
      LABEL_85:
        v37 = *(_BYTE **)(v2 + 16);
        *v37 = 0;
        *(_DWORD *)(v2 + 16) = v37 + 1;
        v38 = *(_DWORD *)(v2 + 20) - 1;
        *(_DWORD *)(v2 + 20) = v38;
        if (!v38) {
          v39 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
          if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v39 + 12))(
                  *(_DWORD *)(v2 + 32))) {
            *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
            (***(void(__cdecl ****)(_DWORD))(v2 + 32))(*(_DWORD *)(v2 + 32));
          }
          *(_DWORD *)(v2 + 16) = *(_DWORD *)v39;
          *(_DWORD *)(v2 + 20) = *(_DWORD *)(v39 + 4);
        }
        goto LABEL_81;
      }
      *(_BYTE *)(v57 + v58++) = v80 & 1;
      ++v89;
      ++v77;
      ++v78;
      if (v59 < v89) {
      LABEL_22:
        if (v55 > 0 || v58) {
          ++*(_DWORD *)(v2 + 56);
          v13 = *(_DWORD *)(v2 + 60) + v58;
          *(_DWORD *)(v2 + 60) = v13;
          if (*(_DWORD *)(v2 + 56) == 0x7FFF || v13 > 0x3A9)
            emit_eobrun(v2);
        }
        goto LABEL_25;
      }
    LABEL_16:;
    }
    while (1) {
      emit_eobrun(v2);
      v16 = *(_DWORD *)(v2 + 52);
      if (*(_BYTE *)(v2 + 12)) {
        ++*(_DWORD *)(*(_DWORD *)(v2 + 4 * v16 + 92) + 960);
      } else {
        v17 = *(_DWORD *)(v2 + 4 * v16 + 76);
        v18 = *(_BYTE *)(v17 + 1264);
        v62 = v18;
        v81 = *(_DWORD *)(v17 + 960);
        v82 = *(_DWORD *)(v2 + 28);
        if (!v18) {
          *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 40;
          (***(void(__cdecl ****)(_DWORD))(v2 + 32))(*(_DWORD *)(v2 + 32));
        }
        if (!*(_BYTE *)(v2 + 12)) {
          v63 = v82 + v62;
          v19 = *(_DWORD *)(v2 + 24) |
                ((v81 & ((1 << v62) - 1)) << (24 - (v82 + v62)));
          if (v82 + v62 > 7) {
            while (1) {
              v20 = *(_BYTE **)(v2 + 16);
              *v20 = BYTE2(v19);
              *(_DWORD *)(v2 + 16) = v20 + 1;
              v21 = *(_DWORD *)(v2 + 20) - 1;
              *(_DWORD *)(v2 + 20) = v21;
              if (v21) {
                if (BYTE2(v19) == 255)
                  goto LABEL_45;
              LABEL_40:
                v19 <<= 8;
                v63 -= 8;
                if (v63 <= 7)
                  break;
              } else {
                v64 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
                if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v64 + 12))(
                        *(_DWORD *)(v2 + 32))) {
                  *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
                  (***(void(__cdecl ****)(_DWORD))(v2 + 32))(
                      *(_DWORD *)(v2 + 32));
                }
                *(_DWORD *)(v2 + 16) = *(_DWORD *)v64;
                *(_DWORD *)(v2 + 20) = *(_DWORD *)(v64 + 4);
                if (BYTE2(v19) != 255)
                  goto LABEL_40;
              LABEL_45:
                v22 = *(_BYTE **)(v2 + 16);
                *v22 = 0;
                *(_DWORD *)(v2 + 16) = v22 + 1;
                v23 = *(_DWORD *)(v2 + 20) - 1;
                *(_DWORD *)(v2 + 20) = v23;
                if (v23)
                  goto LABEL_40;
                v65 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
                if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v65 + 12))(
                        *(_DWORD *)(v2 + 32))) {
                  *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
                  (***(void(__cdecl ****)(_DWORD))(v2 + 32))(
                      *(_DWORD *)(v2 + 32));
                }
                *(_DWORD *)(v2 + 16) = *(_DWORD *)v65;
                *(_DWORD *)(v2 + 20) = *(_DWORD *)(v65 + 4);
                v19 <<= 8;
                v63 -= 8;
                if (v63 <= 7)
                  break;
              }
            }
          }
          *(_DWORD *)(v2 + 24) = v19;
          *(_DWORD *)(v2 + 28) = v63;
          v55 -= 16;
          if (*(_BYTE *)(v2 + 12))
            goto LABEL_32;
          goto LABEL_50;
        }
      }
      v55 -= 16;
      if (*(_BYTE *)(v2 + 12))
        goto LABEL_32;
    LABEL_50:
      if (v58) {
        v87 = (_BYTE *)v57;
        for (n = (_BYTE *)v57;; n = v87) {
          if (!*(_BYTE *)(v2 + 12)) {
            v66 = *(_DWORD *)(v2 + 28) + 1;
            v25 = *(_DWORD *)(v2 + 24) | ((*n & 1) << (24 - v66));
            if (v66 > 7) {
              while (1) {
                v26 = *(_BYTE **)(v2 + 16);
                *v26 = BYTE2(v25);
                *(_DWORD *)(v2 + 16) = v26 + 1;
                v27 = *(_DWORD *)(v2 + 20) - 1;
                *(_DWORD *)(v2 + 20) = v27;
                if (v27) {
                  if (BYTE2(v25) == 255)
                    goto LABEL_61;
                LABEL_56:
                  v25 <<= 8;
                  v66 -= 8;
                  if (v66 <= 7)
                    break;
                } else {
                  v67 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
                  if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v67 + 12))(
                          *(_DWORD *)(v2 + 32))) {
                    *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
                    (***(void(__cdecl ****)(_DWORD))(v2 + 32))(
                        *(_DWORD *)(v2 + 32));
                  }
                  *(_DWORD *)(v2 + 16) = *(_DWORD *)v67;
                  *(_DWORD *)(v2 + 20) = *(_DWORD *)(v67 + 4);
                  if (BYTE2(v25) != 255)
                    goto LABEL_56;
                LABEL_61:
                  v28 = *(_BYTE **)(v2 + 16);
                  *v28 = 0;
                  *(_DWORD *)(v2 + 16) = v28 + 1;
                  v29 = *(_DWORD *)(v2 + 20) - 1;
                  *(_DWORD *)(v2 + 20) = v29;
                  if (v29)
                    goto LABEL_56;
                  v68 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
                  if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v68 + 12))(
                          *(_DWORD *)(v2 + 32))) {
                    *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
                    (***(void(__cdecl ****)(_DWORD))(v2 + 32))(
                        *(_DWORD *)(v2 + 32));
                  }
                  *(_DWORD *)(v2 + 16) = *(_DWORD *)v68;
                  *(_DWORD *)(v2 + 20) = *(_DWORD *)(v68 + 4);
                  v25 <<= 8;
                  v66 -= 8;
                  if (v66 <= 7)
                    break;
                }
              }
            }
            *(_DWORD *)(v2 + 24) = v25;
            *(_DWORD *)(v2 + 28) = v66;
          }
          if (++v87 == (_BYTE *)(v57 + v58))
            break;
        }
      }
    LABEL_32:
      v57 = *(_DWORD *)(v2 + 64);
      v58 = 0;
      if (v55 <= 15)
        goto LABEL_20;
    }
  }
LABEL_25:
  **(_DWORD **)(a1 + 32) = *(_DWORD *)(v2 + 16);
  *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4) = *(_DWORD *)(v2 + 20);
  v14 = *(_DWORD *)(a1 + 192);
  if (v14) {
    if (!*(_DWORD *)(v2 + 68)) {
      *(_DWORD *)(v2 + 68) = v14;
      *(_DWORD *)(v2 + 72) = ((unsigned __int8)*(_DWORD *)(v2 + 72) + 1) & 7;
    }
    --*(_DWORD *)(v2 + 68);
  }
  return 1;
}

int __cdecl encode_mcu_DC_refine(int a1, int a2) {
  int v2;    // esi
  int i;     // edx
  int v4;    // edi
  _BYTE *v5; // eax
  int v6;    // eax
  _BYTE *v7; // eax
  int v8;    // eax
  int v9;    // ecx
  int v10;   // eax
  int v12;   // [esp+18h] [ebp-20h]
  int v13;   // [esp+1Ch] [ebp-1Ch]
  int v14;   // [esp+24h] [ebp-14h]
  int v15;   // [esp+28h] [ebp-10h]
  int v16;   // [esp+2Ch] [ebp-Ch]

  v2 = *(_DWORD *)(a1 + 352);
  v13 = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(v2 + 16) = **(_DWORD **)(a1 + 32);
  *(_DWORD *)(v2 + 20) = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4);
  if (*(_DWORD *)(a1 + 192) && !*(_DWORD *)(v2 + 68))
    emit_restart(v2, *(_DWORD *)(v2 + 72));
  if (*(int *)(a1 + 260) <= 0) {
    v9 = a1;
  } else {
    v12 = 0;
    for (i = 0;; i = v12) {
      if (!*(_BYTE *)(v2 + 12)) {
        v16 = *(_DWORD *)(v2 + 28) + 1;
        v4 = *(_DWORD *)(v2 + 24) |
             (((**(__int16 **)(a2 + 4 * i) >> v13) & 1) << (24 - v16));
        if (v16 > 7) {
          while (1) {
            v5 = *(_BYTE **)(v2 + 16);
            *v5 = BYTE2(v4);
            *(_DWORD *)(v2 + 16) = v5 + 1;
            v6 = *(_DWORD *)(v2 + 20) - 1;
            *(_DWORD *)(v2 + 20) = v6;
            if (v6) {
              if (BYTE2(v4) == 255)
                goto LABEL_15;
            LABEL_10:
              v4 <<= 8;
              v16 -= 8;
              if (v16 <= 7)
                break;
            } else {
              v14 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
              if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v14 + 12))(
                      *(_DWORD *)(v2 + 32))) {
                *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
                (***(void(__cdecl ****)(_DWORD))(v2 + 32))(
                    *(_DWORD *)(v2 + 32));
              }
              *(_DWORD *)(v2 + 16) = *(_DWORD *)v14;
              *(_DWORD *)(v2 + 20) = *(_DWORD *)(v14 + 4);
              if (BYTE2(v4) != 255)
                goto LABEL_10;
            LABEL_15:
              v7 = *(_BYTE **)(v2 + 16);
              *v7 = 0;
              *(_DWORD *)(v2 + 16) = v7 + 1;
              v8 = *(_DWORD *)(v2 + 20) - 1;
              *(_DWORD *)(v2 + 20) = v8;
              if (v8)
                goto LABEL_10;
              v15 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
              if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v15 + 12))(
                      *(_DWORD *)(v2 + 32))) {
                *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
                (***(void(__cdecl ****)(_DWORD))(v2 + 32))(
                    *(_DWORD *)(v2 + 32));
              }
              *(_DWORD *)(v2 + 16) = *(_DWORD *)v15;
              *(_DWORD *)(v2 + 20) = *(_DWORD *)(v15 + 4);
              v4 <<= 8;
              v16 -= 8;
              if (v16 <= 7)
                break;
            }
          }
        }
        *(_DWORD *)(v2 + 24) = v4;
        *(_DWORD *)(v2 + 28) = v16;
      }
      if (++v12 >= *(_DWORD *)(a1 + 260))
        break;
    }
    v9 = a1;
  }
  **(_DWORD **)(v9 + 32) = *(_DWORD *)(v2 + 16);
  *(_DWORD *)(*(_DWORD *)(v9 + 32) + 4) = *(_DWORD *)(v2 + 20);
  v10 = *(_DWORD *)(v9 + 192);
  if (v10) {
    if (!*(_DWORD *)(v2 + 68)) {
      *(_DWORD *)(v2 + 68) = v10;
      *(_DWORD *)(v2 + 72) = ((unsigned __int8)*(_DWORD *)(v2 + 72) + 1) & 7;
    }
    --*(_DWORD *)(v2 + 68);
  }
  return 1;
}

int __cdecl encode_mcu_DC_first(int a1, int a2) {
  int v2;       // esi
  int v3;       // ecx
  int i;        // eax
  int v5;       // edx
  int v6;       // edi
  int v7;       // ecx
  int v8;       // eax
  int v9;       // edi
  _BYTE *v10;   // eax
  int v11;      // eax
  _BYTE *v12;   // eax
  int v13;      // eax
  int v14;      // eax
  int v15;      // eax
  char v16;     // dl
  int v17;      // edi
  _BYTE *v18;   // eax
  int v19;      // eax
  _BYTE *v20;   // eax
  int v21;      // eax
  int v22;      // ecx
  int v23;      // eax
  __int16 *v25; // [esp+1Ch] [ebp-4Ch]
  int v26;      // [esp+20h] [ebp-48h]
  int v27;      // [esp+24h] [ebp-44h]
  int v28;      // [esp+28h] [ebp-40h]
  int v29;      // [esp+2Ch] [ebp-3Ch]
  int v30;      // [esp+30h] [ebp-38h]
  int v31;      // [esp+34h] [ebp-34h]
  int v32;      // [esp+3Ch] [ebp-2Ch]
  int v33;      // [esp+40h] [ebp-28h]
  int v34;      // [esp+48h] [ebp-20h]
  int v35;      // [esp+4Ch] [ebp-1Ch]
  int v36;      // [esp+50h] [ebp-18h]
  int v37;      // [esp+54h] [ebp-14h]
  int v38;      // [esp+58h] [ebp-10h]
  int v39;      // [esp+5Ch] [ebp-Ch]

  v2 = *(_DWORD *)(a1 + 352);
  v28 = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(v2 + 16) = **(_DWORD **)(a1 + 32);
  *(_DWORD *)(v2 + 20) = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4);
  if (*(_DWORD *)(a1 + 192) && !*(_DWORD *)(v2 + 68))
    emit_restart(v2, *(_DWORD *)(v2 + 72));
  if (*(int *)(a1 + 260) > 0) {
    v37 = a1;
    v36 = 1;
    v3 = a1;
    for (i = a1;; i = a1) {
      v5 = *(_DWORD *)(v3 + 264);
      v6 = *(_DWORD *)(i + 4 * v5 + 236);
      v25 = *(__int16 **)(a2 + 4 * v36 - 4);
      v7 = (*v25 >> v28) - *(_DWORD *)(v2 + 4 * v5 + 36);
      *(_DWORD *)(v2 + 4 * v5 + 36) = *v25 >> v28;
      if (v7 < 0) {
        v26 = v7 - 1;
        v7 = -v7;
      } else {
        v26 = v7;
      }
      if (v7) {
        v27 = 0;
        do {
          ++v27;
          v7 >>= 1;
        } while (v7);
        if (v27 > 11) {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 6;
          (**(void(__cdecl ***)(int))a1)(a1);
        }
      } else {
        v27 = 0;
      }
      v8 = *(_DWORD *)(v6 + 20);
      if (*(_BYTE *)(v2 + 12)) {
        ++*(_DWORD *)(*(_DWORD *)(v2 + 4 * v8 + 92) + 4 * v27);
      } else {
        v15 = *(_DWORD *)(v2 + 4 * v8 + 76);
        v16 = *(_BYTE *)(v27 + v15 + 1024);
        v29 = v16;
        v30 = *(_DWORD *)(v15 + 4 * v27);
        v31 = *(_DWORD *)(v2 + 28);
        if (!v16) {
          *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 40;
          (***(void(__cdecl ****)(_DWORD))(v2 + 32))(*(_DWORD *)(v2 + 32));
        }
        if (!*(_BYTE *)(v2 + 12)) {
          v38 = v31 + v29;
          v17 = *(_DWORD *)(v2 + 24) |
                ((v30 & ((1 << v29) - 1)) << (24 - (v31 + v29)));
          if (v31 + v29 <= 7) {
          LABEL_44:
            *(_DWORD *)(v2 + 24) = v17;
            *(_DWORD *)(v2 + 28) = v38;
            goto LABEL_12;
          }
          while (1) {
            v18 = *(_BYTE **)(v2 + 16);
            *v18 = BYTE2(v17);
            *(_DWORD *)(v2 + 16) = v18 + 1;
            v19 = *(_DWORD *)(v2 + 20) - 1;
            *(_DWORD *)(v2 + 20) = v19;
            if (v19) {
              if (BYTE2(v17) != 255)
                goto LABEL_35;
            } else {
              v32 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
              if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v32 + 12))(
                      *(_DWORD *)(v2 + 32))) {
                *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
                (***(void(__cdecl ****)(_DWORD))(v2 + 32))(
                    *(_DWORD *)(v2 + 32));
              }
              *(_DWORD *)(v2 + 16) = *(_DWORD *)v32;
              *(_DWORD *)(v2 + 20) = *(_DWORD *)(v32 + 4);
              if (BYTE2(v17) != 255) {
              LABEL_35:
                v17 <<= 8;
                v38 -= 8;
                if (v38 <= 7)
                  goto LABEL_44;
                continue;
              }
            }
            v20 = *(_BYTE **)(v2 + 16);
            *v20 = 0;
            *(_DWORD *)(v2 + 16) = v20 + 1;
            v21 = *(_DWORD *)(v2 + 20) - 1;
            *(_DWORD *)(v2 + 20) = v21;
            if (v21)
              goto LABEL_35;
            v33 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
            if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v33 + 12))(
                    *(_DWORD *)(v2 + 32))) {
              *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
              (***(void(__cdecl ****)(_DWORD))(v2 + 32))(*(_DWORD *)(v2 + 32));
            }
            *(_DWORD *)(v2 + 16) = *(_DWORD *)v33;
            *(_DWORD *)(v2 + 20) = *(_DWORD *)(v33 + 4);
            v17 <<= 8;
            v38 -= 8;
            if (v38 <= 7)
              goto LABEL_44;
          }
        }
      }
    LABEL_12:
      if (v27 && !*(_BYTE *)(v2 + 12)) {
        v39 = v27 + *(_DWORD *)(v2 + 28);
        v9 = *(_DWORD *)(v2 + 24) | ((v26 & ((1 << v27) - 1)) << (24 - v39));
        if (v39 > 7) {
          while (1) {
            v10 = *(_BYTE **)(v2 + 16);
            *v10 = BYTE2(v9);
            *(_DWORD *)(v2 + 16) = v10 + 1;
            v11 = *(_DWORD *)(v2 + 20) - 1;
            *(_DWORD *)(v2 + 20) = v11;
            if (v11) {
              if (BYTE2(v9) == 255)
                goto LABEL_22;
            LABEL_17:
              v9 <<= 8;
              v39 -= 8;
              if (v39 <= 7)
                break;
            } else {
              v34 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
              if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v34 + 12))(
                      *(_DWORD *)(v2 + 32))) {
                *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
                (***(void(__cdecl ****)(_DWORD))(v2 + 32))(
                    *(_DWORD *)(v2 + 32));
              }
              *(_DWORD *)(v2 + 16) = *(_DWORD *)v34;
              *(_DWORD *)(v2 + 20) = *(_DWORD *)(v34 + 4);
              if (BYTE2(v9) != 255)
                goto LABEL_17;
            LABEL_22:
              v12 = *(_BYTE **)(v2 + 16);
              *v12 = 0;
              *(_DWORD *)(v2 + 16) = v12 + 1;
              v13 = *(_DWORD *)(v2 + 20) - 1;
              *(_DWORD *)(v2 + 20) = v13;
              if (v13)
                goto LABEL_17;
              v35 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
              if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v35 + 12))(
                      *(_DWORD *)(v2 + 32))) {
                *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
                (***(void(__cdecl ****)(_DWORD))(v2 + 32))(
                    *(_DWORD *)(v2 + 32));
              }
              *(_DWORD *)(v2 + 16) = *(_DWORD *)v35;
              *(_DWORD *)(v2 + 20) = *(_DWORD *)(v35 + 4);
              v9 <<= 8;
              v39 -= 8;
              if (v39 <= 7)
                break;
            }
          }
        }
        *(_DWORD *)(v2 + 24) = v9;
        *(_DWORD *)(v2 + 28) = v39;
      }
      v14 = v36++;
      v37 += 4;
      if (v14 >= *(_DWORD *)(a1 + 260)) {
        v22 = a1;
        goto LABEL_51;
      }
      v3 = v37;
    }
  }
  v22 = a1;
LABEL_51:
  **(_DWORD **)(v22 + 32) = *(_DWORD *)(v2 + 16);
  *(_DWORD *)(*(_DWORD *)(v22 + 32) + 4) = *(_DWORD *)(v2 + 20);
  v23 = *(_DWORD *)(v22 + 192);
  if (v23) {
    if (!*(_DWORD *)(v2 + 68)) {
      *(_DWORD *)(v2 + 68) = v23;
      *(_DWORD *)(v2 + 72) = ((unsigned __int8)*(_DWORD *)(v2 + 72) + 1) & 7;
    }
    --*(_DWORD *)(v2 + 68);
  }
  return 1;
}

int __cdecl encode_mcu_AC_first(int a1, int *a2) {
  int v2;      // esi
  int v3;      // eax
  _DWORD *i;   // ecx
  __int16 v5;  // ax
  int v6;      // edx
  int v7;      // eax
  int v8;      // eax
  int v9;      // ecx
  int v10;     // eax
  int v11;     // edi
  int v12;     // edi
  int v13;     // eax
  int v14;     // eax
  int v16;     // eax
  char v17;    // dl
  int v18;     // edi
  _BYTE *v19;  // eax
  int v20;     // eax
  _BYTE *v21;  // eax
  int v22;     // eax
  _BYTE *v23;  // eax
  int v24;     // eax
  _BYTE *v25;  // eax
  int v26;     // eax
  int v27;     // eax
  char v28;    // dl
  int v29;     // edi
  _BYTE *v30;  // eax
  int v31;     // eax
  _BYTE *v32;  // eax
  int v33;     // eax
  int v34;     // [esp+10h] [ebp-88h]
  int v35;     // [esp+14h] [ebp-84h]
  int v36;     // [esp+18h] [ebp-80h]
  int v37;     // [esp+1Ch] [ebp-7Ch]
  int v38;     // [esp+20h] [ebp-78h]
  int v39;     // [esp+24h] [ebp-74h]
  int v40;     // [esp+28h] [ebp-70h]
  int v41;     // [esp+2Ch] [ebp-6Ch]
  int v42;     // [esp+30h] [ebp-68h]
  int v43;     // [esp+34h] [ebp-64h]
  int v44;     // [esp+3Ch] [ebp-5Ch]
  int v45;     // [esp+40h] [ebp-58h]
  int v46;     // [esp+44h] [ebp-54h]
  int v47;     // [esp+48h] [ebp-50h]
  int v48;     // [esp+4Ch] [ebp-4Ch]
  int v49;     // [esp+54h] [ebp-44h]
  int v50;     // [esp+58h] [ebp-40h]
  int v51;     // [esp+5Ch] [ebp-3Ch]
  int v52;     // [esp+64h] [ebp-34h]
  int v53;     // [esp+68h] [ebp-30h]
  _DWORD *v54; // [esp+6Ch] [ebp-2Ch]
  int v55;     // [esp+70h] [ebp-28h]
  int v56;     // [esp+74h] [ebp-24h]
  int v57;     // [esp+78h] [ebp-20h]
  int v58;     // [esp+7Ch] [ebp-1Ch]

  v2 = *(_DWORD *)(a1 + 352);
  v39 = *(_DWORD *)(a1 + 308);
  v40 = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(v2 + 16) = **(_DWORD **)(a1 + 32);
  *(_DWORD *)(v2 + 20) = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4);
  if (*(_DWORD *)(a1 + 192) && !*(_DWORD *)(v2 + 68))
    emit_restart(v2, *(_DWORD *)(v2 + 72));
  v41 = *a2;
  v3 = *(_DWORD *)(a1 + 304);
  v38 = v3;
  if (v39 >= v3) {
    v54 = &jpeg_natural_order[v3];
    v37 = 0;
    for (i = v54;; i = v54) {
      v5 = *(_WORD *)(v41 + 2 * *i);
      if (!v5 ||
          (v5 < 0 ? (v34 = -v5 >> v40, v6 = ~v34) : (v6 = v5 >> v40, v34 = v6),
           v35 = v6, !v34)) {
        ++v37;
        ++v38;
        ++v54;
        if (v39 < v38)
          goto LABEL_26;
        continue;
      }
      if (*(_DWORD *)(v2 + 56))
        emit_eobrun(v2);
      while (v37 > 15) {
        v7 = *(_DWORD *)(v2 + 52);
        if (*(_BYTE *)(v2 + 12)) {
          ++*(_DWORD *)(*(_DWORD *)(v2 + 4 * v7 + 92) + 960);
        } else {
          v16 = *(_DWORD *)(v2 + 4 * v7 + 76);
          v17 = *(_BYTE *)(v16 + 1264);
          v42 = v17;
          v55 = *(_DWORD *)(v16 + 960);
          v56 = *(_DWORD *)(v2 + 28);
          if (!v17) {
            *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 40;
            (***(void(__cdecl ****)(_DWORD))(v2 + 32))(*(_DWORD *)(v2 + 32));
          }
          if (!*(_BYTE *)(v2 + 12)) {
            v43 = v56 + v42;
            v18 = *(_DWORD *)(v2 + 24) |
                  ((v55 & ((1 << v42) - 1)) << (24 - (v56 + v42)));
            if (v56 + v42 <= 7) {
            LABEL_51:
              *(_DWORD *)(v2 + 24) = v18;
              *(_DWORD *)(v2 + 28) = v43;
              v37 -= 16;
              continue;
            }
            while (1) {
              v19 = *(_BYTE **)(v2 + 16);
              *v19 = BYTE2(v18);
              *(_DWORD *)(v2 + 16) = v19 + 1;
              v20 = *(_DWORD *)(v2 + 20) - 1;
              *(_DWORD *)(v2 + 20) = v20;
              if (v20) {
                if (BYTE2(v18) != 255)
                  goto LABEL_42;
              } else {
                v44 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
                if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v44 + 12))(
                        *(_DWORD *)(v2 + 32))) {
                  *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
                  (***(void(__cdecl ****)(_DWORD))(v2 + 32))(
                      *(_DWORD *)(v2 + 32));
                }
                *(_DWORD *)(v2 + 16) = *(_DWORD *)v44;
                *(_DWORD *)(v2 + 20) = *(_DWORD *)(v44 + 4);
                if (BYTE2(v18) != 255) {
                LABEL_42:
                  v18 <<= 8;
                  v43 -= 8;
                  if (v43 <= 7)
                    goto LABEL_51;
                  continue;
                }
              }
              v21 = *(_BYTE **)(v2 + 16);
              *v21 = 0;
              *(_DWORD *)(v2 + 16) = v21 + 1;
              v22 = *(_DWORD *)(v2 + 20) - 1;
              *(_DWORD *)(v2 + 20) = v22;
              if (v22)
                goto LABEL_42;
              v45 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
              if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v45 + 12))(
                      *(_DWORD *)(v2 + 32))) {
                *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
                (***(void(__cdecl ****)(_DWORD))(v2 + 32))(
                    *(_DWORD *)(v2 + 32));
              }
              *(_DWORD *)(v2 + 16) = *(_DWORD *)v45;
              *(_DWORD *)(v2 + 20) = *(_DWORD *)(v45 + 4);
              v18 <<= 8;
              v43 -= 8;
              if (v43 <= 7)
                goto LABEL_51;
            }
          }
        }
        v37 -= 16;
      }
      v8 = v34 >> 1;
      if (v34 >> 1) {
        v36 = 1;
        do {
          ++v36;
          v8 >>= 1;
        } while (v8);
        if (v36 > 10) {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 6;
          (**(void(__cdecl ***)(int))a1)(a1);
        }
      } else {
        v36 = 1;
      }
      v9 = 16 * v37 + v36;
      v10 = *(_DWORD *)(v2 + 52);
      if (*(_BYTE *)(v2 + 12)) {
        ++*(_DWORD *)(*(_DWORD *)(v2 + 4 * v10 + 92) + 4 * v9);
        v11 = *(_DWORD *)(v2 + 28);
        goto LABEL_21;
      }
      v27 = *(_DWORD *)(v2 + 4 * v10 + 76);
      v28 = *(_BYTE *)(v9 + v27 + 1024);
      v46 = v28;
      v47 = *(_DWORD *)(v27 + 4 * v9);
      v48 = *(_DWORD *)(v2 + 28);
      if (v28) {
        if (*(_BYTE *)(v2 + 12))
          goto LABEL_64;
      } else {
        *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 40;
        (***(void(__cdecl ****)(_DWORD))(v2 + 32))(*(_DWORD *)(v2 + 32));
        if (*(_BYTE *)(v2 + 12)) {
        LABEL_64:
          v51 = *(_DWORD *)(v2 + 28);
          if (v36)
            goto LABEL_22;
          goto LABEL_65;
        }
      }
      v57 = v48 + v46;
      v29 = *(_DWORD *)(v2 + 24) |
            ((v47 & ((1 << v46) - 1)) << (24 - (v48 + v46)));
      if (v48 + v46 > 7)
        break;
    LABEL_71:
      *(_DWORD *)(v2 + 24) = v29;
      *(_DWORD *)(v2 + 28) = v57;
      v11 = v57;
    LABEL_21:
      v51 = v11;
      if (v36)
        goto LABEL_22;
    LABEL_65:
      *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 40;
      (***(void(__cdecl ****)(_DWORD))(v2 + 32))(*(_DWORD *)(v2 + 32));
    LABEL_22:
      if (*(_BYTE *)(v2 + 12))
        goto LABEL_25;
      v58 = v51 + v36;
      v12 = *(_DWORD *)(v2 + 24) |
            ((v35 & ((1 << v36) - 1)) << (24 - (v51 + v36)));
      if (v51 + v36 > 7) {
        while (1) {
          v23 = *(_BYTE **)(v2 + 16);
          *v23 = BYTE2(v12);
          *(_DWORD *)(v2 + 16) = v23 + 1;
          v24 = *(_DWORD *)(v2 + 20) - 1;
          *(_DWORD *)(v2 + 20) = v24;
          if (!v24)
            break;
          if (BYTE2(v12) == 255)
            goto LABEL_58;
        LABEL_55:
          v12 <<= 8;
          v58 -= 8;
          if (v58 <= 7)
            goto LABEL_24;
        }
        v52 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
        if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v52 + 12))(
                *(_DWORD *)(v2 + 32))) {
          *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
          (***(void(__cdecl ****)(_DWORD))(v2 + 32))(*(_DWORD *)(v2 + 32));
        }
        *(_DWORD *)(v2 + 16) = *(_DWORD *)v52;
        *(_DWORD *)(v2 + 20) = *(_DWORD *)(v52 + 4);
        if (BYTE2(v12) != 255)
          goto LABEL_55;
      LABEL_58:
        v25 = *(_BYTE **)(v2 + 16);
        *v25 = 0;
        *(_DWORD *)(v2 + 16) = v25 + 1;
        v26 = *(_DWORD *)(v2 + 20) - 1;
        *(_DWORD *)(v2 + 20) = v26;
        if (!v26) {
          v53 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
          if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v53 + 12))(
                  *(_DWORD *)(v2 + 32))) {
            *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
            (***(void(__cdecl ****)(_DWORD))(v2 + 32))(*(_DWORD *)(v2 + 32));
          }
          *(_DWORD *)(v2 + 16) = *(_DWORD *)v53;
          *(_DWORD *)(v2 + 20) = *(_DWORD *)(v53 + 4);
        }
        goto LABEL_55;
      }
    LABEL_24:
      *(_DWORD *)(v2 + 24) = v12;
      *(_DWORD *)(v2 + 28) = v58;
    LABEL_25:
      v37 = 0;
      ++v38;
      ++v54;
      if (v39 < v38) {
      LABEL_26:
        if (v37 > 0) {
          v13 = *(_DWORD *)(v2 + 56) + 1;
          *(_DWORD *)(v2 + 56) = v13;
          if (v13 == 0x7FFF)
            emit_eobrun(v2);
        }
        goto LABEL_29;
      }
    }
    while (1) {
      v30 = *(_BYTE **)(v2 + 16);
      *v30 = BYTE2(v29);
      *(_DWORD *)(v2 + 16) = v30 + 1;
      v31 = *(_DWORD *)(v2 + 20) - 1;
      *(_DWORD *)(v2 + 20) = v31;
      if (!v31)
        break;
      if (BYTE2(v29) == 255)
        goto LABEL_78;
    LABEL_75:
      v29 <<= 8;
      v57 -= 8;
      if (v57 <= 7)
        goto LABEL_71;
    }
    v49 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
    if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v49 + 12))(
            *(_DWORD *)(v2 + 32))) {
      *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
      (***(void(__cdecl ****)(_DWORD))(v2 + 32))(*(_DWORD *)(v2 + 32));
    }
    *(_DWORD *)(v2 + 16) = *(_DWORD *)v49;
    *(_DWORD *)(v2 + 20) = *(_DWORD *)(v49 + 4);
    if (BYTE2(v29) != 255)
      goto LABEL_75;
  LABEL_78:
    v32 = *(_BYTE **)(v2 + 16);
    *v32 = 0;
    *(_DWORD *)(v2 + 16) = v32 + 1;
    v33 = *(_DWORD *)(v2 + 20) - 1;
    *(_DWORD *)(v2 + 20) = v33;
    if (!v33) {
      v50 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 32);
      if (!(*(unsigned __int8(__cdecl **)(_DWORD))(v50 + 12))(
              *(_DWORD *)(v2 + 32))) {
        *(_DWORD *)(**(_DWORD **)(v2 + 32) + 20) = 24;
        (***(void(__cdecl ****)(_DWORD))(v2 + 32))(*(_DWORD *)(v2 + 32));
      }
      *(_DWORD *)(v2 + 16) = *(_DWORD *)v50;
      *(_DWORD *)(v2 + 20) = *(_DWORD *)(v50 + 4);
    }
    goto LABEL_75;
  }
LABEL_29:
  **(_DWORD **)(a1 + 32) = *(_DWORD *)(v2 + 16);
  *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4) = *(_DWORD *)(v2 + 20);
  v14 = *(_DWORD *)(a1 + 192);
  if (v14) {
    if (!*(_DWORD *)(v2 + 68)) {
      *(_DWORD *)(v2 + 68) = v14;
      *(_DWORD *)(v2 + 72) = ((unsigned __int8)*(_DWORD *)(v2 + 72) + 1) & 7;
    }
    --*(_DWORD *)(v2 + 68);
  }
  return 1;
}

int __cdecl inflate_fast(int a1, int a2, int a3, int a4, _DWORD *a5,
                         unsigned __int8 **a6) {
  unsigned int v6;      // edi
  unsigned int v7;      // eax
  unsigned __int8 *v8;  // edx
  int v9;               // esi
  int v10;              // ecx
  unsigned int v11;     // eax
  int v13;              // ecx
  int v14;              // ecx
  unsigned int v15;     // edx
  unsigned int v16;     // edi
  unsigned __int8 *v17; // esi
  int v18;              // esi
  int v19;              // ecx
  unsigned int v20;     // esi
  unsigned __int8 *v21; // edx
  _BYTE *v22;           // edx
  unsigned int v23;     // eax
  int v24;              // esi
  int v25;              // eax
  _BYTE *v26;           // edx
  _BYTE *v27;           // ecx
  int v28;              // ecx
  unsigned int v29;     // eax
  unsigned int v30;     // eax
  _BYTE *v31;           // edx
  _BYTE *v32;           // ecx
  _BYTE *v33;           // ecx
  _BYTE *v34;           // esi
  _BYTE *v35;           // edx
  unsigned int v36;     // eax
  _BYTE *v37;           // [esp+8h] [ebp-3Ch]
  unsigned int v38;     // [esp+Ch] [ebp-38h]
  int v39;              // [esp+10h] [ebp-34h]
  int v40;              // [esp+14h] [ebp-30h]
  unsigned __int8 *v41; // [esp+18h] [ebp-2Ch]
  unsigned int v42;     // [esp+1Ch] [ebp-28h]
  unsigned int v43;     // [esp+20h] [ebp-24h]
  unsigned int v44;     // [esp+24h] [ebp-20h]
  unsigned int v45;     // [esp+28h] [ebp-1Ch]
  unsigned __int8 *v46; // [esp+2Ch] [ebp-18h]
  unsigned int v47;     // [esp+30h] [ebp-14h]

  v41 = *a6;
  v42 = (unsigned int)a6[1];
  v6 = a5[8];
  v43 = a5[7];
  v37 = (_BYTE *)a5[13];
  v7 = a5[12];
  if ((unsigned int)v37 >= v7)
    v38 = a5[11] - (_DWORD)v37;
  else
    v38 = v7 - (_DWORD)v37 - 1;
  v39 = inflate_mask[a1];
  v40 = inflate_mask[a2];
  while (1) {
    while (v43 <= 0x13) {
      --v42;
      v6 |= *v41++ << v43;
      v43 += 8;
    }
    v8 = (unsigned __int8 *)(a3 + 8 * (v6 & v39));
    v9 = *v8;
    if (*v8)
      break;
  LABEL_6:
    v10 = v8[1];
    v6 >>= v10;
    v43 -= v10;
    *v37++ = *((_DWORD *)v8 + 1);
    --v38;
  LABEL_7:
    if (v38 <= 0x101 || v42 <= 9) {
      v11 = (unsigned int)&a6[1][-v42];
      if (v11 > v43 >> 3)
        v11 = v43 >> 3;
      a5[8] = v6;
      a5[7] = v43 - 8 * v11;
      a6[1] = (unsigned __int8 *)(v42 + v11);
      a6[2] += &v41[-v11] - *a6;
      *a6 = &v41[-v11];
      a5[13] = v37;
      return 0;
    }
  }
  while (1) {
    v13 = v8[1];
    v6 >>= v13;
    v43 -= v13;
    if ((v9 & 0x10) != 0)
      break;
    if ((v9 & 0x40) != 0) {
      if ((v9 & 0x20) != 0) {
        v30 = (unsigned int)&a6[1][-v42];
        if (v30 > v43 >> 3)
          v30 = v43 >> 3;
        a5[8] = v6;
        a5[7] = v43 - 8 * v30;
        a6[1] = (unsigned __int8 *)(v42 + v30);
        a6[2] += &v41[-v30] - *a6;
        *a6 = &v41[-v30];
        a5[13] = v37;
        return 1;
      } else {
        a6[6] = "invalid literal/length code";
        v36 = (unsigned int)&a6[1][-v42];
        if (v36 > v43 >> 3)
          v36 = v43 >> 3;
        a5[8] = v6;
        a5[7] = v43 - 8 * v36;
        a6[1] = (unsigned __int8 *)(v42 + v36);
        a6[2] += &v41[-v36] - *a6;
        *a6 = &v41[-v36];
        a5[13] = v37;
        return -3;
      }
    }
    v8 += 8 * *((_DWORD *)v8 + 1) + 8 * (inflate_mask[v9] & v6);
    v9 = *v8;
    if (!*v8)
      goto LABEL_6;
  }
  v14 = v9 & 0xF;
  v47 = *((_DWORD *)v8 + 1) + (v6 & inflate_mask[v14]);
  v15 = v6 >> v14;
  v16 = v43 - v14;
  if (v43 - v14 <= 0xE) {
    v17 = v41;
    do {
      v15 |= *v17++ << v16;
      v16 += 8;
    } while (v16 <= 0xE);
    v42 = &v41[v42] - v17;
    v41 = v17;
  }
  v46 = (unsigned __int8 *)(a4 + 8 * (v15 & v40));
  v18 = *v46;
  v19 = v46[1];
  v45 = v15 >> v19;
  v44 = v16 - v19;
  if ((v18 & 0x10) != 0) {
  LABEL_22:
    v20 = v18 & 0xF;
    if (v20 > v44) {
      v21 = v41;
      do {
        v45 |= *v21++ << v44;
        v44 += 8;
      } while (v20 > v44);
      v42 = &v41[v42] - v21;
      v41 = v21;
    }
    v6 = v45 >> v20;
    v43 = v44 - v20;
    v38 -= v47;
    v22 = &v37[-*((_DWORD *)v46 + 1) - (inflate_mask[v20] & v45)];
    v23 = a5[10];
    if ((unsigned int)v22 >= v23) {
      *v37 = *v22;
      v37[1] = v22[1];
      v31 = v22 + 2;
      v32 = v37 + 2;
      v37 += v47;
      do
        *v32++ = *v31++;
      while (v37 != v32);
    } else {
      v24 = a5[11];
      do
        v22 += a5[11] - v23;
      while (v23 > (unsigned int)v22);
      v25 = v24 - (_DWORD)v22;
      if (v47 > v24 - (int)v22) {
        v33 = v37;
        v34 = &v37[v25];
        do
          *v33++ = *v22++;
        while (&v37[v25] != v33);
        v35 = (_BYTE *)a5[10];
        do
          *v34++ = *v35++;
        while (v34 != &v37[v47]);
        v37 = v34;
      } else {
        *v37 = *v22;
        v37[1] = v22[1];
        v26 = v22 + 2;
        v27 = v37 + 2;
        v37 += v47;
        do
          *v27++ = *v26++;
        while (v37 != v27);
      }
    }
    goto LABEL_7;
  }
  while ((v18 & 0x40) == 0) {
    v46 += 8 * *((_DWORD *)v46 + 1) + 8 * (inflate_mask[v18] & v45);
    v18 = *v46;
    v28 = v46[1];
    v45 >>= v28;
    v44 -= v28;
    if ((v18 & 0x10) != 0)
      goto LABEL_22;
  }
  a6[6] = "invalid distance code";
  v29 = (unsigned int)&a6[1][-v42];
  if (v29 > v44 >> 3)
    v29 = v44 >> 3;
  a5[8] = v45;
  a5[7] = v44 - 8 * v29;
  a6[1] = (unsigned __int8 *)(v42 + v29);
  a6[2] += &v41[-v29] - *a6;
  *a6 = &v41[-v29];
  a5[13] = v37;
  return -3;
}

int __cdecl jpeg_idct_4x4(int a1, int a2, __int16 *a3, _DWORD *a4, int a5) {
  __int16 *v5;  // ecx
  __int16 *v6;  // eax
  __int16 *v7;  // edi
  __int16 *v8;  // edx
  int v9;       // esi
  int v10;      // ecx
  int v11;      // esi
  int v12;      // edi
  int v13;      // ecx
  int v14;      // esi
  int v15;      // eax
  _DWORD *v16;  // eax
  _DWORD *v17;  // esi
  char *v18;    // edx
  int v19;      // edi
  int v20;      // edx
  int v21;      // edi
  int v22;      // ecx
  int v23;      // esi
  int result;   // eax
  int v25;      // eax
  __int16 v26;  // [esp+26h] [ebp-E2h]
  int v27;      // [esp+28h] [ebp-E0h]
  int v28;      // [esp+2Ch] [ebp-DCh]
  __int16 *v29; // [esp+38h] [ebp-D0h]
  _DWORD *v30;  // [esp+3Ch] [ebp-CCh]
  char *v31;    // [esp+40h] [ebp-C8h]
  _BYTE *v32;   // [esp+44h] [ebp-C4h]
  int v33;      // [esp+48h] [ebp-C0h]
  int v34;      // [esp+4Ch] [ebp-BCh]
  _DWORD *v35;  // [esp+50h] [ebp-B8h]
  _DWORD *v36;  // [esp+54h] [ebp-B4h]
  _DWORD *v37;  // [esp+58h] [ebp-B0h]
  __int16 *v38; // [esp+5Ch] [ebp-ACh]
  __int16 *v39; // [esp+60h] [ebp-A8h]
  __int16 *v40; // [esp+64h] [ebp-A4h]
  int v41;      // [esp+68h] [ebp-A0h]
  int *v42;     // [esp+6Ch] [ebp-9Ch]
  int v43;      // [esp+70h] [ebp-98h]
  int v44;      // [esp+74h] [ebp-94h]
  int v45;      // [esp+78h] [ebp-90h]
  int v46;      // [esp+7Ch] [ebp-8Ch]
  char v47;     // [esp+80h] [ebp-88h] BYREF
  int v48;      // [esp+84h] [ebp-84h]

  v33 = *(_DWORD *)(a1 + 296) + 128;
  v30 = *(_DWORD **)(a2 + 80);
  v29 = a3;
  v34 = 8;
  v42 = (int *)&v47;
  v5 = a3;
LABEL_9:
  v26 = v5[8];
  if (v26) {
    v6 = v29 + 16;
    v7 = v29 + 48;
    v38 = v29 + 56;
    v39 = v29 + 40;
    v40 = v29 + 24;
    v8 = v29;
  } else {
    v6 = v29 + 16;
    if (v29[16]) {
      v7 = v29 + 48;
      v38 = v29 + 56;
      v39 = v29 + 40;
      v40 = v29 + 24;
      v8 = v29;
    } else {
      v40 = v29 + 24;
      if (v29[24]) {
        v7 = v29 + 48;
        v38 = v29 + 56;
        v39 = v29 + 40;
        v8 = v29;
      } else {
        v39 = v29 + 40;
        if (v29[40]) {
          v7 = v29 + 48;
          v38 = v29 + 56;
          v8 = v29;
        } else {
          v7 = v29 + 48;
          if (v29[48]) {
            v38 = v29 + 56;
            v8 = v29;
          } else {
            v38 = v29 + 56;
            if (!v29[56]) {
              v25 = 4 * *v30 * *v29;
              *v42 = v25;
              v42[8] = v25;
              v42[16] = v25;
              v42[24] = v25;
              goto LABEL_5;
            }
            v8 = v29;
          }
        }
      }
    }
  }
  v9 = (*v30 * *v8) << 14;
  v10 = 15137 * v30[16] * *v6 - 6270 * v30[48] * *v7;
  v46 = v9 + v10;
  v45 = v9 - v10;
  v44 = v30[56] * *v38;
  v11 = v30[40] * *v39;
  v43 = v30[24] * *v40;
  v12 = v30[8] * v26;
  v13 = 8697 * v12 - 17799 * v43 + 11893 * v11 - 1730 * v44;
  v14 = 7373 * v43 + 20995 * v12 + -4926 * v11 - 4176 * v44;
  *v42 = (v46 + v14 + 2048) >> 12;
  v42[24] = (v46 - v14 + 2048) >> 12;
  v42[8] = (v45 + v13 + 2048) >> 12;
  v42[16] = (v45 - v13 + 2048) >> 12;
LABEL_5:
  v15 = v34;
  while (1) {
    ++v29;
    ++v30;
    ++v42;
    v34 = v15 - 1;
    if (v15 - 1 <= 0)
      break;
    v15 = 4;
    if (v34 != 4) {
      v5 = v29;
      goto LABEL_9;
    }
  }
  v31 = &v47;
  v41 = 1;
  v32 = (_BYTE *)(*a4 + a5);
  v27 = v48;
  if (v48)
    goto LABEL_19;
LABEL_14:
  v16 = v31 + 8;
  if (*((_DWORD *)v31 + 2)) {
    v17 = v31 + 24;
    v35 = v31 + 28;
    v36 = v31 + 20;
    v37 = v31 + 12;
    v18 = v31;
    goto LABEL_16;
  }
  v37 = v31 + 12;
  if (*((_DWORD *)v31 + 3)) {
    v17 = v31 + 24;
    v35 = v31 + 28;
    v36 = v31 + 20;
    v18 = v31;
    goto LABEL_16;
  }
  v36 = v31 + 20;
  v18 = v31;
  if (*((_DWORD *)v31 + 5)) {
    v17 = v31 + 24;
    v35 = v31 + 28;
    v18 = v31;
  } else {
    v17 = v31 + 24;
    if (*((_DWORD *)v31 + 6)) {
      v35 = v31 + 28;
      v18 = v31;
    } else {
      v35 = v31 + 28;
      if (!*((_DWORD *)v31 + 7)) {
        result =
            *(unsigned __int8 *)(v33 + (((*(_DWORD *)v31 + 16) >> 5) & 0x3FF));
        *v32 = result;
        v32[1] = result;
        v32[2] = result;
        v32[3] = result;
        v31 += 32;
        goto LABEL_17;
      }
    }
  }
LABEL_16:
  while (1) {
    v19 = *(_DWORD *)v18 << 14;
    v20 = 15137 * *v16 - 6270 * *v17;
    v28 = v19 + v20;
    v21 = v19 - v20;
    v22 = 8697 * v27 - 17799 * *v37 + 11893 * *v36 - 1730 * *v35;
    v23 = 7373 * *v37 + 20995 * v27 + -4926 * *v36 - 4176 * *v35;
    *v32 = *(_BYTE *)(v33 + (((v28 + v23 + 0x40000) >> 19) & 0x3FF));
    v32[3] = *(_BYTE *)(v33 + (((v28 - v23 + 0x40000) >> 19) & 0x3FF));
    v32[1] = *(_BYTE *)(v33 + (((v21 + v22 + 0x40000) >> 19) & 0x3FF));
    result =
        *(unsigned __int8 *)(v33 + (((v21 - v22 + 0x40000) >> 19) & 0x3FF));
    v32[2] = result;
    v31 += 32;
  LABEL_17:
    if (++v41 == 5)
      return result;
    v32 = (_BYTE *)(a4[v41 - 1] + a5);
    v27 = *((_DWORD *)v31 + 1);
    if (!v27)
      goto LABEL_14;
  LABEL_19:
    v16 = v31 + 8;
    v17 = v31 + 24;
    v35 = v31 + 28;
    v36 = v31 + 20;
    v37 = v31 + 12;
    v18 = v31;
  }
}

int __cdecl jpeg_idct_2x2(int a1, int a2, __int16 *a3, int a4, int a5) {
  __int16 *v5;   // eax
  __int16 *v6;   // ecx
  __int16 *v7;   // edx
  int v8;        // edi
  int v9;        // eax
  int v10;       // esi
  _DWORD *v11;   // eax
  _DWORD *v12;   // ecx
  _DWORD *v13;   // edx
  int v14;       // edi
  int result;    // eax
  int v16;       // eax
  __int16 v17;   // [esp+12h] [ebp-76h]
  int v18;       // [esp+14h] [ebp-74h]
  __int16 *v19;  // [esp+18h] [ebp-70h]
  _DWORD *v20;   // [esp+1Ch] [ebp-6Ch]
  _DWORD *v21;   // [esp+20h] [ebp-68h]
  _BYTE *v22;    // [esp+24h] [ebp-64h]
  int v23;       // [esp+28h] [ebp-60h]
  int v24;       // [esp+2Ch] [ebp-5Ch]
  _DWORD *v25;   // [esp+30h] [ebp-58h]
  __int16 *v26;  // [esp+34h] [ebp-54h]
  int i;         // [esp+38h] [ebp-50h]
  int *v28;      // [esp+3Ch] [ebp-4Ch]
  _BYTE v29[72]; // [esp+40h] [ebp-48h] BYREF

  v23 = *(_DWORD *)(a1 + 296) + 128;
  v20 = *(_DWORD **)(a2 + 80);
  v19 = a3;
  v24 = 8;
  v28 = (int *)v29;
  v17 = a3[8];
  if (v17) {
  LABEL_10:
    v5 = v19 + 56;
    v6 = v19 + 40;
    v26 = v19 + 24;
    v7 = v19;
    goto LABEL_4;
  }
LABEL_2:
  v26 = v19 + 24;
  if (v19[24]) {
    v5 = v19 + 56;
    v6 = v19 + 40;
    v7 = v19;
  LABEL_4:
    v8 = (*v20 * *v7) << 15;
    v9 = 6967 * v20[40] * *v6 - 5906 * v20[56] * *v5 - 10426 * v20[24] * *v26 +
         29692 * v20[8] * v17;
    *v28 = (v8 + v9 + 4096) >> 13;
    v28[8] = (v8 - v9 + 4096) >> 13;
    goto LABEL_5;
  }
  v6 = v19 + 40;
  if (v19[40]) {
    v5 = v19 + 56;
    v7 = v19;
    goto LABEL_4;
  }
  v5 = v19 + 56;
  v7 = v19;
  if (v19[56])
    goto LABEL_4;
  v16 = 4 * *v20 * *v19;
  *v28 = v16;
  v28[8] = v16;
LABEL_5:
  while (1) {
    ++v19;
    ++v20;
    ++v28;
    if (--v24 <= 0)
      break;
    if (v24 != 6 && v24 != 4 && v24 != 2) {
      v17 = v19[8];
      if (v17)
        goto LABEL_10;
      goto LABEL_2;
    }
  }
  v21 = v29;
  for (i = 1; i != 3; ++i) {
    v22 = (_BYTE *)(*(_DWORD *)(a4 + 4 * i - 4) + a5);
    v10 = v21[1];
    if (v10) {
      v11 = v21 + 7;
      v12 = v21 + 5;
      v25 = v21 + 3;
      v13 = v21;
      goto LABEL_15;
    }
    v25 = v21 + 3;
    if (v21[3]) {
      v11 = v21 + 7;
      v12 = v21 + 5;
      v13 = v21;
    LABEL_15:
      v18 = *v13 << 15;
      v14 = -10426 * *v25 + 29692 * v10 + 6967 * *v12 - 5906 * *v11;
      *v22 = *(_BYTE *)(v23 + (((v18 + v14 + 0x80000) >> 20) & 0x3FF));
      result =
          *(unsigned __int8 *)(v23 + (((v18 - v14 + 0x80000) >> 20) & 0x3FF));
      v22[1] = result;
      v21 += 8;
      continue;
    }
    v12 = v21 + 5;
    if (v21[5]) {
      v11 = v21 + 7;
      v13 = v21;
      goto LABEL_15;
    }
    v11 = v21 + 7;
    v13 = v21;
    if (v21[7])
      goto LABEL_15;
    result = *(unsigned __int8 *)(v23 + (((*v21 + 16) >> 5) & 0x3FF));
    *v22 = result;
    v22[1] = result;
    v21 += 8;
  }
  return result;
}

int __cdecl jpeg_idct_1x1(int a1, int a2, __int16 *a3, _DWORD *a4, int a5) {
  int result; // eax

  result = a5;
  *(_BYTE *)(*a4 + a5) =
      *(_BYTE *)(*(_DWORD *)(a1 + 296) +
                 (((**(_DWORD **)(a2 + 80) * *a3 + 4) >> 3) & 0x3FF) + 128);
  return result;
}

int __cdecl jpeg_idct_float(int a1, int a2, __int16 *a3, int a4, int a5) {
  float *v5;    // ecx
  float *v7;    // esi
  __int16 *v8;  // edi
  float v9;     // xmm4_4
  float v10;    // xmm2_4
  float v11;    // xmm1_4
  float v12;    // xmm6_4
  float v13;    // xmm4_4
  float v14;    // xmm2_4
  float v15;    // xmm0_4
  float v16;    // xmm6_4
  float v17;    // xmm4_4
  float v18;    // xmm3_4
  float v19;    // xmm2_4
  float v20;    // xmm0_4
  float v21;    // xmm1_4
  float v22;    // xmm7_4
  float v23;    // xmm0_4
  float v24;    // xmm2_4
  float v25;    // xmm3_4
  float v26;    // xmm5_4
  float v27;    // xmm1_4
  float v28;    // xmm0_4
  float v29;    // xmm2_4
  float v30;    // xmm3_4
  float *v31;   // ecx
  int i;        // esi
  _BYTE *v33;   // edx
  float v34;    // xmm0_4
  float v35;    // xmm7_4
  float v36;    // xmm4_4
  float v37;    // xmm2_4
  float v38;    // xmm1_4
  float v39;    // xmm0_4
  float v40;    // xmm6_4
  float v41;    // xmm7_4
  float v42;    // xmm4_4
  float v43;    // xmm0_4
  float v44;    // xmm1_4
  float v45;    // xmm0_4
  float v46;    // xmm2_4
  float v47;    // xmm3_4
  float v48;    // xmm5_4
  float v49;    // xmm0_4
  float v50;    // xmm1_4
  float v51;    // xmm2_4
  float v52;    // xmm3_4
  int result;   // eax
  float v54;    // xmm0_4
  __int16 v55;  // [esp+12h] [ebp-146h]
  float v56;    // [esp+14h] [ebp-144h]
  float v57;    // [esp+18h] [ebp-140h]
  int v58;      // [esp+1Ch] [ebp-13Ch]
  __int16 *v59; // [esp+20h] [ebp-138h]
  __int16 *v60; // [esp+24h] [ebp-134h]
  __int16 *v61; // [esp+28h] [ebp-130h]
  __int16 *v62; // [esp+2Ch] [ebp-12Ch]
  __int16 *v63; // [esp+30h] [ebp-128h]
  int v64;      // [esp+34h] [ebp-124h]
  float v65;    // [esp+38h] [ebp-120h]
  float v66;    // [esp+3Ch] [ebp-11Ch]
  char v67;     // [esp+40h] [ebp-118h] BYREF
  char v68;     // [esp+60h] [ebp-F8h] BYREF

  v58 = *(_DWORD *)(a1 + 296) + 128;
  v5 = *(float **)(a2 + 80);
  v7 = (float *)&v67;
  v64 = 8;
  do {
    v55 = a3[8];
    if (v55) {
      v59 = a3 + 16;
      v60 = a3 + 32;
      v61 = a3 + 48;
      v62 = a3 + 24;
      v63 = a3 + 40;
    LABEL_8:
      v8 = a3 + 56;
    LABEL_4:
      v9 = (float)*a3 * *v5;
      v10 = (float)*v60 * v5[32];
      v11 = (float)*v61 * v5[48];
      v12 = v9 + v10;
      v13 = v9 - v10;
      v14 = (float)((float)*v59 * v5[16]) + v11;
      v15 = (float)((float)((float)((float)*v59 * v5[16]) - v11) * 1.4142135) -
            v14;
      v66 = v12 + v14;
      v16 = v12 - v14;
      v65 = v13 + v15;
      v17 = v13 - v15;
      v18 = (float)v55 * v5[8];
      v19 = (float)*v62 * v5[24];
      v20 = (float)*v63 * v5[40];
      v21 = (float)*v8 * v5[56];
      v22 = v19 + v20;
      v23 = v20 - v19;
      v24 = v18 + v21;
      v25 = v18 - v21;
      v26 = v22 + v24;
      v27 = (float)(v23 + v25) * 1.847759;
      v28 = (float)((float)(v23 * -2.613126) + v27) - (float)(v22 + v24);
      v29 = (float)((float)(v24 - v22) * 1.4142135) - v28;
      v30 = (float)((float)(v25 * 1.0823922) - v27) + v29;
      *v7 = v66 + v26;
      v7[56] = v66 - v26;
      v7[8] = v65 + v28;
      v7[48] = v65 - v28;
      v7[16] = v17 + v29;
      v7[40] = v17 - v29;
      v7[32] = v16 + v30;
      v7[24] = v16 - v30;
      ++a3;
      ++v5;
      ++v7;
      goto LABEL_5;
    }
    v59 = a3 + 16;
    if (a3[16]) {
      v60 = a3 + 32;
      v61 = a3 + 48;
      v62 = a3 + 24;
      v63 = a3 + 40;
      v8 = a3 + 56;
      goto LABEL_4;
    }
    v62 = a3 + 24;
    if (a3[24]) {
      v60 = a3 + 32;
      v61 = a3 + 48;
      v63 = a3 + 40;
      v8 = a3 + 56;
      goto LABEL_4;
    }
    v60 = a3 + 32;
    if (a3[32]) {
      v61 = a3 + 48;
      v63 = a3 + 40;
      v8 = a3 + 56;
      goto LABEL_4;
    }
    v63 = a3 + 40;
    if (a3[40]) {
      v61 = a3 + 48;
      v8 = a3 + 56;
      goto LABEL_4;
    }
    v61 = a3 + 48;
    if (a3[48])
      goto LABEL_8;
    v8 = a3 + 56;
    if (a3[56])
      goto LABEL_4;
    v54 = (float)*a3 * *v5;
    *v7 = v54;
    v7[8] = v54;
    v7[16] = v54;
    v7[24] = v54;
    v7[32] = v54;
    v7[40] = v54;
    v7[48] = v54;
    v7[56] = v54;
    ++a3;
    ++v5;
    ++v7;
  LABEL_5:
    --v64;
  } while (v64);
  v31 = (float *)&v68;
  for (i = 1; i != 9; ++i) {
    v33 = (_BYTE *)(*(_DWORD *)(a4 + 4 * i - 4) + a5);
    v34 = *(v31 - 4);
    v35 = *(v31 - 8) + v34;
    v36 = *(v31 - 8) - v34;
    v37 = *(v31 - 2);
    v38 = *(v31 - 6) + v37;
    v39 = (float)((float)(*(v31 - 6) - v37) * 1.4142135) - v38;
    v40 = v35 + v38;
    v41 = v35 - v38;
    v56 = v36 + v39;
    v42 = v36 - v39;
    v43 = *(v31 - 5);
    v57 = *(v31 - 3) + v43;
    v44 = *(v31 - 3) - v43;
    v45 = *(v31 - 1);
    v46 = *(v31 - 7) + v45;
    v47 = *(v31 - 7) - v45;
    v48 = v57 + v46;
    v49 = (float)(v44 + v47) * 1.847759;
    v50 = (float)((float)(v44 * -2.613126) + v49) - (float)(v57 + v46);
    v51 = (float)((float)(v46 - v57) * 1.4142135) - v50;
    v52 = (float)((float)(v47 * 1.0823922) - v49) + v51;
    *v33 = *(_BYTE *)(v58 + ((((int)(float)(v40 + v48) + 4) >> 3) & 0x3FF));
    v33[7] = *(_BYTE *)(v58 + ((((int)(float)(v40 - v48) + 4) >> 3) & 0x3FF));
    v33[1] = *(_BYTE *)(v58 + ((((int)(float)(v56 + v50) + 4) >> 3) & 0x3FF));
    v33[6] = *(_BYTE *)(v58 + ((((int)(float)(v56 - v50) + 4) >> 3) & 0x3FF));
    v33[2] = *(_BYTE *)(v58 + ((((int)(float)(v42 + v51) + 4) >> 3) & 0x3FF));
    v33[5] = *(_BYTE *)(v58 + ((((int)(float)(v42 - v51) + 4) >> 3) & 0x3FF));
    v33[4] = *(_BYTE *)(v58 + ((((int)(float)(v41 + v52) + 4) >> 3) & 0x3FF));
    result = *(unsigned __int8 *)(v58 + ((((int)(float)(v41 - v52) + 4) >> 3) &
                                         0x3FF));
    v33[3] = result;
    v31 += 8;
  }
  return result;
}

int __cdecl jpeg_idct_ifast(int a1, int a2, __int16 *a3, int a4, int a5) {
  __int16 *i;     // ecx
  __int16 *v6;    // edx
  __int16 *v7;    // esi
  __int16 *v8;    // edi
  __int16 *v9;    // eax
  __int16 *v10;   // ecx
  __int16 *v11;   // edi
  int v12;        // esi
  int v13;        // edx
  int v14;        // eax
  int v15;        // ecx
  int v16;        // edi
  int v17;        // eax
  int v18;        // edi
  int v19;        // ecx
  int v20;        // edx
  int v21;        // eax
  int v22;        // edx
  int v23;        // edi
  int v24;        // ecx
  int v25;        // eax
  int v26;        // esi
  int v27;        // edx
  __int16 *v28;   // ecx
  __int16 *v29;   // edi
  int *j;         // esi
  int *v31;       // edx
  int *v32;       // eax
  int *v33;       // esi
  int *v34;       // edi
  int v35;        // ecx
  int v36;        // eax
  int v37;        // edi
  int v38;        // edx
  int v39;        // eax
  int v40;        // esi
  int v41;        // eax
  int v42;        // ecx
  int v43;        // edi
  int v44;        // esi
  int v45;        // edx
  int v46;        // ecx
  int v47;        // edi
  int result;     // eax
  int *v49;       // ecx
  int *v50;       // ecx
  int *v51;       // edi
  int v52;        // eax
  __int16 v53;    // [esp+22h] [ebp-186h]
  int v54;        // [esp+24h] [ebp-184h]
  int v55;        // [esp+28h] [ebp-180h]
  int v56;        // [esp+34h] [ebp-174h]
  int v57;        // [esp+38h] [ebp-170h]
  int v58;        // [esp+3Ch] [ebp-16Ch]
  int v59;        // [esp+40h] [ebp-168h]
  int v60;        // [esp+44h] [ebp-164h]
  __int16 *v61;   // [esp+48h] [ebp-160h]
  _DWORD *v62;    // [esp+4Ch] [ebp-15Ch]
  int *v63;       // [esp+50h] [ebp-158h]
  _BYTE *v64;     // [esp+54h] [ebp-154h]
  int v65;        // [esp+58h] [ebp-150h]
  _DWORD *v66;    // [esp+5Ch] [ebp-14Ch]
  _DWORD *v67;    // [esp+60h] [ebp-148h]
  _DWORD *v68;    // [esp+64h] [ebp-144h]
  __int16 *v69;   // [esp+68h] [ebp-140h]
  __int16 *v70;   // [esp+6Ch] [ebp-13Ch]
  __int16 *v71;   // [esp+70h] [ebp-138h]
  int v72;        // [esp+74h] [ebp-134h]
  int v73;        // [esp+78h] [ebp-130h]
  int v74;        // [esp+7Ch] [ebp-12Ch]
  int v75;        // [esp+84h] [ebp-124h]
  int v76;        // [esp+88h] [ebp-120h]
  int v77;        // [esp+8Ch] [ebp-11Ch]
  int v78;        // [esp+90h] [ebp-118h]
  int v79;        // [esp+94h] [ebp-114h]
  int v80;        // [esp+98h] [ebp-110h]
  int *v81;       // [esp+9Ch] [ebp-10Ch]
  _BYTE v82[264]; // [esp+A0h] [ebp-108h] BYREF

  v65 = *(_DWORD *)(a1 + 296) + 128;
  v62 = *(_DWORD **)(a2 + 80);
  v61 = a3;
  v63 = (int *)v82;
  v72 = 8;
  for (i = a3;; i = v61) {
    v53 = i[8];
    if (v53) {
      v6 = v61 + 16;
      v9 = v61 + 32;
      v10 = v61 + 48;
      v69 = v61 + 24;
      v8 = v61;
      goto LABEL_4;
    }
    v6 = v61 + 16;
    v7 = v61;
    if (v61[16]) {
      v8 = v61;
      v9 = v61 + 32;
      v10 = v61 + 48;
      v69 = v61 + 24;
    LABEL_4:
      v70 = v8 + 40;
      v71 = v61 + 56;
      v11 = v61;
      goto LABEL_5;
    }
    v69 = v61 + 24;
    if (v61[24]) {
      v28 = v61;
      v29 = v61;
      v9 = v61 + 32;
      goto LABEL_12;
    }
    v9 = v61 + 32;
    v28 = v61;
    if (v61[32]) {
      v7 = v61;
      v29 = v61;
    LABEL_12:
      v10 = v28 + 48;
      v70 = v7 + 40;
    LABEL_13:
      v71 = v29 + 56;
      v11 = v61;
    LABEL_5:
      v12 = *v62 * *v11;
      v13 = v62[16] * *v6;
      v14 = v62[32] * *v9;
      v15 = v62[48] * *v10;
      v16 = v12 + v14;
      v74 = v12 - v14;
      v17 = ((362 * (v13 - v15)) >> 8) - (v13 + v15);
      v80 = v16 + v13 + v15;
      v79 = v16 - (v13 + v15);
      v78 = v17 + v74;
      v77 = v74 - v17;
      v18 = v62[8] * v53;
      v19 = v62[24] * *v69;
      v20 = v62[40] * *v70;
      v21 = v62[56] * *v71;
      v76 = v19 + v20;
      v22 = v20 - v19;
      v75 = v18 + v21;
      v23 = v18 - v21;
      v24 = (473 * (v22 + v23)) >> 8;
      v25 = v24 + ((-669 * v22) >> 8) - (v75 + v76);
      v26 = ((362 * (v75 - v76)) >> 8) - v25;
      v27 = v26 + ((277 * v23) >> 8) - v24;
      *v63 = v75 + v76 + v80;
      v63[56] = v80 - (v75 + v76);
      v63[8] = v25 + v78;
      v63[48] = v78 - v25;
      v63[16] = v26 + v77;
      v63[40] = v77 - v26;
      v63[32] = v27 + v79;
      v63[24] = v79 - v27;
      ++v61;
      ++v62;
      ++v63;
      goto LABEL_6;
    }
    v70 = v61 + 40;
    if (v61[40]) {
      v10 = v61 + 48;
      v71 = v61 + 56;
      v11 = v61;
      goto LABEL_5;
    }
    v29 = v61;
    v10 = v61 + 48;
    if (v61[48])
      goto LABEL_13;
    v71 = v61 + 56;
    v11 = v61;
    if (v61[56])
      goto LABEL_5;
    v52 = *v62 * *v61;
    *v63 = v52;
    v63[8] = v52;
    v63[16] = v52;
    v63[24] = v52;
    v63[32] = v52;
    v63[40] = v52;
    v63[48] = v52;
    v63[56] = v52;
    ++v61;
    ++v62;
    ++v63;
  LABEL_6:
    if (!--v72)
      break;
  }
  v81 = (int *)v82;
  v73 = 1;
  for (j = (int *)v82;; j = v81) {
    v64 = (_BYTE *)(*(_DWORD *)(a4 + 4 * v73 - 4) + a5);
    v54 = j[1];
    if (v54) {
      v32 = v81 + 4;
      v31 = v81 + 2;
      v33 = v81 + 6;
      v66 = v81 + 5;
      v67 = v81 + 3;
      v49 = v81;
    LABEL_22:
      v68 = v49 + 7;
      v34 = v81;
    LABEL_17:
      v35 = *v34;
      v36 = *v32;
      v37 = *v34 + v36;
      v58 = v35 - v36;
      v38 = *v31;
      v39 = *v33;
      v40 = v38 + *v33;
      v41 = ((362 * (v38 - v39)) >> 8) - v40;
      v55 = v37 + v40;
      v56 = v37 - v40;
      v60 = *v66 + *v67;
      v42 = *v66 - *v67;
      v43 = *v68 + v54;
      v59 = v54 - *v68;
      v57 = v43 + v60;
      v44 = (473 * (v42 + v59)) >> 8;
      v45 = v44 + ((-669 * v42) >> 8) - (v43 + v60);
      v46 = ((362 * (v43 - v60)) >> 8) - v45;
      v47 = v46 + ((277 * v59) >> 8) - v44;
      *v64 = *(_BYTE *)(v65 + (((v57 + v55) >> 5) & 0x3FF));
      v64[7] = *(_BYTE *)(v65 + (((v55 - v57) >> 5) & 0x3FF));
      v64[1] = *(_BYTE *)(v65 + (((v45 + v41 + v58) >> 5) & 0x3FF));
      v64[6] = *(_BYTE *)(v65 + (((v41 + v58 - v45) >> 5) & 0x3FF));
      v64[2] = *(_BYTE *)(v65 + (((v46 + v58 - v41) >> 5) & 0x3FF));
      v64[5] = *(_BYTE *)(v65 + (((v58 - v41 - v46) >> 5) & 0x3FF));
      v64[4] = *(_BYTE *)(v65 + (((v47 + v56) >> 5) & 0x3FF));
      result = *(unsigned __int8 *)(v65 + (((v56 - v47) >> 5) & 0x3FF));
      v64[3] = result;
      v81 += 8;
      goto LABEL_18;
    }
    v31 = v81 + 2;
    if (v81[2]) {
      v32 = v81 + 4;
      v33 = v81 + 6;
      v66 = v81 + 5;
      v67 = v81 + 3;
      v68 = v81 + 7;
      v34 = v81;
      goto LABEL_17;
    }
    v50 = v81;
    v67 = v81 + 3;
    if (v81[3]) {
      v51 = v81;
      v32 = v81 + 4;
    LABEL_25:
      v33 = v50 + 6;
      v66 = v50 + 5;
      v68 = v51 + 7;
      v34 = v81;
      goto LABEL_17;
    }
    v32 = v81 + 4;
    v50 = v81;
    if (v81[4]) {
      v51 = v81;
      goto LABEL_25;
    }
    v66 = v81 + 5;
    if (v81[5]) {
      v33 = v81 + 6;
      v68 = v81 + 7;
      v34 = v81;
      goto LABEL_17;
    }
    v33 = v81 + 6;
    v49 = v81;
    if (v81[6])
      goto LABEL_22;
    v68 = v81 + 7;
    if (v81[7]) {
      v34 = v81;
      goto LABEL_17;
    }
    result = *(unsigned __int8 *)(v65 + ((*v81 >> 5) & 0x3FF));
    *v64 = result;
    v64[1] = result;
    v64[2] = result;
    v64[3] = result;
    v64[4] = result;
    v64[5] = result;
    v64[6] = result;
    v64[7] = result;
    v81 += 8;
  LABEL_18:
    if (++v73 == 9)
      break;
  }
  return result;
}

int __cdecl jpeg_idct_islow(int a1, int a2, __int16 *a3, int a4, int a5) {
  __int16 *i;     // ecx
  __int16 *v6;    // edx
  __int16 *v7;    // eax
  int v8;         // esi
  int v9;         // edi
  int v10;        // ecx
  int v11;        // edx
  int v12;        // edi
  int v13;        // eax
  int v14;        // esi
  int v15;        // eax
  int v16;        // esi
  int v17;        // ecx
  int v18;        // edi
  int v19;        // ecx
  int v20;        // edx
  int v21;        // edi
  int v22;        // esi
  int v23;        // edx
  _BYTE *j;       // edx
  _DWORD *v25;    // edx
  _DWORD *v26;    // edi
  _DWORD *v27;    // eax
  int v28;        // esi
  int v29;        // ecx
  int v30;        // eax
  int v31;        // esi
  int v32;        // edx
  int v33;        // edx
  int v34;        // edi
  int v35;        // esi
  int v36;        // edx
  int result;     // eax
  int v38;        // eax
  int v39;        // [esp+28h] [ebp-1C0h]
  int v40;        // [esp+38h] [ebp-1B0h]
  __int16 v41;    // [esp+3Eh] [ebp-1AAh]
  int v42;        // [esp+40h] [ebp-1A8h]
  int v43;        // [esp+44h] [ebp-1A4h]
  int v44;        // [esp+48h] [ebp-1A0h]
  int v45;        // [esp+4Ch] [ebp-19Ch]
  int v46;        // [esp+50h] [ebp-198h]
  __int16 *v47;   // [esp+58h] [ebp-190h]
  _DWORD *v48;    // [esp+5Ch] [ebp-18Ch]
  int *v49;       // [esp+60h] [ebp-188h]
  _BYTE *v50;     // [esp+64h] [ebp-184h]
  int v51;        // [esp+68h] [ebp-180h]
  _DWORD *v52;    // [esp+6Ch] [ebp-17Ch]
  _DWORD *v53;    // [esp+70h] [ebp-178h]
  _DWORD *v54;    // [esp+74h] [ebp-174h]
  _DWORD *v55;    // [esp+78h] [ebp-170h]
  __int16 *v56;   // [esp+7Ch] [ebp-16Ch]
  __int16 *v57;   // [esp+80h] [ebp-168h]
  __int16 *v58;   // [esp+84h] [ebp-164h]
  __int16 *v59;   // [esp+88h] [ebp-160h]
  int v60;        // [esp+8Ch] [ebp-15Ch]
  int v61;        // [esp+90h] [ebp-158h]
  int v62;        // [esp+94h] [ebp-154h]
  int v63;        // [esp+9Ch] [ebp-14Ch]
  int v64;        // [esp+A0h] [ebp-148h]
  int v65;        // [esp+A4h] [ebp-144h]
  int v66;        // [esp+ACh] [ebp-13Ch]
  int v67;        // [esp+BCh] [ebp-12Ch]
  int v68;        // [esp+C0h] [ebp-128h]
  int v69;        // [esp+CCh] [ebp-11Ch]
  int v70;        // [esp+D0h] [ebp-118h]
  int v71;        // [esp+D4h] [ebp-114h]
  int v72;        // [esp+D8h] [ebp-110h]
  _DWORD *v73;    // [esp+DCh] [ebp-10Ch]
  _BYTE v74[264]; // [esp+E0h] [ebp-108h] BYREF

  v51 = *(_DWORD *)(a1 + 296) + 128;
  v48 = *(_DWORD **)(a2 + 80);
  v47 = a3;
  v49 = (int *)v74;
  v60 = 8;
  for (i = a3;; i = v47) {
    v41 = i[8];
    if (v41) {
      v6 = v47 + 16;
      v7 = v47 + 48;
      v56 = v47 + 32;
      v57 = v47 + 56;
      v58 = v47 + 40;
      v59 = v47 + 24;
      goto LABEL_4;
    }
    v6 = v47 + 16;
    if (v47[16]) {
      v7 = v47 + 48;
      v56 = v47 + 32;
      v57 = v47 + 56;
      v58 = v47 + 40;
      v59 = v47 + 24;
    LABEL_4:
      v8 = v48[16] * *v6;
      v9 = 4433 * (v8 + v48[48] * *v7);
      v10 = v9 - 15137 * v48[48] * *v7;
      v11 = v9 + 6270 * v8;
      v12 = *v48 * *v47;
      v13 = v48[32] * *v56;
      v14 = (v12 + v13) << 13;
      v15 = (v12 - v13) << 13;
      v72 = v11 + v14;
      v71 = v14 - v11;
      v70 = v10 + v15;
      v69 = v15 - v10;
      v16 = v48[56] * *v57;
      v17 = v48[40] * *v58;
      v63 = v48[24] * *v59;
      v62 = v48[8] * v41;
      v68 = v17 + v63;
      v66 = v17 + v62;
      v40 = 9633 * (v17 + v62 + v16 + v63);
      v18 = 16819 * v17;
      v19 = -7373 * (v16 + v62);
      v65 = v19 + v40 - 16069 * (v16 + v63) + 2446 * v16;
      v20 = v40 - 3196 * v66;
      v21 = -20995 * v68 + v20 + v18;
      v22 = v40 - 16069 * (v16 + v63) - 20995 * v68 + 25172 * v63;
      v23 = v20 + v19 + 12299 * v62;
      *v49 = (v72 + v23 + 1024) >> 11;
      v49[56] = (v72 - v23 + 1024) >> 11;
      v49[8] = (v70 + v22 + 1024) >> 11;
      v49[48] = (v70 - v22 + 1024) >> 11;
      v49[16] = (v69 + v21 + 1024) >> 11;
      v49[40] = (v69 - v21 + 1024) >> 11;
      v49[24] = (v71 + v65 + 1024) >> 11;
      v49[32] = (v71 - v65 + 1024) >> 11;
      ++v47;
      ++v48;
      ++v49;
      goto LABEL_5;
    }
    v59 = v47 + 24;
    if (v47[24]) {
      v7 = v47 + 48;
      v56 = v47 + 32;
      v57 = v47 + 56;
      v58 = v47 + 40;
      goto LABEL_4;
    }
    v56 = v47 + 32;
    if (v47[32]) {
      v7 = v47 + 48;
      v57 = v47 + 56;
      v58 = v47 + 40;
      goto LABEL_4;
    }
    v58 = v47 + 40;
    if (v47[40]) {
      v7 = v47 + 48;
      v57 = v47 + 56;
      goto LABEL_4;
    }
    v7 = v47 + 48;
    if (v47[48]) {
      v57 = v47 + 56;
      goto LABEL_4;
    }
    v57 = v47 + 56;
    if (v47[56])
      goto LABEL_4;
    v38 = 4 * *v48 * *v47;
    *v49 = v38;
    v49[8] = v38;
    v49[16] = v38;
    v49[24] = v38;
    v49[32] = v38;
    v49[40] = v38;
    v49[48] = v38;
    v49[56] = v38;
    ++v47;
    ++v48;
    ++v49;
  LABEL_5:
    if (!--v60)
      break;
  }
  v73 = v74;
  v61 = 1;
  for (j = v74;; j = v73) {
    v50 = (_BYTE *)(*(_DWORD *)(a4 + 4 * v61 - 4) + a5);
    v42 = *((_DWORD *)j + 1);
    if (v42) {
      v25 = v73 + 2;
      v27 = v73 + 6;
      v52 = v73 + 4;
      v53 = v73 + 7;
      v26 = v73;
      goto LABEL_14;
    }
    v25 = v73 + 2;
    if (v73[2]) {
      v26 = v73;
      v27 = v73 + 6;
      v52 = v73 + 4;
      v53 = v73 + 7;
    LABEL_14:
      v54 = v26 + 5;
      v55 = v73 + 3;
    LABEL_15:
      v28 = 4433 * (*v25 + *v27);
      v29 = v28 - 15137 * *v27;
      v30 = v28 + 6270 * *v25;
      v31 = (*v73 + *v52) << 13;
      v32 = (*v73 - *v52) << 13;
      v43 = v30 + v31;
      v46 = v31 - v30;
      v44 = v29 + v32;
      v45 = v32 - v29;
      v67 = *v54 + *v55;
      v39 = 9633 * (*v54 + v42 + *v53 + *v55);
      v64 = -7373 * (*v53 + v42) + v39 - 16069 * (*v53 + *v55) + 2446 * *v53;
      v33 = v39 - 3196 * (*v54 + v42);
      v34 = -20995 * v67 + v33 + 16819 * *v54;
      v35 = v39 - 16069 * (*v53 + *v55) - 20995 * v67 + 25172 * *v55;
      v36 = v33 - 7373 * (*v53 + v42) + 12299 * v42;
      *v50 = *(_BYTE *)(v51 + ((((int)&loc_20000 + v43 + v36) >> 18) & 0x3FF));
      v50[7] = *(_BYTE *)(v51 + (((v43 - v36 + 0x20000) >> 18) & 0x3FF));
      v50[1] =
          *(_BYTE *)(v51 + ((((int)&loc_20000 + v44 + v35) >> 18) & 0x3FF));
      v50[6] = *(_BYTE *)(v51 + (((v44 - v35 + 0x20000) >> 18) & 0x3FF));
      v50[2] =
          *(_BYTE *)(v51 + ((((int)&loc_20000 + v45 + v34) >> 18) & 0x3FF));
      v50[5] = *(_BYTE *)(v51 + (((v45 - v34 + 0x20000) >> 18) & 0x3FF));
      v50[3] =
          *(_BYTE *)(v51 + ((((int)&loc_20000 + v46 + v64) >> 18) & 0x3FF));
      result =
          *(unsigned __int8 *)(v51 + (((v46 - v64 + 0x20000) >> 18) & 0x3FF));
      v50[4] = result;
      v73 += 8;
      goto LABEL_16;
    }
    v55 = v73 + 3;
    if (v73[3]) {
      v27 = v73 + 6;
      v52 = v73 + 4;
      v53 = v73 + 7;
      v54 = v73 + 5;
      goto LABEL_15;
    }
    v52 = v73 + 4;
    if (v73[4]) {
      v27 = v73 + 6;
      v53 = v73 + 7;
      v54 = v73 + 5;
      goto LABEL_15;
    }
    v54 = v73 + 5;
    if (v73[5]) {
      v27 = v73 + 6;
      v53 = v73 + 7;
      goto LABEL_15;
    }
    v27 = v73 + 6;
    if (v73[6]) {
      v53 = v73 + 7;
      goto LABEL_15;
    }
    v53 = v73 + 7;
    if (v73[7])
      goto LABEL_15;
    result = *(unsigned __int8 *)(v51 + (((*v73 + 16) >> 5) & 0x3FF));
    *v50 = result;
    v50[1] = result;
    v50[2] = result;
    v50[3] = result;
    v50[4] = result;
    v50[5] = result;
    v50[6] = result;
    v50[7] = result;
    v73 += 8;
  LABEL_16:
    if (++v61 == 9)
      break;
  }
  return result;
}

float *__cdecl jpeg_fdct_float(float *a1) {
  float *v1;     // eax
  int v2;        // edx
  float v3;      // xmm0_4
  float v4;      // xmm4_4
  float v5;      // xmm7_4
  float v6;      // xmm0_4
  float v7;      // xmm2_4
  float v8;      // xmm6_4
  float v9;      // xmm0_4
  float v10;     // xmm3_4
  float v11;     // xmm1_4
  float v12;     // xmm4_4
  float v13;     // xmm2_4
  float v14;     // xmm3_4
  float v15;     // xmm0_4
  float v16;     // xmm3_4
  float v17;     // xmm1_4
  float v18;     // xmm6_4
  float v19;     // xmm2_4
  float v20;     // xmm7_4
  float *result; // eax
  int v22;       // edx
  float v23;     // xmm0_4
  float v24;     // xmm4_4
  float v25;     // xmm7_4
  float v26;     // xmm0_4
  float v27;     // xmm2_4
  float v28;     // xmm6_4
  float v29;     // xmm0_4
  float v30;     // xmm3_4
  float v31;     // xmm1_4
  float v32;     // xmm4_4
  float v33;     // xmm2_4
  float v34;     // xmm3_4
  float v35;     // xmm0_4
  float v36;     // xmm3_4
  float v37;     // xmm1_4
  float v38;     // xmm6_4
  float v39;     // xmm2_4
  float v40;     // xmm7_4
  float v41;     // [esp+0h] [ebp-20h]
  float v42;     // [esp+4h] [ebp-1Ch]
  float v43;     // [esp+8h] [ebp-18h]
  float v44;     // [esp+Ch] [ebp-14h]
  float v45;     // [esp+10h] [ebp-10h]
  float v46;     // [esp+14h] [ebp-Ch]

  v1 = a1;
  v2 = 8;
  do {
    v3 = v1[7];
    v4 = *v1 + v3;
    v5 = *v1 - v3;
    v6 = v1[6];
    v7 = v1[1] + v6;
    v8 = v1[1] - v6;
    v9 = v1[5];
    v46 = v1[2] + v9;
    v45 = v1[2] - v9;
    v10 = v1[3];
    v41 = v1[4];
    v11 = v4 + (float)(v41 + v10);
    v12 = v4 - (float)(v41 + v10);
    *v1 = v11 + (float)(v46 + v7);
    v1[4] = v11 - (float)(v46 + v7);
    v13 = (float)((float)(v7 - v46) + v12) * 0.70710677;
    v1[2] = v12 + v13;
    v1[6] = v12 - v13;
    v14 = (float)(v10 - v41) + v45;
    v15 = (float)(v14 - (float)(v5 + v8)) * 0.38268343;
    v16 = (float)(v14 * 0.54119611) + v15;
    v17 = (float)((float)(v5 + v8) * 1.306563) + v15;
    v18 = (float)(v8 + v45) * 0.70710677;
    v19 = v5 + v18;
    v20 = v5 - v18;
    v1[5] = v16 + v20;
    v1[3] = v20 - v16;
    v1[1] = v17 + v19;
    v1[7] = v19 - v17;
    v1 += 8;
    --v2;
  } while (v2);
  result = a1;
  v22 = 8;
  do {
    v23 = result[56];
    v24 = *result + v23;
    v25 = *result - v23;
    v26 = result[48];
    v27 = result[8] + v26;
    v28 = result[8] - v26;
    v29 = result[40];
    v43 = result[16] + v29;
    v44 = result[16] - v29;
    v30 = result[24];
    v42 = result[32];
    v31 = v24 + (float)(v42 + v30);
    v32 = v24 - (float)(v42 + v30);
    *result = v31 + (float)(v43 + v27);
    result[32] = v31 - (float)(v43 + v27);
    v33 = (float)((float)(v27 - v43) + v32) * 0.70710677;
    result[16] = v32 + v33;
    result[48] = v32 - v33;
    v34 = (float)(v30 - v42) + v44;
    v35 = (float)(v34 - (float)(v25 + v28)) * 0.38268343;
    v36 = (float)(v34 * 0.54119611) + v35;
    v37 = (float)((float)(v25 + v28) * 1.306563) + v35;
    v38 = (float)(v28 + v44) * 0.70710677;
    v39 = v25 + v38;
    v40 = v25 - v38;
    result[40] = v36 + v40;
    result[24] = v40 - v36;
    result[8] = v37 + v39;
    result[56] = v39 - v37;
    ++result;
    --v22;
  } while (v22);
  return result;
}

int __cdecl jpeg_fdct_ifast(_DWORD *a1) {
  _DWORD *v1;  // ecx
  _DWORD *i;   // edi
  int v3;      // eax
  int v4;      // esi
  int v5;      // edx
  int v6;      // eax
  int v7;      // ecx
  int v8;      // edx
  int v9;      // eax
  int v10;     // edi
  int v11;     // edx
  int v12;     // eax
  int v13;     // edi
  int v14;     // esi
  int v15;     // esi
  int v16;     // eax
  _DWORD *v17; // edx
  int *v18;    // esi
  _DWORD *j;   // edi
  int v20;     // edx
  int v21;     // eax
  int v22;     // esi
  int v23;     // edx
  int v24;     // eax
  int v25;     // ecx
  int v26;     // edx
  int v27;     // eax
  int v28;     // edi
  int v29;     // edx
  int v30;     // eax
  int v31;     // edi
  int v32;     // esi
  int v33;     // esi
  int v34;     // eax
  int v35;     // ecx
  int result;  // eax
  _DWORD *v37; // edx
  int v38;     // [esp+0h] [ebp-60h]
  int v39;     // [esp+0h] [ebp-60h]
  int v40;     // [esp+18h] [ebp-48h]
  int v41;     // [esp+1Ch] [ebp-44h]
  int v42;     // [esp+20h] [ebp-40h]
  int v43;     // [esp+24h] [ebp-3Ch]
  int v44;     // [esp+28h] [ebp-38h]
  int v45;     // [esp+2Ch] [ebp-34h]
  int v46;     // [esp+30h] [ebp-30h]
  _DWORD *v47; // [esp+34h] [ebp-2Ch]
  int v48;     // [esp+38h] [ebp-28h]
  int v49;     // [esp+3Ch] [ebp-24h]
  _DWORD *v50; // [esp+40h] [ebp-20h]
  int v51;     // [esp+44h] [ebp-1Ch]
  int v52;     // [esp+48h] [ebp-18h]
  int v53;     // [esp+4Ch] [ebp-14h]
  int v54;     // [esp+50h] [ebp-10h]
  int v55;     // [esp+54h] [ebp-Ch]

  v50 = a1;
  v48 = 8;
  v1 = a1;
  for (i = a1;; i = v17) {
    v3 = v1[7];
    v4 = *v1 + v3;
    v55 = *v1 - v3;
    v5 = v1[1];
    v6 = v1[6];
    v7 = v5 + v6;
    v54 = v5 - v6;
    v8 = i[2];
    v9 = i[5];
    v53 = v8 + v9;
    v52 = v8 - v9;
    v10 = v50[3];
    v40 = v50[4];
    v11 = v4 + v10 + v40;
    v51 = v4 - (v10 + v40);
    *v50 = v11 + v7 + v53;
    v50[4] = v11 - (v7 + v53);
    v12 = (181 * (v51 + v7 - v53)) >> 8;
    v50[2] = v12 + v51;
    v50[6] = v51 - v12;
    v13 = v52 + v10 - v40;
    v14 = (98 * (v13 - (v54 + v55))) >> 8;
    v38 = v14 + ((139 * v13) >> 8);
    v15 = ((334 * (v54 + v55)) >> 8) + v14;
    v16 = (181 * (v52 + v54)) >> 8;
    v50[5] = v55 - v16 + v38;
    v50[3] = v55 - v16 - v38;
    v50[1] = v15 + v16 + v55;
    v50[7] = v16 + v55 - v15;
    v17 = v50 + 8;
    v50 += 8;
    if (!--v48)
      break;
    v1 = v17;
  }
  v47 = a1;
  v49 = 8;
  v18 = a1;
  for (j = a1;; j = v37) {
    v20 = *v18;
    v21 = v18[56];
    v22 = *v18 + v21;
    v45 = v20 - v21;
    v23 = j[8];
    v24 = j[48];
    v25 = v23 + v24;
    v44 = v23 - v24;
    v26 = j[16];
    v27 = j[40];
    v42 = v26 + v27;
    v43 = v26 - v27;
    v28 = v47[24];
    v41 = v47[32];
    v29 = v22 + v28 + v41;
    v46 = v22 - (v28 + v41);
    *v47 = v29 + v25 + v42;
    v47[32] = v29 - (v25 + v42);
    v30 = (181 * (v46 + v25 - v42)) >> 8;
    v47[16] = v30 + v46;
    v47[48] = v46 - v30;
    v31 = v43 + v28 - v41;
    v32 = (98 * (v31 - (v44 + v45))) >> 8;
    v39 = v32 + ((139 * v31) >> 8);
    v33 = ((334 * (v44 + v45)) >> 8) + v32;
    v34 = (181 * (v43 + v44)) >> 8;
    v35 = v34 + v45;
    v47[40] = v45 - v34 + v39;
    v47[24] = v45 - v34 - v39;
    result = v33 + v35;
    v47[8] = v33 + v35;
    v47[56] = v35 - v33;
    v37 = ++v47;
    if (!--v49)
      break;
    v18 = v37;
  }
  return result;
}

int __cdecl jpeg_fdct_islow(_DWORD *a1) {
  _DWORD *i;   // ecx
  int v2;      // eax
  int v3;      // esi
  int v4;      // edx
  int v5;      // eax
  int v6;      // edi
  int v7;      // edx
  int v8;      // eax
  int v9;      // edx
  int v10;     // eax
  int v11;     // ecx
  int v12;     // edx
  int v13;     // esi
  int v14;     // edi
  int v15;     // ecx
  int v16;     // ecx
  int v17;     // edi
  int v18;     // esi
  _DWORD *v19; // edx
  int *j;      // edi
  int v21;     // edx
  int v22;     // eax
  int v23;     // edi
  int v24;     // edx
  int v25;     // eax
  int v26;     // esi
  int v27;     // edx
  int v28;     // eax
  int v29;     // edx
  int v30;     // eax
  int v31;     // ecx
  int v32;     // edx
  int v33;     // edi
  int v34;     // esi
  int v35;     // ecx
  int v36;     // ecx
  int v37;     // edi
  int v38;     // esi
  int result;  // eax
  int *v40;    // edx
  int v41;     // [esp+4h] [ebp-68h]
  int v42;     // [esp+4h] [ebp-68h]
  int v43;     // [esp+8h] [ebp-64h]
  int v44;     // [esp+8h] [ebp-64h]
  int v45;     // [esp+Ch] [ebp-60h]
  int v46;     // [esp+10h] [ebp-5Ch]
  int v47;     // [esp+14h] [ebp-58h]
  int v48;     // [esp+18h] [ebp-54h]
  int v49;     // [esp+1Ch] [ebp-50h]
  int *v50;    // [esp+2Ch] [ebp-40h]
  int v51;     // [esp+30h] [ebp-3Ch]
  int v52;     // [esp+34h] [ebp-38h]
  _DWORD *v53; // [esp+38h] [ebp-34h]
  int v54;     // [esp+50h] [ebp-1Ch]
  int v55;     // [esp+54h] [ebp-18h]
  int v56;     // [esp+58h] [ebp-14h]
  int v57;     // [esp+5Ch] [ebp-10h]
  int v58;     // [esp+60h] [ebp-Ch]

  v53 = a1;
  v51 = 8;
  for (i = a1;; i = v19) {
    v2 = i[7];
    v3 = *i + v2;
    v54 = *i - v2;
    v4 = i[1];
    v5 = i[6];
    v6 = v4 + v5;
    v55 = v4 - v5;
    v7 = i[2];
    v8 = i[5];
    v58 = v7 + v8;
    v56 = v7 - v8;
    v9 = v53[3];
    v10 = v53[4];
    v11 = v9 + v10;
    v57 = v9 - v10;
    v12 = v3 + v9 + v10;
    v13 = v3 - v11;
    v43 = v6 + v58;
    v14 = v6 - v58;
    *v53 = 4 * (v12 + v43);
    v53[4] = 4 * (v12 - v43);
    v15 = 4433 * (v13 + v14);
    v53[2] = (v15 + 6270 * v13 + 1024) >> 11;
    v53[6] = (v15 - 15137 * v14 + 1024) >> 11;
    v16 = -7373 * (v57 + v54);
    v17 = -20995 * (v56 + v55);
    v41 = 16069 * (v57 + v55);
    v18 = 9633 * (v56 + v54 + v57 + v55) - 3196 * (v56 + v54);
    v53[7] =
        (9633 * (v56 + v54 + v57 + v55) - v41 + v16 + 2446 * v57 + 1024) >> 11;
    v53[5] = (v18 + v17 + 16819 * v56 + 1024) >> 11;
    v53[3] =
        (9633 * (v56 + v54 + v57 + v55) - v41 + v17 + 25172 * v55 + 1024) >> 11;
    v53[1] = (v18 + v16 + 12299 * v54 + 1024) >> 11;
    v19 = v53 + 8;
    v53 += 8;
    if (!--v51)
      break;
  }
  v50 = a1;
  v52 = 8;
  for (j = a1;; j = v40) {
    v21 = *j;
    v22 = j[56];
    v23 = *j + v22;
    v49 = v21 - v22;
    v24 = v50[8];
    v25 = v50[48];
    v26 = v24 + v25;
    v48 = v24 - v25;
    v27 = v50[16];
    v28 = v50[40];
    v45 = v27 + v28;
    v47 = v27 - v28;
    v29 = v50[24];
    v30 = v50[32];
    v31 = v29 + v30;
    v46 = v29 - v30;
    v32 = v23 + v29 + v30;
    v33 = v23 - v31;
    v44 = v26 + v45;
    v34 = v26 - v45;
    *v50 = (v32 + v44 + 2) >> 2;
    v50[32] = (v32 - v44 + 2) >> 2;
    v35 = 4433 * (v33 + v34);
    v50[16] = (v35 + 6270 * v33 + 0x4000) >> 15;
    v50[48] = (v35 - 15137 * v34 + 0x4000) >> 15;
    v36 = -7373 * (v46 + v49);
    v37 = -20995 * (v47 + v48);
    v42 = 16069 * (v46 + v48);
    v38 = 9633 * (v47 + v49 + v46 + v48) - 3196 * (v47 + v49);
    v50[56] =
        (9633 * (v47 + v49 + v46 + v48) - v42 + v36 + 2446 * v46 + 0x4000) >>
        15;
    v50[40] = (v38 + v37 + 16819 * v47 + 0x4000) >> 15;
    v50[24] =
        (9633 * (v47 + v49 + v46 + v48) - v42 + v37 + 25172 * v48 + 0x4000) >>
        15;
    result = (v38 + v36 + 12299 * v49 + 0x4000) >> 15;
    v50[8] = result;
    v40 = ++v50;
    if (!--v52)
      break;
  }
  return result;
}

void __cdecl __noreturn exit(int a1) { exit_ptr(a1); }

int __keymgr_dwarf2_register_sections() {
  return __keymgr_dwarf2_register_sections_ptr();
}

void __cdecl __noreturn sub_284833E(int a1, int a2, int a3) {
  dword_284A000 = a1;
  dword_284A004 = a2;
  dword_284A008 = a3;
  if (*(_DWORD *)dword_284C000)
    (*(void (**)(void))dword_284C000)();
  if (*(_DWORD *)dword_284C008)
    (*(void (**)(void))dword_284C008)();
  sub_284C03D();
}

int sub_284843D() {
  int (*v1[3])(void); // [esp+1Ch] [ebp-Ch] BYREF

  sub_2848474(aDyldMakeDelaye_0, v1);
  return v1[0]();
}

unsigned int *__cdecl sub_284847A(unsigned int *a1, int a2, signed int a3) {
  _BYTE v5[4096];  // [esp+10h] [ebp-1018h]
  int i;           // [esp+1010h] [ebp-18h]
  unsigned int v7; // [esp+1014h] [ebp-14h]
  _DWORD *v8;      // [esp+1018h] [ebp-10h]
  int v9;          // [esp+101Ch] [ebp-Ch]

  v8 = a1 + 1;
  v7 = *a1;
  if (v7 >= 0x1000)
    return a1;
  for (i = 0; (unsigned int)i <= 0xFFF; ++i)
    v5[i] = 0;
  for (i = 0; i < (int)v7; ++i)
    v5[i] = *((_BYTE *)v8 + i);
  for (i = v7 - 2; i >= 0; --i)
    v5[i] ^= v5[i + 1];
  v9 = v7 + 1;
  if ((int)(v7 + 1) > a3)
    v9 = a3;
  for (i = 0; i < v9; ++i)
    *(_BYTE *)(a2 + i) = v5[i];
  return (unsigned int *)a2;
}

unsigned int *__cdecl sub_284858F(unsigned int *a1) {
  return sub_284847A(a1, (int)dword_284A3E0, 4096);
}

int sub_28485BE() {
  void (*v1)(void); // [esp+1Ch] [ebp-Ch]

  sub_284858F((unsigned int *)dword_2849EA8);
  sub_284858F((unsigned int *)&word_2849EC2);
  sub_284858F((unsigned int *)&word_2849EDE);
  if (off_284A018[0]) {
    *(_DWORD *)off_284A018[0] = off_284A01C[0];
    sub_284858F((unsigned int *)dword_2849EFC);
  }
  if (off_284A020[0]) {
    v1 = (void (*)(void))off_284A020[0];
    sub_284858F((unsigned int *)&word_2849F22);
    v1();
  }
  sub_284858F((unsigned int *)&byte_2849F3F);
  return 0;
}

int sub_28486A3() {
  _BYTE v1[4];                             // [esp+1Ch] [ebp-2Ch] BYREF
  int(__cdecl * v2)(char *, int, _BYTE *); // [esp+20h] [ebp-28h] BYREF
  _BYTE v3[4];                             // [esp+24h] [ebp-24h] BYREF
  int(__cdecl * v4)(int, int, _DWORD);     // [esp+28h] [ebp-20h] BYREF
  int(__cdecl * v5)(char *, int);          // [esp+2Ch] [ebp-1Ch] BYREF
  int v6;                                  // [esp+30h] [ebp-18h]
  int v7;                                  // [esp+38h] [ebp-10h]
  int v8;                                  // [esp+3Ch] [ebp-Ch]

  v6 = sub_2848474(aDyldNsaddimage, &v5);
  v6 = sub_2848474(aDyldNslookupsy, &v4);
  v6 = sub_2848474(aDyldNsissymbol, v3);
  v6 = sub_2848474(aDyldLookupAndB, &v2);
  v6 = sub_2848474(aDyldNslookupsy_0, loc_284C034);
  v6 = sub_2848474(aDyldNsaddresso, *(&loc_284C020 + 1));
  v8 = v5(aSystemLibraryF_7, 2);
  *(_DWORD *)dword_284C018 = sub_2848663(v8, v4, (int)aExit);
  v7 = v5(aSystemLibraryF_8, 2);
  *(_DWORD *)dword_284C010 = sub_2848663(v7, v4, (int)aGetmemfragment);
  **(_DWORD **)((char *)&loc_284C027 + 1) =
      sub_2848663(v7, v4, (int)aMakedataexecut);
  *(_DWORD *)dword_284C014 = sub_2848663(v7, v4, (int)aNewptr);
  *loc_284C020 = sub_2848663(v7, v4, (int)aBlockmove);
  **(_DWORD **)((char *)&loc_284C02F + 1) =
      sub_2848663(v7, v4, (int)aDisposeptr);
  *loc_284C02C = sub_2848663(v7, v4, (int)aFindsymbol);
  v2(aNscreateobject, *(_DWORD *)&byte_284C01C, v1);
  return v2(aNslinkmodule, dword_284C00C, v1);
}

int InitFunc_0() {
  _BYTE v1[128];              // [esp+3Ch] [ebp-1CCh] BYREF
  _BYTE v2[128];              // [esp+BCh] [ebp-14Ch] BYREF
  _BYTE v3[128];              // [esp+13Ch] [ebp-CCh] BYREF
  _BYTE v4[8];                // [esp+1BCh] [ebp-4Ch] BYREF
  _DWORD v5[3];               // [esp+1C4h] [ebp-44h] BYREF
  int j;                      // [esp+1D0h] [ebp-38h]
  int v7;                     // [esp+1D4h] [ebp-34h]
  __int16 v8;                 // [esp+1DAh] [ebp-2Eh]
  char *v9;                   // [esp+1E0h] [ebp-28h]
  int v10;                    // [esp+1E4h] [ebp-24h]
  int v11;                    // [esp+1E8h] [ebp-20h]
  int(__cdecl * v12)(char *); // [esp+1ECh] [ebp-1Ch]
  int *v13;                   // [esp+1F0h] [ebp-18h]
  int *v14;                   // [esp+1F4h] [ebp-14h]
  int v15;                    // [esp+1F8h] [ebp-10h]
  int i;                      // [esp+1FCh] [ebp-Ch]

  sub_28486A3();
  v9 = aTestl;
  sub_284858F((unsigned int *)dword_2849F48);
  sub_284910E(*(int(__cdecl **)(int))dword_284C014,
              **(void(__cdecl ***)(int))((char *)&loc_284C02F + 1));
  for (i = 0; i <= 7; ++i)
    v4[i] = 0;
  sub_28492BC((int *)((char *)&(*off_284A010)[8] + dword_284A014 + 1), (int)v3);
  sub_28492BC((int *)((char *)&(*off_284A010)[8] + dword_284A014 + 2), (int)v2);
  sub_28492BC((int *)((char *)&(*off_284A010)[8] + dword_284A014 + 3), (int)v1);
  for (i = 0; i <= 7; ++i)
    sub_284858F((unsigned int *)&byte_2849F57);
  v15 = dword_284A014 + 33 - (dword_284A014 + 33) % 8;
  v13 = (int *)off_284A010;
  sub_284858F((unsigned int *)dword_2849F64);
  sub_284858F((unsigned int *)dword_2849F78);
  sub_284858F((unsigned int *)&byte_2849F9B);
  v14 = (int *)(*(int(__cdecl **)(int))dword_284C014)(v15);
  sub_284858F((unsigned int *)&byte_2849F9B);
  sub_2849B1C((int)v13, v14, v15, (int)v1, (int)v2, (int)v3, (int)v4, 2);
  ((void(__cdecl *)(int *, int *, int)) * loc_284C020)(v14, v13, v15);
  sub_284858F((unsigned int *)byte_2849FB5);
  sub_284858F((unsigned int *)&word_2849FCE);
  (**(void(__cdecl ***)(int *))((char *)&loc_284C02F + 1))(v14);
  sub_2849232(**(void(__cdecl ***)(int))((char *)&loc_284C02F + 1));
  for (j = 0; j <= 9; ++j)
    sub_284858F((unsigned int *)dword_2849FE0);
  sub_284858F((unsigned int *)&dword_2849FE8);
  v8 = (**(int(__cdecl ***)(int *, int, _DWORD *)) &
        byte_284C01C)((int *)off_284A010, dword_284A014, v5);
  v10 =
      (*(int(__cdecl **)(_DWORD, char *, int))dword_284C00C)(v5[0], aTestl, 2);
  v11 = ((int(__cdecl *)(int, char *)) * loc_284C034)(v10, aDoMain);
  v12 = (int(__cdecl *)(char *))((int(__cdecl *)(int)) *
                                 *(&loc_284C020 + 1))(v11);
  v7 = v12((char *)&(*off_284A010)[0] + dword_284A014 + 1);
  sub_284858F((unsigned int *)&byte_2849FEF);
  if (v7 == 1)
    sub_28485BE();
  else
    (*(void(__cdecl **)(int))dword_284C018)(99);
  return 0;
}

int __cdecl sub_2848DA5(int a1) {
  char v2; // [esp+Fh] [ebp-9h]
  char v3; // [esp+Fh] [ebp-9h]

  v2 = HIBYTE(a1);
  HIBYTE(a1) = a1;
  LOBYTE(a1) = v2;
  v3 = BYTE2(a1);
  BYTE2(a1) = BYTE1(a1);
  BYTE1(a1) = v3;
  return a1;
}

int *__cdecl sub_2848E02(int a1, int a2) {
  int *result; // eax
  int v3;      // [esp+1Ch] [ebp-2Ch]
  int j;       // [esp+20h] [ebp-28h]
  int m;       // [esp+20h] [ebp-28h]
  int k;       // [esp+24h] [ebp-24h]
  int n;       // [esp+24h] [ebp-24h]
  int i;       // [esp+28h] [ebp-20h] BYREF
  int v9;      // [esp+2Ch] [ebp-1Ch]

  for (i = 0; i <= 15; ++i) {
    for (j = 0; j <= 15; ++j) {
      for (k = 0; k <= 7; ++k)
        *(_BYTE *)(a1 + (i << 7) + 8 * j + k) = 0;
    }
    result = &i;
  }
  for (i = 0; i <= 15; ++i) {
    for (m = 0; m <= 15; ++m) {
      for (n = 0; n <= 63; ++n) {
        v3 = *(unsigned __int8 *)(a2 + n) - 1;
        if (v3 >> 2 == i && (m & dword_284A3A0[v3 & 3]) != 0) {
          v9 = n & 7;
          *(_BYTE *)(a1 + (i << 7) + 8 * m + (n >> 3)) |= dword_284A380[v9];
        }
      }
    }
    result = &i;
  }
  return result;
}

int *__cdecl sub_28492BC(int *a1, int a2) {
  int *result;   // eax
  int v3;        // [esp+18h] [ebp-B0h]
  int v4;        // [esp+1Ch] [ebp-ACh]
  _BYTE v5[112]; // [esp+2Ch] [ebp-9Ch]
  int i;         // [esp+9Ch] [ebp-2Ch] BYREF
  int j;         // [esp+A0h] [ebp-28h] BYREF
  int v8;        // [esp+A4h] [ebp-24h]
  int v9;        // [esp+A8h] [ebp-20h]
  int *v10;      // [esp+ACh] [ebp-1Ch]

  result = a1;
  v10 = a1;
  for (i = 0; i <= 15; ++i) {
    for (j = 0; j <= 7; ++j)
      *(_BYTE *)(a2 + 8 * i + j) = 0;
    result = &i;
  }
  for (j = 0; j <= 55; ++j) {
    v8 = *((unsigned __int8 *)&loc_284A0C0 + j) - 1;
    v9 = v8 & 7;
    v5[j + 56] =
        (*((unsigned __int8 *)v10 + (v8 >> 3)) & dword_284A380[v9]) != 0;
    result = &j;
  }
  for (i = 0; i <= 15; ++i) {
    for (j = 0; j <= 55; ++j) {
      v8 = j + *((char *)dword_284A0F8 + i);
      if (j > 27)
        v4 = 56;
      else
        v4 = 28;
      if (v8 < v4)
        v3 = v8;
      else
        v3 = v8 - 28;
      v5[j] = v5[v3 + 56];
    }
    for (j = 0; j <= 47; ++j) {
      if (v5[*((char *)dword_284A120 + j) - 1]) {
        v8 = j % 6;
        *(_BYTE *)(a2 + 8 * i + j / 6) |= dword_284A380[j % 6] >> 2;
      }
    }
    result = &i;
  }
  return result;
}

int *__cdecl sub_28494ED(int *a1, int a2) {
  int *result; // eax
  int i;       // [esp+Ch] [ebp-Ch] BYREF

  result = a1;
  for (i = 0; i <= 7; ++i) {
    *((_BYTE *)a1 + i) = *(_BYTE *)(a2 + i);
    result = &i;
  }
  return result;
}

int *__cdecl sub_2849529(int a1, int a2, int *a3) {
  int *result; // eax
  int v4;      // [esp+18h] [ebp-20h]
  int j;       // [esp+18h] [ebp-20h]
  int i;       // [esp+1Ch] [ebp-1Ch]
  _BYTE *v7;   // [esp+20h] [ebp-18h] BYREF
  int *v8;     // [esp+24h] [ebp-14h]
  _BYTE *v9;   // [esp+28h] [ebp-10h]
  _BYTE *v10;  // [esp+2Ch] [ebp-Ch]

  if (!a2)
    return sub_28494ED(a3, a1);
  v4 = 8;
  v8 = a3;
  while (v4) {
    *(_BYTE *)v8 = 0;
    v8 = (int *)((char *)v8 + 1);
    --v4;
  }
  result = (int *)a1;
  v7 = (_BYTE *)a1;
  for (i = 0; i <= 15; i += 2) {
    v8 = a3;
    v9 = (_BYTE *)(8 * (16 * i + ((*v7 >> 4) & 0xF)) + a2);
    v10 = (_BYTE *)(a2 + (i << 7) + 8 * (*v7 & 0xF) + 128);
    for (j = 8; j; --j) {
      *(_BYTE *)v8 |= *v9 | *v10;
      v8 = (int *)((char *)v8 + 1);
      ++v9;
      ++v10;
    }
    result = (int *)&v7;
    ++v7;
  }
  return result;
}

int __cdecl sub_2849634(int a1, _BYTE *a2) {
  unsigned int v3; // [esp+8h] [ebp-20h]
  unsigned int v4; // [esp+Ch] [ebp-1Ch]
  int v5;          // [esp+18h] [ebp-10h]
  int v6;          // [esp+18h] [ebp-10h]
  int v7;          // [esp+18h] [ebp-10h]
  int v8;          // [esp+18h] [ebp-10h]
  _BYTE *v9;       // [esp+34h] [ebp+Ch]

  v3 = (unsigned int)a1 >> 1;
  if ((a1 & 1) != 0)
    v4 = 0x80000000;
  else
    v4 = 0;
  v5 = *(_DWORD *)(dword_284B3E0 + 4 * ((((v4 | v3) >> 26) ^ *a2) & 0x3F));
  v9 = a2 + 1;
  v6 = *(_DWORD *)(dword_284B3E0 + 256 +
                   4 * (((unsigned __int8)((v4 | v3) >> 22) ^ *v9++) & 0x3F)) |
       v5;
  v7 = *(_DWORD *)(dword_284B3E0 + 512 +
                   4 * (((unsigned __int8)((v4 | v3) >> 18) ^ *v9++) & 0x3F)) |
       v6;
  v8 = *(_DWORD *)(dword_284B3E0 + 768 +
                   4 * (((unsigned __int8)((v4 | v3) >> 14) ^ *v9++) & 0x3F)) |
       v7;
  return *(_DWORD *)(dword_284B3E0 + 1792 +
                     4 * (((unsigned __int8)((2 * a1) | (a1 < 0)) ^ v9[3]) &
                          0x3F)) |
         *(_DWORD *)(dword_284B3E0 + 1536 +
                     4 * (((unsigned __int8)((v4 | v3) >> 2) ^ v9[2]) & 0x3F)) |
         *(_DWORD *)(dword_284B3E0 + 1280 +
                     4 * (((unsigned __int8)((v4 | v3) >> 6) ^ v9[1]) & 0x3F)) |
         *(_DWORD *)(dword_284B3E0 + 1024 +
                     4 * (((unsigned __int8)((v4 | v3) >> 10) ^ *v9) & 0x3F)) |
         v8;
}

int __cdecl sub_284981B(int a1, int *a2, int a3) {
  int v3;     // edi
  int result; // eax
  int v5;     // esi
  int v6;     // edx

  if ((a1 & 1) != 0) {
    v3 = a2[1];
    result = v3 ^ sub_2849634(*a2, (_BYTE *)(a3 + 8 * a1));
    a2[1] = result;
  } else {
    v5 = *a2;
    v6 = sub_2849634(a2[1], (_BYTE *)(a3 + 8 * a1)) ^ v5;
    result = (int)a2;
    *a2 = v6;
  }
  return result;
}

int *__cdecl sub_2849891(int *a1, int a2, int a3) {
  int v4; // [esp+10h] [ebp-18h] BYREF
  int v5; // [esp+14h] [ebp-14h]
  int i;  // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]

  sub_28494ED(&v4, (int)a1);
  v4 = sub_2848DA5(v4);
  v5 = sub_2848DA5(v5);
  if (a3 == 1) {
    for (i = 0; i <= 15; ++i)
      sub_284981B(i, &v4, a2);
    v7 = v4;
    v4 = v5;
    v5 = v7;
  } else {
    v7 = v4;
    v4 = v5;
    v5 = v7;
    for (i = 15; i >= 0; --i)
      sub_284981B(i, &v4, a2);
  }
  v4 = sub_2848DA5(v4);
  v5 = sub_2848DA5(v5);
  return sub_28494ED(a1, (int)&v4);
}

int *__cdecl sub_284997D(int *a1, int a2, int a3, int a4) {
  int v5[4]; // [esp+18h] [ebp-10h] BYREF

  sub_2849529((int)a1, dword_284B3E4, v5);
  sub_2849891(v5, a2, 1);
  sub_2849891(v5, a3, 2);
  sub_2849891(v5, a4, 1);
  return sub_2849529((int)v5, dword_284B3E8[0], a1);
}

int *__cdecl sub_2849A19(int *a1, int a2, int a3, int a4) {
  int v5[4]; // [esp+18h] [ebp-10h] BYREF

  sub_2849529((int)a1, dword_284B3E4, v5);
  sub_2849891(v5, a2, 2);
  sub_2849891(v5, a3, 1);
  sub_2849891(v5, a4, 2);
  return sub_2849529((int)v5, dword_284B3E8[0], a1);
}

int *__cdecl sub_2849AB5(int *a1, int a2, int a3) {
  int v4[4]; // [esp+18h] [ebp-10h] BYREF

  sub_2849529((int)a1, dword_284B3E4, v4);
  sub_2849891(v4, a2, a3);
  return sub_2849529((int)v4, dword_284B3E8[0], a1);
}

int *__cdecl sub_2849B1C(int a1, int *a2, int a3, int a4, int a5, int a6,
                         int a7, int a8) {
  int *result;   // eax
  int v9;        // [esp+1Ch] [ebp-1Ch] BYREF
  int v10;       // [esp+20h] [ebp-18h]
  int v11;       // [esp+24h] [ebp-14h] BYREF
  int v12;       // [esp+28h] [ebp-10h]
  _DWORD v13[3]; // [esp+2Ch] [ebp-Ch] BYREF

  v13[0] = a3;
  if (a8 == 1) {
    result = sub_28494ED(&v11, a7);
    while (v13[0] > 0) {
      sub_28494ED(&v9, a1);
      v9 ^= v11;
      v10 ^= v12;
      sub_284997D(&v9, a4, a5, a6);
      sub_28494ED(&v11, (int)&v9);
      sub_28494ED(a2, (int)&v9);
      a1 += 8;
      a2 += 2;
      result = v13;
      v13[0] -= 8;
    }
  } else {
    result = sub_28494ED(&v11, a7);
    while (v13[0] > 0) {
      sub_28494ED(&v9, a1);
      sub_2849A19(&v9, a4, a5, a6);
      v9 ^= v11;
      v10 ^= v12;
      sub_28494ED(&v11, a1);
      sub_28494ED(a2, (int)&v9);
      a1 += 8;
      a2 += 2;
      result = v13;
      v13[0] -= 8;
    }
  }
  return result;
}

void sub_2849EA4() { ; }

void __usercall sub_284A040(int a1 @<eax>, _BYTE *a2 @<edx>, _BYTE *a3 @<ecx>,
                            unsigned int a4 @<ebx>, int a5 @<ebp>,
                            unsigned int a6 @<edi>) {
  bool v6; // cf

  v6 = BYTE1(a1) < *a2;
  BYTE1(a1) -= *a2;
  LOBYTE(a2) = (_BYTE)a2 - (v6 + *a2);
  LOBYTE(a1) =
      ((*a2 | a1) - 36 - (((unsigned __int8)(*a2 | a1) < 0x24u) + 20)) | 4;
  _EAX = (_BYTE *)(a1 + 1);
  v6 = *_EAX < BYTE1(_EAX);
  *_EAX -= BYTE1(_EAX);
  *_EAX -= v6 + (_BYTE)a2;
  *a3 |= BYTE1(a4);
  *(_DWORD *)a3 ^= a5;
  *(_DWORD *)a3 &= a4;
  *(_DWORD *)a3 += a3;
  *(_DWORD *)a4 += a6;
  _KR00_8 = (*(unsigned int *)0x1D252D35 | 0x373F050D00000000LL) +
            __PAIR64__((unsigned int)_EAX, a6);
  __asm
  {
    das
    daa
  }
  __asm { sysret }
}

void __usercall sub_284A080(_BYTE *a1 @<eax>, int a2 @<edx>, int a3 @<ecx>,
                            _DWORD *a4 @<ebx>, _BYTE *a5 @<edi>) {
  int v7;     // eax
  int v8;     // eax
  _DWORD *v9; // ecx
  int v10;    // edx
  bool v11;   // cf
  int v14;    // [esp-10h] [ebp-10h] BYREF
  int v15;    // [esp-Ch] [ebp-Ch]
  int v16;    // [esp-8h] [ebp-8h]
  int v17;    // [esp-4h] [ebp-4h]

  *a1 -= a3;
  *a1 ^= a2;
  _EAX = a1 + 1;
  *a5 &= BYTE1(_EAX);
  __asm
      {
    das
    getsec
      }
  __SS__ = v16;
  __asm { aas }
  __DS__ = v17;
  v17 = (unsigned __int16)v15;
  v16 = (unsigned __int16)__CS__;
  v15 = (unsigned __int16)__SS__;
  v14 = (unsigned __int16)__DS__;
  v7 = (_EAX & 0x350D2D05) + 69475645;
  LOBYTE(v7) = (v7 - 12) ^ 0x14;
  v8 = *a4 & v7;
  v9 = (_DWORD *)(a3 - *a4);
  v10 = *a4 ^ a2;
  LOBYTE(v8) = *(_BYTE *)v10 & v8;
  LOBYTE(v9) = (_BYTE)v9 - *(_BYTE *)v10;
  LOBYTE(v10) = *(_BYTE *)v10 ^ v10;
  *v9 &= v8;
  *v9 -= v9;
  *v9 ^= v10;
  v11 = *v9 < (unsigned int)&v14;
  *v9 -= &v14;
  *v9 -= v11 + v10;
  *v9 |= v8;
  v11 = BYTE1(v8) < *(_BYTE *)v10;
  BYTE1(v8) -= *(_BYTE *)v10;
  LOBYTE(v10) = v10 - (v11 + *(_BYTE *)v10);
  LOBYTE(v8) = *(_BYTE *)v10 | v8;
  _EAX = *a4 | v8;
  LOBYTE(_EAX) = _EAX - 36;
  __asm
  {
    aas
    aaa
    das
    daa
  }
  __asm { sysret }
}
